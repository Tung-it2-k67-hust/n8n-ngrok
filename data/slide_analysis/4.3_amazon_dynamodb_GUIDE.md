# Phân tích chi tiết: 4.3_amazon_dynamodb.pdf

Dưới đây là tài liệu phân tích chi tiết về **Amazon DynamoDB** dựa trên nội dung slide được cung cấp, được trình bày chuyên nghiệp bằng tiếng Việt với các ví dụ minh họa thực tế.

---

# Phân tích Amazon DynamoDB: Kiến trúc và Nguyên lý hoạt động

## 1. Tổng quan về Amazon DynamoDB

**Amazon DynamoDB** là một hệ thống cơ sở dữ liệu NoSQL key/value store được thiết kế để cung cấp khả năng sẵn sàng cao (High Availability) và khả năng mở rộng (Scalability) tuyến tính. Điểm khác biệt lớn nhất so với các hệ thống quan hệ truyền thống là DynamoDB hi sinh tính nhất quán mạnh (Strong Consistency) để đảm bảo hệ thống luôn ghi nhận dữ liệu được (**"Always Writeable"**).

### Các đặc điểm thiết kế cốt lõi:
*   **Giao diện đơn giản (Simple Interface):** Tập trung vào các thao tác Get/Put đơn giản.
*   **Mô hình Key/Value:** Dữ liệu được truy cập thông qua khóa duy nhất.
*   **Conflict Resolution during Read:** Xung đột dữ liệu (do ghi đồng thời) được giải quyết khi đọc dữ liệu, không chặn việc ghi.

---

## 2. Nguyên lý Thiết kế (Design Considerations)

Để xây dựng một hệ thống phân tán hoạt động ổn định, DynamoDB tuân thủ 4 nguyên lý thiết kế chính:

| Nguyên lý | Giải thích | Ưu điểm |
| :--- | :--- | :--- |
| **Incremental Scalability (Mở rộng tuyến tính)** | Hệ thống cho phép thêm tài nguyên (node) mà không cần downtime và có thể mở rộng từ nhỏ đến lớn. | Tiết kiệm chi phí, đáp ứng nhu cầu tăng trưởng dữ liệu. |
| **Symmetry (Tính đối xứng)** | Mọi node trong hệ thống đều có vai trò và trách nhiệm như nhau (peer-to-peer). | Đơn giản hóa việc quản lý, không có điểm lỗi đơn lẻ (Single Point of Failure). |
| **Decentralization (Phi trung ương)** | Loại bỏ kiểm soát tập trung. Các node tự quyết định và giao tiếp với nhau. | Tăng khả năng chịu lỗi, tránh các sự cố do lỗi ở node trung tâm. |
| **Heterogeneity (Tính đa dạng)** | Hệ thống tận dụng sự khác biệt về phần cứng. Node mới có dung lượng lớn hơn có thể xử lý nhiều dữ liệu hơn node cũ. | Dễ dàng nâng cấp hạ tầng từng phần mà không cần thay đổi toàn bộ hệ thống. |

---

## 3. Kiến trúc Hệ thống (System Architecture)

Kiến trúc của DynamoDB tập trung giải quyết các bài toán phức tạp trong môi trường phân tán:

1.  **Partitioning (Phân vùng dữ liệu):** Chia nhỏ dữ liệu để lưu trữ trên nhiều node khác nhau.
2.  **High Availability for writes:** Đảm bảo ghi dữ liệu thành công ngay cả khi một số node gặp sự cố.
3.  **Handling temporary failures (Xử lý lỗi tạm thời):** Cơ chế sao lưu và phục hồi khi node mất kết nối短暂.
4.  **Membership and failure detection (Thành viên và phát hiện lỗi):** Theo dõi trạng thái các node trong cluster.

---

## 4. Thuật toán Phân vùng: Consistent Hashing

DynamoDB sử dụng thuật toán **Consistent Hashing** để phân phối dữ liệu.

### Khái niệm Consistent Hashing:
Thay vì ánh xạ trực tiếp dữ liệu vào một danh sách cố định các node, Consistent Hashing ánh xạ cả **Khóa (Key)** và **Node** lên cùng một không gian tên (namespace) hình tròn, gọi là **"Ring" (Vòng tròn)**.

*   **Cách hoạt động:** Hash function output được coi là một vòng tròn cố định.
*   **Zero-hop DHT:** DynamoDB là một Distributed Hash Table (Bảng băm phân tán) không cần nhảy qua nhiều node để tìm đích đến (mỗi node biết đường đi trực tiếp).

### Thách thức lớn (Grand Challenge):
Làm thế nào để mọi node luôn có được **"view" (góc nhìn)** cập nhật nhất về vòng tròn (ring) khi có node mới加入 hoặc bị loại bỏ?

---

## 5. Code Mẫu & Minh họa Thực tế

### A. Minh họa Consistent Hashing (Python)

Để giải quyết bài toán "Ring view", chúng ta cần một cơ chế băm và quản lý node.

```python
import hashlib

class ConsistentHashRing:
    def __init__(self, nodes=None, replicas=3):
        """
        replicas: Số lượng bản sao ảo (virtual nodes) để cân bằng tải.
        """
        self.replicas = replicas
        self.ring = dict()
        self.sorted_keys = []
        if nodes:
            for node in nodes:
                self.add_node(node)

    def _hash(self, key):
        """Băm key thành số nguyên 32-bit"""
        return int(hashlib.md5(key.encode('utf-8')).hexdigest(), 16)

    def add_node(self, node):
        """Thêm node vào vòng tròn"""
        for i in range(self.replicas):
            key = self._hash(f"{node}:{i}")
            self.ring[key] = node
            self.sorted_keys.append(key)
        
        # Sắp xếp các key để tìm kiếm nhị phân
        self.sorted_keys.sort()

    def get_node(self, key):
        """Tìm node chịu trách nhiệm lưu trữ key"""
        if not self.ring:
            return None
        
        hash_key = self._hash(key)
        
        # Tìm key lớn nhất nhỏ hơn hoặc bằng hash_key (Binary Search)
        # Nếu không tìm thấy, quay lại đầu vòng tròn (wrap around)
        idx = self._binary_search(hash_key)
        
        return self.ring[self.sorted_keys[idx]]

    def _binary_search(self, hash_key):
        # Logic tìm kiếm nhị phân trong danh sách sorted_keys
        # (Để ngắn gọn, giả định hàm này trả về index)
        # Trong thực tế, dùng bisect module của Python
        pass 

# Sử dụng
ring = ConsistentHashRing(["NodeA", "NodeB", "NodeC"])
print(f"Data 'User:123' stored at: {ring.get_node('User:123')}")
```

### B. Giao diện Ghi dữ liệu (Pseudo-code)

DynamoDB cho phép ghi bất chấp lỗi tạm thời (Always Writeable).

```python
def dynamodb_put_item(table_name, item):
    """
    Ghi item vào DynamoDB.
    Chiến lược: Ghi vào W node (Write Quorum).
    """
    nodes = get_responsible_nodes_for_item(item['id'])
    
    try:
        # Thực hiện ghi đồng thời vào các node
        results = parallel_write(nodes, item)
        
        # Kiểm tra số lượng ghi thành công
        success_count = sum(1 for r in results if r.status == 'OK')
        
        if success_count >= WRITE_QUORUM:
            return {"status": "SUCCESS"}
        else:
            # Nếu không đạt Quorum, ghi vào hàng đợi (Hinted Handoff)
            queue.write_later(item)
            return {"status": "SUCCESS_WITH_HINT"}
            
    except TemporaryFailure:
        # Không bao giờ từ chối ghi
        queue.write_later(item)
        return {"status": "SUCCESS"}
```

---

## 6. Hướng dẫn Sử dụng & Phân tích

### Khi nào sử dụng DynamoDB? (Use Cases)
*   **Ứng dụng cần độ trễ cực thấp:** Game, quảng cáo theo thời gian thực.
*   **Dữ liệu lớn, cần mở rộng nhanh:** Lưu trữ log, lịch sử truy cập người dùng hàng tỷ bản ghi.
*   **Hệ thống cần "Always Available":** Ứng dụng di động, IoT, nơi việc mất kết nối mạng là thường xuyên.

### Sử dụng như thế nào? (How to use)
1.  **Xác định Primary Key:** Chọn Partition Key (và Sort Key nếu cần) để dữ liệu được phân vùng đều.
2.  **Thiết lập Read/Write Capacity Unit (RCU/WCU):** Cấu hình băng thông đọc/ghi.
3.  **API Calls:** Sử dụng `PutItem` để ghi, `GetItem` để đọc (bằng Primary Key), `Query` hoặc `Scan` (ít khuyến khích do tốn tài nguyên).

### Ưu & Nhược điểm

| Ưu điểm (Pros) | Nhược điểm (Cons) |
| :--- | :--- |
| **Khả năng mở rộng vô hạn:** Dễ dàng thêm node. | **Không có transaction phức tạp:** Hỗ trợ transaction cơ bản nhưng không mạnh như SQL. |
| **Sẵn sàng cao (High Availability):** Chịu được lỗi node. | **Chi phí:** Có thể đắt đỏ nếu truy vấn nhiều (Scan) hoặc dung lượng lớn. |
| **Độ trễ thấp:** Phù hợp thời gian thực. | **Phức tạp trong modeling:** Phải design schema theo query pattern, không linh hoạt như NoSQL document. |

---

## 7. Ví dụ Thực tế trong Industry

**Ví dụ: Hệ thống giỏ hàng Shopping Cart (Amazon)**

*   **Bài toán:** Hàng triệu người dùng thêm/xóa sản phẩm cùng lúc. Nếu hệ thống bị lỗi (mất mạng, server chết), người dùng không thể thanh toán là mất doanh thu.
*   **Giải pháp DynamoDB:**
    *   **Key:** `UserID`
    *   **Hoạt động:** Khi người dùng thêm sản phẩm, request được gửi đi.
    *   **Conflict Resolution:** Nếu người dùng thêm sản phẩm trên điện thoại và laptop cùng lúc (cùng một giỏ hàng), DynamoDB sẽ ghi nhận cả hai thao tác. Khi đọc giỏ hàng, hệ thống sẽ gộp các thay đổi lại (ví dụ: Merge các item).
    *   **Tại sao dùng Consistent Hashing?** Đảm bảo dù người dùng ở quốc gia nào, dữ liệu vẫn được phân phối đều và truy cập nhanh chóng.

---

*Tài liệu tham khảo: "4.3_amazon_dynamodb.pdf" - Chương 4: Cơ sở dữ liệu phi quan hệ NoSQL.*

---

Chào bạn, với vai trò là một chuyên gia về Big Data và Hệ thống Phân tán, tôi sẽ phân tích và trình bày lại nội dung từ các slide về **Amazon DynamoDB** một cách chi tiết, chuyên nghiệp và dễ hiểu dưới đây.

---

# Phân tích Hệ thống Phân tán trong Amazon DynamoDB

Tài liệu này t tổng hợp các khái niệm cốt lõi về kiến trúc DynamoDB, một cơ sở dữ liệu NoSQL quan trọng trong hệ sinh thái AWS. Các khái niệm này giải quyết các bài toán về **tính khả dụng (Availability)**, **tính nhất quán (Consistency)** và **khả năng mở rộng (Scalability)** trong môi trường phân tán.

## 1. Virtual Nodes (Nút Ảo)

### Giải thích Khái niệm
Trong các hệ thống phân tán sử dụng mô hình **Consistent Hashing**, mỗi máy chủ vật lý (Physical Node) không chỉ đại diện cho một điểm duy nhất trên vòng (Hash Ring). Thay vào đó, một máy chủ vật lý sẽ chịu trách nhiệm cho nhiều **Virtual Nodes** (nút ảo) khác nhau.

*   **Tại sao cần Virtual Nodes?**
    *   **Cân bằng tải (Load Balancing):** Nếu mỗi máy chủ chỉ là một nút duy nhất, việc thêm hoặc bớt máy chủ sẽ gây ra sự dịch chuyển dữ liệu lớn. Virtual Nodes cho phép phân phối dữ liệu đều hơn.
    *   **Xử lý phần cứng không đồng nhất (Heterogeneity):** Các máy chủ mạnh hơn (nhiều CPU/RAM) sẽ được gán nhiều Virtual Nodes hơn, từ đó xử lý nhiều lưu lượng truy cập hơn.

### Code Mẫu: Cấu trúc Consistent Hashing với Virtual Nodes
Dưới đây là ví dụ minh họa bằng Python về cách một máy chủ vật lý có thể quản lý nhiều Virtual Nodes.

```python
import hashlib

class VirtualNode:
    def __init__(self, node_id, virtual_id):
        self.node_id = node_id  # ID máy chủ vật lý (ví dụ: "Server-A")
        self.virtual_id = virtual_id # ID ảo (ví dụ: 1, 2, 3...)
        self.key = f"{node_id}-{virtual_id}"
    
    def get_hash(self):
        # Tính hash để xác định vị trí trên Ring
        return int(hashlib.md5(self.key.encode()).hexdigest(), 16)

class PhysicalNode:
    def __init__(self, name, capacity_weight=1):
        self.name = name
        self.capacity_weight = capacity_weight
        self.virtual_nodes = []
        
    def create_virtual_nodes(self, num_vnodes):
        for i in range(num_vnodes):
            vnode = VirtualNode(self.name, i)
            self.virtual_nodes.append(vnode)
            print(f"Created {vnode.key} at hash {vnode.get_hash()}")

# Ví dụ sử dụng
server_A = PhysicalNode("Server-A", capacity_weight=3) # Server mạnh
server_B = PhysicalNode("Server-B", capacity_weight=1) # Server yếu

# Server A có nhiều virtual nodes hơn do cấu hình mạnh hơn
server_A.create_virtual_nodes(3) 
server_B.create_virtual_nodes(1)
```

### Hướng dẫn Sử dụng
*   **Khi nào sử dụng?** Dùng trong các hệ thống phân tán cần cân bằng tải động và khả năng chịu lỗi cao (Fault Tolerance).
*   **Sử dụng như thế nào?**
    1.  Xác định số lượng Virtual Nodes dựa trên năng lực máy chủ.
    2.  Phân phối các nút ảo này đều trên Consistent Hash Ring.
    3.  Khi một Physical Node bị lỗi, các Virtual Nodes của nó sẽ được chuyển sang các Physical Node khác.
*   **Ưu & Nhược điểm:**
    *   *Ưu:* Cân bằng tải tốt hơn, giảm thời gian downtime khi thêm/bớt node, xử lý được máy chủ không đồng nhất.
    *   *Nhược:* Tăng chi phí quản lý ánh xạ (phải theo dõi nhiều phần tử hơn).

---

## 2. Replication (Nhân bản)

### Giải thích Khái niệm
**Replication** là quá trình sao chép dữ liệu (mỗi item) sang nhiều máy chủ khác nhau để đảm bảo dữ liệu không bị mất khi một máy chủ gặp sự cố.

*   **Preference List:** Danh sách các máy chủ (host) chịu trách nhiệm lưu trữ một key cụ thể.
*   **N (Replication Factor):** Số lượng bản sao của dữ liệu (ví dụ: N=3 có nghĩa là 1 bản chính và 2 bản sao).

### Code Mẫu: Logic Replication
Minh họa quy trình ghi dữ liệu vào nhiều replica.

```python
class ReplicationManager:
    def __init__(self, nodes, replication_factor=3):
        self.nodes = nodes # Danh sách các node trên ring
        self.N = replication_factor

    def find_preference_list(self, key):
        # Logic tìm N node tiếp theo trên ring cho key này
        # (Giả định danh sách nodes đã được sắp xếp theo hash)
        print(f"Finding {self.N} replicas for key: {key}")
        # ... Logic Consistent Hashing ...
        return self.nodes[:self.N] 

    def write_data(self, key, value):
        replicas = self.find_preference_list(key)
        success_count = 0
        
        for node in replicas:
            try:
                # Giả lập ghi vào node
                print(f"Writing to node {node}: {key}={value}")
                success_count += 1
            except Exception as e:
                print(f"Failed to write to {node}: {e}")
        
        if success_count >= self.N:
            return True
        return False

# Ví dụ
nodes = ["Node-1", "Node-2", "Node-3", "Node-4"]
rep_manager = ReplicationManager(nodes, N=3)
rep_manager.write_data("user_123", "John Doe")
```

### Hướng dẫn Sử dụng
*   **Khi nào sử dụng?** Luôn luôn sử dụng trong các hệ thống Production để đảm bảo **High Availability** (Tính khả dụng cao).
*   **Sử dụng như thế nào?** Thiết lập hệ số replication (N) khi tạo bảng hoặc keyspace.
*   **Ưu & Nhược điểm:**
    *   *Ưu:* Chịu lỗi tốt (tolerate node failure), tăng khả năng đọc dữ liệu (có thể đọc từ bản sao gần nhất).
    *   *Nhược:* Tăng chi phí lưu trữ và độ phức tạp khi ghi (write amplification).

---

## 3. Quorum (Bỏ phiếu đa số)

### Giải thích Khái niệm
Quorum là cơ chế để đạt được sự nhất quán (Consistency) giữa các bản sao (Replicas) khi có các thao tác đọc (Read) và ghi (Write). Nó dựa trên công thức toán học:

$$R + W > N$$

Trong đó:
*   **N:** Tổng số bản sao (Replication Factor).
*   **R:** Số lượng node phải thành công để coi thao tác **Read** là thành công.
*   **W:** Số lượng node phải thành công để coi thao tác **Write** là thành công.

### Phân loại Cấu hình
| Cấu hình | Mô tả | Ưu điểm | Nhược điểm |
| :--- | :--- | :--- | :--- |
| **Strong Consistency** | $R + W > N$ (Ví dụ: $R=2, W=2, N=3$) | Đảm bảo dữ liệu đọc luôn là dữ liệu mới nhất vừa ghi. | Tăng độ trễ (Latency) do phải chờ nhiều node phản hồi. |
| **Eventual Consistency** | $R + W \le N$ (Ví dụ: $R=1, W=1, N=3$) | Tốc độ rất nhanh, độ trễ thấp. | Dữ liệu có thể không đồng nhất ngay lập tức (mô hình "last write wins"). |

### Code Mẫu: Logic Quorum
```python
class QuorumSystem:
    def __init__(self, N, R, W):
        self.N = N
        self.R = R
        self.W = W
        # Kiểm tra tính hợp lệ
        if R + W <= N:
            print("Warning: Eventual Consistency mode (R + W <= N)")
        else:
            print("Strong Consistency mode enabled")

    def perform_write(self, replicas):
        # Giả lập ghi vào W node
        success = 0
        for node in replicas[:self.W]:
            success += 1 # Giả lập thành công
        return success >= self.W

    def perform_read(self, replicas):
        # Giả lập đọc từ R node
        success = 0
        for node in replicas[:self.R]:
            success += 1
        return success >= self.R

# Ví dụ: Strong Consistency
system = QuorumSystem(N=3, R=2, W=2)
print(f"Write success: {system.perform_write(['N1', 'N2', 'N3'])}")
print(f"Read success: {system.perform_read(['N1', 'N2', 'N3'])}")
```

### Hướng dẫn Sử dụng
*   **Khi nào sử dụng?**
    *   Dùng cho các hệ thống tài chính hoặc dữ liệu nhạy cảm cần chính xác ngay lập tức (Strong Consistency).
    *   Dùng cho mạng xã hội, cache (Eventual Consistency).
*   **Sử dụng như thế nào?** Chọn các giá trị R và W phù hợp khi cấu hình DynamoDB (Strongly Consistent Read vs. Eventually Consistent Read).
*   **Ưu & Nhược điểm:**
    *   *Ưu:* Linh hoạt, cân bằng giữa độ chính xác và tốc độ.
    *   *Nhược:* Nếu cấu hình sai (ví dụ N=3, R=3, W=3), hệ thống sẽ bị treo nếu chỉ hỏng 1 node.

---

## 4. Temporary Failures: Sloppy Quorum & Hinted Handoff

### Giải thích Khái niệm
Khi một node trong hệ thống tạm thời không thể truy cập (do lỗi mạng, bảo trì), cơ chế **Quorum** thông thường sẽ thất bại. DynamoDB sử dụng các kỹ thuật sau để đảm bảo hệ thống **"Always Writeable"** (Luôn ghi được):

1.  **Sloppy Quorum (Quorum Lỏng lẻo):**
    *   Thay vì ghi vào N node trong Preference List (mặc định), hệ thống sẽ ghi vào N node *khác* bất kỳ trong Ring (gọi là **Sloppy Quorum**).
2.  **Hinted Handoff (Bàn giao có ghi chú):**
    *   Node nhận thay thế (ví dụ node E) sẽ lưu dữ liệu đó.
    *   Node E sẽ đánh dấu rằng dữ liệu này thuộc về node B (bị lỗi).
    *   Khi node B hoạt động trở lại, node E sẽ **bàn giao (handoff)** dữ liệu đó lại cho node B.

### Ví dụ Trực quan
*   **Tình huống:** Ghi dữ liệu vào Node B, nhưng Node B đang down.
*   **Hành động:** Hệ thống chuyển bản sao sang Node E.
*   **Ghi chú:** Node E lưu dữ liệu với "Hint" (chú thích): "Dữ liệu này của Node B".
*   **Kết quả:** Node B quay lại -> Node E gửi dữ liệu về -> Xóa dữ liệu tạm.

### Code Mẫu: Logic Hinted Handoff
```python
class HintedHandoffManager:
    def __init__(self):
        self.storage = {} # Lưu trữ tạm thời
        self.down_nodes = {"Node-B"} # Giả lập Node B đang down

    def write(self, key, value, intended_node):
        if intended_node in self.down_nodes:
            print(f"Node {intended_node} is down. Using Sloppy Quorum.")
            # Chọn một node thay thế (ví dụ Node-E)
            fallback_node = "Node-E"
            
            # Lưu với "Hint"
            self.storage[f"{key}_hint"] = {
                "owner": intended_node,
                "data": value,
                "status": "WAITING_FOR_HANDOFF"
            }
            print(f"Data stored at {fallback_node} with Hint for {intended_node}")
            return True
        else:
            print(f"Write directly to {intended_node}")
            return True

    def recover_node(self, node_name):
        if node_name in self.down_nodes:
            print(f"Node {node_name} is back online. Checking for hints...")
            # Tìm và bàn giao dữ liệu
            for k, v in list(self.storage.items()):
                if v.get("owner") == node_name:
                    print(f"Handing off data {v['data']} to {node_name}")
                    # Gửi dữ liệu về node chính
                    del self.storage[k] # Xóa sau khi bàn giao
            self.down_nodes.remove(node_name)

# Ví dụ
manager = HintedHandoffManager()
manager.write("user_101", "Alice", "Node-B")
manager.recover_node("Node-B")
```

### Hướng dẫn Sử dụng
*   **Khi nào sử dụng?** Khi hệ thống yêu cầu độ sẵn sàng ghi dữ liệu (Write Availability) cao hơn là độ nhất quán nghiêm ngặt.
*   **Sử dụng như thế nào?** Đây là cơ chế mặc định trong DynamoDB để xử lý lỗi tạm thời.
*   **Ưu & Nhược điểm:**
    *   *Ưu:* Giữ cho hệ thống hoạt động ngay cả khi nhiều node bị lỗi (giảm downtime).
    *   *Nhược:* Nếu node lỗi quá lâu, các node thay thế sẽ bị quá tải; dữ liệu có thể bị mất nếu node thay thế bị lỗi trước khi bàn giao.

---

## 5. Replica Synchronization & Merkle Tree

### Giải thích Khái niệm
Khi một node bị lỗi và sau đó hoạt động trở lại, dữ liệu của nó có thể bị **lệch lạc (Inconsistency)** so với các node khác. Chúng ta cần đồng bộ hóa (Synchronize) lại.

Nếu dữ liệu lớn, việc so sánh từng key một là rất chậm. **Merkle Tree** được sử dụng để tối ưu hóa việc này.

*   **Merkle Tree (Hash Tree):**
    *   Cây nhị phân.
    *   **Lá (Leaves):** Là hash của các giá trị của từng key riêng lẻ.
    *   **Node cha:** Là hash của các node con của nó.
    *   **Node gốc (Root):** Đại diện cho hash của toàn bộ dữ liệu trong phân khu đó.

### Ưu điểm của Merkle Tree
*   **Kiểm tra độc lập:** Chỉ cần so sánh **Root Hash** của 2 node.
*   **Phát hiện nhanh:** Nếu Root Hash khác nhau, ta đi xuống nhánh con để tìm ra key nào bị sai mà không cần tải toàn bộ dữ liệu.
*   **Giảm băng thông:** Chỉ cần trao đổi các hash ở mức cao để tìm ra vùng dữ liệu bị lỗi.

### Code Mẫu: Cấu trúc Merkle Tree (Đơn giản)
```python
import hashlib

class MerkleNode:
    def __init__(self, data=None, left=None, right=None):
        self.left = left
        self.right = right
        self.data = data
        self.hash = self._compute_hash()

    def _compute_hash(self):
        if self.data:
            return hashlib.sha256(self.data.encode()).hexdigest()
        if self.left and self.right:
            return hashlib.sha256((self.left.hash + self.right.hash).encode()).hexdigest()
        return None

def build_merkle_tree(data_list):
    # Tạo các node lá
    leaves = [MerkleNode(data=d) for d in data_list]
    
    # Xây dựng cây lên trên
    while len(leaves) > 1:
        next_level = []
        for i in range(0, len(leaves), 2):
            left = leaves[i]
            right = leaves[i+1] if i + 1 < len(leaves) else left
            parent = MerkleNode(left=left, right=right)
            next_level.append(parent)
        leaves = next_level
    
    return leaves[0] if leaves else None

# Ví dụ: So sánh dữ liệu 2 Replica
replica_A_data = ["data1", "data2", "data3"]
replica_B_data = ["data1", "data2", "data4"] # Lỗi tại data3 vs data4

root_A = build_merkle_tree(replica_A_data)
root_B = build_merkle_tree(replica_B_data)

print(f"Root Hash A: {root_A.hash}")
print(f"Root Hash B: {root_B.hash}")

if root_A.hash != root_B.hash:
    print("Phát hiện lỗi đồng bộ! Cần so sánh sâu hơn (truy xuất key cụ thể).")
```

### Hướng dẫn Sử dụng
*   **Khi nào sử dụng?** Khi các node trong hệ thống phân tán mất kết nối tạm thời và cần đồng bộ lại dữ liệu khi kết nối phục hồi.
*   **Sử dụng như thế nào?**
    1.  Tính toán Merkle Tree cho các block dữ liệu trên mỗi node.
    2.  So sánh Root Hash của các node.
    3.  Nếu khác nhau, duyệt xuống các node con để tìm ra block/key bị sai.
    4.  Chỉ đồng bộ hóa các block/key bị sai đó.
*   **Ưu & Nhược điểm:**
    *   *Ưu:* Tiết kiệm băng thông đáng kể, tăng tốc độ đồng bộ hóa.
    *   *Nhược:* Tốn CPU để tính toán hash cây; phức tạp trong việc cập nhật (cần cập nhật từ lá lên root).

---

## Tóm tắt Ví dụ Thực tế trong Ngành

Hãy tưởng tượng bạn đang xây dựng một ứng dụng **Đặt vé máy bay (Airline Booking System)** sử dụng DynamoDB:

1.  **Virtual Nodes:** Các máy chủ vật lý trong trung tâm dữ liệu của AWS được chia thành hàng nghìn Virtual Nodes. Khi Black Friday đến, AWS tự động thêm các máy chủ mạnh và tăng Virtual Nodes cho các region đang bị quá tải.
2.  **Replication:** Khi bạn đặt vé (Key: `Booking#123`), dữ liệu được ghi vào 3 Region khác nhau (ví dụ: Virginia, Ireland, Singapore) để đảm bảo nếu một trung tâm dữ liệu bị cháy, vé của bạn vẫn an toàn.
3.  **Quorum:** Khi bạn nhấn "Thanh toán", hệ thống yêu cầu ghi thành công vào ít nhất 2 trong 3 Region (W=2). Khi bạn kiểm tra lại vé, hệ thống đọc từ 2 Region (R=2) để đảm bảo bạn không thấy vé "ảo" hoặc vé đã bị h hủy.
4.  **Sloppy Quorum:** Đột nhiên Region Ireland bị lỗi mạng. Hệ thống tự động ghi vé của bạn vào một Region dự phòng khác (ví dụ: Tokyo) với "Hint" là "Vé này thuộc về Ireland". Khi Ireland phục hồi, vé được chuyển về.
5.  **Merkle Tree:** Sau sự cố, Region Ireland quay lại. Thay vì tải lại hàng triệu vé từ Region khác, hệ thống so sánh Merkle Tree. Nó phát hiện chỉ có các vé từ 10h đến 11h là bị lệch, và chỉ đồng bộ hóa phần dữ liệu nhỏ này.

---


> [Lỗi xử lý trang 11-15]
Chào bạn, tôi là một chuyên gia về Big Data và Hệ thống Phân tán. Tôi đã phân tích yêu cầu của bạn và nội dung slide được cung cấp.

**Phân tích nội dung:**
Nội dung slide bạn cung cấp (`4.3_amazon_dynamodb.pdf`) chỉ bao gồm phần kết thúc: "Thank you for your attention! Q&A". Điều này có nghĩa là không có thông tin chi tiết về Amazon DynamoDB trong slide này.

Tuy nhiên, với vai trò là chuyên gia và để đáp ứng đầy đủ các yêu cầu chi tiết của bạn (trích xuất code, giải thích khái niệm, ví dụ thực tế...), tôi sẽ **tái tạo và trình bày toàn diện kiến thức về Amazon DynamoDB** dựa trên kiến thức chuyên môn sâu rộng của tôi, tương ứng với chủ đề của slide (4.3 - Amazon DynamoDB).

Dưới đây là tài liệu chi tiết được trình bày chuyên nghiệp bằng tiếng Việt.

---

# 4.3: Amazon DynamoDB - Phân tích & Hướng dẫn Chi tiết

## 1. Tổng quan về Amazon DynamoDB

**Amazon DynamoDB** là một dịch vụ cơ sở dữ liệu NoSQL được quản lý hoàn toàn (fully managed) của AWS. Nó cung cấp khả năng lưu trữ và truy xuất dữ liệu với hiệu suất ổn định và độ trễ thấp, bất kể quy mô dữ liệu.

### Giải thích Khái niệm:
*   **NoSQL (Not Only SQL):** Khác với cơ sở dữ liệu quan hệ (RDBMS) như MySQL hay PostgreSQL, DynamoDB không cần định nghĩa schema cố định và linh hoạt trong việc xử lý dữ liệu phi cấu trúc hoặc bán cấu trúc.
*   **Fully Managed:** AWS chịu trách nhiệm quản lý phần cứng, vá lỗi, sao lưu và mở rộng quy mô. Developers chỉ cần tập trung vào việc xây dựng ứng dụng.
*   **Key-Value & Document Database:** DynamoDB lưu trữ dữ liệu dưới dạng các mục (items) trong các bảng (tables). Mỗi mục là một tập hợp các cặp Attribute-Value.

---

## 2. Các Khái niệm Nền tảng (Core Concepts)

### 2.1. Cấu trúc Dữ liệu
*   **Tables:** Tương tự như bảng trong RDBMS.
*   **Items:** Các bản ghi dữ liệu, tương tự như hàng (rows). Mỗi Item có thể có số lượng thuộc tính khác nhau.
*   **Attributes:** Các cặp khóa - giá trị (Key-Value) cấu thành nên một Item.
*   **Primary Key:** Dùng để định danh duy nhất một Item trong bảng.
    *   **Partition Key (PK):** Dùng để phân vùng dữ liệu trên các server vật lý.
    *   **Composite Key (PK + Sort Key):** PK kết hợp với Sort Key (SK) để tạo cấu trúc phân cấp và cho phép truy vấn phức tạp hơn.

### 2.2. Capacity Modes (Chế độ năng lực)
DynamoDB cung cấp hai chế độ tính năng để phù hợp với từng loại workload:

1.  **On-Demand Mode:**
    *   Tự động mở rộng quy mô mà không cần dự đoán traffic.
    *   Thanh toán theo số lượng request thực tế (pay-per-request).
    *   Phù hợp cho workload không đều, khó dự đoán.
2.  **Provisioned Mode:**
    *   Bạn xác định số lượng Read Capacity Units (RCU) và Write Capacity Units (WCU) cần thiết.
    *   Phù hợp cho workload ổn định, có thể dự đoán được để tối ưu chi phí.

---

## 3. Code Mẫu & Cách Sử dụng

Để minh họa, chúng ta sẽ sử dụng **Python (Boto3 SDK)**. Giả sử chúng ta đang xây dựng hệ thống quản lý người dùng (User Profile).

### 3.1. Thiết lập & Tạo Bảng (Setup & Create Table)

**Khi nào sử dụng?** Khi bắt đầu một dự án mới hoặc cần tạo cấu trúc lưu trữ dữ liệu phi cấu trúc.

**Cách sử dụng:** Định nghĩa Primary Key và khởi tạo bảng.

```python
import boto3

# Khởi tạo client DynamoDB
dynamodb = boto3.resource('dynamodb', region_name='us-east-1')

def create_user_table():
    try:
        # Tạo bảng Users với Primary Key là 'user_id' (String)
        table = dynamodb.create_table(
            TableName='Users',
            KeySchema=[
                {
                    'AttributeName': 'user_id',
                    'KeyType': 'HASH'  # Partition Key
                }
            ],
            AttributeDefinitions=[
                {
                    'AttributeName': 'user_id',
                    'AttributeType': 'S'  # String
                }
            ],
            BillingMode='PAY_PER_REQUEST'  # Sử dụng On-Demand Mode
        )
        # Chờ cho đến khi bảng được tạo
        table.meta.client.get_waiter('table_exists').wait(TableName='Users')
        print(f"Table {table.table_name} created successfully!")
        return table
    except Exception as e:
        print(f"Error creating table: {e}")

# Chạy hàm
# create_user_table()
```

### 3.2. Thêm và Truy xuất Dữ liệu (Put & Get Item)

**Khi nào sử dụng?**
*   **PutItem:** Khi cần ghi mới một bản ghi (Record).
*   **GetItem:** Khi cần truy xuất nhanh một bản ghi dựa trên Primary Key.

**Ưu điểm:** Hoạt động trong thời gian thực (Single-digit millisecond latency).

```python
def add_user(user_id, name, email, age):
    table = dynamodb.Table('Users')
    try:
        response = table.put_item(
            Item={
                'user_id': user_id,
                'name': name,
                'email': email,
                'age': age,
                'status': 'ACTIVE'
            }
        )
        print(f"User {name} added successfully.")
        return response
    except Exception as e:
        print(f"Error adding user: {e}")

def get_user(user_id):
    table = dynamodb.Table('Users')
    try:
        response = table.get_item(
            Key={
                'user_id': user_id
            }
        )
        item = response.get('Item')
        if item:
            return item
        else:
            return "User not found."
    except Exception as e:
        return f"Error getting user: {e}"

# Ví dụ sử dụng:
# add_user("U123", "Alice", "alice@example.com", 28)
# print(get_user("U123"))
```

### 3.3. Query và Scan (Truy vấn phức tạp)

**Giải thích khái niệm:**
*   **Query:** Tìm các Item có Primary Key (Partition Key) khớp với giá trị cụ thể. Rất hiệu quả và nhanh chóng. Có thể lọc thêm bằng Sort Key.
*   **Scan:** Đọc toàn bộ bảng. Rất chậm và tốn kém tài nguyên (Read Capacity). Chỉ nên dùng khi cần duyệt toàn bộ dữ liệu hoặc với bảng nhỏ.

**Khi nào sử dụng Query?** Khi bạn biết giá trị của Partition Key và muốn tìm các bản ghi liên quan.

```python
def query_users_by_status(status_value):
    table = dynamodb.Table('Users')
    try:
        # Giả sử chúng ta có một Index phụ (GSI) trên cột 'status'
        # Hoặc nếu 'status' là Sort Key (phổ biến hơn trong ví dụ này)
        # Để minh họa rõ ràng, ta sẽ dùng Scan (cần thận trọng) hoặc Query nếu có Index
        
        # Ví dụ Query nếu 'status' là Sort Key và chúng ta có Partition Key (ví dụ: 'country')
        # Ở đây tôi sẽ minh họa Scan (vì slide không cung cấp schema chi tiết)
        # Lưu ý: Trong thực tế, tránh Scan trên bảng lớn.
        
        response = table.scan(
            FilterExpression=boto3.dynamodb.conditions.Attr('status').eq(status_value)
        )
        
        items = response.get('Items', [])
        return items
    except Exception as e:
        print(f"Error querying: {e}")

# Ví dụ thực tế: Tìm tất cả người dùng đang hoạt động
# active_users = query_users_by_status('ACTIVE')
# print(active_users)
```

---

## 4. Ưu & Nhược điểm (Pros & Cons)

| Tiêu chí | Ưu điểm (Pros) | Nhược điểm (Cons) |
| :--- | :--- | :--- |
| **Hiệu suất** | Cung cấp độ trễ dưới 10ms (single-digit millisecond) ổn định, bất kể dữ liệu lớn hay nhỏ. | Không phù hợp cho các truy vấn phức tạp (joins) như SQL. |
| **Quy mô (Scalability)** | Tự động mở rộng quy mô mà không downtime. Khả năng lưu trữ dữ liệu không giới hạn. | Chi phí có thể tăng nhanh nếu không quản lý tốt Capacity Modes hoặc thiết kế Primary Key kém (Hot Partition). |
| **Quản lý** | Fully Managed: Không cần lo lắng về server, backup (có thể bật tự động). | Thiếu các tính năng linh hoạt của RDBMS (ví dụ: Transactions hạn chế hơn - mặc dù DynamoDB có hỗ trợ Transactions nhưng phức tạp hơn). |
| **Tích hợp** | Tích hợp sâu với hệ sinh thái AWS (Lambda, API Gateway, S3). | Khó di chuyển (migrate) sang các cloud provider khác nếu sử dụng các tính năng đặc thù của AWS. |

---

## 5. Ví dụ Thực tế trong Ngành Công Nghiệp

### Case Study 1: Gaming - Leaderboard (Bảng xếp hạng)
*   **Vấn đề:** Cần lưu trữ và cập nhật điểm số của hàng triệu người chơi realtime, hiển thị top người chơi nhanh chóng.
*   **Giải pháp với DynamoDB:**
    *   Sử dụng **Composite Key**: `Partition Key` là `GameID` và `Sort Key` là `Score` (hoặc `Time`).
    *   Khi cần lấy Top 10: Query `GameID` và sắp xếp theo `Sort Key` giảm dần (Scan từ đầu).
    *   DynamoDB đảm bảo ghi điểm (Write) cực nhanh không bị tắc nghẽn.

### Case Study 2: E-commerce - Giỏ hàng (Shopping Cart)
*   **Vấn đề:** Mỗi phiên đăng nhập cần truy xuất danh sách sản phẩm trong giỏ hàng ngay lập tức.
*   **Giải pháp với DynamoDB:**
    *   `Partition Key`: `UserID`.
    *   Mỗi Item trong giỏ hàng là một dòng dữ liệu (ví dụ: `ProductID`, `Quantity`, `Price`).
    *   **Ưu điểm:** Khi người dùng reload trang, hệ thống gọi `GetItem(UserID)` là xem ngay giỏ hàng mà không cần join nhiều bảng.

### Case Study 3: IoT (Internet of Things)
*   **Vấn đề:** Hàng tỷ cảm biến (sensors) gửi dữ liệu mỗi giây.
*   **Giải pháp với DynamoDB:**
    *   Lưu trữ dữ liệu thời gian thực.
    *   Sử dụng **Time to Live (TTL)**: Tự động xóa dữ liệu cũ sau 30 ngày để tiết kiệm chi phí và dung lượng.

---

## 6. Kết luận

Amazon DynamoDB là một công cụ mạnh mẽ trong kiến trúc **Big Data và Phân tán**, đặc biệt cho các ứng dụng cần độ sẵn sàng cao (99.999%) và khả năng mở rộng vô hạn. Tuy nhiên, để sử dụng hiệu quả, người thiết kế cần hiểu rõ về **Primary Key design** và lựa chọn **Capacity Mode** phù hợp để tối ưu hóa chi phí và hiệu năng.

---

