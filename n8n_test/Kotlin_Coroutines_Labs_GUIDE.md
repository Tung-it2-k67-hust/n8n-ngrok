# DEVELOPER DECISION GUIDE: Kotlin_Coroutines_Labs.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:05:48



<!-- CHUNK 1-10 -->

# Kotlin Coroutines Developer Decision Guide

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

### Core Definitions

**Coroutine (Tiến trình rút gọn)**
Đoạn code có thể thực thi ngắt quãng, tạm dừng và tiếp tục mà không bloque luồng执行 (Thread).
- *Mental Model*: Giống một hàm có thể "tạm dừng" (pause) ở giữa, nhường Thread cho việc khác, rồi "tiếp tục" (resume) sau đó. Chi phí tạo rẻ hơn Thread rất nhiều.

**Dispatcher (Bộ phân phối)**
Xác định Thread nào sẽ chạy Coroutine đó.
- *Mental Model*: Giống một người chỉ huy, ra lệnh cho Coroutine chạy ở "làn đường" nào (Nhóm tính toán, Nhóm IO, hay Main).

**Scope (Phạm vi)**
Đối tượng quản lý vòng đời của một tập hợp Coroutines. Hủy Scope = Hủy所有 Coroutines trong nó.
- *Mental Model*: Cha mẹ của các Coroutines. Khi cha mẹ chết, con cái theo hết.

**Structured Concurrency (Tính đồng bộ có cấu trúc)**
Principle: Coroutines phải được khởi chạy trong một Scope, và Scope đó phải chờ chúng hoàn thành.
- *Lợi ích*: Chắc chắn không có Coroutine nào bị "bỏ sót" (leak) khi UI/Function kết thúc.

### Why Coroutines?
- **Thread là tài nguyên khan hiếm**: Tạo 1 Thread tốn ~1MB RAM.
- **Callback Hell**: Code异步 (async) truyền thống lồng nhau khó đọc.
- **Coroutines**: Code đọc như đồng bộ (sync), xử lý异步 dễ dàng, cancel an toàn.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Chọn Dispatcher (When to use Dispatcher X?)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Tính toán nặng (CPU-bound)<br>Ví dụ: Parse JSON lớn, xử lý image | **Dispatchers.Default** | Dùng thread pool cố định (số core). Tối ưu cho CPU. | Dùng IO hoặc Main gây tắc nghẽn luồng khác. |
| IO operations (Network, Database, File)<br>Ví dụ: API Call, Read DB | **Dispatchers.IO** | Tạo thread linh hoạt (đến 64 threads). Đợi IO không chặn CPU. | Dùng Default làm chậm tính toán. |
| Cập nhật UI<br>Ví dụ: Đổ dữ liệu lên RecyclerView, show Dialog | **Dispatchers.Main** | Đảm bảo thao tác UI an toàn. | Tránh làm heavy task trên Main. |
| Test hoặc không quan tâm thread | **Dispatchers.Unconfined** | Tiếp tục chạy trên thread của Coroutine gọi nó. | Khó dự đoán thread tiếp theo, dễ crash nếu gọi UI sai thread. |

### Table 2: Khởi tạo Coroutine (Launch vs Async)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Không cần trả kết quả<br>Chỉ cần thực thi任务 | **launch** | Trả về `Job`. Dùng để cancel hoặc join. | Nuốt exception nếu không xử lý Job. |
| Cần trả kết quả (Value)<br>Chờ đợi tính toán hoàn thành | **async** | Trả về `Deferred`. Phải gọi `.await()` để lấy giá trị. | Quên `.await()` -> trả về `Deferred` object thay vì giá trị. |
| Chạy nhiều task độc lập cùng lúc | **async** (nhiều lần) | Kết hợp `awaitAll()` để lấy kết quả tất cả. | Dùng sequential (lần lượt) làm chậm performance. |

### Table 3: Xử lý dữ liệu (Sequence vs Flow)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Dữ liệu IEnumerable (blocks code) | **Sequence** | Đơn giản, sinh ra iterator. Không hỗ trợ suspend. | Dùng Sequence cho code có IO/Network -> blocks Thread. |
| Dữ liệu stream (async, continuous) | **Flow** | Hỗ trợ suspend, operator (map, filter), lạnh (cold). | Dùng List/Sequence cho dữ liệu realtime/stream. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### The Hierarchy of Context

```text
[Scope] (Ví dụ: viewModelScope, GlobalScope)
   |
   v
[CoroutineContext] (Map các element)
   |
   +-- [Job] (Quản lý vòng đời: cancel, join)
   |
   +-- [Dispatcher] (Quản lý thread: Main, IO, Default)
   |
   +-- [CoroutineName] (Tên cho debug)
   |
   +-- [ExceptionHandler] (Bắt lỗi)
```

### Lifecycle Flow

```text
GlobalScope.launch(Dispatchers.IO) {  // 1. Tạo Scope & Context
    try {
        // 2. Kiểm tra Active
        delay(1000)                   // 3. Suspend (tạm dừng)
        // 4. Resume (tiếp tục)
    } catch (e: Exception) {          // 5. Bắt lỗi (nếu có)
    } finally {
        // 6. Cleanup (finally)
    }
}                                     // 7. Kết thúc khi block hết hoặc bị cancel
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: UI Update with `withContext`
**Khi nào dùng:** Khi xử lý dữ liệu từ IO (Network/DB) và cần update UI.

**Tại sao đúng:** `withContext` switch thread tự động, đảm bảo code sau nó chạy đúng thread mong muốn mà không cần callback.

```kotlin
suspend fun loadAndShowUser() {
    // Code ở đây mặc định chạy trên Main (nếu được gọi từ Main)
    showLoading()
    
    // Switch sang IO để fetch data
    val user = withContext(Dispatchers.IO) {
        api.getUser(userId) // Network call
    }
    
    // Tự động switch về Main (thread cũ) để update UI
    updateUi(user)
}
```

### Pattern 2: Parallel Execution
**Khi nào dùng:** Khi có nhiều tác vụ độc lập và muốn chạy song song để tiết kiệm thời gian.

**Tại sao đúng:** `async` tạo ra các job song song, `awaitAll` đợi tất cả hoàn thành cùng lúc.

```kotlin
suspend fun loadDashboardData() {
    val (profile, news, stats) = coroutineScope {
        val profileDeferred = async { api.getProfile() }
        val newsDeferred = async { api.getNews() }
        val statsDeferred = async { api.getStats() }
        
        // Đợi tất cả hoàn thành
        awaitAll(profileDeferred, newsDeferred, statsDeferred)
    }
    updateDashboard(profile, news, stats)
}
```

### Pattern 3: Safe ViewModel Scope
**Khi nào dùng:** Trong Android ViewModel để tránh leak memory khi Activity/Fragment bị hủy.

**Tại sao đúng:** `viewModelScope` tied với ViewModel lifecycle. Hút ViewModel = Hút Coroutine.

```kotlin
class MyViewModel : ViewModel() {
    fun fetchData() {
        viewModelScope.launch {
            try {
                val data = withContext(Dispatchers.IO) { api.get() }
                _uiState.value = UiState.Success(data)
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message)
            }
        }
    }
}
```

### Pattern 4: Sequences for Pagination
**Khi nào dùng:** Load dữ liệu theo trang (lazy loading).

**Tại sao đúng:** `yield` trả về giá trị và tạm dừng, gọi lại mới tính tiếp.

```kotlin
fun loadPages(): Sequence<String> = sequence {
    var page = 1
    while (true) {
        val data = "Page $page" // Giả lập load
        yield(data)
        page++
    }
}

// Usage
val pages = loadPages()
println(pages.take(3).toList()) // ["Page 1", "Page 2", "Page 3"]
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

### 1. Using `GlobalScope`
**Tại sao nguy hiểm:**
- Coroutine chạy vĩnh viễn, không quản lý bởi lifecycle của App/Screen.
- **Dễ Leak Memory**: Nếu Activity hủy nhưng GlobalScope vẫn chạy, nó giữ ссыл kế đến Activity.

### 2. Blocking code inside Coroutine
**Tại sao nguy hiểm:**
```kotlin
launch(Dispatchers.IO) {
    Thread.sleep(1000) // Sai! Block thread池 của IO
}
```
- `Thread.sleep()` blocks thread. Trong `Dispatchers.IO`, nó chiếm slot nhưng không làm gì.
- **Solution**: Dùng `delay()` (non-blocking) thay vì `sleep()`.

### 3. Fire and Forget without Exception Handling
**Tại sao nguy hiểm:**
```kotlin
launch {
    throw Exception("Crash!") // Crash app nếu không có handler
}
```
- Luôn luôn dùng `try-catch` trong `launch` hoặc dùng `CoroutineExceptionHandler` nếu không muốn app crash.

### 4. `runBlocking` trong Production Code
**Tại sao nguy hiểm:**
- Nó block thread hiện tại cho đến khi coroutine inside nó xong.
- Chỉ dùng cho `main()` function hoặc **Test**.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Quick Rules

1.  **Thread Decision**:
    *   CPU Calculation -> `Dispatchers.Default`
    *   Network/DB/File -> `Dispatchers.IO`
    *   Update UI -> `Dispatchers.Main`

2.  **Return Value**:
    *   No return (`void`) -> `launch`
    *   Has return (`value`) -> `async { ... }.await()`

3.  **Suspend Functions**:
    *   Only call suspend from another suspend or coroutine.
    *   Never call blocking (IO) code directly in `Default` or `Main`.

4.  **Memory Safety**:
    *   Always use `viewModelScope` or `lifecycleScope` in Android.
    *   Avoid `GlobalScope` (unless for long-running service).

5.  **Cancellation**:
    *   `Job.cancel()` stops the coroutine.
    *   Use `isActive` check in long loops to support cancellation.

### Top 10 Things to Remember
1.  `delay()` (suspend) vs `Thread.sleep()` (block).
2.  `launch` returns `Job`, `async` returns `Deferred`.
3.  `withContext` is for switching threads easily.
4.  `coroutineScope` ensures children fail together (Structured Concurrency).
5.  `GlobalScope` lives forever (Danger!).
6.  `runBlocking` blocks the current thread (Use in main or tests).
7.  `Flow` is for streams, `Sequence` is for instant collections.
8.  `await()` is needed to get the result from `async`.
9.  `Dispatchers.Main` is only for UI updates.
10. Always handle exceptions inside coroutines.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines - Dispatchers, Jobs & Cancellation

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **Dispatcher (Bộ phân phối):** Specifies which thread or thread pool the coroutine will run on. It decides the "context" of execution.
*   **Unconfined (Không giới hạn):** A dispatcher that starts the coroutine in the caller thread, but resumes it in whatever thread the suspending function (like `delay`) decides. It "jumps" threads.
*   **Main (Luồng chính):** Executes on the UI thread. Required for updating UI elements safely.
*   **withContext (Với ngữ cảnh):** A suspending function that changes the Dispatcher for a specific block of code, then returns to the previous context automatically.
*   **Job (Công việc):** Represents a cancellable unit of work with a lifecycle (active, completed, cancelled).
*   **Cancellation (Hủy bỏ):** Stopping a coroutine's execution gracefully. It does not stop the thread; it stops the coroutine logic.

### Key Mental Models
1.  **Thread Jumping vs. Thread Binding:**
    *   **Unconfined** acts like a "fire and forget" until the first suspension, then it lands wherever the OS wakes it up (e.g., moving from UI to a background worker after `delay`).
    *   **Main** or **IO** bind the code block to that specific thread pool.
2.  **Structured Concurrency:**
    *   `GlobalScope` creates coroutines that live forever (or until the app dies). This is dangerous for memory leaks.
    *   `launch` inside a scope (like `runBlocking` or `viewModelScope`) creates a child job. If the parent dies, the child dies.

### Why this is better than Threads
Using `withContext(Dispatchers.IO)` is vastly superior to `thread { ... }` because it is **suspension-based**, not thread-blocking. It releases the thread back to the pool while waiting (e.g., for network), allowing the app to stay responsive with fewer threads.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Safe UI Updates** | `Dispatchers.Main` | **UI Thread Safety:** The UI framework is not thread-safe. You must run view updates on the Main thread. | Calling `setText()` inside `Dispatchers.IO` causing crashes (Not on Main Thread). |
| **Network/DB/Disk I/O** | `Dispatchers.IO` | **Shared Pool:** Uses a shared pool of threads optimized for waiting operations. Efficient for network calls. | Using `Dispatchers.Default` for network calls, wasting CPU threads meant for calculation. |
| **Heavy CPU Calculation** | `Dispatchers.Default` | **Dedicated CPU Threads:** Creates threads equal to CPU cores. Prevents blocking the UI or IO pools with heavy math. | Running `while (true)` calculation loops on `Dispatchers.Main` (Freezes the app). |
| **Uncertain Behavior** | `Dispatchers.Unconfined` | **Start Fast:** Starts immediately in the current thread. Use only if you don't care which thread resumes after suspension. | Using `Unconfined` for UI updates; app may crash if it resumes on a background thread after `delay`. |
| **Logic inside I/O block** | `withContext(Main)` | **Context Switching:** Efficiently switches threads without creating a new coroutine scope. | Launching a new `GlobalScope.launch(Main)` inside an IO block, creating unnecessary nested jobs. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Execution Flow: `withContext`
The `withContext` function is the bridge between dispatchers. It retains safety while allowing thread switching.

```
[ Start: Main Thread ]
       |
       v
GlobalScope.launch(Dispatchers.IO) {
    (Thread: Background-1)
    |
    +--> Long Task (Network)
    |
    +--> withContext(Dispatchers.Main) {
    |      (Thread: Main/UI)
    |      Update UI
    |      RetVal: String
    |    }
    |
    +--> Resume on (Background-1) [If not returned to caller]
}
```

### Job Hierarchy
*   **Parent Job:** Controls the lifecycle.
*   **Child Job:** `launch` creates a child.
*   **Rule:** `Parent.cancel()` -> `Child.cancel()` (Automatic propagation).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe UI Update Pattern (The Standard)
**Khi nào dùng:** When you need to fetch data and update the UI (e.g., Activity, Fragment, View).

**Tại sao đúng:** It performs heavy work on the IO thread, then safely switches to Main for UI updates using `withContext`.

```kotlin
fun fetchAndDisplayData() {
    // Ideally launched in viewModelScope or lifecycleScope
    GlobalScope.launch(Dispatchers.IO) {
        // 1. Run on Background Thread
        Log.d("myLog", "Run long time task - Thread: ${Thread.currentThread().name}")
        delay(2000) // Simulate network delay
        
        // 2. Switch to Main Thread safely
        withContext(Dispatchers.Main) {
            // Update UI here
            Log.d("myLog", "Update UI - Thread: ${Thread.currentThread().name}")
            // myTextView.text = "Data Loaded"
        }
    }
}
```

### Pattern 2: Cooperative Cancellation (The Safe Loop)
**Khi nào dùng:** When writing loops that run for a long time or involve CPU work.

**Tại sao đúng:** `delay()` is a suspension point that checks for cancellation. If you use a busy loop (while true), you must manually check `isActive` to allow cancellation.

```kotlin
fun startSafeJob() = runBlocking {
    val startTime = System.currentTimeMillis()
    val job = launch(Dispatchers.Default) {
        var nextPrintTime = startTime
        var i = 0
        
        // Check isActive to allow cancellation
        while (isActive) { 
            if (System.currentTimeMillis() >= nextPrintTime) {
                println("job: I'm sleeping ${i++} ...")
                nextPrintTime += 500
            }
        }
    }
    
    delay(1400)
    println("main: Tired of waiting")
    job.cancelAndJoin() // Stops the loop safely
    println("main: Quit")
}
```

### Pattern 3: Cleanup on Cancellation (Finally Block)
**Khi nào dùng:** When a coroutine acquires resources (files, locks, sockets) that must be released regardless of success or cancellation.

**Tại sao đúng:** `finally` executes whether the coroutine completes normally or is cancelled.

```kotlin
fun performCancelableWork() = runBlocking {
    val job = launch {
        try {
            repeat(1000) { i ->
                delay(100)
                println("Hello Coroutine $i")
            }
        } finally {
            // This runs even if cancel() is called
            println("Print from finally - Cleaning up resources")
        }
    }
    
    delay(300)
    println("I want stop coroutine")
    job.cancel()
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Infinite" Blocking Loop (CPU Hoarding)
**Code:** `while (true) { /* do work */ }` inside a Coroutine.
**Lý do nguy hiểm:** If this runs on `Dispatchers.Default`, it will hog all CPU threads. If on `Dispatchers.Main`, it freezes the UI.
**Sửa chữa:** Always add `delay()` (which yields the thread) or check `isActive` to allow cancellation.

### 2. Ignoring `isActive` in computation-heavy tasks
**Code:** A tight loop doing math without checking `isActive`.
**Lý do nguy hiểm:** `cancel()` sends a signal to the coroutine, but if the code never checks (e.g., inside a heavy calculation), the coroutine keeps running forever, wasting battery and potentially showing stale data.

### 3. Mixing GlobalScope with UI updates
**Code:** `GlobalScope.launch(Dispatchers.Main) { updateUI() }`
**Lý do nguy hiểm:** `GlobalScope` coroutines are top-level and not bound to any lifecycle. If the Activity is destroyed while the network request is running, the coroutine continues and tries to update a destroyed View, causing a memory leak or crash.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **Main:** Only for UI updates.
2.  **IO:** Only for Network, Database, File I/O.
3.  **Default:** Only for CPU intensive calculations (sorting huge lists, parsing JSON).
4.  **Unconfined:** Avoid unless you know exactly why you need it. It's unpredictable.
5.  **`withContext` is King:** Use it to switch threads safely inside a coroutine.
6.  **Suspending ≠ Blocking:** `delay` is suspending (good). `Thread.sleep` is blocking (bad).
7.  **Check `isActive`:** Mandatory in loops without `delay`.
8.  **`cancelAndJoin`:** Use to stop a job and wait for it to clean up.
9.  **`try...finally`:** The only place to guarantee resource cleanup.
10. **Scope Matters:** Do not use `GlobalScope` in production architecture; use `viewModelScope` or `lifecycleScope`.

### Decision Logic (If-Else)

```text
IF (Task updates UI) -> Use Dispatchers.Main
ELSE IF (Task reads/writes to Disk or Network) -> Use Dispatchers.IO
ELSE IF (Task calculates numbers/loops) -> Use Dispatchers.Default
ELSE -> Use Current Context or launch new scope.

IF (Loop has no delay) -> Check while(isActive)
IF (Resource acquired) -> Wrap in try { } finally { }
```

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines - Advanced Concepts

---

## SECTION 1: CORE MENTAL MODEL

### 1.1. Cancellation & Cleanup

**Key Concept:** When a Coroutine is cancelled, it enters a **Cancelling** state. Any code inside `finally` blocks will execute, but **suspension points inside `finally`** are subject to CancellationExceptions unless protected.

**Why is this better?** Unlike traditional threads, Coroutines support **cooperative cancellation**. You explicitly define cleanup logic, preventing resource leaks without the heavy overhead of killing threads.

**The Problem:** Standard `delay` or `suspend` functions throw `CancellationException` when cancelled. If your cleanup *needs* to finish (e.g., saving data to a database), the coroutine dies before it finishes.

**The Solution:** `NonCancellable` (Job).
- **Mental Model:** Think of `withContext(NonCancellable)` as a "fireproof room" inside a burning building. You can enter it to finish critical tasks, but you cannot start new "normal" work.

**Code Demo: The "Fireproof" Cleanup**

```kotlin
import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

fun main() = runBlocking {
    val job = launch {
        try {
            println("Working...")
            delay(5000) // Simulating long work
        } finally {
            // If we don't use NonCancellable, this delay(1000) throws CancellationException immediately
            // and "Cleanup Done" never prints.
            withContext(NonCancellable) {
                println("Cleanup: Saving data...")
                delay(1000) // Safe suspension
                println("Cleanup Done")
            }
        }
    }
    
    delay(500) // Let it start
    println("Main: Cancelling job")
    job.cancel() // Triggers cancellation
    println("Main: Finished")
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Handling Timeouts

| Tình huống sử dụng | Nên dùng gì | Tại sao (Timeout Control) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Coroutine **must** finish within $X ms or fail. | `withTimeout(ms)` | **Non-blocking sleep:** Throws `TimeoutCancellationException` if limit exceeded. Keeps code strictly synchronous in structure. | Using `Thread.sleep()` which blocks the thread and freezes the app. |
| Coroutine **should** try to finish within $X ms, return `null` if fails. | `withTimeoutOrNull(ms)` | **Graceful handling:** Returns `null` on timeout instead of crashing. Use this for non-critical background tasks. | Not checking for `null` return value, causing NPEs. |
| Legacy/Complex logic requiring `java.util.concurrent` | `withContext(Dispatchers.IO.limitedTo(500.ms))` | **Blocking fallback:** If migrating legacy code, strictly limit time on blocking threads. | Using `Future.get(timeout, TimeUnit)` inside a coroutine—defeats the purpose of structured concurrency. |

### Table 2: Concurrent Execution

| Tình huống sử dụng | Nên dùng gì | Tại sao (Concurrency) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Need to perform 2 independent network calls, **aggregate** results. | `async` + `await()` | **Structured Async:** `async` returns a `Deferred`. `await()` retrieves the result. Runs **in parallel** if started sequentially. | Calling `await()` immediately after `async` (e.g., `val a = async{...}.await()`). This forces sequential execution. |
| Need to perform 1 background task, **don't need result**. | `launch` | **Fire-and-Forget:** Use when you only care about the side effect (logging, updating DB), not the return value. | Using `async` just to trigger a side effect. Wasteful overhead for `Deferred` object creation. |
| Need to limit concurrency (e.g., max 3 requests at once). | `async` inside a Semaphore or `limitedTo`. | **Throttling:** Prevents overwhelming the server. `async` itself runs concurrently; you need a manager to limit it. | Spawning unlimited `async` calls causing `OutOfMemoryError` or rate limits. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Hierarchy of Scopes

A Coroutine **Scope** is a container that groups coroutines. It determines the lifecycle and context.

```text
[ Parent Job / Scope ]
       |
       +-- [ CoroutineContext ]
            |
            +-- (Dispatcher)   : Where it runs (IO, Main, Default)
            +-- (Job)          : Cancellation & Lifecycle
            +-- (ExceptionHandler) : Error handling

       |
       +-- [ Coroutine Builders ]
            |
            +-- launch { }  : Returns Job (Fire & Forget)
            +-- async { }   : Returns Deferred (Awaitable result)
            +-- runBlocking : Bridges blocking code to suspending code
```

### Relationship Flow: Timeout + Async

When combining concepts, the execution flow is strict:

1.  **Scope Created:** `runBlocking` or `coroutineScope`.
2.  **Async Starts:** `val d = async { ... }` (Job starts immediately).
3.  **Timeout Guard:** `withTimeout(1000) { ... }` starts a countdown.
4.  **Await:** `d.await()` waits for the result.
    *   If `d` finishes < 1000ms: Success.
    *   If `d` is still running > 1000ms: `TimeoutCancellationException` is thrown. The scope cancels `d` immediately.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Strict Deadline" (Network/Fetch)

**Khi nào dùng:**
Khi bạn gọi API nhưng không muốn người dùng chờ đợi vô thời hạn. Nếu quá thời gian, phải hủy bỏ.

**Tại sao đúng:**
Sử dụng `withTimeout` để ném ra Exception chủ động, giúp luồng xử lý lỗi (try-catch) bắt được và xử lý UI (hiển thị "Mất kết nối") ngay lập tức.

```kotlin
import kotlinx.coroutines.*
import java.io.IOException

suspend fun fetchUserData(): String {
    delay(2000) // Simulating slow network
    return "User Data"
}

fun main() = runBlocking {
    try {
        // Nó sẽ ném TimeoutCancellationException nếu fetchUserData > 1500ms
        val result = withTimeout(1500) {
            fetchUserData()
        }
        println("Success: $result")
    } catch (e: TimeoutCancellationException) {
        println("Error: Timeout! The request took too long.")
    } catch (e: Exception) {
        println("Error: ${e.message}")
    }
}
```

### Pattern 2: Safe Multiple Requests (Async/Await)

**Khi nào dùng:**
Cần gọi 2 API độc lập (Ví dụ: Lấy thông tin người dùng + Lấy danh sách sản phẩm) và đợi cả 2 xong mới hiện UI.

**Tại sao đúng:**
Sử dụng `async` cho mỗi tác vụ độc lập. `await()` là điểm chờ duy nhất. Nếu dùng sequential (call A xong mới call B), thời gian tổng bằng tổng thời gian 2 tác vụ (slow).

```kotlin
import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

suspend fun getProfile(): String {
    delay(1000)
    return "Profile"
}

suspend fun getOrders(): String {
    delay(1000)
    return "Orders"
}

fun main() = runBlocking {
    val time = measureTimeMillis {
        // Khởi tạo cả 2 ngay lập tức (Parallel)
        val profileDeferred = async { getProfile() }
        val ordersDeferred = async { getOrders() }

        // Chờ kết quả tại đây
        val profile = profileDeferred.await()
        val orders = ordersDeferred.await()
        
        println("Result: $profile, $orders")
    }
    // Kết quả: ~1000ms (Parallel) thay vì ~2000ms (Sequential)
    println("Total time: $time") 
}
```

### Pattern 3: Leaking "NonCancellable" (Emergency Only)

**Khi nào dùng:**
Trong block `finally`, bạn *phải* thực hiện một suspend call (VD: ghi log ra file mạng, database) để không mất data quan trọng, dù Coroutine đã bị hủy.

**Tại sao đúng:**
`withContext(NonCancellable)` tạo một Context mới không lắng nghe tín hiệu cancel, cho phép `delay` hoặc `suspend` function thực thi.

```kotlin
fun main() = runBlocking {
    val job = launch {
        try {
            // Work
        } finally {
            // MUST FINISH THIS
            withContext(NonCancellable) {
                println("Saving critical state...")
                delay(500) // Chắc chắn chạy xong
                println("State saved.")
            }
        }
    }
    job.cancel()
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Suspend in `finally` without `NonCancellable`
**Dịch:** Treo máy (Deadlock/Leak) hoặc lỗi bỏ lỡ (Silent Failure).
**Why:** Nếu coroutine đang bị hủy (`cancel()` được gọi), khối `finally` sẽ chạy. Nhưng khi nó chạm vào `delay()`, nó sẽ ném `CancellationException` ngay lập tức và đoạn code dưới `delay` sẽ **không bao giờ thực thi**. Dữ liệu quan trọng bị mất.

### 2. Using `Thread.sleep()` inside Coroutines
**Dịch:** Chặn hoàn toàn luồng执行线程 (Blocking Thread).
**Why:** `delay()` là suspend function (không chiếm tài nguyên CPU). `Thread.sleep()` là blocking operation. Nếu bạn dùng nó trong `runBlocking` hoặc `Dispatchers.Main`, UI sẽ bị freeze. Nếu dùng trong `Dispatchers.IO`, nó làm cạn kiệt pool threads.

### 3. Calling `await()` Immediately After `async`
**Dịch:** Phá vỡ tính song song (Sequential Execution).
**Why:**
```kotlin
// SAI
val a = async { getData1() }.await() 
val b = async { getData2() }.await()
// Kết quả: getData1 xong mới chạy getData2. Tốn 2 * time.
```
**Fix:** Khởi tạo `Deferred` trước, sau đó mới gọi `await()`.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Logic

**1. Need Result?**
> `async { }` -> `Deferred` -> `await()`

**2. Just Task?**
> `launch { }` -> `Job`

**3. Need Time Limit?**
> `withTimeout(ms) { }` (Crash on fail)
> `withTimeoutOrNull(ms) { }` (Null on fail)

**4. Coroutine Cancelled?**
> Inside `try` -> `finally` -> `withContext(NonCancellable) { suspend }` -> Finish critical work.

### Top 5 Things to Remember

1.  **`delay` is cheap, `sleep` is expensive.**
2.  **`async` is for values, `launch` is for actions.**
3.  **`withTimeout` throws exceptions.** Handle it!
4.  **`await()` is the gatekeeper.** Don't call it too early.
5.  **`NonCancellable` is your only shield** against cancellation during cleanup.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines - Context, Hierarchy & Errors

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Coroutine Context (Ngữ cảnh coroutine)**: Là một tập hợp các giá trị xác định hành vi của coroutine, bao gồm `Job`, `Dispatcher`, và `CoroutineExceptionHandler`.
- **Structured Concurrency (Tính đồng bộ có cấu trúc)**: Một mô hình mới trong lập trình song song, nơi một khối mã (scope) không thể hoàn thành cho đến khi tất cả các coroutine con bên trong nó hoàn thành hoặc bị hủy.
- **CoroutineScope (Phạm vi coroutine)**: Interface quản lý vòng đời của các coroutine. Khi scope bị hủy, tất cả coroutine trong scope đó cũng bị hủy.
- **Job (Nhiệm vụ)**: Represents a background task. Nó có thể bị hủy (`cancel()`) và chúng ta có thể đợi nó hoàn thành (`join()`).
- **GlobalScope (Phạm vi toàn cục)**: Một scope sống lâu như toàn bộ ứng dụng. Sử dụng nó để tạo các coroutine không bị ràng buộc bởi lifecycle của caller.
- **CoroutineExceptionHandler (Bộ xử lý ngoại lệ)**: Một cơ chế bắt lỗi nâng cao cho các coroutine ở mức root (top-level). Nó chỉ hoạt động trên `launch`, không phải `async`.

### Key Mental Models
1. **Hierarchy là Cha-Con**: Trong structured concurrency, nếu `Job` cha bị hủy (`cancel()`), tất cả `Job` con của nó sẽ tự động bị hủy theo (thuận tiện cho việc dọn dẹp).
2. **GlobalScope là "bất tử"**: Coroutine tạo từ `GlobalScope` không thuộc scope nào cả. Nếu coroutine cha bị hủy, GlobalScope coroutine vẫn chạy. Nó bỏ qua quy tắc Hierarchy.
3. **Lỗi "Nuốt chửng"**: Trong structured concurrency, nếu một coroutine con (kể cả trong vòng lặp `launch` lồng nhau) ném ra exception, nó sẽ hủy job cha và lan truyền lỗi lên trên.
4. **Exception Handling**: `CoroutineExceptionHandler` là "lưới an toàn" cuối cùng cho các lỗi không được xử lý ở mức root.

---

## SECTION 2: DECISION TABLES

### Khi nào dùng `launch` vs `async`?

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Common mistake |
| :--- | :--- | :--- | :--- |
| **Cần thực thi tác vụ và không cần trả về giá trị.** (Ví dụ: Gửi log, cập nhật UI không đồng bộ) | `launch` | Là `Fire-and-forget`. Trả về `Job`. Đơn giản, không cần xử lý kết quả phức tạp. | Dùng `async` nhưng không gọi `await()`. Điều này có thể nuốt lỗi (nếu không dùng supervisorScope). |
| **Cần thực thi tác vụ và cần trả về giá trị (Kết quả).** (Ví dụ: Call API lấy data) | `async` | Trả về `Deferred` (một kiểu `Future`). Phải gọi `await()` để lấy giá trị hoặc ném lỗi. | Quên gọi `await()`. Lỗi trong `async` sẽ không được báo nếu không gọi `await()`. |

### Khi nào dùng `GlobalScope`?

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Common mistake |
| :--- | :--- | :--- | :--- |
| **Tạo task chạy background độc lập với UI/Lifecycle.** (Ví dụ: Service lắng nghe socket, Worker chạy vĩnh viễn) | `GlobalScope` | Scope này sống sót sau khi caller (Activity/Fragment) bị hủy. Cấu trúc này là "unstructured". | Lạm dụng `GlobalScope` trong Activity/Fragment. Dẫn đến rò rỉ bộ nhớ (Memory Leak) vì task không bao giờ dừng theo Activity. |
| **Task phải hoàn thành ngay cả khi app đang đóng.** | `GlobalScope` | Task thuộc hệ thống, không bị phụ thuộc vào UI. | Bắt lỗi trong `GlobalScope` không đúng cách (xem bảng exception). |

### Khi nào dùng `CoroutineExceptionHandler` (CEH)?

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Common mistake |
| :--- | :--- | :--- | :--- |
| **Bắt lỗi từ coroutine root (level 1) do `launch` tạo ra.** (Ví dụ: Background task độc lập) | `CEH` trong Context | Là nơi duy nhất bắt được lỗi đã "không bị nuốt" trong coroutine root của `launch`. | Dùng `CEH` cho `async`. CEH không bắt lỗi trong `async` (phải dùng `try/catch` quanh `await`). |
| **Cần log lỗi hoặc báo cáo crash (Crash reporting).** | `CEH` | Giúp tránh crash app, cho phép xử lý lỗi tập trung. | Quên thêm CEH cho các coroutine launch ở GlobalScope (lỗi sẽ crash app). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Cancellation Flow
Hãy xem xét cấu trúc sau: `Parent` (runBlocking/Job) → `Child 1` & `Child 2`.

```text
[Parent Job] (runBlocking hoặc launch)
   │
   ├── [Child Job 1] (launch)
   │      │
   │      └── [Sub-child] (launch)
   │
   └── [Child Job 2] (launch)
```

**Quy tắc tương tác:**
1. **Parent Cancel → Child Cancel**: Nếu gọi `parentJob.cancel()`, `Child 1`, `Child 2` và `Sub-child` sẽ bị hủy ngay lập tức.
2. **Child Crash → Parent Cancel**: Nếu `Child 1` ném Exception, `Parent` và `Child 2` sẽ bị hủy (thuộc tính Structured Concurrency).

### GlobalScope Breaks Hierarchy
```text
[Parent Job] (runBlocking)
   │
   ├── [Child Job] (GlobalScope.launch)
   │      │
   │      └── (Không thuộc Parent)
   │             -> Nếu Parent cancel, GlobalScope job vẫn chạy.
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Structured Concurrency with Hierarchy (Nên dùng)
**Khi nào dùng:** Khi bạn muốn đảm bảo các task con được hủy tự động khi task cha bị hủy (ví dụ: Điều hướng Activity).

```kotlin
import kotlinx.coroutines.*
import kotlin.coroutines.CoroutineContext

fun main() = runBlocking {
    val job = launch {
        // Launch 2 child coroutines
        launch {
            delay(100)
            println("Child 1: Hello")
            delay(1000) // Will be cancelled
            println("Child 1: Goodbye") // Won't print
        }
        launch {
            delay(100)
            println("Child 2: Hello")
            delay(1000) // Will be cancelled
            println("Child 2: Goodbye") // Won't print
        }
    }
    
    delay(500) 
    println("Cancelling Parent...")
    job.cancel() // Hủy cả 2 child bên trong
    
    println("Done")
    // Kết quả: Child 1 & 2 Hello in ra. Parent Cancel in ra. Không in Goodbye.
}
```

### Pattern 2: GlobalScope for Independence (Dùng thận trọng)
**Khi nào dùng:** Khi task phải chạy độc lập, không bị hủy theo cha. Ví dụ: Job queue worker.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val parentJob = launch {
        // Task này sẽ KHÔNG bị cancel dù parentJob.cancel() được gọi
        GlobalScope.launch {
            try {
                delay(500)
                println("GlobalScope: I survived parent cancellation!")
            } catch (e: Exception) {
                println("GlobalScope caught: $e")
            }
        }

        // Task con bình thường
        launch {
            delay(100)
            println("Child: I will die")
        }
    }

    delay(200)
    parentJob.cancel() // Hủy Child, nhưng GlobalScope vẫn sống
    delay(1000) // Đợi GlobalScope chạy xong
}
```

### Pattern 3: Robust Exception Handling
**Khi nào dùng:** Khi cần bắt lỗi từ `launch` hoặc `async` một cách chính xác.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception ->
        println("Caught in Handler: $exception")
    }

    // 1. Launch with Handler (Catches exception in Root Launch)
    val job = GlobalScope.launch(handler) {
        throw NullPointerException("Launch Error")
    }
    job.join()

    // 2. Async with Try/Catch (Handler doesn't work on Async!)
    val deferred = GlobalScope.async {
        throw IndexOutOfBoundsException("Async Error")
    }
    try {
        deferred.await()
    } catch (e: IndexOutOfBoundsException) {
        println("Caught in Try/Catch: $e")
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Chaotic Cancellation in Loops
**Code sai:**
```kotlin
launch {
    repeat(3) { i ->
        launch {
            delay(1000)
            println("Task $i")
        }
    }
    throw Exception("Boom") // Nếu lỗi này xảy ra, các launch con có thể chưa kịp chạy hoặc bị kill ngay lập tức mà không xử lý dở dang.
}
```
**Tại sao sai:** Kung launch lồng nhau, nếu cha ném lỗi, các con bị hủy ngay lập tức (cancellation). Điều này làm luồng xử lý bị ngắt quãng không kiểm soát.

### 2. Lạm dụng GlobalScope
**Code sai:**
```kotlin
class MyActivity {
    fun loadData() {
        GlobalScope.launch {
            // Network call...
        }
    }
}
```
**Tại sao sai:** Nếu người dùng đóng Activity, `GlobalScope` vẫn giữ network call chạy. Nếu Activity bị destroy và object bị tham chiếu, sẽ gây **Memory Leak**. Luôn dùng `lifecycleScope` (Android) hoặc `CoroutineScope` custom.

### 3. Async không gọi await()
**Code sai:**
```kotlin
val result = async { 1 + 1 }
// Kết thúc hàm luôn, task async có thể bị cancel hoặc lỗi bị nuột.
```
**Tại sao sai:** `async` chỉ khởi chạy khi `await()` được gọi (hoặc có các phương thức kích hoạt khác). Không gọi `await()` là sai logic hoàn toàn.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic: Xử lý Lỗi & Scope
1. **Lỗi trong `launch`**:
   - Có `try-catch` trong body? → Lỗi được bắt.
   - Không có? → Lỗi lan lên cha hoặc `CoroutineExceptionHandler`.
2. **Lỗi trong `async`**:
   - **Luôn** phải `try-catch` autour `await()`.
   - `CoroutineExceptionHandler` không hoạt động ở đây.
3. **Cần hủy theo cha?**
   - Dùng `launch` hoặc `async` (trong `runBlocking` hoặc `coroutineScope`).
4. **Cần bỏ qua hủy cha?**
   - Dùng `GlobalScope.launch`.

### Top 5 Rules for Exams/Coding
1. **Hủy cha = Hủy con**: Quy tắc vàng của Structured Concurrency.
2. **GlobalScope ≠ Hủy cha**: Scope này cô lập, không bị hủy theo cha.
3. **CEH ≠ Async**: Bắt lỗi `async` phải dùng `try-catch` + `await`.
4. **Job.join()**: Đợi job xong (thành công hoặc lỗi).
5. **Job.cancel()**: Hút job ngay lập tức (nếu đang delay/chờ).

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines Error Handling & Sequences

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**CoroutineExceptionHandler (Bộ xử lý ngoại lệ Coroutine)**
*   **Purpose:** Một bộ xử lý toàn cục (Global Handler) để bắt lỗi không được xử lý ở các coroutine cấp cao nhất (Root Coroutines). Nó hoạt động như `Thread.UncaughtExceptionHandler`.
*   **Behavior:** Chỉ bắt lỗi nếu coroutine bị crash (throw Exception mà không tự bắt). Nếu coroutine đã xử lý lỗi nội bộ (try-catch), `CoroutineExceptionHandler` sẽ không được gọi.
*   **Lưu ý QUAN TRỌNG:** `async` mặc định dùng `SupervisorJob` và bắt buộc phải gọi `await()` để ném lỗi. Lỗi xảy ra bên trong `async` nếu không gọi `await()` sẽ không kích hoạt Handler.

**SupervisorJob (Công việc Giám sát)**
*   **Purpose:** Cho phép các job con (Child Jobs) chạy độc lập. Nếu một job con bị lỗi, nó sẽ không hủy cha hoặc các anh em cùng cha.
*   **Behavior:** Cha (Parent) sẽ không cancel khi con (Child) fail.

**Sequence (Chuỗi)**
*   **Purpose:** Các collection đựợc lazy-evaluated (tính toán trì hoãn). Các phần tử chỉ được sinh ra khi được yêu cầu (trong vòng lặp hoặc terminal operation như `forEach`).
*   **Sử dụng `yield()`:** Tạm dừng execution và trả về giá trị, đợi直到 được gọi lại.

### Why this approach is better than others?

*   **Structured Concurrency (Đồng nhất cấu trúc):** `SupervisorJob` giúp xử lý lỗi song song (parallel) mà không phá vỡ cấu trúc logic của ứng dụng. Thay vì dùng `try-catch` bọc mọi thứ, ta dùng `SupervisorScope` để cách ly lỗi.
*   **Resource Efficiency (Sequence):** `Sequence` tránh tạo ra các collection trung gian lớn khi thực hiện các phép biến đổi chuỗi (chain) phức tạp (`map`, `filter`), giúp tiết kiệm bộ nhớ và CPU.

---

## SECTION 2: DECISION TABLES

### Khi nào dùng CoroutineExceptionHandler vs SuperviserJob?

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cần ghi log lỗi hoặc hiển thị UI khi crash** | `CoroutineExceptionHandler` | **Global Error Handling:** Bắt lỗi văng ra từ coroutine gốc (Root Coroutine). Dùng cho việc "bắt cháy" cuối cùng. | Dùng `try-catch` trong Coroutine con và gọi `handler` thủ công. |
| **Cần 1 Coroutine cha không bị cancel khi 1 trong các Coroutine con bị lỗi** | `SupervisorJob` hoặc `supervisorScope` | **Isolation (Cô lập lỗi):** `Job` mặc định có quan hệ cha-con chặt chẽ. `SupervisorJob` phá vỡ điều này, cho phép con fail mà cha vẫn sống. | Dùng `launch` thường bên trong `GlobalScope` mà không có giám sát, dẫn đến việc khó kiểm soát vòng đời. |
| **Sử dụng `async` để lấy kết quả异步** | **Không dùng `CoroutineExceptionHandler`** | **Constraint (Ràng buộc):** `async` tự gói lỗi bên trong `Deferred`. Lỗi chỉ được ném ra khi gọi `await()`. | Mong đợi `handler` bắt lỗi thay cho `async` block mà không cần `await`. |
| **Có nhiều Coroutine con độc lập trong cùng một scope** | `SupervisorScope` | **Parallel Execution:** Đảm bảo lỗi ở Job A không ảnh hưởng đến Job B hay Job C đang chạy song song. | Dùng `launch` thường kết hợp với `join()` một cách lộn xộn để mong xử lý lỗi riêng lẻ. |

### Khi nào dùng Sequence vs List/Collection?

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Xử lý chuỗi dữ liệu lớn hoặc các phép toán phức tạp (heavy mapping/filtering)** | `sequence { ... }` | **Lazy Evaluation (Tính toán trễ):** Chỉ tính toán khi cần, tránh tạo mảng trung gian. Tiết kiệm bộ nhớ. | Dùng `List` với các hàm `map`, `filter` liên tục trên dữ liệu lớn, gây tốn RAM và CPU cho các bước trung gian. |
| **Cần trả về nhiều giá trị từ một hàm (Generator pattern)** | `sequence` với `yield` | **Control Flow:** Cho phép hàm sinh ra giá trị, tạm dừng, và tiếp tục khi được gọi lại. | Sử dụng `return list` với vòng lặp tạo list bên trong, làm chậm trễ nếu chỉ cần phần tử đầu tiên. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Error Handling Hierarchy

```text
[GlobalScope / Root Scope]
       |
       +--- [CoroutineExceptionHandler] (Attach vào Scope)
       |
       +--- [Job (Standard)] --------------------+
       |                                        |
       +--- [SupervisorJob]                     |
       |     |                                  |
       |     +--- Child 1 (Success)             |
       |     +--- Child 2 (Fail) -----> [Crash Parent?] -> CÓ (Standard) / KHÔNG (Supervisor)
       |     +--- Child 3 (Running)             |
       |                                        |
       +--- [Async / Deferred]                  |
             |                                  |
             +--- Call .await() ---------> [Throw Exception] -> Có thể bắt bởi try-catch tại điểm gọi
             +--- Không gọi .await() ----> [Lỗi bị nuốt] -> KHÔNG bắt bởi CoroutineExceptionHandler
```

### Sequence Execution Flow

```text
Call Sequence
     |
     v
Start Block { ... } (chưa lặp)
     |
     v
Call Terminal Op (forEach, toList)
     |
     v
Enter Block -> Loop
     |
     v
yield(value) --> TRẢ VỀ value ngay lập tức --> TẠM DỪNG Block
     |
(Nhận value từ forEach)
     |
(Loop tiếp theo yêu cầu phần tử tiếp theo)
     |
     v
Tiếp tục Block từ yield() trước
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: SupervisorScope để chạy Parallel Tasks an toàn

**Khi nào dùng:** Khi bạn cần chạy nhiều tác vụ song song, và muốn đảm bảo rằng nếu một tác vụ bị lỗi, các tác vụ khác vẫn tiếp tục chạy.

**Tại sao đúng:** Sử dụng `supervisorScope` tự động tạo `SupervisorJob`, cô lập lỗi giữa các `launch` con.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex

fun main() = runBlocking {
    // Sử dụng supervisorScope để cách ly lỗi
    supervisorScope {
        val mutex = Mutex() // Để in ra console không bị lộn xộn
        
        // Job 1: Sẽ bị lỗi
        launch {
            try {
                delay(100)
                println("Job 1: Bắt đầu tính toán...")
                throw ArithmeticException("Lỗi tính toán")
            } catch (e: Exception) {
                // Lỗi này không lan ra scope cha
                mutex.lock()
                println("Job 1 đã bắt lỗi: ${e.message}")
                mutex.unlock()
            }
        }

        // Job 2: Sẽ chạy thành công dù Job 1 fail
        launch {
            delay(200)
            mutex.lock()
            println("Job 2: Hoàn thành thành công!")
            mutex.unlock()
        }
    }
    println("Scope hoàn thành.")
}
```

### Pattern 2: Bắt lỗi với CoroutineExceptionHandler

**Khi nào dùng:** Khi bạn cần xử lý lỗi ở mức Root Coroutine (ví dụ: log lỗi hệ thống).

**Lưu ý:** Phải attach handler vào scope hoặc job khi khởi tạo.

```kotlin
import kotlinx.coroutines.*

fun main() {
    val handler = CoroutineExceptionHandler { _, exception ->
        println(">>> CATCHED BY HANDLER: ${exception.message}")
    }

    runBlocking {
        // Chỉ bắt lỗi từ 'launch', không bắt lỗi từ 'async' nếu không gọi await()
        val job = GlobalScope.launch(handler) {
            delay(100)
            throw IOException("Mạng bị lỗi")
        }
        job.join()
    }
}
```

### Pattern 3: Sequence Generator

**Khi nào dùng:** Khi cần sinh ra một chuỗi giá trị dựa trên logic phức tạp mà không muốn lưu tất cả vào RAM.

**Tại sao đúng:** `yield` giữ trạng thái của vòng lặp.

```kotlin
// Hàm sinh ra các số chẵn từ 0 đến n
fun generateEvenNumbers(n: Int): Sequence<Int> = sequence {
    for (i in 0..n) {
        if (i % 2 == 0) {
            yield(i) // Tạm dừng và trả về i
        }
    }
}

fun main() {
    val seq = generateEvenNumbers(10)
    
    // Lấy 2 phần tử đầu tiên mà không cần lặp hết 10 số
    println(seq.take(2).toList()) // Output: [0, 2]
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Lỗi `Async` bị nuốt (Silent Failure)
**Tại sao nguy hiểm:** Nếu bạn dùng `GlobalScope.async { throw Exception() }` mà không có `await()`, ứng dụng sẽ im lặng rơi vào trạng thái lỗi mà không báo cáo gì. `async` luôn hoãn ném lỗi cho đến khi `await()` được gọi.
**Cách tránh:** Luôn gọi `.await()` hoặc sử dụng `launch` nếu không cần trả về kết quả.

### 2. Lạm dụng `GlobalScope`
**Tại sao nguy hiểm:** `GlobalScope` tạo các coroutine sống vĩnh viễn independent lifecycle. Nếu có lỗi, `CoroutineExceptionHandler` không bắt được lỗi trong `GlobalScope` nếu bạn không cấu hình đúng cho `Dispatchers.IO` hoặc Default.
**Cách tránh:** Luôn tạo scope từ `CoroutineScope(SupervisorJob() + Dispatchers.Main)` hoặc pass scope từ Component (Activity/ViewModel).

### 3.混淆 `try-catch` và `CoroutineExceptionHandler`
**Tại sao nguy hiểm:** `CoroutineExceptionHandler` không thay thế được `try-catch`. Nếu bạn bắt lỗi bằng `try-catch` bên trong coroutine, `CoroutineExceptionHandler` sẽ không được kích hoạt (vì coroutine đã thành công).
**Cách phân biệt:**
*   Dùng `try-catch` khi muốn xử lý lỗi của từng dòng code cụ thể (ví dụ: rollback DB).
*   Dùng `handler` khi muốn xử lý crash của cả coroutine (ví dụ: log lỗi, hiển thị dialog chung).

### 4. Quên `supervisorScope` khi cần Parallel Execution
**Tại sao nguy hiểm:** Trong `coroutineScope` thường, nếu một child fail, các child khác sẽ bị cancel ngay lập tức. Điều này gây mất dữ liệu nếu các tác vụ là độc lập.
**Cách tránh:** Luôn dùng `supervisorScope` nếu các `launch` con không phụ thuộc vào nhau.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

1.  **`launch`**: "Fire and Forget". Ném lỗi ra thread cha. Dùng `try-catch` hoặc `CoroutineExceptionHandler`.
2.  **`async`**: "Compute Result". Ném lỗi vào `Deferred`. Bắt buộc dùng `try-catch` quanh `await()`.
3.  **`SupervisorJob`**: "Cha bị hủy nếu con fail?" -> **KHÔNG**. Dùng cho việc sinh lỗi parallel.
4.  **`yield()`**: Dùng trong `sequence` để sinh ra giá trị và tạm dừng.
5.  **Handler**: Chỉ bắt lỗi từ Root Job nếu lỗi chưa bị bắt.

### Decision Logic (If-Else)

*   **IF** cần lấy giá trị异步 -> **ELSE** dùng `async { ... }.await()` (bắt lỗi tại `await`).
*   **IF** cần log lỗi root -> **ELSE** dùng `CoroutineExceptionHandler`.
*   **IF** cần 3 tasks chạy song song, 1 fail không ảnh hưưởng 2 kia -> **ELSE** dùng `supervisorScope`.
*   **IF** xử lý dữ liệu lớn/lazy -> **ELSE** dùng `sequence { yield(...) }`.

### Top 5 Things to Remember

1.  `GlobalScope.async` không tự báo lỗi nếu không gọi `await`.
2.  `SupervisorJob` tách biệt lỗi giữa các anh em.
3.  `runBlocking` tạo `StandardJob` (cha hủy nếu con fail).
4.  `supervisorScope` tạo `SupervisorJob` (cha sống sót nếu con fail).
5.  `Sequence` là Lazy, `List` là Eager.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: Kotlin Flows

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Flow (Luồng dữ liệu)**: A stream of values that are emitted asynchronously. Unlike a `List` which holds all data in memory at once, a `Flow` emits values one by one over time, respecting coroutine cancellation.

**Operator (Toán tử)**: Functions that transform, filter, or combine flows. They are lazy and do not execute until a "Terminal Operator" triggers collection.

**Terminal Operator (Toán tử kết thúc)**: A function that starts the flow and waits for completion (e.g., `collect`, `reduce`, `fold`). Without this, the flow does nothing.

### Code Demo: Basic Flow Structure
```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun foo(n: Int): Flow<Int> = flow {
    for (i in 0..n) {
        delay(1000) // Simulate async work
        emit(i)     // Emit value
    }
}

fun main() = runBlocking {
    // Trigger collection
    foo(2).collect { 
        println("Received: $it") 
    }
}
```

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Transform data (1-to-1)**<br>Mỗi giá trị đầu vào đổi ra 1 giá trị đầu ra | **`map`** | **Projection (Phép chiếu)**: Dùng khi chỉ cần thay đổi format/value mà không cần logic phức tạp. | Dùng `transform` cho việc map đơn giản (lãng phí code). |
| **Transform data (1-to-N)**<br>Mỗi giá trị đầu vào đổi ra nhiều giá trị đầu ra | **`transform`** | **Flexibility (Tính linh hoạt)**: Có thể gọi `emit()` nhiều lần trong 1 block để tạo ra nhiều giá trị khác nhau. | Dùng `map` (chỉ trả về được 1 giá trị). |
| **Conditional filtering**<br>Lọc dữ liệu theo điều kiện | **`filter`** | **Selection (Lựa chọn)**: Loại bỏ các phần tử không mong muốn giữ lại phần tử thỏa mãn. | Dùng `if/else` bên trong `map`. |
| **Limiting stream**<br>Chỉ lấy X phần tử đầu tiên | **`take(n)`** | **Control (Kiểm soát)**: Dừng stream khi đạt số lượng mong muốn để tiết kiệm tài nguyên. | Dùng `filter` kết hợp biến đếm thủ công. |
| **Aggregation (Reduce)**<br>Tính toán kết quả cuối cùng (Cần giá trị khởi tạo) | **`fold(initial)`** | **Initialization (Khởi tạo)**: Cho phép định nghĩa giá trị ban đầu (ví dụ: sum = 0, list = empty). | Dùng `reduce` khi cần phải chèn giá trị ban đầu khác 0. |
| **Aggregation (Reduce)**<br>Tính toán kết quả cuối cùng (Dựa trên giá trị đầu tiên) | **`reduce`** | **Accumulation (Tích lũy)**: Tự động lấy phần tử đầu làm giá trị khởi tạo accumulator. | Không xử lý trường hợp flow rỗng (gây crash). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Flow Lifecycle
A Flow is a **pipeline**. Data flows from Source -> Intermediate Operators -> Terminal Operator.

```text
[Source: Flow Builder]
       |
       v
[Data Emission: emit(n)]  <-- (Time passes here: delay)
       |
       v
[Intermediate Operators]  -->  [map { ... }]
                              [filter { ... }]
                              [transform { ... }]
                              [take(3)]
       |
       v
[Terminal Operator]       -->  [collect { ... }]
                              [reduce { ... }]
                              [fold(x) { ... }]
       |
       v
[Completion / Error]
```

**Cancellation Relationship:**
If the **Scope** (e.g., `runBlocking`) is cancelled or times out, the **Source** stops emitting immediately.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Simple Transformation
**When to use (Khi nào dùng):** Standard data mapping (DTO to Domain).
**Why (Tại sao đúng):** Clean, declarative, and handles suspension automatically.

```kotlin
suspend fun processNumbers() {
    listOf(1, 8, 9, 3).asFlow()
        .map { it * it } // 1->1, 8->64
        .collect { println(it) } // Output: 1, 64, 81, 9
}
```

### Pattern 2: Complex Emission (1-to-N)
**When to use (Khi nào dùng):** When one input value needs to generate multiple outputs (e.g., downloading a file emits progress 0-100%).
**Why (Tại sao đúng):** `map` cannot emit multiple times; `transform` allows granular control over the output stream.

```kotlin
suspend fun expandValue() {
    flowOf(1)
        .transform { value ->
            emit(value)         // Emit 1
            emit(value * 10)    // Emit 10
            emit(value * 100)   // Emit 100
        }
        .collect { println(it) } // Output: 1, 10, 100
}
```

### Pattern 3: Reduction (Sum/Count)
**When to use (Khi nào dùng):** When you need a single result from a stream (e.g., calculating total price of a cart).
**Why (Tại sao đúng):** Performs calculation asynchronously without loading the entire stream into a list first.

```kotlin
suspend fun calculateSum() {
    val total = listOf(1, 8, 9, 3).asFlow()
        .fold(5) { acc, value -> 
            acc + value 
        } 
    println("Total: $total") // (5+1)+(5+8)... = accumulative
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Missing Terminal Operator (Forget `.collect`):**
    *   **Why:** Flow is **cold**. Defining `val f = flow { ... }` or adding `.map` creates the structure but does not execute the code. Nothing happens until `collect` is called.
    *   **Danger:** Logic bugs where you expect data to be processed, but nothing happens.

2.  **Blocking inside `flow { }`:**
    *   **Why:** Calling `Thread.sleep()` or heavy blocking IO inside `flow { }` blocks the underlying coroutine dispatcher.
    *   **Danger:** Kills the performance benefits of coroutines. Use `delay()` instead.

3.  **Using `map` instead of `transform` (and trying to emit multiple):**
    *   **Why:** `map` lambda returns a single value (which is auto-emitted).
    *   **Danger:** You cannot emit multiple times inside `map`. If you need multiple emissions per item, you must use `transform`.

4.  **Unconfined Dispatcher Confusion:**
    *   **Why:** Flows emit on the Context of the collector by default.
    *   **Danger:** If you perform heavy UI work inside `collect` without specifying context, you might block the UI thread. Use `.flowOn(Dispatchers.IO)` to change the upstream source.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
*   **Sequence**: In-memory, blocking. Use for small, fast calculations.
*   **Flow**: Asynchronous, cold, cancellable. Use for streams of data over time.

### Decision Logic (If-Else)
*   **IF** you need to change value A → B: Use **`map`**.
*   **IF** you need to split value A → (A, A+1, ...): Use **`transform`**.
*   **IF** you need to remove items: Use **`filter`**.
*   **IF** you need the first N items: Use **`take`**.
*   **IF** you need a final result (e.g., Sum): Use **`fold`** or **`reduce`**.

### Top 3 Things to Remember
1.  **Cold:** Flow won't run without `.collect()`.
2.  **Context:** Flow runs in the collector's context unless `.flowOn()` is used.
3.  **Cancellation:** Flows are cancellable by default (check `withTimeoutOrNull` example).

<!-- CHUNK 61-68 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines Flow Operators

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Flow (Dòng dữ liệu)**: Một chuỗi giá trị bất đồng bộ có thể emit nhiều giá trị theo thời gian. Khác với suspend function chỉ trả về 1 giá trị, Flow lắng nghe và xử lý chuỗi sự kiện.

**Operator (Toán tử)**: Hàm biến đổi chuỗi giá trị Flow. Chia làm 3 loại chính: Transform (biến đổi), Combine (kết hợp), và Terminal (kết thúc).

### Mental Model

Flow hoạt động như một **dòng nước**:
- **Nguồn (Source)**: `asFlow()`, `flow {}`
- **Ống dẫn (Pipeline)**: `filter`, `map`, `delay`
- **Vòi nước (Terminal)**: `collect`, `single`, `zip`

### Why Flow Operators?

| Traditional Approach | Flow Approach | Advantage |
|---------------------|---------------|-----------|
| Callback hell | Linear pipeline | Readable |
| Manual synchronization | Built-in combine | Thread-safe |
| Blocking operations | Suspending operators | Non-blocking |

---

## SECTION 2: DECISION TABLES

### Table 1: Filter & Transform vs Terminal

| Use Case | Should Use | Why | Common Mistake |
|----------|------------|-----|----------------|
| Chuyển đổi từng giá trị | `map { }` | **Transform**: Giữ nguyên số lượng giá trị | Dùng `map` thay vì `forEach` (không return được Flow mới) |
| Lọc bớt giá trị | `filter { }` | **Transform**: Loại bỏ giá trị không thỏa điều kiện | Bỏ qua `filter` rồi xử lý logic bên trong `collect` (hardcode) |
| Giới hạn số lượng | `take(n)` | **Transform**: Stop sau n giá trị | Quên `take`导致 Full stream processing không cần thiết |

### Table 2: Kiểm tra số lượng giá trị

| Use Case | Should Use | Why | Common Mistake |
|----------|------------|-----|----------------|
| Flow có đúng 1 giá trị | `single()` | **Terminal**: Validation strict, throw exception nếu ≠ 1 | Dùng `single()` trên stream có thể emit nhiều lần → Crash |
| Flow có 0 hoặc 1 giá trị | `singleOrNull()` | **Terminal**: An toàn, return null nếu rỗng hoặc >1 | Bỏ qua null check sau khi dùng `singleOrNull()` |
| Flow có nhiều giá trị | `collect()` | **Terminal**: Lặp qua tất cả | Dùng `single()` trên Flow đa giá trị |

### Table 3: Kết hợp 2 Flow

| Use Case | Should Use | Why | Common Mistake |
|----------|------------|-----|----------------|
| Đợi cả 2 Flow emit cùng lúc | `zip()` | **Sync**: Chờ cả 2 Flow có giá trị mới emit cặp | Dùng `zip` với Flow tốc độ khác nhau → Bị chậm bởi Flow chậm nhất |
| Emit khi có 1 trong 2 thay đổi | `combine()` | **Reactive**: Emit mới mỗi khi có Flow thay đổi | Dùng `combine` thay vì `zip` nếu cần pairing theo index |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow Operator Hierarchy

```
Flow Source (asFlow, flowOf)
    |
    +-- Transform Operators (Intermediate)
    |   |-- filter { }      // Filter values
    |   |-- map { }         // Transform values
    |   |-- take(n)         // Limit count
    |   |-- onEach { }      // Side effect
    |
    +-- Combine Operators (Multi-Flow)
    |   |-- zip()           // Sync pairing (A+B → C)
    |   |-- combine()       // Reactive pairing (A or B → C)
    |
    +-- Terminal Operators (Final)
        |-- collect()       // Iterate all
        |-- single()        // Expect exactly 1
        |-- singleOrNull()  // Safe 0/1
```

### Execution Flow

```
Source → Transform → Transform → ... → Terminal
   ↓        ↓            ↓               ↓
Emit 1 → Filtered? → Mapped? → Limited? → Result
Emit 2 → Filtered? → Mapped? → Limited? → Result
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Filter-Map-Take Pipeline

**When to use**: Xử lý chuỗi dữ liệu, chỉ lấy số lượng có hạn sau khi lọc và biến đổi.

**Why correct**: Tối ưu CPU - chỉ xử lý cần thiết, dừng sớm khi đủ.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() {
    runBlocking {
        listOf(1, 8, 9, 3, 6, 7, 2)
            .asFlow()
            .filter { it % 2 == 0 }      // 8, 6, 2
            .map { it * 2 }              // 16, 12, 4
            .take(2)                     // 16, 12
            .collect { value ->
                println("value = $value")
            }
    }
}
```

### Pattern 2: Safe Single Value Validation

**When to use**: Khi cần đảm bảo Flow emit đúng 1 giá trị, nếu không phải thì xử lý an toàn.

**Why correct**: `singleOrNull()` tránh crash, cho phép xử lý trường hợp đặc biệt.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() {
    runBlocking {
        // Case 1: Empty flow
        val result1 = emptyList<Int>().asFlow().singleOrNull()
        println("Empty: $result1")  // null
        
        // Case 2: One value
        val result2 = flowOf(42).singleOrNull()
        println("One value: $result2")  // 42
        
        // Case 3: Multiple values
        val result3 = (1..10).asFlow().singleOrNull()
        println("Multiple: $result3")  // null
    }
}
```

### Pattern 3: Zip for Index Pairing

**When to use**: Kết hợp 2 Flow theo cặp (Item 1 của A + Item 1 của B), giữ thứ tự.

**Why correct**: `zip()` guarantee A[n] paired with B[n], waiting for both.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() {
    runBlocking {
        val nums = (1..3).asFlow()
        val strs = listOf("one", "two", "three").asFlow()
        
        nums.zip(strs) { num, str ->
            "(num = $num and str = $str)"
        }.collect { println(it) }
        // Output: (num = 1 and str = one)
        //         (num = 2 and str = two)
        //         (num = 3 and str = three)
    }
}
```

### Pattern 4: Combine for Reactive UI Updates

**When to use**: Khi 1 trong 2 Flow thay đổi (user input + server response), cần update UI realtime.

**Why correct**: `combine()` emit ngay khi có thay đổi, không đợi cặp.

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*

fun main() {
    runBlocking {
        val nums = (1..3).asFlow().onEach { delay(100) }
        val strs = listOf("one", "two", "three").asFlow().onEach { delay(400) }
        
        val startTime = System.currentTimeMillis()
        
        nums.combine(strs) { num, str ->
            "(num = $num and str = $str)"
        }.collect { value ->
            println("$value at ${System.currentTimeMillis() - startTime}ms")
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern 1: Misusing `single()` on Multi-Value Flow
**Code nguy hiểm**:
```kotlin
(1..10).asFlow().single() // Throws Exception!
```
**Why dangerous**: `single()` throw `IllegalStateException` nếu Flow emit > 1 giá trị. Làm crash app nếu không xử lý exception.

### Anti-Pattern 2: Using `zip()` with Unequal Speed
**Code nguy hiểm**:
```kotlin
val fast = flowOf(1, 2).onEach { delay(10) }
val slow = flowOf("a", "b").onEach { delay(1000) }
fast.zip(slow) { n, s -> "$n-$s" }.collect { println(it) }
// Takes 2+ seconds even though fast is quick
```
**Why dangerous**: `zip()` waits for BOTH flows. Slow flow blocks the pipeline, gây chậm hệ thống không cần thiết.

### Anti-Pattern 3: Forgetting Terminal Operator
**Code nguy hiểm**:
```kotlin
flowOf(1, 2, 3).filter { it > 1 }.map { it * 2 }
// Nothing happens! Flow là cold stream, không có terminal → không execute
```
**Why dangerous**: Flow là **cold stream** - không có `collect`, `single`, v.v... thì pipeline không chạy. Gây bug "không thấy dữ liệu".

### Anti-Pattern 4: Mixing `zip` and `combine` Semantics
**Code nguy hiểm**:
```kotlin
// Muốn update UI khi có thay đổi nhưng lại dùng zip
val userInput = MutableStateFlow("")
val serverData = MutableStateFlow("")
userInput.zip(serverData) { u, s -> "$u+$s" }.collect { updateUI(it) }
```
**Why dangerous**: Nếu `userInput` thay đổi 5 lần mà `serverData` chưa thay đổi, `zip` không emit → UI không update. Dùng `combine()` cho reactive UI.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules

| Task | Operator | Remember |
|------|----------|----------|
| Filter values | `filter { }` | Keep only matching |
| Transform values | `map { }` | Change each value |
| Limit count | `take(n)` | Stop after n |
| Exactly 1 value | `single()` | Crash if ≠ 1 |
| Safe 0/1 values | `singleOrNull()` | Null if empty/many |
| Pair by index | `zip()` | Wait for both |
| React to changes | `combine()` | Emit on any change |

### Decision Logic (If-Else)

```
IF you need to process many values → collect()
ELSE IF you expect exactly 1 value → single()
ELSE IF you want safe 0/1 → singleOrNull()

IF you have 2 flows to combine:
  IF you need to pair by index → zip()
  IF you need to react to changes → combine()

IF you need to reduce data:
  IF keep all → filter + map
  IF keep only first n → take(n)
```

### Top 10 Things to Remember

1. **Flow là cold stream**: Phải có terminal operator mới chạy
2. **`single()` là strict**: Nếu emit > 1 giá trị → crash
3. **`zip()` đợi cả 2**: Tốc độ = tốc độ Flow chậm nhất
4. **`combine()` là reactive**: Emit mỗi khi có Flow thay đổi
5. **Order matters**: `filter` → `map` → `take` → `collect`
6. **`singleOrNull()` an toàn**: Dùng cho validation
7. **`onEach()` side-effect**: Chạy code giữa các operator
8. **Delay trong Flow**: `delay()` không ảnh hưởng operator khác
9. **Error handling**: `catch {}` hoặc try-catch trong collect
10. **Scope lifecycle**: Flow tự hủy khi scope hủy (trừ GlobalScope)