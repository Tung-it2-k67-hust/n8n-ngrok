# DEVELOPER DECISION GUIDE: Kotlin_Coroutines_Basics.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:02:06



<!-- CHUNK 1-10 -->

# Kotlin Coroutines Basics: Developer Decision Guide

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

### Core Definitions
- **Coroutine (Tiến trình rút gọn)**: Một đơn vị tính toán có thể tạm dừng (suspend) và tiếp tục执行. Nó lightweight hơn thread, cho phép viết code song song theo kiểu tuần tự.
- **Suspending Function (Hàm tạm dừng)**: Hàm có thể pause execution để chờ kết quả mà không block thread. Chỉ được gọi từ coroutine hoặc hàm suspend khác.
- **Coroutine Scope (Phạm vi coroutine)**: Vùng lifecycle quản lý các coroutine. Khi scope hủy, tất cả coroutine trong scope đều hủy.
- **Dispatcher (Bộ phân phối)**: Xác định thread nào sẽ chạy coroutine. Core concept: chuyển đổi luồng execution giữa các thread (Main, IO, Default).

### Key Mental Model
**"Coroutines là lightweight threads"**: Một thread có thể chứa hàng nghìn coroutine. Khi một coroutine suspend (chờ I/O), thread đó không bị block mà chạy coroutine khác. Điều này khác biệt hoàn toàn với traditional threading (block thread = resources waste).

**Execution Flow**: Code chạy tuần tự như sync code, nhưng thực tế là async. `suspend` đóng vai trò như "yield point" - nơi coroutine có thể nhường thread cho tác vụ khác.

### Why Better?
- **vs Threads**: Thread heavyweight (memory, context switch cost). Coroutine lightweight (~KB memory).
- **vs Callback**: Tránh "Callback Hell" - code đọc như sync, không cần nested callbacks.
- **vs Rx/CompletableFuture**: Native Kotlin syntax, compiler support, structured concurrency built-in.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### When to use `suspend` vs `launch` vs `async`

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Khai báo hàm logic có async operation | `suspend fun` | **Suspend modifier**: Chỉ khai báo capability, không tự động chạy. Cho phép gọi từ coroutine khác. | Khai báo `suspend` nhưng không có logic suspend nào bên trong → overhead vô ích. |
| Bắt đầu 1 job không cần kết quả | `launch` | **Fire-and-forget**: Trả về `Job`, không có return value. Dùng khi muốn run background task. | Dùng `launch` nhưng muốn lấy kết quả → phải dùng `Channel` hoặc shared state (rườm rà). |
| Bắt đầu 1 job và cần kết quả | `async` | **Deferred result**: Trả về `Deferred<T>`, gọi `.await()` để lấy giá trị. Dùng khi cần aggregate kết quả. | Quên `.await()` → compile error (Deferred chưa unwrapped). |
| Chạy tuần tự nhiều async ops | `suspend fun` + gọi hàm async bên trong | **Sequential by default**: Code chạy tuần tự, tránh race condition. Dùng khi ops phụ thuộc nhau. | Dùng `launch` cho từng op → phải join manually, code phức tạp. |

### When to use Dispatchers

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| CPU-intensive work (tính toán) | `Dispatchers.Default` | Thread pool tối ưu cho CPU-bound work (số threads = cores). | Dùng `Dispatchers.IO` → waste resources, không tối ưu. |
| I/O operations (network, DB) | `Dispatchers.IO` | Thread pool lớn (64 threads) optimized cho blocking I/O. | Dùng `Dispatchers.Main` → block UI, ANR. |
| Update UI | `Dispatchers.Main` | Đảm bảo chạy trên Main thread. | Quên switch về Main → UI update từ background thread → crash. |
| Test | `Dispatchers.Unconfined` hoặc mock | Kiểm soát execution order trong test. | Dùng real Dispatchers → test flaky, phụ thuộc timing. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### Hierarchy & Flow
```
Main Thread (UI)
└── CoroutineScope (lifecycle owner)
    ├── Coroutine 1 (Dispatchers.Main)
    │   ├── suspend fun A()
    │   │   └── withContext(Dispatchers.IO) → Switch thread
    │   │       └── blockingCall() → Runs on IO thread
    │   └── updateUI() → Back to Main
    └── Coroutine 2 (Dispatchers.Default)
        └── heavyCalculation() → Runs on CPU thread pool
```

### Relationship Rules
1. **Scope > Context > Dispatcher**: `Scope` defines lifecycle, `Context` carries data, `Dispatcher` defines thread.
2. **Child-parent**: Coroutine launched in scope là child. Parent cancel → all children cancel.
3. **Suspend chaining**: `suspend fun` gọi `suspend fun` →在同一 coroutine context, không tạo thread mới.

--------------------------------
SECTION 4: CODE PATTERNS
--------------------------------

### Pattern 1: Basic Sequential Execution
**When to use**: Logic phụ thuộc từng bước, cần return value.
**Why**: `suspend` cho phép viết async code như sync. Không cần callback hell.

```kotlin
suspend fun loadUserProfile(userId: String): UserProfile {
    // Bước 1: Get user data (I/O)
    val user = withContext(Dispatchers.IO) {
        api.getUser(userId) // blocking call
    }
    
    // Bước 2: Load avatar (I/O, phụ thuộc user)
    val avatar = withContext(Dispatchers.IO) {
        api.getAvatar(user.avatarUrl)
    }
    
    // Bước 3: Process (CPU)
    val processedAvatar = withContext(Dispatchers.Default) {
        processImage(avatar)
    }
    
    return UserProfile(user, processedAvatar)
}

// Usage
suspend fun main() {
    val profile = loadUserProfile("user123") // Chạy tuần tự
    println(profile)
}
```

### Pattern 2: Parallel Execution (Aggregation)
**When to use**: Có nhiều tasks độc lập, muốn chạy parallel để faster.
**Why**: `async` each task, then `awaitAll()` để lấy kết quả cùng lúc.

```kotlin
suspend fun loadDashboardData(userId: String): DashboardData {
    return coroutineScope {
        val profileDeferred = async { loadUserProfile(userId) }
        val statsDeferred = async { loadUserStats(userId) }
        val friendsDeferred = async { loadFriends(userId) }
        
        // Wait for all, return aggregated result
        DashboardData(
            profile = profileDeferred.await(),
            stats = statsDeferred.await(),
            friends = friendsDeferred.await()
        )
    }
}
```

### Pattern 3: Fire-and-Forget Job
**When to use**: Background task không cần kết quả, không cần await.
**Why**: `launch` tự động start, management tự động qua Job.

```kotlin
fun startBackgroundSync() {
    // Requires Scope (e.g., from lifecycle)
    viewModelScope.launch {
        try {
            withContext(Dispatchers.IO) {
                syncDataWithServer()
            }
        } catch (e: Exception) {
            // Handle error
        }
    }
}
```

### Pattern 4: Timeout & Cancellation
**When to use**: Operation có thể lâu hoặc không trả về.
**Why**: Tránh freeze app, release resource sớm.

```kotlin
suspend fun fetchWithTimeout(url: String): String {
    return withTimeout(5000) { // 5 seconds
        withContext(Dispatchers.IO) {
            // Long running network call
            downloadLargeFile(url)
        }
    }
}
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1. **Blocking inside `suspend` without context**
   ```kotlin
   suspend fun badExample() {
       Thread.sleep(1000) // DANGER: Block thread, không suspend properly
   }
   ```
   **Why dangerous**: Thread bị block → thread pool exhaustion → app freeze. Phải dùng `delay()` thay cho `sleep()`.

2. **GlobalScope usage**
   ```kotlin
   GlobalScope.launch { /* ... */ } // ANTI-PATTERN
   ```
   **Why dangerous**: Non-structured concurrency. Không có parent, lifecycle không quản lý → memory leak nếu activity destroy mà job vẫn chạy.

3. **Missing `coroutineScope` in suspend functions**
   ```kotlin
   suspend fun loadData() {
       launch { /* ... */ } // ERROR: Không có scope
   }
   ```
   **Why dangerous**: Compiler error. Must use `coroutineScope` builder để tạo child scope.

4. **Calling blocking code on `Dispatchers.Main`**
   ```kotlin
   viewModelScope.launch(Dispatchers.Main) {
       val data = withContext(Dispatchers.IO) {
           blockingDbCall()
       }
       // Update UI
   }
   ```
   **Why dangerous**: Though wrapped, nếu `withContext` fail hoặc logic bug, Main thread có thể block → ANR. Luôn validate context.

5. **Not handling exception in `async`**
   ```kotlin
   val result = async { riskyOp() }
   // Quên try-catch await() → Crash nếu fail
   ```
   **Why dangerous**: `async` chỉ wrap exception trong Deferred. Phải gọi `await()` trong `try-catch`.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Quick Rules
- **`suspend` = "This function might pause"**: Use for logic, not execution.
- **`launch` = "Run & Forget"**: Use for fire-and-forget.
- **`async` = "Run & Get Result"**: Use when you need return value.
- **`withContext` = "Switch Thread"**: Use inside suspend functions.
- **`coroutineScope` = "Parent Control"**: Use to launch children safely.

### Decision Logic (If-Else)
```
If (Need to run logic?) → Use `suspend fun`
Else if (Need to start job?)
    ├─ If (Need result?) → `async` + `await()`
    ├─ If (No result?) → `launch`
    └─ If (Switch thread?) → `withContext(Dispatcher)`
    
If (Timeout possible?) → Wrap in `withTimeout()`
If (Blocking code?) → Always put in `Dispatchers.IO`
```

### Top 10 Things to Remember
1. **Suspend is not parallel**: It pauses execution, doesn't create thread.
2. **Dispatcher.Main = UI thread**: Only use for UI updates.
3. **CoroutineScope lifecycle**: Destroy scope = cancel all coroutines.
4. **Async needs await()**: No await = no execution.
5. **Launch returns Job**: Can cancel it manually.
6. **Block thread bad**: Use `delay()`, `yield()` instead of `Thread.sleep()`.
7. **GlobalScope is leak**: Avoid unless for truly app-wide lifecycle.
8. **Structured concurrency**: Always launch in scope.
9. **Test with TestDispatcher**: Control time in tests.
10. **Exception handling**: Use `try-catch` around `await()` or `launch` with `CoroutineExceptionHandler`.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines Basics

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Coroutine (Tiến trình rút gọn)**: Một đơn vị công việc nhẹ, có thể tạm dừng và tiếp tục lại sau này mà không làm block thread.
- **Suspend Function (Hàm hoãn)**: Hàm có thể tạm dừng thực thi, trả lại CPU cho hệ thống, và tiếp tục từ điểm dừng trước đó. Trong Kotlin, dùng từ khóa `suspend`.
- **Dispatcher (Bộ định tuyến)**: Xác định thread hoặc pool thread nào sẽ chạy coroutine. Kiểm soát nơi code của bạn thực thi (Main, IO, Default).
- **Structured Concurrency (Tính đồng bộ có cấu trúc)**: Một coroutine mới được khởi tạo trong một `CoroutineScope` (phạm vi), đảm bảo các coroutine con sẽ bị hủy bỏ nếu scope cha bị hủy.
- **Blocking (Chặn thread)**: Thread bị chiếm dụng hoàn toàn và không thể làm việc khác cho đến khi nhiệm vụ kết thúc. Của thế giới cũ (Java Threads).
- **Suspending (Hoãn)**: Thread được giải phóng để làm việc khác trong khi chờ (ví dụ: network call). Của thế giới mới (Coroutines).

### Key Mental Models
- **Event Loop Model**: Imagine a single-threaded environment (like JS). `suspend` means "I'm waiting for something, you can do other tasks now." When the result is ready, it resumes.
- **Worker Pools Model**: Imagine a factory (CPU cores). `withContext(Dispatchers.Default)` is like sending tasks to the factory floor. It doesn't wait idly; it works efficiently on available workers.

### Why Coroutines > Threads/Callbacks?
- **Lightweight**: Tạo 1,000,000 coroutines dễ hơn 1,000 threads. Thread là tài nguyên hệ thống nặng (heavy).
- **Structured**: Không lo bị rò rỉ bộ nhớ (memory leaks) vì coroutine tự hủy khi scope kết thúc.
- **No Callback Hell**: Code viết tuần tự (sequential) nhưng hành xử là bất đồng bộ (asynchronous).

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Chạy code `main()` hoặc cần block thread đợi kết quả (Ví dụ: Unit test, CLI) | `runBlocking { ... }` | Biến hàm suspending thành blocking. Dùng khi plataforma yêu cầu (ví dụ: hàm `main` không hỗ trợ suspend). | Dùng `runBlocking` trong UI thread của Android/JavaFX (gây freeze UI). |
| Thực thi task CPU nặng (Tính toán, xử lý ảnh) | `withContext(Dispatchers.Default)` | Tối ưu cho CPU-bound. Sử dụng thread pool size = số core CPU. | Dùng Default cho IO (File/Network) làm lãng phí thread CPU. |
| Thực thi task chờ I/O (Network, Database, File) | `withContext(Dispatchers.IO)` | Tối ưu cho IO-bound. Có thể tạo nhiều thread nếu cần để chờ (blocking). | Lạm dụng IO Dispatcher cho task tính toán nặng (gây context switching overhead). |
| Khởi chạy một coroutine không cần đợi kết quả (Fire-and-forget) | `launch { ... }` | Trả về `Job`. Kiểm soát lifecycle (start, cancel). | Dùng `launch` nhưng không lưu `Job` → Không thể hủy nếu cần. |
| Khởi chạy một coroutine cần trả về giá trị (Kết quả async) | `async { ... }` | Trả về `Deferred`. Dùng `.await()` để lấy kết quả. | Quên `.await()` → Không bao giờ thực thi code bên trong `async`. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Flow
```text
[Main Thread / UI Thread] (Top Level)
       |
       v
runBlocking / launch (in UI Scope)
       |
       +---> [Thread Pool] (Dispatchers)
             |
             +---> Dispatcher.Default (CPU: Cores count)
             +---> Dispatcher.IO (Backing Thread Pool)
             +---> Dispatcher.Main (UI Thread)
                   |
                   v
             [Coroutines] (Lightweight units of work)
```

**Relations:**
1. **Scope -> Job**: `CoroutineScope` quản lý `Job`.
2. **Job -> Context**: `Job` mang theo `CoroutineContext` (bao gồm `Dispatcher`).
3. **Suspend -> Resume**: Code thực thi tuần tự, nhưng có thể nhảy qua lại giữa các thread qua `withContext`.

---

## SECTION 4: CODE PATTERNS

### Pattern 1: The Safe Entry Point
**Khi nào dùng:** Khi `main` function không support `suspend` nhưng bạn muốn dùng coroutine.
**Tại sao đúng:** `runBlocking` đóng vai trò cầu nối giữa thế giới blocking (main) và thế giới suspending (coroutines).
**Code:**

```kotlin
import kotlinx.coroutines.*
import kotlin.time.Duration.Companion.seconds

suspend fun getData(): String {
    delay(1.seconds) // Simulate network
    return "Data"
}

fun main() = runBlocking { // Bridge
    val result = getData()
    println(result)
}
```

### Pattern 2: Context Switching (CPU vs IO)
**Khi nào dùng:** Khi logic cần chạy trên thread pool này, nhưng thao tác IO lại phải trên thread pool khác.
**Tại sao đúng:** Tối ưu tài nguyên hệ thống. Không để CPU block等待 I/O.
**Code:**

```kotlin
suspend fun fetchAndProcess() {
    // Chạy trên thread pool IO (nhiều thread, chờ được)
    val json = withContext(Dispatchers.IO) {
        // Gọi API hoặc đọc file
        "{'key': 123}"
    }
    
    // Chuyển về Default để parse JSON/cpu work
    val result = withContext(Dispatchers.Default) {
        // Parse json (CPU intensive)
        json.length
    }
    println("Result: $result")
}
```

### Pattern 3: Concurrent Launch (Multiple Tasks)
**Khi nào dùng:** Khi có 2+ task độc lập và muốn chạy song song để giảm thời gian tổng thể.
**Tại sao đúng:** `launch` là "fire-and-forget", chạy song song ngay lập tức. `join` (hoặc scope kết thúc) mới chờ.
**Code:**

```kotlin
suspend fun loadData() = coroutineScope { // Scope để quản lý child
    val job1 = launch {
        delay(1000)
        println("Task 1 done")
    }
    
    val job2 = launch {
        delay(1000)
        println("Task 2 done")
    }
    
    // Scope tự động chờ tất cả child hoàn thành
}
```

### Pattern 4: Returning Values (Async/Await)
**Khi nào dùng:** Khi task A cần kết quả của task B.
**Tại sao đúng:** `async` trả về `Deferred`. `await` suspends chờ kết quả, nhưng các task khác vẫn chạy nếu không dùng `await` sớm.
**Code:**

```kotlin
suspend fun getUserAndProfile() = withContext(Dispatchers.IO) {
    val userDeferred = async { fetchUser() } // Fire 1
    val profileDeferred = async { fetchProfile() } // Fire 2

    // Wait for both to finish
    val user = userDeferred.await()
    val profile = profileDeferred.await()
    
    println("$user, $profile")
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Blocking Inside Suspended Function
**Code Danger:**
```kotlin
suspend fun badFunction() {
    Thread.sleep(5000) // DANGER!
}
```
**Why:** `Thread.sleep` blocks the underlying thread. If you are on `Dispatchers.Main` or a limited thread pool, you freeze the system. Always use `delay()` instead.

### 2. GlobalScope Usage
**Code Danger:**
```kotlin
GlobalScope.launch { ... }
```
**Why:** Cực kỳ nguy hiểm. `GlobalScope` là "Top-Heavy". Nó tạo coroutine sống vĩnh viễn, không bị ràng buộc với bất kỳ lifecycle nào → Dễ gây Memory Leak và Crash.

### 3. launch Without Context
**Code Danger:**
```kotlin
fun trigger() {
    launch { ... } // Error: Not inside a CoroutineScope
}
```
**Why:** Thiếu `CoroutineScope` (hoặc `GlobalScope`). Compiler sẽ báo lỗi. Phải dùng `runBlocking`, `viewModelScope`, hoặc tạo scope thủ công.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **`delay(n)`**: Dùng để nghỉ ngơi/giả lập thời gian (không block thread).
2. **`Thread.sleep(n)`**: **TUYỆT ĐỐI TRÁNH** trong coroutine.
3. **`runBlocking`**: Chỉ dùng cho `main` hoặc Unit Test.
4. **`withContext`**: Dùng để chuyển đổi Thread/Dispatcher (IO -> Default).
5. **`coroutineScope`**: Dùng để launch child coroutines và đảm bảo chúng hoàn thành trước khi tiếp tục.

### Decision Logic (If-Else)
```text
IF (Function is called from non-suspend world (Main)) THEN
   Use runBlocking { ... }

ELSE IF (Task is CPU heavy (Calculations)) THEN
   Use withContext(Dispatchers.Default)

ELSE IF (Task is I/O (Network/DB/File)) THEN
   Use withContext(Dispatchers.IO)

ELSE IF (Need result (Wait for calculation)) THEN
   Use async { ... }.await()

ELSE IF (Just run it, don't wait (UI updates)) THEN
   Use launch { ... }
```

### Top 5 Things To Remember
1. **Suspend** là cooperative. Code chỉ dừng khi gọi hàm suspending (như `delay`).
2. **Dispatcher** là nơi code chạy (Thread pool).
3. **Structured Concurrency** dùng `scope` để tránh leak.
4. **Main Thread** là duy nhất, hãy giữ nó rảnh rang (dùng IO/Default cho heavy work).
5. **Fail Fast**: Coroutine con bị lỗi sẽ hủy coroutine cha nếu dùng `supervisorScope` không đúng.

<!-- CHUNK 21-30 -->

# Kotlin Coroutines Basics - Developer Decision Guide

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Coroutine (Tiến trình rút gọn)**: Một đơn vị công việc nhẹ, có thể bị hoãn mà không block thread.
- **Structured Concurrency (Song song có cấu trúc)**: Nguyên tắc tổ chức coroutines thành cây cha-con với vòng đời được liên kết.
- **CoroutineScope (Phạm vi coroutine)**: Đối tượng quản lý vòng đời và context của coroutines, tạo ranh giới cho việc hủy bỏ an toàn.
- **Coroutine Context (Ngữ cảnh coroutine)**: Tập hợp các thông tin định nghĩa cách coroutine hoạt động (dispatcher, tên, v.v.).
- **Parent-Child Hierarchy (Mối quan hệ cha-con)**: Coroutine được tạo ra trong scope khác sẽ trở thành con của scope đó.

### Key Mental Models
**Reality Check**: Coroutines là các công việc được đóng gói trong một cây gia tộc. Khi cha bị hủy, tất cả con bị hủy theo đệ quy. Khi cha hoàn thành, nó phải đợi tất cả con xong trước.

**Why Better**: Traditional threads không thể hủy an toàn mà không để lại rác. Structured concurrency đảm bảo cleanup tự động, tránh rò rỉ tài nguyên và lỗi trạng thái treo.

```kotlin
// Mental model: Một cây coroutines
suspend fun example() {
    coroutineScope { // Cây mới, là root
        launch { // Con trực tiếp của scope
            delay(1000)
            launch { // Cháu của scope, con của launch trên
                delay(500)
            }
        }
        launch { // Con trực tiếp của scope
            delay(2000)
        }
    } // Đợi TẤT CẢ con xong mới chạy tiếp
}
```

## SECTION 2: DECISION TABLES

### Table 1: Khi nào dùng coroutineScope() vs launches tự do

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|-------------------|-------------|---------|-------------------|
| Cần group nhiều coroutines và đợi tất cả hoàn thành | `coroutineScope { launch { } launch { } }` | **Structured concurrency**: Cha đợi con, tự động cleanup nếu có lỗi | Dùng nhiều `GlobalScope.launch` riêng lẻ -> không đợi nhau, lỗi khó dự đoán |
| Bắt đầu coroutine mới từ suspend function | `coroutineScope.launch { }` hoặc `coroutineScope { }` | Kế thừa context hiện tại, lifecycle được quản lý | Dùng `GlobalScope` -> coroutine có thể thoát function mà chưa hoàn thành |
| Xử lý nhiều tác vụ độc lập nhưng cần rollback khi lỗi | `coroutineScope { }` với try-catch bên ngoài | Nếu 1 con lỗi -> cancel toàn bộ scope | Dùng `async` không có scope -> lỗi không lan truyền, resource rò rỉ |

### Table 2: Khi nào dùng Dispatchers

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|-------------------|-------------|---------|-------------------|
| CPU-intensive work | `Dispatchers.Default` | Thread pool tối ưu cho CPU-bound tasks | Dùng main thread -> freeze UI |
| I/O operations (file, network) | `Dispatchers.IO` | Thread pool lớn (~64 threads) cho blocking calls | Dùng Default -> lãng phí threads cho blocking |
| UI updates | `Dispatchers.Main` | Tránh race condition với UI framework | Dùi background thread -> crash UI |
| Không specify | Kế thừa từ scope | Debug dễ hơn với tên coroutine | Bỏ qua context -> dispatcher không rõ ràng |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Hierarchy
```
Global Scope (Root, không recommend)
├── Job (root)
└── Các coroutines tự do (không có cha)

Structured Scope (Root của bạn)
├── coroutineScope { }  // Root của subtree
│   ├── launch { }      // Child 1
│   │   └── launch { }  // Child 1.1 (grandchild)
│   ├── launch { }      // Child 2
│   └── async { }       // Child 3
│       └── launch { }  // Child 3.1
└── (Sau khi block kết thúc)
    └── println("Done") // Chỉ chạy sau khi tất cả con hoàn thành

Lifecycle Flow:
Launch -> Active -> Completing -> Completed
    ↓ (nếu lỗi/hủy)
    -> Cancelling -> Cancelled
```

### Relationship Rules
1. **Scope -> Context**: Scope chứa Context (Dispatcher, Job, Name)
2. **Context -> Coroutine**: Context được truyền khi build coroutine
3. **Parent -> Child**: Lifecycle phụ thuộc nhau (cha hủy -> con hủy)
4. **Child -> Parent**: Con hoàn thành không tự hủy cha

## SECTION 4: CODE PATTERNS

### Pattern 1: Root Coroutine Scope
**Khi nào dùng**: Bắt đầu một group coroutines độc lập từ một suspend function hoặc main.

**Tại sao đúng**: Tạo ranh giới rõ ràng, đảm bảo cleanup tự động.

```kotlin
suspend fun processData() {
    // Root của subtree
    coroutineScope { // this: CoroutineScope
        launch {
            delay(1000)
            println("Task 1 done")
        }
        launch {
            delay(2000)
            println("Task 2 done")
        }
    }
    // Dòng này chỉ chạy sau khi cả 2 task trên xong
    println("All tasks completed, safe to continue")
}
```

### Pattern 2: Nested Launch with Inherited Context
**Khi nào dùng**: Launch coroutines con bên trong coroutine cha.

**Tại sao đúng**: Con tự động nhận context từ cha (dispatcher, tên, v.v.).

```kotlin
suspend fun parent() {
    coroutineScope {
        // Receiver là CoroutineScope, có thể bỏ "this."
        launch { // Inherits context from outer scope
            println("Child in thread: ${Thread.currentThread().name}")
            
            // Launch grandchild
            launch {
                delay(500)
                println("Grandchild completed")
            }
        }
    }
}
```

### Pattern 3: Extracted Launch Function
**Khi nào dùng**: Tách logic launch ra function riêng để tái sử dụng.

**Tại sao đúng**: Function vẫn là extension trên CoroutineScope, giữ nguyên lifecycle rules.

```kotlin
// Extension function on CoroutineScope
fun CoroutineScope.launchWorker() {
    this.launch {
        delay(1000)
        println("Worker finished")
    }
}

suspend fun main() {
    coroutineScope {
        launchWorker() // Gọi như method của scope
        launchWorker()
    }
}
```

### Pattern 4: Debug with Coroutine Names
**Khi nào dùng**: Debug coroutines, theo dõi tên trong log.

**Tại sao đúng**: Rõ ràng hơn khi có nhiều coroutines chạy parallel.

```kotlin
// Add VM option: -Dkotlinx.coroutines.debug
suspend fun debugExample() {
    coroutineScope {
        launch(CoroutineName("Worker-1")) {
            println("Running in ${Thread.currentThread().name}")
            delay(500)
        }
        launch(CoroutineName("Worker-2")) {
            println("Running in ${Thread.currentThread().name}")
            delay(500)
        }
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern 1: Dùng GlobalScope.launch
**Tại sao nguy hiểm**: Không có cha -> không được quản lý, không tự động hủy, không đợi completion. Dễ gây rò rỉ coroutine, crash khi app tắt.

```kotlin
// ❌ DANGEROUS
suspend fun wrong() {
    GlobalScope.launch { 
        delay(5000) 
    }
    // Function kết thúc ngay, coroutine vẫn chạy!
}
```

### Anti-Pattern 2: Launch không có scope trong suspend function
**Tại sao nguy hiểm**: Coroutine có thể "tách" ra, sống sót sau khi function return, dẫn đến race condition.

```kotlin
// ❌ DANGEROUS
suspend fun danglingLaunch() {
    launch { // Implicitly using some outer scope, unclear lifecycle
        delay(1000)
    }
    // Nếu không có scope外, có thể crash hoặc lỗi logic
}
```

### Anti-Pattern 3: Không đợi child coroutine
**Tại sao nguy hiểm**: Parent hoàn thành trước khi child xong ->丢失 kết quả hoặc thao tác sai.

```kotlin
// ❌ WRONG
suspend fun incomplete() {
    coroutineScope {
        launch { delay(2000) } // Child 1
        launch { delay(2000) } // Child 2
    }
    // Parent phải đợi cả 2, đúng! Nhưng nếu bạn không dùng coroutineScope:
    // GlobalScope.launch { ... } // Không đợi -> Rác
}
```

### Warning 4: Coroutine trong loop không có scope
**Tại sao nguy hiểm**: Nếu dùng `GlobalScope` trong loop, tạo ra hàng trăm coroutine không kiểm soát.

```kotlin
// ❌ DANGEROUS
suspend fun loopWrong() {
    repeat(100) {
        GlobalScope.launch { // 100 coroutines không được quản lý!
            delay(1000)
        }
    }
}
```

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
- **Luật 1**: Luôn dùng `coroutineScope { }` hoặc `CoroutineScope.launch { }` trong suspend function.
- **Luôn 2**: Đừng bao giờ dùng `GlobalScope` trong production code.
- **Luôn 3**: Nếu cần đợi nhiều coroutines -> `coroutineScope { launch { } launch { } }`.
- **Luôn 4**: Con tự động inherit context từ cha.
- **Luôn 5**: Enable debug với `-Dkotlinx.coroutines.debug` để thấy tên coroutine.

### Decision Logic (If-Else Style)
```
IF cần launch coroutine mới trong suspend function:
  → USE coroutineScope { launch { } } (hoặc launch(this))

ELSE IF cần return result từ nhiều coroutines:
  → USE coroutineScope { async { } async { } }

ELSE IF chỉ cần fire-and-forget UI update:
  → USE viewModelScope.launch { } (trong Android)

ELSE IF đang debug và cần tên coroutine:
  → ADD CoroutineName("Tên") vào context

ELSE:
  → NGHĨ LẠI. Có thể bạn cần structured scope.
```

### Top 10 Things to Remember
1. **Cancelling**: Hủy cha = Hủy con (đệ quy).
2. **Completion**: Cha chỉ hoàn thành khi con hoàn thành.
3. **Error**: Lỗi con -> lan lên cha -> hủy cha.
4. **Scope**: `coroutineScope()` = root mới, kế thừa context.
5. **Context**: Combine với `+` (e.g., `Dispatchers.IO + CoroutineName("Worker")`).
6. **Debug VM Option**: `-Dkotlinx.coroutines.debug` bắt buộc.
7. **Extension**: `launch` là extension function của `CoroutineScope`.
8. **Receiver**: Trong `coroutineScope { }`, `this` là `CoroutineScope`.
9. **Default Dispatcher**: Nếu không specify -> `Dispatchers.Default`.
10. **Cleanup**: Structured concurrency tự động cancel và cleanup.

<!-- CHUNK 31-40 -->

# Kotlin Coroutines Basics - Developer Decision Guide

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Coroutine Builder (Hàm xây dựng tiến trình rút gọn)**: A function that accepts a `suspend` lambda and starts a coroutine, requiring a `CoroutineScope` context.
- **CoroutineScope (Phạm vi tiến trình rút gọn)**: An implicit receiver that provides the context and lifecycle for launching child coroutines. Inside `coroutineScope { }`, builders like `launch` and `async` become extension functions.
- **Deferred (Đối tượng bị hoãn)**: A `Deferred<T>` handle returned by `async()` that represents a suspendable result with value `T`. Use `.await()` to retrieve the value.
- **`this: CoroutineScope`**: Explicit receiver type required when extracting coroutine builder calls into separate functions to maintain scope context.

### Key Mental Model
- **Scopes are not containers**: `CoroutineScope` is a context provider, not a thread pool. It manages cancellation and concurrency, not execution threads.
- **Implicit receiver magic**: Inside `coroutineScope { }`, you call `launch { }` directly. Compiler resolves these as `this.launch { }` on the provided scope.
- **Fire-and-forget vs. Result**: `launch` is for fire-and-forget (no return). `async` is for concurrent work with a result (returns `Deferred`).

### Why Better
- **Structured concurrency**: Scopes enforce parent-child relationships. If the parent cancels, all children cancel automatically, preventing leaks.
- **Composable**: Functions can be `suspend` and be called from any coroutine without manually passing callbacks or threads.
- **Non-blocking**: Unlike threads, coroutines are cheap (~few KB). You can launch thousands without performance issues.

---

## SECTION 2: DECISION TABLES

### Launch vs Async
| Tình huống sử dụng | Nên dùng gì | Tại sao (Structured Concurrency) | Sai lầm thường gặp |
|-------------------|-------------|----------------------------------|---------------------|
| Run background task, don't wait for result | `launch` | Fire-and-forget. Starts concurrently, returns `Job` (cancellation handle). Parent scope continues. | Using `launch` for tasks that require result, leading to race conditions. |
| Run concurrent tasks, need results later | `async` | Returns `Deferred` (promise). Use `.await()` to suspend and get result. Enables parallel computation. | Not calling `.await()`, leaving `Deferred` unresolved or misusing it as `Job`. |
| Run task sequentially (one after another) | Plain `suspend` function | Just call another `suspend` function directly. No builder needed. | Using `launch` + `delay` or `join()` to sequence tasks, creating unnecessary `Job` objects. |

### Scope Providers
| Tình huống sử dụng | Nên dùng gì | Tại sao (Execution Context) | Sai lầm thường gặp |
|-------------------|-------------|----------------------------------|---------------------|
| Top-level `main()` or test entry | `runBlocking` | Bridges blocking world to suspending world. Blocks current thread until all coroutines complete. | Using `runBlocking` inside other coroutines (creates nested blocks, blocks threads unnecessarily). |
| Inside `suspend` function, need to launch children | `coroutineScope` | Creates a scope that inherits parent context but can have its own children. Cancels all if one fails. | Not using `coroutineScope` when launching multiple children, leading to unstructured leaks. |
| Switching thread context for CPU/IO work | `withContext(Dispatchers.IO)` | Suspends, moves execution to specific dispatcher, then returns result. Does NOT create a new scope. | Confusing `withContext` with `launch` (it's a builder but for single task, returning result directly). |

### Function Signature Pattern
| Tình huống sử dụng | Nên dùng gì | Tại sao (Scope Declaration) | Sai lầm thường gặp |
|-------------------|-------------|----------------------------------|---------------------|
| Function needs to launch multiple coroutines | `fun CoroutineScope.myFunction() { ... }` | Declares a receiver. Inside, you can call `launch` and `async` directly (resolved as `this.launch`). | Declaring `suspend` function without receiver, then failing to compile `launch` calls. |
| Function is a pure suspending operation | `suspend fun myFunction() { ... }` | No children to launch. Performs its work and returns. | Adding `CoroutineScope` receiver unnecessarily, polluting API. |
| Private helper launching children | `private fun CoroutineScope.launchAll() { ... }` | Allows extraction of builder logic. Called inside an existing scope. | Extracting logic into non-scope function, forcing manual scope passing. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Flow
```
runBlocking {                            // Bridge: Blocks thread, creates root Scope
    │
    ├── coroutineScope {                 // Child Scope: Inherits Dispatchers, manages children
    │   │
    │   ├── launch { ... }               // Fire-and-forget: No return, runs concurrently
    │   └── async { ... }                // Result-oriented: Returns Deferred<T>
    │
    └── withContext(Dispatchers.IO) {    // Context Switch: Suspends, runs block, returns value
        // Just code execution here
    }
}
```

### Relationships
- **`coroutineScope` > `launch`/`async`**: `coroutineScope` is the **provider**. `launch` and `async` are **extension functions** on that provider.
- **`runBlocking` = Parent Scope**: It creates the top-level scope. Use it **only** at the absolute edge of the application (main, tests).
- **`withContext` ≠ Scope**: It is a builder but **does not create a scope**. It switches dispatchers for a single block and returns the result. It is **sequential** by default.
- **Scope Receiver**: `fun CoroutineScope.foo()` means `foo` can only be called where a `CoroutineScope` is available (`this`, or passed in), enabling implicit `this.launch`.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Launching Multiple" Pattern
**When to use**: You are inside a `suspend` function and need to run multiple tasks concurrently, waiting for all to finish (or cancel if one fails).

**Why correct**: `coroutineScope` ensures all children are joined. If one throws, it cancels siblings and rethrows.

```kotlin
suspend fun downloadData() = coroutineScope {
    // Implicit receiver: this: CoroutineScope
    val result1 = async { fetchFromNetwork("api/v1") }
    val result2 = async { fetchFromNetwork("api/v2") }
    
    // Wait for both
    println("Result: ${result1.await()} and ${result2.await()}")
    // If fetchFromNetwork fails, both async calls cancel automatically
}

// Usage
suspend fun main() {
    downloadData()
}
```

### Pattern 2: The "Extension Receiver" Pattern
**When to use**: You want to extract a block of code that uses `launch` or `async` into a separate named function.

**Why correct**: The extracted function must declare `CoroutineScope` as a receiver to access the builder extensions.

```kotlin
fun CoroutineScope.startBackgroundJobs() {
    // "this" is the implicit receiver (CoroutineScope)
    this.launch { println("Job 1") }  // Same as just launch { ... }
    this.launch { println("Job 2") }
}

suspend fun main() {
    coroutineScope {
        startBackgroundJobs() // Called on the current scope
    }
}
```

### Pattern 3: The "Bridge" Pattern
**When to use**: Entering coroutines from a non-suspending context (like a button click in UI or `main` entry).

**Why correct**: `runBlocking` blocks the current thread safely until coroutines finish. Do not use it inside other coroutines.

```kotlin
// Standard main entry
fun main() = runBlocking {
    // We can now call suspend functions here
    performBackgroundWork()
    println("Done")
}

suspend fun performBackgroundWork() = coroutineScope {
    launch { 
        delay(100)
        println("Background")
    }
    println("Scope continues")
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Extracting Builders without Receiver**
    -   **Code**: `fun launchJobs() { launch { ... } }` (inside a suspend function).
    -   **Why dangerous**: Compilation error. `launch` requires `CoroutineScope` receiver. You must define `fun CoroutineScope.launchJobs()`.

2.  **Nested `runBlocking`**
    -   **Code**: `runBlocking { launch { runBlocking { ... } } }`
    -   **Why dangerous**: Creates a blocking context inside a suspending context. It blocks a thread that might be needed by the parent, leading to deadlocks or performance degradation.

3.  **Ignoring `coroutineScope` in `suspend` functions**
    -   **Code**: `suspend fun doWork() { launch { ... } }`
    -   **Why dangerous**: Compilation error. `launch` is not available. You must wrap in `coroutineScope { launch { ... } }` or make the function `fun CoroutineScope.doWork()`.

4.  **Treating `Deferred` as `Job`**
    -   **Code**: `val d = async { ... }`; `d.cancel()` (instead of `d.await()`).
    -   **Why dangerous**: While `Deferred` is a `Job`, you usually want the result. Calling `cancel` discards the result without throwing, making it look like it worked.

5.  **Using `launch` when you need a return value**
    -   **Code**: `launch { return@launch "Result" }`. The result is lost.
    -   **Why dangerous**: The calling function cannot access the string. Use `async` + `await()` to return values from concurrent work.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  `launch`: No return (Job). `async`: Return value (Deferred).
2.  `runBlocking`: Only at the top (main/test).
3.  `coroutineScope`: Inside suspend functions to launch children.
4.  `withContext`: To switch threads (IO/CPU). Sequential by default.
5.  `scope.launch`: Inside a `coroutineScope` or `runBlocking`.
6.  `fun CoroutineScope.foo()`: Pattern to extract launch/async logic.
7.  Cancellation propagates down automatically.
8.  `await()` suspends until value is ready.
9.  **Implicit Receiver**: `coroutineScope { launch { } }` is magic.
10. **Structure**: Unstructured (`GlobalScope`) = Leaks. Structured (`scope`) = Safe.

### Decision Logic
- **Is it an entry point (main/test)?** -> `runBlocking`
- **Inside suspend, need to wait for result?** -> `async` -> `await()`
- **Inside suspend, need to run concurrently?** -> `launch`
- **Inside suspend, need to launch helpers?** -> `coroutineScope { ... }`
- **Need to call `launch` in a helper function?** -> `fun CoroutineScope.helper()`
- **Need to switch threads for work?** -> `withContext(Dispatchers.IO)`

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines Basics

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **runBlocking (Chạy chặn)**: Tạo một `CoroutineScope` và **chặn** thread hiện tại cho đến khi mọi coroutine trong scope đó hoàn thành.
*   **Coroutine Dispatcher (Bộ điều phối tiến trình rút gọn)**: Xác định thread hoặc pool thread nào sẽ thực thi coroutine.
*   **Suspend (Tạm dừng)**: Dừng thực thi coroutine để chờ kết quả (không block thread), sau đó resume (tiếp tục) ở cùng context.

### Key Mental Models
1.  **Thread vs. Coroutine**: Thread là "xe lớn" (tốn tài nguyên), Coroutine là "hành khách" (nhẹ, đông). Dispatcher là "lái xe" quyết định乘客在哪 xe nào.
2.  **Context Propagation**: Con coroutine tự động thừa hưởng `Dispatcher` từ cha (Scope). Không cần khai báo lại nếu dùng đúng ngữ cảnh.
3.  **Blocking vs. Suspending**:
    *   **Blocking**: Cứng đầu, giữ nguyên thread (gây tê liệt nếu thread chính).
    *   **Suspending**: Nhẹ nhàng, nhường chỗ cho việc khác (CPU không bị rảnh rang).

### Why this approach?
Thay vì tạo `Thread` mới cho mỗi tác vụ (dễ gây overflow memory), Coroutines cho phép thực thi **nghịch lý**: Code viết tuần tự nhưng chạy song song/hiệu quả.

---

## SECTION 2: DECISION TABLES

### Table 1: `runBlocking` vs `coroutineScope`
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Main App Logic / UI** | `coroutineScope` (hoặc `lifecycleScope`) | **Structured Concurrency**: Cha chết thì con theo, không rò rỉ bộ nhớ. | Dùng `runBlocking` trong UI thread -> **ANR (App Not Responding)**. |
| **Unit Tests** | `runBlocking` | **Bridge**: Cần chuyển code đồng bộ (test) gọi hàm suspending. | Quên `runBlocking` trong test -> Compilation error (suspending không gọi được từ regular func). |
| **Legacy Code / Interface Restriction** | `runBlocking` | **Last Resort**: Khi interface c cứng không cho `suspend`, buộc phải block. | Lạm dụng trong业务 logic -> Giảm hiệu năng app. |

### Table 2: Dispatchers Selection
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **CPU Intensive** (Tính toán, Parse JSON lớn) | `Dispatchers.Default` | **Worker Pool**: Dùng thread pool tối ưu cho CPU-bound tasks. | Dùng `Main` -> Block UI, giật lag. |
| **UI Update / User Input** | `Dispatchers.Main` | **Main Thread**: Duy nhất thread an toàn để update View. | Dùng `Default` cho UI -> Crash (View không thuộc thread đó). |
| **I/O Operations** (Database, Network, File) | `Dispatchers.IO` | **Cached Threads**: Tạo thread mới khi cần, tối ưu cho việc chờ đợi (blocking I/O). | Dùng `Default` cho I/O -> Phung phí thread CPU cho việc chờ. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Execution Flow
Coroutine Scope giữ lifcycle, Dispatcher giữ execution context.

```text
[ Parent Scope ]
      |
      | inherits (Default if not specified)
      v
[ Coroutine Context ] <--- Contains [ Dispatcher ]
      |
      | determines
      v
[ Thread Execution ]
```

### Dependency Logic
1.  **Top-level Scope** (UI/Activity) → Defaults to `Main`.
2.  **Child Coroutine** → Inherit from Parent.
3.  **Override** → Explicitly pass `Dispatchers.IO` to switch context.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Bridging Legacy to Suspending
**Khi nào dùng**: Khi bạn implement một Interface không hỗ trợ `suspend`, nhưng bên trong cần gọi hàm chờ (API/DB).

**Tại sao đúng**: Dùng `runBlocking` để "đóng băng" thread hiện tại đúng như yêu cầu của interface, nhưng cho phép dùng logic hiện đại ở bên trong.

```kotlin
import kotlinx.coroutines.*
import kotlin.time.Duration.Companion.milliseconds

// Interface第三人方 (không sửa được)
interface Repository {
    fun readItem(): Int // Phải là regular function
}

object MyRepository : Repository {
    override fun readItem(): Int {
        // Solution: Bắt buộc phải block thread này ở đây
        return runBlocking {
            // Gọi logic suspending hiện đại
            myReadItem()
        }
    }
}

suspend fun myReadItem(): Int {
    delay(100.milliseconds) // Simulate network delay
    return 4
}
```

### Pattern 2: Switching Context for CPU Work
**Khi nào dùng**: Khi ở `Main` thread nhưng cần tính toán dữ liệu nặng.

**Tại sao đúng**: `withContext` chuyển luồng执行 về `Default`, sau khi xong tự động chuyển về scope cũ (Main).

```kotlin
suspend fun processData() = withContext(Dispatchers.Default) {
    // Chạy trên thread nền
    println("Calculation on ${Thread.currentThread().name}")
    val result = (1L..1_000_000L).sum() // CPU heavy
    // Logic update UI sẽ KHÔNG nằm trong block này
    return@withContext result 
}
```

### Pattern 3: Concurrent Execution (Async/Await)
**Khi nào dùng**: Khi cần gọi 2 API song song và gộp kết quả.

**Tại sao đúng**: `async` trả về `Deferred` (future), `await` chờ cả hai. CPU利用率 cao.

```kotlin
suspend fun getAggregatedData() = withContext(Dispatchers.IO) {
    // Tạo 2 job song song
    val one = async { getApiDataA() }
    val two = async { getApiDataB() }
    
    // Chờ cả hai và gộp
    val total = one.await() + two.await()
    return@withContext total
}

suspend fun getApiDataA(): Int { delay(100); return 10 }
suspend fun getApiDataB(): Int { delay(100); return 20 }
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The `runBlocking` Cancer
*   **Action**: Dùng `runBlocking` trong function suspendable hoặc trong logic chính của app.
*   **Why dangerous**: Nó **block thread** chính (Main thread). Bất kỳ tác vụ nào sau nó đều phải chờ, dẫn đến ANR (Application Not Responding) và trải nghiệm người dùng tệ.

### 2. Wrong Dispatcher for Blocking API
*   **Action**: Dùng `Dispatchers.Default` cho Network Request (Retrofit/OkHttp).
*   **Why dangerous**: `Default` có giới hạn thread (số CPU cores). Nếu gọi Block I/O ở đây, sẽ cạn kiệt thread CPU -> Tính toán logic khác bị delay.

### 3. Forgetting `coroutineScope` in Suspend Functions
*   **Action**: Viết hàm `suspend` nhưng không có scope bao bọc khi launch job con.
*   **Why dangerous**: Nếu hàm này bị hủy (cancel), job con vẫn chạy lẻ và gây rò rỉ bộ nhớ (Memory Leak).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Main Thread**: Dùng `Dispatchers.Main` cho UI updates.
2.  **Calculation**: Dùng `Dispatchers.Default`.
3.  **Network/DB**: Dùng `Dispatchers.IO`.
4.  **Legacy Interface**: Dùng `runBlocking` (ẩn sâu nhất có thể).

### Decision Logic (If-Else)
*   **IF** đang ở UI thread và cần load data:
    *   Launch `viewModelScope.launch(Dispatchers.IO)`.
*   **ELSE IF** cần trả về kết quả từ `suspend` trong non-suspend function:
    *   Chỉ dùng `runBlocking` trong **Unit Test** hoặc **Interface Adapter**.
*   **ELSE** làm gì đó nặng:
    *   Dùng `withContext(Dispatchers.Default)`.

### Top 5 Things to Remember
1.  **Blocking = Dead** (trừ Test).
2.  **Suspending = Efficient**.
3.  Context chuyển thread tự động, state variable không bị reset khi chuyển thread.
4.  `runBlocking` chỉ để "cứu" code cũ hoặc test.
5.  Luôn nhớ `await()` khi dùng `async` để lấy kết quả.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines vs Threads

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Coroutine (Tiến trình rút gọn)**
Đoạn mã có thể tạm dừng và tiếp tục执行, chạy chồng lên các thread hiện có mà không chiếm hữu thread.

**Thread (Tiến trình hệ điều hành)**
Đơn vị执行 cơ bản của hệ điều hành, có stack riêng và bị quản lý bởi kernel.

**Suspend (Tạm dừng)**
Hành động dừng执行 coroutine, trả thread về thread pool để dùng cho việc khác, sau đó có thể resume từ đúng điểm đó.

### Key Mental Models
**Thread là "đường cao tốc" (Fixed Lane)**
Mỗi thread là một làn đường cố định, tốn xăng (RAM) và chỉ chạy được 1 xe (task) cùng lúc. Dừng xe = cả làn bị chặn.

**Coroutine là "xe bus" (Shared Lane)**
Nhiều coroutine shared 1 thread (xe bus). Khi xe bus dừng đón/trả khách (suspend), xe không bị chặn đường, xe khác vẫn chạy. Passenger (coroutine) có thể lên xe bus khác khi resume.

**Why better?**
- **Thread**: 1000 threads ~ 2-4GB RAM, OS context switch overhead.
- **Coroutine**: 1 triệu coroutines ~ vài trăm MB RAM, không OS context switch.

### Code Demo: The Scale Test
```kotlin
// COROUTINE WAY: 50,000 tasks, ~500MB RAM
suspend fun printPeriods() = coroutineScope {
    repeat(50_000) {
        launch {
            delay(5000) // Suspend, release thread
            print(".")
        }
    }
}

// THREAD WAY: 50,000 threads, ~100GB RAM, CRASH
fun main() {
    repeat(50_000) {
        thread { // Each needs 2MB+ stack
            Thread.sleep(5000L)
            print(".")
        }
    }
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Concurrency Model Selection

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|-------------------|-------------|---------|-------------------|
| **IO-bound task** (API call, DB query) | Coroutine + `Dispatchers.IO` | Light weight, non-blocking, can spawn 1000s | Using `thread {}` causing resource exhaustion |
| **CPU-bound task** (Image processing, math) | `Dispatchers.Default` | Thread pool optimized for CPU cores | Using `Dispatchers.IO` wasting threads on CPU work |
| **Long-running background task** | Coroutine + `launch` + SupervisorJob | Structured cancellation, exception handling | Using `GlobalScope` - leaks resources, no parent cancellation |
| **Need parallel execution** | `async/await` or `coroutineScope` | Returns result, concurrent execution | Sequential `suspend` calls - loses parallelism |
| **Event-driven (UI, callback)** | `suspend` functions or `callbackFlow` | Cleaner code, no callback hell | Wrapping in `thread` - blocks UI thread unnecessarily |

### Table 2: Thread vs Coroutine Resource Usage

| Resource Type | 1000 Threads | 1000 Coroutines | Winner |
|--------------|--------------|-----------------|--------|
| **Memory Stack** | 2-4 GB | < 1 MB | Coroutines |
| **Context Switch** | OS Kernel (slow) | User-space (fast) | Coroutines |
| **Creation Time** | ~10-20ms | ~0.1ms | Coroutines |
| **Blocking Behavior** | Blocks thread | Suspends, releases thread | Coroutines |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Hierarchy Diagram
```
[OS Threads (Limited: ~thousands)]
         |
[Thread Pool (Dispatchers)]
         |
[Coroutines (Unlimited: millions)]
         |
[Suspend Functions]
```

**Relationship Flow:**
```
Thread Pool (Dispatchers.IO) → 64 Threads
    └─> Coroutine 1: Runs → Suspend → Releases Thread → Resume on Thread 2
    └─> Coroutine 2: Runs → Suspend → Releases Thread → Resume on Thread 1
    └─> Coroutine 3...N: Same pattern, no thread allocation overhead
```

### Key Relationships
**Dispatcher = Thread Pool Manager**
- `Dispatchers.IO`: 64 threads for IO tasks
- `Dispatchers.Default`: CPU cores count threads for computation
- `Dispatchers.Main`: UI thread (Android/Desktop)

**CoroutineScope = Lifecycle Owner**
- Manages hierarchy of coroutines
- Parent cancels all children

**Structured Concurrency**
- Coroutines have parent-child relationships
- Parent dies → all children cancelled automatically

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Right Way - Heavy Load
**When to use (Khi nào dùng):**
When you need to execute many concurrent tasks (1000+) without crashing.

**Why this pattern is correct:**
Uses structured concurrency with proper scope and dispatcher, allowing massive concurrency.

```kotlin
suspend fun processBatch(ids: List<Int>) = coroutineScope {
    // Launch 50,000+ coroutines safely
    ids.map { id ->
        launch(Dispatchers.IO) {
            // Simulate IO work
            delay(100)
            println("Processed $id")
        }
    }.joinAll() // Wait for all to complete
}

// Usage in ViewModel or Repository
class MyRepository {
    suspend fun fetchData() {
        val ids = (1..50_000).toList()
        processBatch(ids)
    }
}
```

### Pattern 2: Wrong Way - Thread Explosion
**When NOT to use (Khi nào tránh):**
Never use this for high concurrency scenarios.

**Why wrong:**
Causes OOM error, resource exhaustion.

```kotlin
// ❌ NEVER DO THIS FOR SCALE
fun badPattern() {
    repeat(50_000) {
        thread { // Memory leak territory
            Thread.sleep(5000L)
            println(".")
        }
    }
}
```

### Pattern 3: Async Result Pattern
**When to use:**
Need to get results from multiple concurrent operations.

**Why correct:**
`async` returns `Deferred`, can `await` results concurrently.

```kotlin
suspend fun fetchMultipleData(): ResultData = coroutineScope {
    val user = async(Dispatchers.IO) { api.getUser() }
    val profile = async(Dispatchers.IO) { api.getProfile() }
    val posts = async(Dispatchers.IO) { api.getPosts() }
    
    ResultData(
        user = user.await(),
        profile = profile.await(),
        posts = posts.await()
    )
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern 1: GlobalScope Usage
**Dangerous Practice:**
```kotlin
GlobalScope.launch { // ❌ BAD
    delay(5000)
}
```
**Why dangerous (Tại sao nguy hiểm):**
- Không có parent → không tự động cancel khi app cần
- Không structured → memory leaks
- Không thể control lifecycle → zombie coroutines

### Anti-Pattern 2: Blocking in Coroutine
**Dangerous Practice:**
```kotlin
launch(Dispatchers.IO) {
    Thread.sleep(5000) // ❌ Blocks thread!
}
```
**Why dangerous:**
- Blocks IO thread, wastes thread pool capacity
- Use `delay()` instead to suspend without blocking

### Anti-Pattern 3: Thread Creation in Coroutines
**Dangerous Practice:**
```kotlin
launch {
    thread { // ❌ Creating threads defeats coroutine purpose
        heavyWork()
    }
}
```
**Why dangerous:**
- Defeats lightweight nature
- Creates unnecessary OS threads
- Use proper dispatcher instead

### Anti-Pattern 4: Not Using coroutineScope in Suspend Functions
**Dangerous Practice:**
```kotlin
suspend fun doWork() {
    launch { /* ... */ } // ❌ No scope, may leak
}
```
**Why dangerous:**
- Launch needs scope, compiler may use GlobalScope silently
- Use `suspend fun doWork() = coroutineScope { ... }`

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **IO Work → Dispatchers.IO** (API, DB, File)
2. **CPU Work → Dispatchers.Default** (Calculation, Processing)
3. **UI Work → Dispatchers.Main** (Update views)
4. **Never → Thread() for concurrency**
5. **Always → Structured concurrency with scope**
6. **Suspend → delay() not Thread.sleep()**

### Decision Logic (If-Else Style)
```
IF task_count > 1000 OR memory_sensitive:
    USE Coroutines
ELSE IF task_count < 10 AND simple:
    Thread() is OK but not preferred
ELSE:
    USE Coroutines
END

IF operation_type == "IO":
    dispatcher = Dispatchers.IO
ELSE IF operation_type == "CPU":
    dispatcher = Dispatchers.Default
ELSE IF operation_type == "UI":
    dispatcher = Dispatchers.Main
END

IF need_result_concurrently:
    USE async/await
ELSE:
    USE launch + joinAll
END
```

### Top 10 Things to Remember
1. **1M Coroutines < 1K Threads** in memory
2. **Suspend ≠ Block** - Thread is freed
3. **Structured Concurrency** = Parent controls children lifecycle
4. **GlobalScope = Memory Leak** in most cases
5. **delay()** is suspend, **Thread.sleep()** is blocking
6. **Dispatchers.IO** has 64 threads, **Default** has CPU cores
7. **launch** returns Job, **async** returns Deferred
8. **coroutineScope** builder ensures all children complete/cancel
9. **Thread()** in coroutine = anti-pattern
10. **1 Coroutine = 1 Stack Frame** (tiny), **1 Thread = 2MB+ Stack** (heavy)

<!-- CHUNK 61-61 -->

# DEVELOPER DECISION GUIDE: Kotlin Coroutines Basics

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

- **Coroutine (Tiến trình rút gọn)**: Một đơn vị thực thi lightweight, có thể tạm dừng và tiếp tục chạy. Không phải là luồng (thread).
- **Suspend Function (Hàm tạm dừng)**: Hàm có thể tạm dừng thực thi mà không block thread hiện tại. Chỉ được gọi từ coroutine hoặc hàm suspend khác.
- **Dispatcher (Bộ điều phối)**: Xác định thread nào coroutine sẽ chạy trên đó (Main, IO, Default).
- **Scope (Phạm vi)**: Bắt buộc lifecycle của coroutine. Quản lý việc hủy bỏ khi scope bị hủy.
- **Job (Nhiệm vụ)**: Đại diện cho một coroutine và có thể được quản lý (hủy, kiểm tra trạng thái).
- **Deferred (Tối thiểu)**: Một job có giá trị trả về (kết quả).

### Key Mental Models

1.  **Lightweight Threads**: Coroutines là các đơn vị thực thi siêu nhẹ. Bạn có thể tạo hàng ngàn coroutine trên một thread duy nhất mà không lo quá tải.
2.  **Suspend, Not Block**: Khi một hàm `suspend` được gọi, nó tạm dừng hoạt động của coroutine hiện tại và nhả thread để làm việc khác. Khi có kết quả, nó tiếp tục từ điểm dừng.
3.  **Structured Concurrency**: Một coroutine mới được khởi tạo trong một `Scope` cụ thể. Khi scope bị hủy, tất cả các con của nó cũng tự động bị hủy theo. Điều này tránh rò rỉ bộ nhớ.
4.  **Sequential by Default**: Code trong coroutine chạy tuần tự như code thông thường trừ khi bạn dùng các hàm khởi tạo song song (ví dụ: `async`).

### Why Better?

- **Không Callback Hell**: Viết code bất đồng bộ trông giống code đồng bộ, dễ đọc và dễ bảo trì.
- **An Toàn**: Cấu trúc có sẵn (`structured concurrency`) tự động quản lý lifecycle và tránh rò rỉ.
- **Linhh Hoạt**: Dễ dàng switch context (từ IO sang Main) với `withContext`.

---

## SECTION 2: DECISION TABLES

### When to use `launch` vs `async`

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cần thực thi tác vụ, không cần kết quả trả về | `launch` | Trả về `Job`. Chỉ để theo dõi hoặc hủy bỏ. Kiểu trả về `Unit`. | Dùng `async` nhưng không cần giá trị trả về -> Code khó hiểu, tạo `Deferred` thừa. |
| Cần thực thi tác vụ và cần kết quả trả về | `async` | Trả về `Deferred<T>`. Phải gọi `.await()` để lấy kết quả. | Quên gọi `.await()` -> Trả về `Deferred` thay vì giá trị thực tế. |
| Khởi tạo nhiều tác vụ song song | `launch` hoặc `async` (trong `coroutineScope`) | Kết hợp với `coroutineScope` để chờ tất cả hoàn thành hoặc hủy nếu có lỗi. | Dùng `launch` từng cái riêng lẻ mà không theo dõi `Job` -> Khó xử lý lỗi tập trung. |

### When to use `coroutineScope` vs ` supervisorScope`

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Một coroutine con lỗi -> Cancel cả group | `coroutineScope` | Tiêu chuẩn. Nếu một con lỗi, các anh em còn lại bị hủy theo (Fail-fast). | Dùng `coroutineScope` khi muốn các tác vụ độc lập (ví dụ: load 3 tab独立的 dữ liệu) -> Nếu 1 lỗi, cả 3 bị cancel. |
| Một coroutine con lỗi -> Không hủy anh em | `supervisorScope` | Nếu một con lỗi, chỉ con đó bị hủy. Các anh em tiếp tục chạy. | Dùng `supervisorScope` không đúng chỗ -> Tránh dùng cho root scope của UI vì khó xử lý lỗi lan truyền. |

### When to use Dispatcher

| Nên dùng gì | Khi nào dùng | Lý do |
| :--- | :--- | :--- |
| **`Dispatchers.Main`** | Cập nhật UI, gọi function UI. | Đảm bảo chạy trên Main Thread. Phải có nền tảng (Android/JavaFX). |
| **`Dispatchers.IO`** | Đọc/ghi file, network, database. | Designed cho tác vụ I/O blocking. Tái sử dụng thread linh hoạt. |
| **`Dispatchers.Default`** | CPU intensive (sorting, parsing, heavy calculation). | Tối ưu cho tác vụ CPU bound, số thread bằng số core CPU. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Flow

Coroutines có cấu trúc cây. Scope là người cha, Job là node con.

```text
GlobalScope (Top-level, không recommended)
└── activityScope (Scope của Activity)
    ├── Job 1 (launch) -> Fetch User
    │   └── Child Job (launch) -> Log debug
    ├── Job 2 (async) -> Fetch Data 1
    └── Job 3 (async) -> Fetch Data 2
```

**Quy tắc vàng:** Khi cha (Scope) bị hủy -> Hủy hết con (Job).

### Flow Data Stream

```text
Emitter (上游) -> Flow (冷流) -> Collector (下游)
```
- **Cold Stream (Cold Stream)**: Code trong Flow chỉ chạy khi có Collector (khi gọi `collect`).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Launch UI-Safe Coroutine
*Khi nào dùng:* Khi bạn ở trong UI layer (Activity/Fragment) và muốn gọi API hoặc xử lý dữ liệu rồi update UI.

*Tại sao đúng:* Switch sang IO để làm việc nặng, rồi switch về Main để update UI. Không block UI.

```kotlin
// Trong Activity hoặc ViewModel
fun loadUserData() {
    // CoroutineScope có sẵn (viewLifecycleOwner.lifecycleScope)
    lifecycleScope.launch {
        try {
            // Switch to IO (Main is free for UI)
            val user = withContext(Dispatchers.IO) {
                apiService.getUser()
            }
            // Switch back to Main automatically
            textView.text = user.name
        } catch (e: Exception) {
            // Handle error here (Main thread)
            showError(e.message)
        }
    }
}
```

### Pattern 2: Run Multiple Requests Parallel
*Khi nào dùng:* Khi cần fetch nhiều data độc lập và gộp lại (ví dụ: Profile + Settings).

*Tại sao đúng:* Dùng `async` để chạy song song, đợi tất cả bằng `awaitAll()` để tối ưu thời gian.

```kotlin
fun loadDashboard() {
    lifecycleScope.launch {
        val (profile, settings) = coroutineScope {
            val deferredProfile = async { api.getProfile() }
            val deferredSettings = async { api.getSettings() }
            // Wait for both
            deferredProfile.await() to deferredSettings.await()
        }
        // Or simpler:
        // val result = awaitAll(deferredProfile, deferredSettings)
        updateUI(profile, settings)
    }
}
```

### Pattern 3: Safe ViewModel Cancellation
*Khi nào dùng:* Luôn luôn dùng khi xử lý async trong ViewModel.

*Tài sao đúng:* `viewModelScope` tự động hủy coroutine khi ViewModel bị clear, tránh rò rỉ bộ nhớ.

```kotlin
class MyViewModel : ViewModel() {
    fun saveData() {
        viewModelScope.launch {
            // Dữ liệu sẽ không được lưu nếu người dùng đóng app đột ngột
            // hoặc xoá screen (tùy design)
            database.save(largeData) 
        }
    }
}
```

### Pattern 4: Sharing Flow (StateFlow/SharedFlow)
*Khi nào dùng:* Khi cần stream dữ liệu từ Repository tới UI (ví dụ: UserState).

*Tại sao đúng:* UICollects Flow. Logic business gọi các hàm suspend. Dùng `stateIn` để đảm bảo có giá trị mặc định.

```kotlin
class UserRepository {
    private val _userState = MutableStateFlow<User?>(null)
    val userState: StateFlow<User?> = _userState.asStateFlow()

    suspend fun fetchUser() {
        val user = api.getUser()
        _userState.value = user // Emit value
    }
}

// Trong UI (Fragment)
lifecycleScope.launch {
    userRepository.userState.collect { user ->
        // Update UI whenever user changes
        if (user != null) showContent(user)
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Blocking in Coroutine (Block trong Coroutine)**
    - *Cách sai:* `Thread.sleep()`, `readLine()` hoặc heavy calculation trực tiếp trong `Dispatchers.Main` hoặc `Default`.
    - *Tại sao nguy hiểm:* Dừng thread đó hoàn toàn. Nếu là Main Thread -> App freeze. Nếu là thread khác -> Phá vỡ cơ chế lightweight.
    - *Sửa:* Dung `delay()` thay cho `sleep`. Đưa IO blocking vào `Dispatchers.IO`.

2.  **GlobalScope (Global Scope)**
    - *Cách sai:* `GlobalScope.launch { ... }`
    - *Tại sao nguy hiểm:* Không được quản lý bởi lifecycle nào. Nếu Activity đóng, coroutine vẫn chạy nền tảng, gây rò rỉ và crash nếu cố update UI đã bị huỷ.
    - *Sửa:* Dùng `lifecycleScope`, `viewModelScope`, hoặc tạo scope tùy chỉnh bằng `CoroutineScope(Dispatchers.IO + Job())`.

3.  **Holding a Reference to Job (Giữ tham chiếu tới Job)**
    - *Cách sai:* Lưu `Job` vào global variable nhưng không huỷ nó khi cần.
    - *Tại sao nguy hiểm:* Gây rò rỉ nghiêm trọng.
    - *Sửa:* Dùng `coroutineScope` tự động quản lý, hoặc chỉ giữ `Job` trong scope hiện tại và gọi `job.cancel()` ở `onCleared()` hoặc `onDestroy()`.

4.  **Fire-and-Forget without Exception Handling (Bắn đi mà không xử lý lỗi)**
    - *Cách sai:* `launch { riskyWork() }` và không bắt exception.
    - *Tại sao nguy hiểm:* Exception sẽ bị nuốt hoặc crash app nếu không có parent catch.
    - *Sửa:* Luôn có `try-catch` trong block `launch` hoặc dùng `CoroutineExceptionHandler` cho các lỗi không mong muốn.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

1.  **Main:** UI update. **IO:** Network/Database. **Default:** CPU Math.
2.  **launch:** Không return. **async:** Return result (`await`).
3.  **GlobalScope:** NO. Use `viewModelScope` or `lifecycleScope`.
4.  **Suspend:** Không block thread, chỉ suspend coroutine.
5.  **Structured:** Scope cha quyết định lifecycle con.

### Decision Logic (If-Else)

```text
IF (Need Result from Background)
   -> async(Dispatchers.IO) { ... }.await()

ELSE IF (Just run Background Task)
   -> launch(Dispatchers.IO) { ... }

ELSE IF (Update UI after Background)
   -> withContext(Dispatchers.Main) { update() }

IF (Scope is Activity/Fragment)
   -> use lifecycleScope

IF (Scope is ViewModel)
   -> use viewModelScope
```

### Top 10 Things to Remember

1.  **Suspend** là non-blocking.
2.  **Launch** là fire-and-forget.
3.  **Async** là để lấy giá trị.
4.  **IO** là cho network/file.
5.  **Default** là cho CPU work.
6.  **Main** là cho UI.
7.  **Scope** quản lý lifecycle.
8.  **Job** quản lý cancellation.
9.  **Timeout** dùng `withTimeout`.
10. **Retry** logic dùng `retry` block hoặc vòng lặp.