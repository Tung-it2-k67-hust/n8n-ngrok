# DEVELOPER DECISION GUIDE: Kotlin_Coroutines_Basics.pdf\n\n> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 16:22:40\n\n\n\n<!-- CHUNK 1-10 -->\n\n# DEVELOPER DECISION GUIDE: Kotlin Coroutines Basics

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Concurrency vs. Parallelism:**
Coroutines enable concurrency (multiple tasks making progress at once). On JVM/Native, they run on OS threads. A coroutine can **suspend** execution instead of blocking the thread, allowing other coroutines to run on that same thread.

**Suspending Function (`suspend`):**
The fundamental building block. It represents a computation that can pause and resume.
- **Rule:** Can only be called from another `suspend` function or a coroutine scope.
- **Superpower:** Pausing execution frees up the thread for other work while waiting (e.g., for data).

--------------------------------
SECTION 2: DECISION TABLES (VERY IMPORTANT)
--------------------------------

| Use Case | Should use | Why | Common Mistake |
| :--- | :--- | :--- | :--- |
| **Entry Point** | `suspend fun main()` | Allows calling `suspend` functions directly at the application start. | Using `fun main()` without `suspend` leads to "Suspend function '...' should be called only from a coroutine" error. |
| **Defining Operation** | `suspend fun` | Marks a function as non-blocking and capable of suspending execution. | Treating `suspend` as just "blocking but async". It implies cooperative cancellation and thread sharing. |
| **Running Logic** | `kotlinx.coroutines` library | Provides essential builders (`launch`, `async`) and context (`Dispatchers`, `Scope`). | Trying to manage concurrency manually using threads and callbacks instead of structured concurrency. |

--------------------------------
SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE
--------------------------------

**Required Components to Launch a Coroutine:**
1.  **Suspending Function:** The logic to execute.
2.  **Coroutine Scope:** Defines the lifecycle and context (e.g., `GlobalScope`, or a lifecycle-specific scope like in Android).
3.  **Builder:** The mechanism to start the coroutine (`launch`, `async`).
4.  **Dispatcher:** Controls the thread pool (e.g., `Dispatchers.Main`, `Dispatchers.IO`).

**Hierarchy:**
`Scope` (Manages lifecycle) -> `Builder` (Starts execution) -> `Dispatcher` (Assigns thread) -> `Suspend Function` (The code).

--------------------------------
SECTION 4: CODE PATTERNS (EXAM-READY)
--------------------------------

### Pattern 1: Sequential Suspending Calls
**When to use:** When you need to perform multiple operations one after another, where each depends on the previous result or involves I/O waiting.

**Why this pattern is correct:**
Using `suspend` functions allows the code to read like synchronous code (sequential style) while actually yielding the thread during I/O waits. This avoids "callback hell."

**Code Example:**
```kotlin
suspend fun showUserInfo() {
    println("Loading user...")
    greet() // Suspends execution here if needed, but non-blocking
    println("User: John Smith")
}

suspend fun greet() {
    println("Hello world from a suspending function")
}

suspend fun main() {
    showUserInfo()
}
```

### Pattern 2: Adding the Library
**When to use:** Every time you need to launch coroutines (use builders like `launch` or `async`).

**Why this pattern is correct:**
Core language provides `suspend` keyword, but the `kotlinx.coroutines` library provides the runtime and tools to actually execute them.

**Code Example (Gradle KTS):**
```kotlin
// build.gradle.kts
repositories {
    mavenCentral()
}
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2")
}
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

*   **Blocking inside `suspend`:** Never call blocking I/O (e.g., `Thread.sleep`, heavy database calls) directly in a `suspend` function without wrapping it or using the correct Dispatcher (like `Dispatchers.IO`). It freezes the thread and hurts performance.
*   **`GlobalScope`:** Avoid using `GlobalScope` (not explicitly in text but implied by "Scope" requirement). It creates coroutines that are not bound to any lifecycle, leading to memory leaks if the app closes while they run.
*   **Thread Blocking:** Relying on `Thread.sleep()` or manual locking defeats the purpose of using coroutines.

--------------------------------
SECTION 6: ONE-PAGE CHEAT SHEET ITEMS
--------------------------------

**Syntax & Keywords:**
*   `suspend fun name()`: Declares a suspending function.
*   `suspend fun main()`: Entry point for coroutine-enabled command line apps.

**Dependencies:**
*   Group: `org.jetbrains.kotlinx`
*   Artifact: `kotlinx-coroutines-core`
*   Check version: `1.10.2` (or latest).

**Execution Flow:**
1.  Define logic in `suspend` functions.
2.  Call from a `CoroutineScope` using a builder (`launch`/`async`).
3.  Library handles threading/suspension automatically.\n\n<!-- CHUNK 11-20 -->\n\n# Developer Decision Guide: Kotlin Coroutines - Execution & Dispatchers

## SECTION 1: CORE MENTAL MODEL

**`suspend` functions**: Đánh dấu hàm có thể "tạm dừng" (pause) và "tiếp tục" (resume) sau đó mà không block thread. Giữ nguyên thread khi không cần thiết.

**`withContext(Dispatchers.Default)`**:
- Là entry point không blocking cho code concurrent.
- Chuyển đổi luồng thực thi (context switching) vào một thread pool chung.
- **Thread pool**: Tối đa số CPU cores, tối thiểu 2 threads.
- Các coroutines con bên trong sẻ **chia sẻ chung scope** (structured concurrency).

**Non-blocking vs Blocking**:
- **Blocking (Cổ điển)**: Thread bị giữ nguyên và chờ (ví dụ: `Thread.sleep()`).
- **Suspending (Coroutines)**: Thread được giải phóng để làm việc khác, sau đó quay lại khi task xong (ví dụ: `delay()`).

**Execution Flow**:
1. `withContext` lấy thread từ pool và bắt đầu block code.
2. `launch` tạo coroutine con chạy **song song** ngay trong scope đó.
3. Khi gặp `delay()`, coroutine tạm dừng, nhả thread về pool.
4. Thread pool có thể dùng lại thread đó cho coroutine khác hoặc task khác.

## SECTION 2: DECISION TABLES

| Use Case | Should use | Why | Common Mistake |
| :--- | :--- | :--- | :--- |
| **Chạy code block suspend trong `main` (App Android/Kotlin JVM)** | `suspend main()` hoặc `fun main() = runBlocking{...}` | Tránh lỗi compile. `suspend main` là entry point chuẩn của Coroutines. | Dùng `runBlocking` khi không cần thiết (cần bridge với blocking code). |
| **Chạy code suspend từ non-suspend code (Java main, legacy)** | `runBlocking { ... }` | Chuyển đổi thế giới blocking sang suspending. Blocking current thread直到coroutine xong. | Quên `runBlocking` khi gọi suspend func từ hàm thường. |
| **Chạy coroutine con, không cần return value** | `scope.launch { ... }` | Fire-and-forget. Chạy song song. | Dùng `async` khi không cần result (lãng phí resource tạo Deferred). |
| **Chạy coroutine con, cần return value** | `scope.async { ... }` | Trả về `Deferred<T>`, sau đó dùng `.await()` để lấy kết quả. | Dùng `launch` + global variable để trả kết quả (không an toàn, không track được). |
| **Chạy code trên Thread Pool đa luồng** | `withContext(Dispatchers.Default)` | Tối ưu cho CPU-intensive tasks (tính toán nặng). | Dùng `Dispatchers.IO` cho CPU-bound tasks (lãng phí thread). |
| **Chạy I/O operations (Network, DB, File)** | `withContext(Dispatchers.IO)` | Tối ưu cho blocking I/O. Pool size lớn (64 threads hoặc tối đa). | Dùng `Dispatchers.Default` cho I/O blocking (cản trở tính toán). |

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

**Hierarchy & Context:**

```
[Process / JVM]
└── [Main Thread (UI/Update)]
    └── suspend fun main() OR runBlocking { ... }
        └── withContext(Dispatchers.Default) { // this: CoroutineScope
              └── [CPU Thread Pool (Min 2, Max Cores)]
                  ├── this.launch { ... }   // Child Job 1
                  ├── this.launch { ... }   // Child Job 2
                  └── this.async { ... }    // Child Job 3 (Returns Deferred)
            }
```

**Quan trọng:**
- `this` bên trong `withContext` là một `CoroutineScope`.
- `this.launch` tạo job con. Nếu scope bị hủy (lỗi hoặc huỷ), tất cả children con đều tự động bị huỷ (Structured Concurrency).
- `withContext` là suspend function, nên nó có thể được gọi bên trong các scope khác.

## SECTION 4: CODE PATTERNS

### Pattern 1: Basic Multi-Coroutine Execution (CPU Intensive)

**Khi nào dùng:**
Khi cần thực thi nhiều tác vụ tính toán nặng hoặc xử lý dữ liệu parallel trên CPU.

**Lý do:**
Tận dụng tối đa thread pool của `Dispatchers.Default`. Coroutines chạy song song, không blocked thread chính.

```kotlin
import kotlinx.coroutines.*
import kotlin.time.Duration.Companion.seconds

suspend fun processData(id: Int) {
    println("Start processing $id on thread: ${Thread.currentThread().name}")
    delay(1.seconds) // Simulates waiting for CPU/Calculation
    println("End processing $id on thread: ${Thread.currentThread().name}")
}

suspend fun main() {
    // Entry point: Non-blocking, uses CPU thread pool
    withContext(Dispatchers.Default) { 
        // this: CoroutineScope
        
        // Launch 3 coroutines concurrently
        launch { processData(1) }
        launch { processData(2) }
        launch { processData(3) }
        
        println("Main logic continues immediately...")
    } // Waits here until all launched coroutines are complete
}
```

### Pattern 2: Running Suspend from Legacy Code

**Khi nào dùng:**
Khi bạn ở trong một hàm `main` java-style (không phải `suspend main`) nhưng cần gọi API suspend.

**Lý do:**
`runBlocking` đóng vai trò cầu nối, block thread hiện tại (thường là main thread) cho đến khi khối code bên trong hoàn thành.

```kotlin
fun main() { // Not suspend
    // Bridge blocking world <-> suspending world
    runBlocking {
        // Inside here, we can call suspend functions
        greet()
    }
}

suspend fun greet() {
    delay(1000L)
    println("Hello from suspend!")
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Dùng `Thread.sleep()` trong `suspend` function:**
- **Tại sao sai:** Nó sẽ block toàn bộ thread, preventing coroutines khác trong cùng pool chạy.
- **Thay thế:** Luôn dùng `delay()` (non-blocking suspension).

**2. Bỏ qua `runBlocking` trong `main`:**
- Compile error nếu gọi suspend function từ hàm thường (trừ `suspend main`).

**3. Lạm dụng `GlobalScope`:**
- `GlobalScope.launch { ... }` tạo coroutines "lưu lượng" (detached). Không có structured concurrency.
- **Lỗi:** Nếu app crash hoặc logic huỷ, coroutines này vẫn chạy ngầm gây rò rỉ bộ nhớ.
- **Đúng:** Luôn dùng scope có sẵn (ví dụ: `CoroutineScope(Dispatchers.Default)` hoặc scope của component).

**4.混淆 Dispatchers:**
- Dùng `Dispatchers.Default` cho việc đọc file/network (blocking I/O) -> Làm chậm cả pool tính toán.
- Dùng `Dispatchers.IO` cho tính toán phức tạp -> Lãng phí thread pool.

## SECTION 6: ONE-PAGE CHEAT SHEET

**Setup & Entry:**
```kotlin
import kotlinx.coroutines.*
```

**Suspending:**
- `suspend fun foo()`: Hàm có thể pause/resume.
- `delay(time)`: Non-blocking wait. Dùng thay cho `Thread.sleep()`.

**Execution:**
- **Single Thread Main:** `runBlocking { ... }` (Bridge).
- **Parallel CPU:** `withContext(Dispatchers.Default) { ... }`.
- **I/O Operations:** `withContext(Dispatchers.IO) { ... }`.

**Builders:**
- `launch`: Fire-and-forget, `Job`. (Returns `Job`).
- `async`: Compute value, `Deferred`. (Returns `Deferred<T>`). Use `.await()`.

**Scope Management:**
- Use `this.launch` inside a scope for structured concurrency.
- **Rule:** Parent scope cancels -> All children cancel automatically.

**Dispatchers Cheat:**
- `Dispatchers.Main`: UI updates.
- `Dispatchers.Default`: CPU work (Calculation, loops).
- `Dispatchers.IO`: Input/Output (Network, DB, Files).\n\n<!-- CHUNK 21-30 -->\n\n# Cheat Sheet: Kotlin Coroutines – Structured Concurrency & Scopes

## SECTION 1: CORE MENTAL MODEL

### Structured Concurrency
- **Concept**: Coroutines form a **parent-child tree hierarchy** with linked lifecycles.
- **Rule**: Parent waits for all children to complete. If parent fails/cancels, all children are recursively cancelled.
- **Benefit**: Predictable cancellation and error handling (no leaks).
- **Requirement**: New coroutines can only be launched inside a `CoroutineScope`.

### Coroutine Lifecycle
- Sequence of states: Creation → Completion, Failure, or Cancellation.
- Managed by the scope in which they are launched.

### `coroutineScope()` vs `CoroutineScope`
- **`coroutineScope()`**: Function that creates a **new scope** within a suspend function. Inherits context from the caller. Waits for all children to complete.
- **`CoroutineScope`**: Interface/Receiver context that provides the ability to launch new coroutines (`launch`, `async`).

---

## SECTION 2: DECISION TABLES

| Use Case | Should Use | Why | Common Mistake |
| :--- | :--- | :--- | :--- |
| **Managing a group of related tasks** | `coroutineScope { ... }` | Creates a strictly scoped block. Fails fast if any child fails. Waits for all children. | Forgetting `coroutineScope`, leading to "fire-and-forget" behavior where errors might be swallowed or scope is lost. |
| **Launching a child coroutine inside a scope** | `this.launch { ... }` or `launch { ... }` | `launch` is an extension function on `CoroutineScope`. Requires a receiver context to function. | Calling `launch` without a `CoroutineScope` receiver (e.g., in a regular function) causes compilation error. |
| **Debugging coroutine execution** | VM Option: `-Dkotlinx.coroutines.debug` | Adds coroutine names to thread names in logs. Without this, threads are reused and hard to trace. | Relying on default thread names, making concurrency issues invisible. |
| **Defining lifecycle for a class** | `class MyViewModel : CoroutineScope by ...` | Explicitly ties coroutines to a component's lifecycle (e.g., `viewModelScope`). | Launching coroutines in global scope (`GlobalScope`) inside classes, causing leaks. |

---

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

### Hierarchy & Relationships

1.  **Root**: `suspend fun main()` or a `CoroutineScope`.
2.  **Scope Creator**: `coroutineScope { ... }` (creates a child scope of the current context).
3.  **Builders**: `launch` / `async` (extension functions on `CoroutineScope`).
4.  **Inheritance**: Builders inside a block inherit the block's context (dispatcher, Job, etc.).

**Structure:**
```text
Root Scope
  └── coroutineScope { ... }  <-- Defines lifecycle boundary
        ├── launch { ... }    <-- Child 1
        │    └── launch { ... } <-- Grandchild 1
        └── launch { ... }    <-- Child 2
```

---

## SECTION 4: CODE PATTERNS (EXAM-READY)

### Pattern 1: Defining a Strict Lifecycle Boundary

**When to use (Vietnamese):**
Khi bạn cần thực hiện nhiều tác vụ bất đồng bộ và muốn đảm bảo tất cả đều hoàn thành (hoặc bị huỷ theo chùm) trước khi continuation tiếp theo được thực thi.

**Why this pattern is correct:**
`coroutineScope` chờ tất cả children hoàn thành. Nếu một trẻ thất bại, nó ném ra异常 và huỷ các trẻ còn lại (Cancellation Propagation).

**Code:**
```kotlin
suspend fun performTask() {
    // Scope mới được tạo tại đây
    coroutineScope { 
        launch { delay(1000); println("Task 1") }
        launch { delay(500); println("Task 2") }
    }
    // Dòng này chỉ chạy khi cả 2 task trên xong
    println("Scope finished, safe to proceed")
}
```

### Pattern 2: Launching from a Receiver Scope

**When to use (Vietnamese):**
Khi viết một hàm mở rộng (extension function) hoặc một class có sẵn `CoroutineScope` và cần tạo ra các coroutines con.

**Why this pattern is correct:**
`launch` là `extension function` của `CoroutineScope`. Phải có `this` (receiver) để biết context nào (Dispatcher, Job) sẽ được kế thừa.

**Code:**
```kotlin
// 'this' là CoroutineScope được inject vào
fun CoroutineScope.startWorkers() {
    this.launch { /* worker 1 */ } 
    launch { /* worker 2 - 'this' là mặc định */ }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern | Why it's dangerous | Fix |
| :--- | :--- | :--- |
| **Missing `coroutineScope`** | Logic sau scope không chờ các coroutines con. Lỗi trong child có thể bị bỏ qua nếu bắt trong try-catch sai chỗ. | Wrap logic chứa `launch` vào `coroutineScope`. |
| **`launch` không có scope** | Code không biên dịch được hoặc treo vĩnh viễn nếu không có scope để đăng ký job. | Đảm bảo gọi `launch` trong block lambda có receiver `CoroutineScope`. |
| **Quên Debug Flag** | Khó khăn trong việc truy vết lỗi race condition hay nhìn rõ tên Coroutine trên Thread. | Thêm `-Dkotlinx.coroutines.debug` vào run configuration. |

---

## SECTION 6: ONE-PAGE CHEAT SHEET ITEMS

*   **Enable Debug**: Run with `-Dkotlinx.coroutines.debug`.
*   **Structured Concurrency**: Parent dies -> Children die.
*   **`coroutineScope`**: Waits for all children. Fails if any child fails.
*   **`launch`**: Extension on `CoroutineScope`.
*   **Inheritance**: Builders inherit Context (Dispatcher/Job) from the scope they are called in.\n\n<!-- CHUNK 31-40 -->\n\n# Kotlin Coroutines: Builders & Scope Decision Guide

---

## SECTION 1: CORE MENTAL MODEL

### What are Coroutine Builders?
Hàm tạo coroutine là hàm nhận một **suspend lambda** để định nghĩa công việc.
Mỗi builder định nghĩa cách coroutine bắt đầu và cách bạn tương tác với kết quả.

### Scope Receiver Model
- `coroutineScope { }` cung cấp receiver là `CoroutineScope`.
- Các builder `launch`, `async` là **extension functions** trên `CoroutineScope`.
- Để trích xuất builder ra hàm riêng, hàm đó phải khai báo `CoroutineScope` receiver.

---

## SECTION 2: DECISION TABLES

### When to use `launch` vs `async`

| Use case | Should use | Why | Common mistake |
|----------|------------|-----|----------------|
| Fire-and-forget task<br>Result không cần thiết | `CoroutineScope.launch()` | Không blocking scope.<br>Tiếp tục work khác mà không cần await. | Await kết quả hoặc bắt lỗi với `try/catch` thay vì `invokeOnCompletion`. |
| Task cần return kết quả | `CoroutineScope.async()` | Return `Deferred`.<br>Phải dùng `.await()` để lấy giá trị. | Dùng `launch` rồi cố gắng return giá trị trực tiếp. |
| Chạy coroutine từ suspend function<br>không có scope rõ ràng | `coroutineScope()` | Tạo scope mới, chờ tất cả child hoàn thành.<br>Khi lỗi, cancel tất cả child. | Quên dùng `coroutineScope` mà gọi trực tiếp `launch` trong suspend function. |

---

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

### Relationship Hierarchy
```
CoroutineScope (Receiver)
├── .launch()  → Job (no result)
├── .async()   → Deferred<T> (with result)
└── coroutineScope() → Creates new scope, waits for children
```

### Key Rules
- **Scope Requirement**: Cả `launch` và `async` đều cần `CoroutineScope` để chạy.
- **Scope Creation**:
  - `coroutineScope()`: Dùng trong suspend function để tạo scope mới.
  - `runBlocking()`: Dùng cho main function hoặc test (blocking thread).
  - `withContext()`: Dùng để switch context, return result.
- **Extracting Builders**: Nếu trích xuất builder ra hàm riêng, hàm đó **phải** là extension trên `CoroutineScope`:
  ```kotlin
  fun CoroutineScope.launchAll() { // this: CoroutineScope
      this.launch { ... }
  }
  ```

---

## SECTION 4: CODE PATTERNS (EXAM-READY)

### Pattern 1: Fire-and-Forget with Launch
**When to use (Vietnamese):** Khi cần chạy task background và không cần đợi kết quả.

**Why this pattern is correct:**
- `launch` chạy concurrent, không blocking scope hiện tại.
- Scope tiếp tục work khác trong khi coroutine chạy ở background.

**Code Example:**
```kotlin
suspend fun performBackgroundWork() = coroutineScope {
    this.launch {
        delay(100)
        println("Sending notification in background")
    }
    println("Scope continues")
}
// Output: Scope continues -> Sending notification in background
```

### Pattern 2: Parallel Execution with Async
**When to use (Vietnamese):** Khi cần chạy nhiều task song song và đợi tất cả kết quả.

**Why this pattern is correct:**
- `async` return `Deferred`, cho phép await kết quả.
- Multiple `async` chạy parallel, không blocking lẫn nhau.

**Code Example:**
```kotlin
suspend fun main() = withContext(Dispatchers.Default) {
    val firstPage = async {
        delay(50)
        "First page"
    }
    val secondPage = async {
        delay(100)
        "Second page"
    }
    val pagesAreEqual = firstPage.await() == secondPage.await()
    println("Pages are equal: $pagesAreEqual")
}
```

### Pattern 3: Extracting Builders to Helper Functions
**When to use (Vietnamese):** Khi cần tái sử dụng logic launch/async trong nhiều nơi.

**Why this pattern is correct:**
- Hàm helper phải là extension trên `CoroutineScope` để truy cập builder.
- Đảm bảo scope receiver được truyền đúng cách.

**Code Example:**
```kotlin
fun CoroutineScope.launchAll() {
    this.launch { println("1") }
    this.launch { println("2") }
}

suspend fun main() {
    coroutineScope {
        launchAll()
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### ❌ Dùng builder mà không có Scope
- **Lỗi**: Gọi `launch` hoặc `async` trong suspend function mà không có `coroutineScope`.
- **Hậu quả**: Compile error, không xác định được scope.

### ❌ Await trong launch
- **Lỗi**: Gọi `await()` trên result của `launch` (vì `launch` return `Job`, không phải `Deferred`).
- **Hậu quả**: Compile error.

### ❌ Trích xuất builder không đúng signature
- **Lỗi**: Định nghĩa hàm helper không có `CoroutineScope` receiver.
- **Ví dụ sai**:
  ```kotlin
  fun launchAll() { launch { ... } } // Compile error
  ```
- **Sửa đúng**:
  ```kotlin
  fun CoroutineScope.launchAll() { this.launch { ... } }
  ```

### ⚠️ Quên await async
- **Cảnh báo**: Không gọi `await()` trên `Deferred` → kết quả không được xử lý, có thể silent failure.

---

## SECTION 6: ONE-PAGE CHEAT SHEET ITEMS

### Builder Summary
- `CoroutineScope.launch()`: Fire-and-forget, return `Job`.
- `CoroutineScope.async()`: Compute result, return `Deferred<T>`.
- `coroutineScope()`: Tạo scope mới, wait for children, cần suspend context.

### Scope Rules
- Builders là extension functions trên `CoroutineScope`.
- Helper functions cần `CoroutineScope` receiver để dùng builder.
- `suspend fun main()` có thể dùng `coroutineScope()` hoặc `withContext()` để tạo scope.

### Usage Checklist
- [ ] Cần result? → Dùng `async` + `await()`.
- [ ] Fire-and-forget? → Dùng `launch`.
- [ ] Extracting to function? → Hàm phải là `fun CoroutineScope.____()`.
- [ ] Run from suspend? → Dùng `coroutineScope { }` hoặc `withContext()`.\n\n<!-- CHUNK 41-50 -->\n\n# Kotlin Coroutines: runBlocking & Dispatchers

## SECTION 1: CORE MENTAL MODEL

**runBlocking**
- Tạo một coroutine scope và **block** thread hiện tại (sync wait) cho đến khi tất cả coroutine trong scope đó hoàn thành.
- Khác với `suspend` functions: `runBlocking` là bridge từ non-suspending sang suspending code.

**Coroutine Dispatchers**
- Chịu trách nhiệm xác định **thread nào (hoặc thread pool nào)** sẽ thực thi coroutine.
- Cho phép coroutine **tạm dừng (suspend)** ở thread này và **tiếp tục (resume)** ở thread khác mà state vẫn được giữ nguyên (concurrency transparency).
- Scope controls lifecycle; Dispatcher controls execution context.

## SECTION 2: DECISION TABLES

### runBlocking vs suspend functions vs launch/async

| Use case | Should use | Why | Common mistake |
| :--- | :--- | :--- | :--- |
| Gọi code suspending từ **non-suspending** code (main, tests, hoặc interface第三方 không sửa được) | `runBlocking { ... }` | Block thread chờ kết quả, bridge giữa blocking world và suspending world. | Lạm dụng `runBlocking` trong `suspend` function hoặc trong CoroutineScope (gây blocking không cần thiết). |
| Thực thi logic suspending trong scope hiện tại | `suspend fun` hoặc `coroutineScope { ... }` | Dễ compose, không block thread, respects structured concurrency. | Dùng `runBlocking` bên trong `suspend` function. |

### Dispatchers Selection

| Use case | Should use | Why | Common mistake |
| :--- | :--- | :--- | :--- |
| CPU-intensive work (calculation, data processing) | `Dispatchers.Default` | Shared pool of threads (size = CPU cores), tối ưu tài nguyên CPU. | Dùng `Dispatchers.Main` gây blocked UI. |
| UI updates, lightweight tasks | `Dispatchers.Main` | Đảm bảo chạy trên Main Thread (Android, JavaFX). | Chạy heavy work trên Main dispatcher. |
| Switching context tạm thời (IO bound hoặc chuyển sang Default) | `withContext(Dispatcher)` | Wrapper an toàn, tự động switch thread và quay về context cũ. | Quên `withContext`导致 race condition hoặc block thread. |

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

**Relationship: Scope và Dispatcher**

- **Parent Scope**: Cung cấp `CoroutineContext` (bao gồm `Job`, `CoroutineName`, `Dispatcher`).
- **Inheritance**: Coroutine con inherit dispatcher từ scope cha nếu không chỉ định explicitly.
- **Override**: Truyền dispatcher vào builder (`.launch(Dispatchers.Default)`) sẽ ghi đè context của scope.

```text
Parent Scope (e.g., MainScope)
   └─ Context: [MainScope, MainDispatcher]
       ├─ launch(Dispatchers.Default)  // Overrides Dispatcher
       └─ launch { ... }               // Inherits MainDispatcher
```

**Syntax:**
1. `launch` (trả về `Job`): "Fire and forget", không trả giá trị.
2. `async` (trả về `Deferred`): Cần kết quả, gọi `.await()` để lấy giá trị.
3. `withContext`: Dùng để chuyển đổi dispatcher cho block code con, trả về kết quả của block.

## SECTION 4: CODE PATTERNS

### Pattern 1: Repository Bridge Pattern
*Use `runBlocking` to implement a blocking interface method by calling a suspending function.*

**When to use:**
- Implementing interface của thư viện第三方 mà không có suspending methods.
- Code logic là suspending (delay, network), nhưng API bắt buộc phải blocking return.

**Why:**
- Giữ logic async (không blocked thread loop chính), nhưng đóng gói thành sync call cho caller.

```kotlin
interface Repository {
    fun readItem(): Int // Blocking signature
}

object MyRepository : Repository {
    override fun readItem(): Int =
        runBlocking { // Bridge
            myReadItem()
        }
}

suspend fun myReadItem(): Int {
    delay(100) // Suspends
    return 4
}
```

### Pattern 2: `withContext` for Thread Switching
*Use `withContext` to perform work in a specific dispatcher and return value.*

**When to use:**
- Chuyển từ Main sang Default để tính toán CPU-heavy.
- Chuyển sang IO để truy cập DB/Network.

**Why:**
- Rút gọn code so với `launch { ... }.join()` hay `async { ... }.await()`.
- Scoped: tự động quản lý lifecycle và cleanup.

```kotlin
suspend fun performCalculation() = withContext(Dispatchers.Default) {
    println("Running on ${Thread.currentThread().name}")
    val result = (1L..1_000_000L).sum()
    result // Implicit return
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Blocking the Main Thread with `runBlocking` in UI code:**
    - Gây froze UI, ANR (Application Not Responding).
    - *Sửa*: Dùng `lifecycleScope.launch` hoặc `GlobalScope.launch(Dispatchers.Main)`.

2.  **Using `runBlocking` inside a `suspend` function:**
    - Gây deadlock tiềm năng hoặc blocked thread không cần thiết.
    - *Sửa*: Dùng `coroutineScope` hoặc `suspend` functions trực tiếp.

3.  **Not specifying dispatcher for CPU-intensive work:**
    - Nếu không chỉ định, coroutine có thể chạy trên `Dispatchers.Main` (nếu scope là Main) hoặc `Default` (nếu global), nhưng việc explicit giúp code rõ ràng.
    - *Lưu ý*: Nếu code chạy trong `runBlocking`, mặc định là `Dispatchers.Default` nhưng thread hiện tại bị blocked.

## SECTION 6: ONE-PAGE CHEAT SHEET

**runBlocking**
- Syntax: `runBlocking { ... }`
- Blocks current thread.
- Use ONLY for bridging non-suspending to suspending (main/test/legacy).

**Dispatchers**
- `Dispatchers.Main`: UI, update view.
- `Dispatchers.Default`: CPU work (calculate, list processing).
- `Dispatchers.IO`: Blocking I/O (network, disk).

**withContext**
- Syntax: `withContext(Dispatcher) { ... }`
- Use for: Switching thread safely inside a suspend function.
- Returns result of the block.\n\n<!-- CHUNK 51-60 -->\n\n# KOTLIN COROUTINES: JVM THREADS VS COROUTINES

## SECTION 1: CORE MENTAL MODEL

**Coroutines vs. JVM Threads: The Resource Model**

*   **JVM Thread:** A heavy, OS-managed execution unit.
    *   **Mental Model:** A dedicated worker with a personal, large workspace (stack).
    *   **Execution:** Tied to a CPU core. Switching is an OS-level, expensive operation (context switch).
    *   **Cost:** High memory (megabytes per thread), high creation overhead. Limited by OS, typically thousands per process.

*   **Coroutine:** A light, developer-managed, suspendable computation.
    *   **Mental Model:** A task that can be paused and resumed, floating on a pool of workers (threads).
    *   **Execution:** Not tied to a thread. When suspended, it detaches, freeing the thread for other work. Resumption can be on a completely different thread.
    *   **Cost:** Negligible memory (bytes per coroutine), near-instant creation. Millions can run in one process.

**Key Takeaway:** Threads manage parallelism (CPU work). Coroutines manage concurrency (waiting for work). Coroutines multiplex thousands of tasks onto a handful of threads.

---

## SECTION 2: DECISION TABLES

### Coroutines vs. Threads

| Use Case | Should use | Why | Common Mistake |
| :--- | :--- | :--- | :--- |
| **High-concurrency I/O tasks** (e.g., 10,000 network requests) | **Coroutines** | Extreme scalability with minimal resource usage. Threads would exhaust memory. | Using `thread {}` builder for a large, unknown number of concurrent tasks. |
| **CPU-bound, parallel processing** (e.g., parallel image processing) | **Threads (or `Dispatchers.Default`)** | Raw CPU power is needed. `Dispatchers.Default` uses a thread pool sized to CPU cores, but `launch` still manages them as coroutines. | Forgetting that coroutines are not magic; CPU-heavy work still consumes CPU resources. |
| **Simple, one-off background task** | **Either** | `thread {}` is simple for Java interop. `launch(Dispatchers.IO)` is idiomatic Kotlin for async tasks. | Using `GlobalScope.launch` instead of structured concurrency within a `CoroutineScope`. |
| **Maintaining state across suspensions** | **Coroutines** | State is preserved naturally within the coroutine's stack frame across suspension points. | Manually passing state objects between threads (`ThreadLocal`), which is complex and error-prone. |

---

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

*   **`launch` / `async` Builders:** These are extensions on `CoroutineScope`. They *create* a coroutine.
*   **`coroutineScope`:** This is a function that *creates* a scope for a block of code. It ensures all coroutines launched within it complete before the block finishes.
*   **Hierarchy:** Parent Scope -> `launch` -> Child Coroutine. The parent scope's lifecycle dictates the children's lifecycle. If the parent is cancelled, all children are cancelled.

```kotlin
// Parent scope (e.g., from a ViewModel or lifecycle)
suspend fun loadData() = coroutineScope { // Creates a scope
    // Child coroutines
    val user = launch { fetchUser() } // Launched in the scope
    val data = launch { fetchData() } // Launched in the scope
    // The coroutineScope function waits here until both children are complete.
}
```

---

## SECTION 4: CODE PATTERNS (EXAM-READY)

### Pattern: Massive Concurrency

*   **When to use:** When you need to perform a very large number of tasks (10,000+) that involve waiting (I/O, delays), such as fetching data for many items in a list.
*   **Why this pattern is correct:** It leverages the lightweight nature of coroutines. Creating 50,000 threads would crash the application, but 50,000 coroutines run flawlessly on a small thread pool managed by dispatchers.
*   **Code Example:**

```kotlin
import kotlinx.coroutines.*
import kotlin.time.Duration.Companion.seconds

// Suspend function that simulates a large number of concurrent tasks
suspend fun processManyItems() = coroutineScope {
    // Launch 50,000 independent tasks
    repeat(50_000) {
        launch {
            // Simulate a 5-second blocking operation (e.g., network call)
            delay(5.seconds)
            // Print a dot to show completion
            print(".")
        }
    }
    // The function will not complete until all 50,000 launched coroutines finish.
}

// Main function to run it (ensure you have a coroutine context)
fun main() = runBlocking {
    processManyItems()
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

*   **⚠️ Spawning Unstructured Threads:** Using `thread { ... }` for a large or dynamic number of concurrent tasks. This is a direct path to `OutOfMemoryError`.
*   **⚠️ Ignoring Coroutine Scopes:** Launching coroutines from `GlobalScope` instead of a specific scope (like `viewModelScope` or `lifecycleScope` in Android, or a custom scope). This creates "fire-and-forget" tasks that are not tied to any lifecycle and cannot be cancelled properly, leading to leaks.
*   **⚠️ Treating Coroutines as Threads:** Believing that a coroutine will stay on the same thread for its entire lifetime. This leads to writing thread-unsafe code inside a coroutine body, as it can be resumed on a different thread after a `suspend` call.

---

## SECTION 6: ONE-PAGE CHEAT SHEET ITEMS

*   **Thread vs Coroutine:**
    *   **Thread:** OS-managed, heavy (MBs), parallel.
    *   **Coroutine:** Kotlin-managed, lightweight (KBs), concurrent.

*   **Memory Scale:** 50,000 Threads ≈ 100 GB. 50,000 Coroutines ≈ 500 MB.

*   **Suspension:** A suspended coroutine is not blocking its underlying thread. The thread is free to do other work.

*   **Builders:**
    *   `launch`: "Fire and forget," returns `Job`.
    *   `async`: "Compute a result," returns `Deferred`.

*   **Scopes:** Always launch coroutines within a `CoroutineScope` (e.g., `coroutineScope { ... }` or a lifecycle-provided scope) to ensure structured concurrency and proper cancellation.\n\n<!-- CHUNK 61-61 -->\n\n# DEVELOPER DECISION GUIDE: Kotlin Coroutines - Scopes, Contexts & Dispatchers

---

## SECTION 1: CORE MENTAL MODEL

### `CoroutineScope`
- **Là gì**: Bắt đầu và quản lý vòng đời của một Coroutine. Định nghĩa khi nào Coroutine start, chạy, và hủy.
- **Cốt lõi**: Chỉ là `CoroutineContext` wrapper. Không thực thi code, chỉ quản lý lifecycle.
- **Quy tắc vàng**: Không có `Scope` thì không có `Coroutine`.

### `CoroutineContext`
- **Là gì**: Tập hợp các `Element` (như `Job`, `Dispatcher`, `CoroutineName`, `ExceptionHandler`).
- **Lưu ý**: Là immutable set. Truy cập qua `context[Key]`.

### `Dispatcher`
- **Là gì**: Chỉ định Thread nào sẽ chạy Coroutine.
- **Phân loại**:
  - `Dispatchers.Main`: UI,主线程.
  - `Dispatchers.IO`: blocking I/O (database, network, file).
  - `Dispatchers.Default`: CPU intensive (sorting, parsing, calculation).
  - `Dispatchers.Unconfined`: Không giới hạn, tiếp tục ngay trên thread hiện tại (dễ gây deadlock nếu không cẩn thận).

### `Job`
- **Là gì**: Handle của Coroutine. Quản lý state (Active, Completing, Cancelled, Failed, Done).
- **Mối quan hệ**: Tạo thành cây cha-con. Cancel cha -> Cancel all con.

---

## SECTION 2: DECISION TABLES (WHEN TO USE WHAT)

### Table 1: `GlobalScope` vs Custom `CoroutineScope`

| Use case | Should use | Why | Common mistake |
| :--- | :--- | :--- | :--- |
| **App lifecycle (Main thread)** | `MainScope()` hoặc `viewModelScope` | Coroutine tự động hủy theo lifecycle của Component (Activity/ViewModel). | Dùng `GlobalScope` -> Memory leak nếu Activity rotate/destroy mà job chưa hoàn thành. |
| **Bối cảnh không có Scope (thư viện, unit test)** | `runBlocking` | Chuyển code sync thành async, dùng cho testing hoặc main thread restriction. | Dùng `runBlocking` trong production code UI (blocking Main thread -> UI freeze). |
| **Bối cảnh Worker thread** | `CoroutineScope(Dispatchers.IO)` | Quản lý nhóm job CPU/I/O độc lập. | Quên cancel scope khi job hoàn thành -> Thread leak. |

### Table 2: `launch` vs `async`

| Use case | Should use | Why | Common mistake |
| :--- | :--- | :--- | :--- |
| **Chạy task không cần result, fire & forget** | `launch` | Trả về `Job`. Dễ cancel. | Dùng `async` rồi bỏ qua `await()` -> Tạo overhead không cần thiết. |
| **Cần lấy result từ nhiều Coroutine (parallel)** | `async` | Trả về `Deferred`. Dùng `await()` để lấy giá trị. | Dùng `launch` + `Channel`/`Mutex` khi chỉ cần `await()` (code phức tạp hơn). |
| **Cần map/trả về giá trị trực tiếp** | `async` hoặc `coroutineScope { ... }` | `coroutineScope` tự động hủy các con nếu có exception và trả về kết quả. | Quên handle `CancellationException` khi cần cleanup. |

### Table 3: `coroutineScope` vs `supervisorScope`

| Use case | Should use | Why | Common mistake |
| :--- | :--- | :--- | :--- |
| **Một con fail -> Cancel cả group** | `coroutineScope` | Hủy các job còn lại nếu một child fail (Structured Concurrency). | Dùng `supervisorScope` khi cần lây lan lỗi (không đúng mục đích). |
| **Một con fail -> Các con khác tiếp tục chạy** | `supervisorScope` | Supervisor job không cancel children khi child fail. Ideal cho Workers độc lập. | Dùng `coroutineScope` cho các task độc lập (một task fail -> mất hết data các task khác). |

---

## SECTION 3: BUILDERS & SCOPE – HOW THEY RELATE

### Hierarchy & Cấu trúc

```text
GlobalScope (DANGER: No lifecycle)
└── (MainScope / viewModelScope / lifecycleScope)
    └── launch / async (Trực thuộc scope)
        └── coroutineScope / supervisorScope (Nested scope)
            └── withContext (Switching context, không tạo scope mới)
```

### Phân tích chi tiết

1.  **Builders tạo Scope ẩn**:
    *   `runBlocking`: Tạo `BlockingCoroutineScope` (chạy blocking).
    *   `coroutineScope`: Tạo `CoroutineScope` kế thừa context từ scope hiện tại.
    *   `GlobalScope`: Tạo scope sống đơn lẻ, không bị ràng buộc.

2.  **Kế thừa Context**:
    *   Khi gọi `launch` trong một `scope`, nó merge `scope.context` + `Dispatcher` mới.
    *   **Quy tắc**: `Job` của scope mới luôn là con của scope cha (trừ `GlobalScope` và `SupervisorJob`).

---

## SECTION 4: CODE PATTERNS (EXAM-READY)

### Pattern 1: Cancelling a Scope (The Right Way)

**Khi nào dùng**: Khi Activity/Fragment/ViewModel bị destroy, cần hủy bỏ mọi tác vụ đang chạy để giải phóng resource.

**Tại sao đúng**: `coroutineScope` tự động đợi所有child jobs complete hoặc cancel, đảm bảo không rò rỉ.

```kotlin
class MyActivity : AppCompatActivity() {
    // Tạo scope gắn với lifecycle
    private val scope = MainScope()

    fun startFetching() {
        scope.launch {
            // Nếu job con throw CancellationException, scope sẽ hủy
            val data = fetchRemoteData()
            updateUI(data)
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel() // Hủy mọi job trong scope
    }

    suspend fun fetchRemoteData(): String = withContext(Dispatchers.IO) {
        // Simulate network call
        delay(2000)
        "Data"
    }
}
```

### Pattern 2: Structured Concurrency with `coroutineScope`

**Khi nào dùng**: Khi cần chạy nhiều task con song song và muốn đảm bảo cả group thành công hoặc fail cùng lúc.

**Tại sao đúng**: Nếu một task con抛出exception, các task còn lại sẽ自动被cancel (tránh chạy lãng phí CPU và resource lỗi).

```kotlin
suspend fun processMultipleImages(images: List<Image>) = coroutineScope {
    images.forEach { img ->
        launch {
            // Nếu một ảnh lỗi (throw), các ảnh khác đang upload sẽ dừng lại
            uploadImage(img)
        }
    }
}
```

### Pattern 3: Independent Workers with `supervisorScope`

**Khi nào dùng**: Khi xử lý nhiều WebSocket connections hoặc Task độc lập, nơi một task fail không ảnh hưởng task khác.

**Tại sao đúng**: `SupervisorJob` bắt con tự chịu trách nhiệm xử lý exception, không lan truyền lên cha.

```kotlin
suspend fun startWorkers() = supervisorScope {
    launch { worker("Worker 1") } // Crash không kill Worker 2
    launch { worker("Worker 2") } // Crash không kill Worker 1
    launch { worker("Worker 3") }
}

suspend fun worker(name: String) {
    delay(100)
    throw RuntimeException("$name failed!")
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. `GlobalScope` Hell
*   **Nguy hiểm**: Không thể hủy theo lifecycle. Nếu app xoá Activity mà GlobalScope job vẫn chạy -> Lỗi bộ nhớ (Memory Leak).
*   **Thay thế**: Dùng `MainScope()` hoặc `lifecycleScope`.

### 2. Blocking trong `runBlocking`
*   **Nguy hiểm**: `runBlocking` block thread gọi nó. Nếu gọi trên Main Thread -> UI treo.
*   **Lưu ý**: Chỉ dùng cho main thread của CLI hoặc testing.

### 3. Missing `SupervisorJob`
*   **Nguy hiểm**: Trong các service chạy nền (Background Service), nếu dùng `coroutineScope` mặc định, một lỗi nhỏ làm sập cả service.
*   **Thay thế**: Dùng `CoroutineScope(Dispatchers.IO + SupervisorJob())`.

### 4. Catching `CancellationException`
*   **Nguy hiểm**: `try-catch` generic `Exception` sẽ bắt cả `CancellationException`.
*   **Hậu quả**: Job không thể bị hủy đúng cách.
*   **Fix**: Chỉ bắt specific exception hoặc dùng `catch` operator của Flow.

---

## SECTION 6: ONE-PAGE CHEAT SHEET ITEMS

### Mental Shortcuts
*   **Scope** = Box quản lý vòng đời.
*   **Context** = Set các phụ thuộc (Job, Dispatchers).
*   **Dispatcher** = Xe chở code đi (Thread).

### Rules of Thumb
1.  **Scope**: `launch`/`async` ở đâu? Dùng scope của component đó (Activity -> `lifecycleScope`, VM -> `viewModelScope`).
2.  **Dispatcher**: CPU -> `Default`. I/O -> `IO`. UI -> `Main`.
3.  **Job**:
    *   Fire & Forget -> `launch`.
    *   Get Result -> `async` + `await`.
4.  **Safety**:
    *   Fail-fast & Clean up -> `coroutineScope`.
    *   Fault-tolerant & Isolated -> `supervisorScope`.

### Key APIs
```kotlin
GlobalScope // Avoid
MainScope() // UI Activity
viewModelScope // Android VM
lifecycleScope // Android Activity/Fragment

launch { } // Job
async { } // Deferred<T>

coroutineScope { } // Rethrow & Cancel group
supervisorScope { } // Isolate & Keep running

withContext(Dispatchers.IO) { } // Switch thread safely
```