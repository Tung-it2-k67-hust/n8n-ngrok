# DEVELOPER DECISION GUIDE: Lesson 6 App navigation.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:27:51



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: App Navigation

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Intent (Ý định)**: Là đối tượng dùng để request một hành động từ các thành phần khác của ứng dụng (như Activity khác). Chứa thông tin về hành động (Action) và dữ liệu (Data).

**Explicit Intent (Ý định rõ ràng)**: Chỉ định chính xác component (ví dụ: `Activity` cụ thể) sẽ được khởi chạy. Dùng cho navigation nội bộ trong app của bạn.
*   **Key:** `Intent(context, TargetActivity::class.java)`

**Implicit Intent (Ý định ngầm)**: Không chỉ định component cụ thể, mà mô tả hành động tổng quát (ví dụ: gửi email, xem ảnh). Hệ thống Android sẽ tìm app nào phù hợp để xử lý.
*   **Key:** `Intent(Intent.ACTION_SEND)`

### Key Mental Models
*   **Đường đi của Intent:**
    1.  App gọi `startActivity(intent)`.
    2.  Hệ thống Android (Activity Manager) nhận Intent.
    3.  Nếu là **Explicit**: Khởi động trực tiếp Activity được chỉ định.
    4.  Nếu là **Implicit**: Quét qua danh sách app đã cài, tìm intent-filter phù hợp, hỏi người dùng nếu có nhiều lựa chọn, rồi khởi động app đó.
*   **Data Flow:** Intent không chỉ chuyển screen, mà còn mang theo data (payload) thông qua `putExtra()`.

### Why this approach is better than others
Sử dụng Intent là chuẩn mực của Android (Standard Pattern), giúp:
1.  **Tương thích tốt:** Hoạt động mượt mà giữa các app của bạn và app của người khác.
2.  **Decoupling:** Giữa các Activity không cần biết太多 về nhau, chỉ cần biết tên và dữ liệu.
3.  **Flexibility:** Implicit Intent cho phép tái sử dụng chức năng của các app khác (ví dụ: dùng trình duyệt hoặc camera có sẵn).

---

## SECTION 2: DECISION TABLES

### Table 1: Explicit Intent vs Implicit Intent

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Chuyển sang một Activity **cùng ứng dụng** (ví dụ: Chi tiết sản phẩm từ danh sách) | **Explicit Intent** (Ý định rõ ràng) | **Direct Targeting (Chỉ định mục tiêu trực tiếp):** Bạn biết chính xác Activity nào cần mở. Tiết kiệm chi phí tìm kiếm. | Dùng Implicit Intent cho mục đích nội bộ -> Tốn tài nguyên, dễ lỗi nếu không đăng ký Intent Filter. |
| Thực hiện hành động **chung** mà app khác có thể làm (ví dụ: Gửi email, Chia sẻ file, Xem trang web) | **Implicit Intent** (Ý định ngầm) | **Action Abstraction (Tổng quát hóa hành động):** Không cần quan tâm app nào xử lý, chỉ cần hệ thống tìm app phù hợp. | Thiếu `resolveActivity()` -> Gặp crash nếu không có app nào xử lý hành động đó. |
| Mở một app **bên thứ 3 cụ thể** hoặc app khác do bạn viết | **Explicit Intent** (nếu biết tên package/class) hoặc Implicit Intent (nếu app đó đã đăng ký filter) | **Specificity (Tính cụ thể):** Tránh xung đột với app khác cùng chức năng. | |

### Table 2: Navigation Components (Fragment vs Multi-Activity vs Navigation Component)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| App hiện đại, nhiều screen, điều hướng phức tạp (Master/Detail, Bottom Nav) | **Navigation Component (Jetpack)** | **Safe Args & Graph:** Quản lý luồng đi, chuyền data type-safe tự động, xử lý back stack chuẩn. | Tự viết FragmentTransaction thủ công -> Dễ quên commit, lỗi back stack, hardcode string route. |
| Chức năng độc lập, tách biệt hoàn toàn (Splash Screen, Settings) | **Multi-Activity** | **Isolation (Cô lập):** Tách biệt lifecycle và task, dễ quản lý trên Android OS. | Dùng Activity cho mọi thứ -> Tốn bộ nhớ, overhead lifecycle phức tạp. |
| Một screen có nhiều phần linh hoạt, thay đổi UI trong runtime | **Single Activity + Multiple Fragments** | **Flexibility (Đa dạng):** Fragment nhẹ hơn Activity, dễ swap (thay thế) UI portion. | Dùng Activity cho các phần nhỏ của UI -> Quản lý lifecycle vất vả. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Flow
Hệ thống điều hướng thường có cấu trúc:
**App Entry (Activity/Fragment)** -> **Intent/NavGraph** -> **Destination (Activity/Fragment)** -> **Data Bundle**

### Flowchart: Navigation Logic

```text
[User Action]
      |
      v
[Check Requirement]
      |
      +-----------------------------+--------------------------------+
      |                             |                                |
(Nội bộ App?)                  (Chung chung?)                   (App c cụ thể?)
      |                             |                                |
      v                             v                                v
[Create Explicit Intent]    [Create Implicit Intent]       [Create Explicit Intent]
      |                             |                                |
      +-> Activity A               +-> Action (Send, View, Edit)    +-> Package Name
      |                             |                                |
      v                             v                                v
[putExtra(Data)]            [setType(MIME)]                  [setPackage(Pkg)]
      |                             |                                |
      v                             v                                v
[startActivity(intent)]      [resolveActivity() check]       [startActivity(intent)]
                                     |
                                     v
                              [System Selects App]
                              (User confirms if multiple)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Internal Navigation (Explicit Intent)

**Khi nào dùng:** Khi người dùng nhấn vào một item trong list và cần xem chi tiết.
**Tại sao đúng:** Đảm bảo chuyển dữ liệu (`id`) chính xác và đi đến đúng screen.

```kotlin
fun navigateToDetail(noteId: Int) {
    // 1. Tạo Intent rõ ràng
    val intent = Intent(this, NoteDetailActivity::class.java).apply {
        // 2. Đính kèm dữ liệu (Payload)
        putExtra("NOTE_ID_KEY", noteId)
        putExtra("IS_EDITABLE", true)
    }
    // 3. Thực hiện chuyển đổi
    startActivity(intent)
}
```

### Pattern 2: Safe External Action (Implicit Intent + Check)

**Khi nào dùng:** Khi cần mở email, share link, hoặc xem PDF từ app của bạn.
**Tại sao đúng:** `resolveActivity` kiểm tra xem có app nào hỗ trợ không trước khi chạy, tránh crash.

```kotlin
fun shareContent(message: String) {
    val intent = Intent(Intent.ACTION_SEND).apply {
        type = "text/plain"
        putExtra(Intent.EXTRA_TEXT, message)
    }

    // Safety Check: Đảm bảo có app xử lý
    if (intent.resolveActivity(packageManager) != null) {
        startActivity(intent)
    } else {
        // Xử lý lỗi: Hiển thị Toast hoặc dialog thông báo
        Toast.makeText(this, "No app found to share", Toast.LENGTH_SHORT).show()
    }
}
```

### Pattern 3: Passing Data via Bundle

**Khi nào dùng:** Khi data phức tạp hoặc cần truy cập trong `onCreate`.
**Tại sao đúng:** `getIntent()` và `extras` là nơi lưu trữ state giữa các screen.

```kotlin
// Activity B (Receiver)
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_detail)

    // Lấy dữ liệu an toàn (có thể null nếu app reopen)
    val userId = intent.getIntExtra("USER_ID", -1)
    
    if (userId != -1) {
        // Load data
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Không kiểm tra `resolveActivity` (Implicit Intent)
*   **Tại sao nguy hiểm:** Nếu người dùng không cài app xử lý (ví dụ: không cài Gmail khi bấm gửi email), app sẽ bị **crash** (`ActivityNotFoundException`).
*   **Solution:** Luôn dùng `if (intent.resolveActivity(packageManager) != null)`.

### 2. Dùng String Hardcode cho Key Intent
*   **Tại sao nguy hiểm:** Viết `putExtra("id", ...)` ở Activity A và `getStringExtra("id")` ở Activity B. Nếu sửa tên string ở một bên, bug sẽ xuất hiện và rất khó debug.
*   **Solution:** Định nghĩa constant trong object hoặc interface chung.

### 3. Mở quá nhiều Activity (Spaghetti Navigation)
*   **Tại sao nguy hiểm:** Dùng `startActivity` loạn xạ sẽ tạo ra một stack (ngăn xếp) Activity深不可測. Khi bấm nút Back, người dùng bị quay lại màn hình không mong muốn hoặc app bị restart.
*   **Solution:** Sử dụng **Single Activity Architecture** với **Fragment** hoặc **Navigation Component** để quản lý stack集中.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Mục tiêu cùng app?** -> `Intent(this, Target::class.java)` (Explicit).
2.  **Mục tiêu app khác?** -> `Intent(ACTION_...)` + `resolveActivity()` (Implicit).
3.  **Chuyền data?** -> `putExtra(key, value)`.

### Decision Logic (If-Else Style)

```text
IF (Action is "Go to specific screen in my app") THEN
    USE: Explicit Intent
    CREATE: Intent(context, Class)
    ACTION: startActivity()

ELSE IF (Action is "Share, View URL, Open Map, Send Email") THEN
    USE: Implicit Intent
    CREATE: Intent(Action_...)
    CHECK: resolveActivity()
    ACTION: startActivity()

ELSE IF (Action is "Open specific external app by package name") THEN
    USE: Explicit Intent for External
    CREATE: Intent + setPackage("com.package.name")
    ACTION: startActivity()
END IF
```

### Top 10 Things to Remember
1.  **Intent** là phương tiện giao tiếp giữa các components.
2.  **Explicit** = Tên chính xác (Điều hướng nội bộ).
3.  **Implicit** = Hành động chung (Mở app ngoài).
4.  Luôn **check null** khi dùng Implicit Intent.
5.  Dùng `apply {}` để builder Intent gọn gàng.
6.  Tránh lặp lại String keys ("NOTE_ID") -> Dùng `const val`.
7.  **Single Activity** là xu hướng, Fragment là nội dung.
8.  **Navigation Component** xử lý back stack tự động.
9.  **Intent Filter** trong `AndroidManifest.xml` để app của bạn có thể nhận Implicit Intent.
10. **Task** là tập hợp các Activity, Intent quyết định Task mới hay cũ.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: App Navigation

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Menu Resource (Tài nguyên Menu)**: File XML định nghĩa các item trong menu của app.
- **Options Menu (Menu Tùy chọn)**: Menu xuất hiện ở thanh Action Bar (phía trên cùng).
- **Navigation Drawer (Thanh điều hướng)**: Menu trượt ra từ mép màn hình (trái/phải).
- **Fragment (Mảnh)**: Một "micro-activity", là một phần của giao diện và luồng sống (lifecycle) bị gắn liền với Activity chủ.

### Key Mental Models
- **Menu là Resource, không phải Logic**: Khai báo menu trong `res/menu`, code chỉ负责 "gán" (inflate) và "lắng nghe" (handle).
- **Fragment là UI Module**: Tưởng tượng Fragment là một phần UI độc lập, có thể thêm/bớt vào Activity như Lego. Lifecycle của Fragment phụ thuộc 100% vào Activity host.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Hiển thị các hành động phổ biến (Lưu, Chia sẻ, Tìm kiếm) | **Options Menu** (XML trong `res/menu`) | `Menu Resource` (Tài nguyên Menu): Dễ dàng quản lý, thay đổi theo từng phiên bản Android mà không cần sửa code. | Code thủ công các nút `Button` trong layout XML thay vì dùng Menu. |
| Điều hướng giữa các trang chính (Home, Settings, Profile) | **Navigation Drawer** hoặc **Bottom Navigation** | `Navigation Component`: Hỗ trợ phức tạp, dễ quản lý Back Stack (lịch sử quay lại). | Dùng quá nhiều `startActivity()`造成碎片化, người dùng không biết đang ở đâu. |
| Hiển thị nội dung phụ hoặc thay đổi linh hoạt trong màn hình | **Fragment** | `Fragment`: Giúp tái sử dụng UI logic cho Tablet/Điện thoại và xoay màn hình. | Cố gắng dùng `Fragment` như một `Activity` (thêm logic nghiệp vụ nặng vào Fragment). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy
```text
[ Activity Host ]
      |
      +-- [ Options Menu ] (Defined in XML, inflated in Activity)
      |
      +-- [ Navigation Drawer ] (Layout container)
           |
           +-- [ Fragment A ] (e.g., Home)
           +-- [ Fragment B ] (e.g., Gallery)
           +-- [ Fragment C ] (e.g., Settings)
```

### Lifecycle Relationship
- **Activity**: Created -> Started -> Resumed -> Paused -> Stopped -> Destroyed.
- **Fragment**: Attached to Activity -> Created -> Started -> Resumed -> Paused -> Stopped -> Destroyed.
- **Rule**: You cannot have a Fragment without an Activity.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Inflate & Handle Options Menu
**Khi nào dùng**: Khi cần hiển thị các hành động chung trong Action Bar.
**Tại sao đúng**: Tách biệt giao diện menu (XML) khỏi logic (Code).

```kotlin
// 1. Define in res/menu/main.xml
/*
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/action_search" android:title="Search" />
    <item android:id="@+id/action_settings" android:title="Settings" />
</menu>
*/

// 2. Inflate in Activity
override fun onCreateOptionsMenu(menu: Menu): Boolean {
    menuInflater.inflate(R.menu.main, menu)
    return true
}

// 3. Handle Click in Activity
override fun onOptionsItemSelected(item: MenuItem): Boolean {
    return when (item.itemId) {
        R.id.action_search -> {
            // Logic tim kiem
            true
        }
        R.id.action_settings -> {
            startActivity(Intent(this, SettingsActivity::class.java))
            true
        }
        else -> super.onOptionsItemSelected(item)
    }
}
```

### Pattern 2: Basic Fragment Host
**Khi nào dùng**: Khi cần chia nhỏ UI Activity hoặc h hỗ trợ Tablet.
**Tại sao đúng**: Dùng `FragmentManager` để thêm/bớt Fragment động mà không cần navigate sang Activity mới.

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Thay thế R.id.fragment_container bằng HomeFragment
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .replace(R.id.fragment_container, HomeFragment())
                .commit()
        }
    }
}

// Code Fragment cơ bản
class HomeFragment : Fragment() {
    // Lưu ý: Không dùng constructor để truyền dữ liệu
    // Dùng Bundle arguments thay thế
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Logic Nghiệp vụ trong Fragment
**Tại sao nguy hiểm**: Fragment lifecycle phức tạp (có thể bị hủy khi người dùng xoay màn hình). Dữ liệu sẽ bị mất nếu logic nằm trong `onCreateView`.
**Cách tránh**: Để logic trong `ViewModel` hoặc `Activity`, Fragment chỉ chịu trách nhiệm hiển thị UI.

### 2. Dùng `activity` trong Fragment tùy tiện
**Tại sao nguy hiểm**: Gây rò rỉ bộ nhớ (Memory Leak) nếu Fragment giữ tham chiếu đến Activity sau khi Activity đã bị hủy.
**Cách tránh**: Chỉ dùng `requireActivity()` hoặc `activity` khi Fragment thực sự attached (trong `onAttach` hoặc sau đó).

### 3. Quên `return true` trong `onCreateOptionsMenu`
**Tại sao nguy hiểm**: Menu sẽ không được hiển thị.
**Cách tránh**: Luôn trả về `true` sau khi inflate.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules
- **Menu**: XML để khai báo, `menuInflater` để hiển thị, `when` để xử lý.
- **Fragment**: Dùng `supportFragmentManager` để quản lý. Không lưu state trong constructor.
- **Navigation**: Nếu chỉ cần thay đổi nội dung trong màn hình hiện tại -> Fragment. Nếu rời khỏi màn hình hiện tại -> Activity mới hoặc Navigation Graph.

### Decision Logic (If-Else)
```text
IF (User action is common across screens like Save/Share) THEN
    Use Options Menu (XML)

ELSE IF (User needs to switch between major app sections) THEN
    Use Navigation Drawer or Bottom Nav

ELSE IF (You need to swap UI parts inside one screen) THEN
    Use Fragment
```

### Top 3 Things to Remember
1. **XML First**: Luôn định nghĩa Menu và Layout Fragment bằng XML trước.
2. **Lifecycle Aware**: Fragment không tồn tại độc lập; nó chết theo Activity.
3. **ID Matters**: Mỗi `item` trong Menu và `Container` trong Layout phải có ID duy nhất (`@+id/...`).

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: App Navigation (Lesson 6)

## SECTION 1: CORE MENTAL MODEL

**Navigation Component (Thành phần Điều hướng)**: A suite of libraries that simplifies app navigation by handling transactions, back stack, and deep linking automatically. It replaces manual Fragment transactions.

**Mental Model**:
Think of Navigation as a **Train Network**.
1.  **Station (Fragment)**: A single screen.
2.  **Map (NavGraph)**: The XML map defining all stations and tracks (connections).
3.  **Driver (NavController)**: The engine that moves the train (swaps fragments) based on the map.

**Why it's better**:
Manual `FragmentManager` requires writing boilerplate code for transactions, back stack handling, and argument passing. Navigation Component handles this declaratively in XML, reducing bugs and code volume.

```kotlin
// Manual (Old & Error-Prone)
supportFragmentManager.beginTransaction()
    .replace(R.id.container, DetailFragment())
    .addToBackStack(null)
    .commit()

// Navigation Component (Safe & Simple)
findNavController().navigate(R.id.action_home_to_detail)
```

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Adding UI logic** to navigation | **XML Attributes** in NavGraph (e.g., `app:destination`) | **Declarative (Khai báo)**: Allows the system to validate paths and handle back stack logic automatically. | Writing custom back stack logic in code, bypassing the `NavController`. |
| **Navigating** between screens | **Action IDs** (`R.id.action_a_to_b`) | **Type Safety (An toàn kiểu)**: Compiler checks if the action exists, preventing runtime crashes. | Using raw Fragment class names or manual transactions instead of actions. |
| **Displaying a dialog** | **DialogFragment** destination | **Lifecycle Integration**: It behaves like a screen in the flow, cancelling the transaction if the user cancels. | Using an `AlertDialog` inside a Fragment, which breaks the navigation history. |
| **Transferring data** between screens | **Safe Args** plugin | **Type Safety**: Generates classes for arguments, preventing "Stringly typed" errors. | Using `Bundle().putString()` manually, which is error-prone and not type-safe. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy**:
`Activity` (Container) -> `NavHostFragment` (Placeholder) -> `NavController` (Manager) -> `NavGraph` (Map).

**Text-Based Flow**:
```text
[Activity Layout]
    |
    +-- <fragment> (NavHostFragment)  <-- Acts as the container
          |
          +-- app:navGraph="@navigation/main_nav_graph" <-- Defines the routes
                |
                +-- <fragment> (Destination A)
                      |
                      +-- <action> (Navigate to B)
                            |
                            +-- [User Trigger] -> [NavController.navigate(id)]
                                  |
                                  +-- [FragmentTransaction] -> [Destination B]
```

**Key Component Setup (XML)**:
```xml
<!-- Inside Activity Layout -->
<androidx.fragment.app.FragmentContainerView
    android:id="@+id/nav_host_fragment"
    android:name="androidx.navigation.fragment.NavHostFragment"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:defaultNavHost="true"  <!-- Captures Back Button -->
    app:navGraph="@navigation/nav_graph" />
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Navigation (Triggering an Action)

**When to use (Khi nào dùng)**: When a user clicks a button or an item to move to the next screen.
**Why this pattern is correct (Tại sao đúng)**: It uses the generated Action ID, ensuring the NavGraph controls the flow, not the Fragment logic.

```kotlin
// Inside SourceFragment.kt
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    
    val button = view.findViewById<Button>(R.id.btn_go_to_detail)
    
    button.setOnClickListener {
        // Uses the ID defined in nav_graph.xml
        findNavController().navigate(R.id.action_welcomeFragment_to_detailFragment)
    }
}
```

### Pattern 2: Passing Data with Safe Args

**When to use (Khi nào dùng)**: Sending information (IDs, strings, objects) to the next screen.
**Why this pattern is correct (Tại sao đúng)**: Generates a Directions class that prevents string typos and ensures type safety.

**Step A: Define Argument in XML**
```xml
<!-- nav_graph.xml -->
<fragment android:id="@+id/detailFragment">
    <argument
        android:name="userId"
        app:argType="string" />
</fragment>
```

**Step B: Pass Data (Source)**
```kotlin
// SourceFragment.kt
val action = WelcomeFragmentDirections.actionWelcomeFragmentToDetailFragment("user_123")
findNavController().navigate(action)
```

**Step C: Receive Data (Destination)**
```kotlin
// DetailFragment.kt
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)
    
    // Access args via auto-generated class
    val args: DetailFragmentArgs by navArgs()
    val userId = args.userId // Type-safe access
}
```

### Pattern 3: Creating a Fragment Class

**When to use (Khi nào dùng)**: Every time you create a new screen/destination.
**Why this pattern is correct (Tại sao đúng)**: It uses the AndroidX library (non-deprecated) and properly inflates the layout within the lifecycle.

```kotlin
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup

class WelcomeFragment : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater, 
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate the layout defined in XML
        return inflater.inflate(R.layout.fragment_welcome, container, false)
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Using `android.app.Fragment`**
*   **Why dangerous**: This is the platform version (API Level 11) and is deprecated. It lacks support library features and will cause compatibility issues.
*   **Fix**: Always use `androidx.fragment.app.Fragment`.

**2. Manual Fragment Transactions**
*   **Why dangerous**: Using `fragmentManager.beginTransaction()` manually bypasses the NavGraph. You lose automatic back-stack handling and validation.
*   **Fix**: Always use `findNavController().navigate()`.

**3. Hardcoding Navigation Logic**
*   **Why dangerous**: Writing code like `if (x == 1) goFragmentA()` makes the flow difficult to visualize and debug.
*   **Fix**: Define the graph visually in `res/navigation/nav_graph.xml`.

**4. Ignoring `defaultNavHost="true"`**
*   **Why dangerous**: Without this, the physical back button on the phone will exit the app instead of going back to the previous fragment.
*   **Fix**: Ensure `<NavHostFragment>` has `app:defaultNavHost="true"`.

---

## SECTION 6: MASTER CHEAT SHEET

**Top 10 Rules**
1.  **Library**: Use `androidx.fragment.app.Fragment`.
2.  **Host**: `NavHostFragment` holds the screens.
3.  **Controller**: `findNavController()` moves the screens.
4.  **Graph**: Defined in `res/navigation/` as XML.
5.  **Linking**: `app:navGraph` connects Host to Graph.
6.  **Back Button**: Set `app:defaultNavHost="true"`.
7.  **Safety**: Use **Safe Args** for passing data.
8.  **Directions**: Use `FragmentDirections` class to navigate with parameters.
9.  **Arguments**: Define `<argument>` tags in XML.
10. **IDs**: Use Action IDs (`action_a_to_b`) for `navigate()`.

**Quick Logic Flow**
```text
IF (User clicks button) 
   THEN -> Call findNavController().navigate(R.id.action_x)

IF (Need to pass data)
   THEN -> Define <argument> in XML -> Use Directions class

IF (App crashes on back button)
   THEN -> Check if NavHost has app:defaultNavHost="true"
```

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: App Navigation (Lesson 6)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**NavController (Bộ điều hướng)**: Lớp trung tâm điều khiển luồng UI, quản lý việc hoán đổi Destination (Fragment/Composable) trong Navigation Host.
**Safe Args (Đối số An toàn)**: Plugin Gradle tự sinh mã để truyền dữ liệu type-safe giữa các Destination.
**Navigation Graph (Đồ thị Điều hướng)**: Tệp XML định nghĩa các Destination, hành động (actions), và tham số (arguments).

### Key Mental Model
Hãy tưởng tượng `NavController` là tài xế và `NavGraph` là bản đồ. Khi bạn gọi `navigate(R.id.action)`, bạn chỉ đang chỉ đường. Tài xế (`NavController`) mới thực sự lái xe (thay đổi UI).

**Tại sao approach này tốt hơn?**
Thay vì quản lý Fragment transaction thủ công (dễ lỗi, phức tạp), Navigation Component cung cấp:
1. **Type-safety**: Tránh lỗi truyền sai kiểu dữ liệu runtime.
2. **Decoupling**: Source không cần biết chi tiết Destination, chỉ cần ID hành động.
3. **Manage state**: Xử lý tự động Back Stack.

---

## SECTION 2: DECISION TABLES (QUAN TRỌNG)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Type-safe & Default Values) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Truyền dữ liệu cơ bản (Int, String, Float)** | **Safe Args (XML)** | Đảm bảo dữ liệu đúng тип, sinh mã tự động (`Directions`, `Args` classes). Hỗ trợ giá trị mặc định. | Dùng Bundle thủ công (`bundleOf`) => Dễ gõ sai key string, không kiểm tra тип. |
| **Truyền Object (Custom Class)** | **Safe Args + Parcelable/Serializable** | Safe Args hỗ trợ trực tiếp тип `parcelable` hoặc `serializable`. Tự động serialize/deserialize. | Cố gắng truyền Object trực tiếp qua action (không serialize) => Crash hoặc lỗi dữ liệu. |
| **Chỉ định nghĩa path, chưa thực thi** | **Action trong XML (`<action>`)** | Khai báo mối quan hệ giữa 2 Destination. `NavController` dùng ID action để thực thi. | Dùng `findNavController().navigate(R.id.dest_id)` (thiếu action) => Mất đi cấu trúc graph, khó manage Back Stack. |
| **Điều hướng tùy chỉnh (popUpTo, anim)** | **`navigate()` với `NavOptions`** | Kiểm soát luồng chính xác: có pop Fragment cũ không, có animation không. | Để mặc định => UI khô khan, Back Stack lộn xộn (dư thừa Fragment). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy Flow
NavHost chứa NavGraph. NavController điều khiển NavGraph qua các Navigation Request (Actions/IDs).

```text
[ Activity (MainActivity) ]
       |
       | findNavController(R.id.myNavHostFragment)
       v
[ NavHostFragment (Container) ]  <-- Chứa graph
       |
       | Đọc file nav_graph.xml
       v
[ NavController (Driver) ] <---- [ Navigation Graph (Bản đồ) ]
       |                              |
       | navigate(R.id.action)       |-- [ Destination A (Fragment) ]
       v                              |-- [ Destination B (Fragment) ]
[ UI Update (Thay đổi Fragment) ]    |-- [ Arguments (Data definitions) ]
```

### Relationship Logic
1. **Source Fragment**: Tạo data -> Gọi `SourceDirections.actionToDest(data)`.
2. **NavController**: Nhận request -> Xử lý Back Stack -> Chuyển data.
3. **Destination Fragment**: Nhận data qua `arguments` (mã tự sinh).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Navigation Execution
**Khi nào dùng:** Khi muốn chuyển sang Fragment khác mà không cần truyền data.

**Tại sao đúng:** Dùng ID action khai báo trong XML, đảm bảo Navigation Graph nắm được luồng.

```kotlin
// Trong Fragment hoặc Activity
fun navigateToDetail() {
    // Tìm controller (nếu dùng Fragment container)
    val navController = findNavController(R.id.myNavHostFragment)
    
    // Thực thi hành động đã khai báo trong nav_graph.xml
    navController.navigate(R.id.action_welcomeFragment_to_detailFragment)
}
```

### Pattern 2: Truyền Data với Safe Args (Sender)
**Khi nào dùng:** Khi Source cần gửi dữ liệu (Int, String, Object) sang Destination.

**Tại sao đúng:** Tự sinh class `Directions` và `Args`, đảm bảo type-safety tuyệt đối.

```kotlin
// Sender Fragment (InputFragment)
fun navigateToCalculation(num1: Float, num2: Float) {
    val action = InputFragmentDirections.actionToMultiplyFragment()
        .setNumber1(num1)
        .setNumber2(num2)
    
    findNavController().navigate(action)
}
```

### Pattern 3: Nhận Data với Safe Args (Receiver)
**Khi nào dùng:** Khi Destination cần lấy dữ liệu được truyền tới.

**Tại sao đúng:** Truy cập dữ liệu qua generated class `Args`, không cần parse manual.

```kotlin
// Receiver Fragment (MultiplyFragment)
class MultiplyFragment : Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Tự sinh class: <TênFragment>Args
        val args: MultiplyFragmentArgs by navArgs()
        
        // Truy cập biến đã khai báo trong XML
        val result = args.number1 * args.number2
        binding.txtResult.text = result.toString()
    }
}
```

### Pattern 4: Cấu hình Safe Args (Gradle)
**Khi nào dùng:** Bước bắt buộc trước khi sử dụng Safe Args.

```kotlin
// Project build.gradle
buildscript {
    dependencies {
        classpath "androidx.navigation:navigation-safe-args-gradle-plugin:2.5.3"
    }
}

// App build.gradle
plugins {
    id 'androidx.navigation.safeargs.kotlin'
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern | Giải thích (Tại sao nguy hiểm) |
| :--- | :--- |
| **Truyền dữ liệu qua Constructor của Fragment** | Navigation Component instantiate Fragment, không gọi constructor có tham số. Dữ liệu sẽ bị mất hoặc crash. **PHẢI DÙNG** `navArgs()` hoặc `arguments` Bundle. |
| **Dùng String literals cho ID argument** | Ví dụ: `bundle.putString("key", "value")`. Dễ typo, không tìm ra lỗi compile-time. Safe Args sinh mã giúp bạn tránh việc này. |
| **Quên cài đặt Plugin Safe Args** | Code `.actionTo...()` hoặc `.args` sẽ không được sinh ra, gây lỗi compile. |
| **Truyền dữ liệu quá lớn (Large Object Graph)** | Parcelize/Serializable có giới hạn Binder (1MB). Truyền dữ liệu lớn gây ANR hoặc Crash. Nên truyền ID và truy xuất data từ Repository. |

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **XML First**: Luôn định nghĩa Action và Argument trong `nav_graph.xml` trước.
2. **Safety First**: Luôn dùng Safe Args Plugin thay vì Bundle thủ công.
3. **ID Rule**: Dùng `R.id.action_A_to_B` (Action ID) thay vì `R.id.fragment_B` (Destination ID) khi có thể.

### Decision Logic (If-Else Style)
- **IF** cần chuyển Fragment **AND** cần truyền dữ liệu:
  - **THEN** Cài đặt Safe Args -> Khai báo `<argument>` -> Tạo Action -> Gọi `Directions.create().navigate()`.
- **IF** chỉ chuyển Fragment không cần data:
  - **THEN** Tạo Action trong XML -> Gọi `navigate(R.id.action_id)`.
- **IF** cần tạo Custom Class object:
  - **THEN** Implement `Parcelable` (để hiệu năng tốt nhất) hoặc `Serializable` -> Khai báo `app:argType="com.example.MyClass"`.

### Top 3 Things To Remember
1. **Safe Args** là bắt buộc cho type-safe navigation (Int, String, Custom Objects).
2. Luôn dùng **Generated Classes** (InputFragmentDirections, MultiplyFragmentArgs) thay vì ID thô.
3. **navArgs()** là cách duy nhất để đọc dữ liệu trong Fragment Destination.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: App Navigation (Lesson 6)

## SECTION 1: CORE MENTAL MODEL

**Navigation (Điều hướng)**: Hành động chuyển đổi giữa các giao diện (Screen). Trong Android hiện đại, chúng ta dùng **Navigation Component (Thành phần Điều hướng)** thay vì tự quản lý Fragment/Activity thủ công.

**Mental Model**: Hãy tưởng tượng Navigation Graph (nav_graph.xml) là bản đồ metro. **NavHostFragment** là toa tàu chứa乘客 (Fragment), và **NavController** là tài xế lái tàu theo bản đồ đó.

**Tại sao tốt hơn?**
- **Type-safe (An toàn kiểu dữ liệu)**: Tránh lỗi truyền dữ liệu sai kiểu nhờ Safe Args.
- **Quản lý Back Stack tự động**: Bạn không cần tự `addToBackStack(null)`.
- **Deep linking dễ dàng**: Chỉ cần URL để đến đúng màn hình.

```kotlin
// Khởi tạo Navigation Controller
val navController = findNavController(R.id.nav_host_fragment)
// Navigating (Tự động xử lý back stack)
navController.navigate(R.id.action_input_to_multiply)
```

---

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

| Tình huống sử dụng | Nên dùng gì | Tại sao (EN + VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Chuyển Fragment & Truyền dữ liệu an toàn** | **Safe Args (Navigation Plugin)** | **Type Safety (An toàn kiểu dữ liệu)**: Đảm bảo dữ liệu truyền đi đúng type, tránh `ClassCastException`. | Dùng `Bundle()` thủ công hoặc `arguments?.getString(...)` dễ gây lỗi cast và khó bảo trì. |
| **Chuyển Activity (App khác hoặc hệ thống)** | **Intent (Explicit/Implicit)** | **Inter-app Communication (Giao tiếp liên ứng dụng)**: Cần ra khỏi app hiện tại hoặc mở app khác (Email, Maps). | Cố gắng dùng Fragment Navigation để mở app khác (Không thể). |
| **Xử lý Click Menu Item** | **`onNavDestinationSelected`** | **Automation (Tự động hóa)**: Tự động map ID menu với ID destination trong graph. | Viết `when (item.id)` xử lý thủ công, lặp lại logic `navigate()`. |
| **Cần Header/Drawer cố định** | **NavigationUI với DrawerLayout** | **Consistency (Tính nhất quán)**: Tự động đồng bộ trạng thái Toolbar/Drawer với Nav Controller. | Quản lý state Drawer (mở/đóng) thủ công trong từng Fragment. |
| **Quay lại màn hình trước** | **`popBackStack()`** | **Back Stack Management**: Lùi một bước trong graph (hoặc về root). | Dùng `activity?.onBackPressed()` (deprecated và không xử lý đúng graph). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy (Mối quan hệ cấp bậc):**

```text
[Activity Layout (XML)]
   │
   ├── [DrawerLayout] (Nếu có)
   │       │
   │       └── [NavigationView] (Menu)
   │
   └── [NavHostFragment] (Container rỗng)
           │
           └── [NavController] (Bộ não điều khiển)
                   │
                   └── [NavGraph] (File XML định nghĩa路线)
                           │
                           ├─ [Destination 1: Fragment A]
                           ├─ [Destination 2: Fragment B]
                           └─ [Destination 3: Activity C]
```

**Data Flow (Luồng dữ liệu):**
1. **InputFragment**: Thu thập data -> Tạo Action (`InputFragmentDirections`) -> Gọi `navigate()`.
2. **NavGraph**: Định tuyến Action ID đến Destination.
3. **MultiplyFragment**: Nhận data qua `NavArgs` (Type-safe).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Passing Data with Safe Args (Truyền dữ liệu an toàn)

**Khi nào dùng:** Khi Fragment A cần gửi dữ liệu (String, Int, Object) cho Fragment B.

**Tại sao đúng:** Không dùng `Bundle` thủ công, tránh lỗi lõi DateTime hoặc Boolean.

```kotlin
// 1. Tạo Action trong nav_graph.xml
// <action android:id="@+id/action_input_to_multiply" ... />

// 2. InputFragment.kt (Sender)
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    binding.button.setOnClickListener {
        val n1 = binding.number1.text.toString().toFloatOrNull() ?: 0.0
        val n2 = binding.number2.text.toString().toFloatOrNull() ?: 0.0
        
        // Tạo action tự động generate bởi Safe Args plugin
        val action = InputFragmentDirections.actionToMultiplyFragment(n1, n2)
        view.findNavController().navigate(action)
    }
}

// 3. MultiplyFragment.kt (Receiver)
class MultiplyFragment : Fragment() {
    // Lấy args tự động, type-safe (Float)
    val args: MultiplyFragmentArgs by navArgs()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val number1 = args.number1
        val number2 = args.number2
        val result = number1 * number2
        binding.output.text = "${number1} * ${number2} = ${result}"
    }
}
```

### Pattern 2: Wiring Navigation Drawer (Kết nối Navigation Drawer)

**Khi nào dùng:** Khi app có menu dạng slide ra (Sliding Pane).

**Tại sao đúng:** `setupWithNavController` tự động xử lý click và highlight item đang chọn.

```kotlin
// Trong MainActivity.kt
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    val navController = findNavController(R.id.nav_host_fragment)
    val drawerLayout = findViewById<DrawerLayout>(R.id.drawer_layout)
    
    // 1. Cho phép NavigationUI xử lý Up button và Drawer
    val appBarConfiguration = AppBarConfiguration(navController.graph, drawerLayout)
    setupActionBarWithNavController(navController, appBarConfiguration)

    // 2. Tự động map menu items với destinations
    val navView = findViewById<NavigationView>(R.id.nav_view)
    navView.setupWithNavController(navController)
}

// 3. Xử lý nút Back/Up trong Toolbar
override fun onSupportNavigateUp(): Boolean {
    val navController = findNavController(R.id.nav_host_fragment)
    return navController.navigateUp() || super.onSupportNavigateUp()
}
```

### Pattern 3: Simple Menu Navigation (Điều hướng Menu đơn giản)

**Khi nào dùng:** Khi không dùng Drawer, chỉ có Menu trong Toolbar.

**Tại sao đúng:** Rất gọn, không cần cấu hình DrawerLayout hay AppBarConfiguration.

```kotlin
// Trong Fragment hoặc Activity
override fun onOptionsItemSelected(item: MenuItem): Boolean {
    val navController = findNavController(R.id.nav_host_fragment)
    // Trả về true nếu ID item khớp với ID destination trong graph
    return item.onNavDestinationSelected(navController) || 
           super.onOptionsItemSelected(item)
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1. **Dùng `activity?.onBackPressed()` thay vì `navController.popBackStack()`**
   - **Nguy hiểm:** Có thể thoát app sai thời điểm hoặc không quay đúng fragment mong đợi nếu có nhiều fragment trong stack.
   - **Đúng:** Dùng `findNavController().popBackStack()` để kiểm soát chính xác quỹ đạo quay lại.

2. **Truyền dữ liệu qua Constructor của Fragment**
   - **Nguy hiểm:** Fragment sẽ crash khi hệ thống recreate (xoay màn hình, mở lại app) vì không thể gọi constructor có tham số.
   - **Đúng:** Dùng `FragmentArgs` hoặc `setArguments()` và `by navArgs()`.

3. **Bỏ qua `lateinit var binding`**
   - **Nguy hiểm:** Lỗi null pointer nếu truy cập `binding` trước khi `onViewCreated`.
   - **Đúng:** Khai báo `lateinit`, gán trong `onViewCreated`, và `null` trong `onDestroyView` để tránh rò rỉ bộ nhớ.

---

## SECTION 6: MASTER CHEAT SHEET

**Top 5 Rules:**
1. **Safe Args là bắt buộc** cho việc truyền dữ liệu giữa Fragments.
2. **Never hardcode navigation**: Luôn dùng ID action/destination từ `nav_graph.xml`.
3. **NavArgs** để nhận dữ liệu an toàn.
4. **NavigationUI** để sync Menu/Toolbar/Drawer.
5. **Back Stack**: Navigating push, Pop back stack pop.

**Decision Logic (If-Else):**

```text
IF (Chuyển giữa Fragments trong app) THEN
   Use NavHostFragment + NavController + navigate(R.id.action)
   AND Use Safe Args để truyền data

ELSE IF (Mở app khác/Chức năng hệ thống) THEN
   Use Intent (Explicit/Implicit)

ELSE IF (Xử lý Menu Item) THEN
   Use item.onNavDestinationSelected(navController)
```

**Remember:**
- `findNavController()` là gateway của mọi hoạt động điều hướng.
- `nav_graph.xml` là single source of truth của layout app.
- `DrawerLayout` + `NavigationView` + `setupWithNavController` = Navigation Drawer hoàn chỉnh.

<!-- CHUNK 51-52 -->

# DEVELOPER DECISION GUIDE: App Navigation (Android Kotlin)

## SECTION 1: CORE MENTAL MODEL

**Navigation Component (Component Navigation)**: Hệ thống quản lý luồng điều hướng (navigation flow) chuẩn hóa, bao gồm `NavHostFragment` (khu vực hiển thị Fragment), `NavController` (bộ điều hướng), và `NavGraph` (sơ đồ luồng).

**Mental Model**: Xem Navigation Graph (`.xml`) là bản đồ định tuyến. `NavController` là tài xế lái xe theo bản đồ đó. `Destinations` (màn hình) là các trạm dừng.

**Lý do nên dùng**: Thay vì tự quản lý `FragmentTransaction` hay `Intent` thủ công, Navigation Component giúp tránh lỗi `back-stack` (lịch sử quay lui), xử lý deep link tự động, và truyền dữ liệu an toàn qua `Safe Args`.

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

### Table 1: Navigation Graph vs Deep Link

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Ứng dụng có nhiều màn hình, cần quản lý trạng thái quay lui (Back stack) | **Navigation Graph** (File `nav_graph.xml`) | **Safe Args**: Đảm bảo tính toàn vẹn dữ liệu và type safety khi chuyển màn hình. | Tự tạo Fragment mới thủ công (`new Fragment()`) mà không thêm vào stack. |
| Mở màn hình specific từ bên ngoài (Notification, Web link) | **Deep Link** (Trong Nav Graph) | Xử lý URI tự động và khôi phục đúng state nếu app bị kill. | Truyền dữ liệu qua biến toàn cục (Global Variable) thay vì URI parameter. |

### Table 2: Fragment vs Activity as Destination

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Màn hình có UI, thao tác lặp lại trong app (Home, Detail) | **Fragment** (Trong NavHost) | Dễ重用 (reuse), quản lý bởi Activity host, h hỗ trợ NavigationUI. | Viết Logic nặng trong Activity thay vì ViewModel của Fragment. |
| Màn hình yêu cầu quyền hệ thống hoặc Splash Screen | **Activity** (Màn hình独立) | Khởi chạy独立 lifecycle, không bị ảnh hưởng bởi NavHost. | Dùng Fragment cho Splash chỉ gây thừa thãi lifecycle. |

### Table 3: Passing Data Mechanism

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Chuyển object lớn (Data class) giữa Fragment A -> B | **Safe Args** (Action & Argument) | **Type Safety**: Tránh lỗi kiểu dữ liệu runtime. Tự động generated code. | Dùng Bundle thủ công (`bundle.putSerializable`) dễ dẫn đến lỗi cast. |
| Chuyển dữ liệu giữa Fragment và ViewModel | **Android ViewModel** hoặc **SavedStateHandle** | Survive configuration change (Xoay màn hình). | Truyền dữ liệu qua Constructor của Fragment (không an toàn khi system recreate). |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Text-Based Flow:**

```
[Main Activity]
    |
    v
[NavHostFragment] (Container trống)
    |
    +--- (Giữ các Fragment destination)
    |
    v
[NavController] (Bộ não điều khiển)
    ^
    |
[nav_graph.xml] (Bản đồ: Gắn các Fragment bằng ID và Action)
    |
    +--> [Fragment A] <---[Safe Args]---> [Fragment B]
    |       (Gọi navigate(R.id.action_A_to_B))
    |
[NavigationUI] (Sync UI với Nav)
    |
    +--> [BottomNavigationView] / [Toolbar]
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Args Implementation

**Khi nào dùng**: Khi cần truyền dữ liệu từ Destination A sang B.

**Tại sao đúng**: Tránh lỗi type mismatch, hỗ trợ null safety.

**Code Demo:**

1. **build.gradle (Module)**
```kotlin
plugins {
    id("androidx.navigation.safeargs.kotlin")
}
```

2. **nav_graph.xml**
```xml
<fragment android:id="@+id/FragmentA" ...>
    <action android:id="@+id/action_FragmentA_to_FragmentB"
            app:destination="@id/FragmentB" />
</fragment>

<fragment android:id="@+id/FragmentB" ...>
    <argument
        android:name="userId"
        app:argType="string" />
</fragment>
```

3. **Source Fragment (Gọi)**
```kotlin
// FragmentA.kt
val action = FragmentADirections.actionFragmentAToFragmentB(userId = "123")
findNavController().navigate(action)
```

4. **Destination Fragment (Nhận)**
```kotlin
// FragmentB.kt
val userId = arguments?.getString("userId") 
// Hoặc dùng generated class nếu dùng Safe Args:
// val safeArgs: FragmentBArgs by navArgs()
```

### Pattern 2: Basic NavigationUI Setup

**Khi nào dùng**: Để sync `Toolbar` hoặc `BottomNavigationView` với `NavController`.

**Tại sao đúng**: Tự động update title/menu và xử lý nút "Up" (Back).

**Code Demo:**

```kotlin
// MainActivity.kt
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    
    val navHostFragment = supportFragmentManager
        .findFragmentById(R.id.nav_host_fragment) as NavHostFragment
    val navController = navHostFragment.navController
    
    // 1. Sync BottomNavigationView
    val bottomNav = findViewById<BottomNavigationView>(R.id.bottom_nav)
    bottomNav.setupWithNavController(navController)
    
    // 2. Sync Toolbar (ActionBar)
    val appBarConfig = AppBarConfiguration(setOf(R.id.home_dest, R.id.profile_dest))
    setupActionBarWithNavController(navController, appBarConfig)
}

// Xử lý nút Back/Up trên Toolbar
override fun onSupportNavigateUp(): Boolean {
    return navController.navigateUp() || super.onSupportNavigateUp()
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Tự quản lý Back Stack thủ công**: Dùng `addToBackStack(null)` trong `FragmentTransaction`.
    *   **Nguy hiểm**: Gây ra hiện tượng "back stack madness" (quay lui lộn xộn, không đúng logic), khó quản lý trạng thái khi xoay màn hình hoặckill app.

2.  **Truyền dữ liệu qua biến static hoặc Singleton**:
    *   **Nguy hiểm**: Dữ liệu không survive khi hệ thống Recycle Fragment/Activity. Gây rò rỉ bộ nhớ (Memory Leak) và Crash khi truy cập Object đã bị huỷ.

3.  **Gọi `navigate()` không kiểm tra điều kiện**:
    *   **Nguy hiểm**: Nếu click nhanh 2 lần hoặc tình huống đặc biệt, `NavController` có thể crash do lỗi `IllegalArgumentException` (Destination không t tồn tại).
    *   **Fix**: Luôn kiểm tra `currentDestination` trước khi navigate.

## SECTION 6: MASTER CHEAT SHEET

**Decision Logic (If-Else):**

*   **IF** bạn có nhiều màn hình cần quản lý luồng Back -> **USE** Navigation Component (Nav Graph).
*   **IF** bạn cần truyền object (Data Class) -> **USE** Safe Args trong Nav Graph.
*   **IF** bạn cần sync Menu/Toolbar với màn hình hiện tại -> **USE** NavigationUI (`setupWithNavController`).
*   **IF** bạn thấy code `fragmentManager.beginTransaction()` -> **STOP** và đổi sang `findNavController().navigate()`.

**Top 5 Things to Remember:**

1.  **NavHostFragment**: Là nơi chứa các Fragment con.
2.  **NavController**: Object dùng để gọi `navigate()` và `navigateUp()`.
3.  **Safe Args**: Plugin + XML Argument -> Đảm bảo Type Safety.
4.  **NavigationUI**: Giúp Toolbar/BottomNav "bắt" sự kiện click và update UI.
5.  **Deep Link**: Có thể generate URI từ Action trong Graph để gọi từ ngoài app.