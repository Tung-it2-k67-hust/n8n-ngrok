# DEVELOPER DECISION GUIDE: Lesson 10 Advanced RecyclerView use cases.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:11:44



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Advanced RecyclerView

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**RecyclerView (Bộ tái sử dụng view):** A ViewGroup that renders list data by reusing (recycling) views to maintain performance and low memory usage.
**Adapter (Bộ điều适配):** A controller object that maps your data source to the RecyclerView's views.
**ViewHolder (Người giữ view):** A wrapper class for an item's View that caches references to its children to avoid expensive `findViewById()` calls.

### Key Mental Model
Imagine a restaurant window with only 5 seats (Visible Views). As customers (Data) move, empty seats go back to the end of the line (Recycle Pool) to be filled by new customers. The **Adapter** is the waiter who reassigns the seat (View) to a new customer (Data at position).

**Why this is better:** It decouples the data from the view. It allows for infinite lists (theoretically) without infinite memory usage.

---

## SECTION 2: DECISION TABLES

### Table: Multiple View Types vs. Single View Type with Visibility Logic

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| List contains fundamentally different items (e.g., Text, Image, Header) | **Multiple View Types** (`getItemViewType`) | **Polymorphism:** Clean separation of logic. `onBindViewHolder` handles specific data types without complex `if-else`. | Using `if-else` inside `onBindViewHolder` to toggle View visibility (GONE/VISIBLE). This bloats the view hierarchy and confuses accessibility services. |
| List contains similar items with minor state changes (e.g., Expanded vs. Collapsed) | **Single View Type** | **Simplicity:** One XML layout. State change is just data update (boolean flag). | Creating a separate ViewType for "Expanded" and "Collapsed" states. Hard to maintain transition animations. |

### Table: Header Implementation Strategy

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| Sticky header (ghim đầu) | **ItemDecoration** | **Separation of Concerns:** Keeps the adapter clean. Drawing is handled by the RecyclerView. | Adding a fake "Header" item to the adapter. This messes up the index (position logic) when clicking items. |
| Scrollable Header (part of the flow) | **Multiple View Types** | **Natural Flow:** It behaves like a standard list item. | Using `ItemDecoration`. It draws over content and doesn't scroll naturally with the list. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy
```text
[Activity/Fragment]
     |
     +-- [RecyclerView] (ViewGroup)
          |
          +-- [LayoutManager] (Logic: Linear, Grid, Staggered)
          |
          +-- [ItemDecoration] (Visuals: Dividers, Headers) -- OPTINAL
          |
          +-- [ItemAnimator] (Visuals: Add/Remove animations) -- OPTIONAL
          |
          +-- [Adapter] (Logic: Data Mapping)
               |
               +-- [ViewHolder] (Caching: View References)
```

### Data Flow Diagram
```text
Data Source (List/Array)
      |
      v
Adapter.notifyItemInserted(position)
      |
      v
RecyclerView (Requests View)
      |
      v
LayoutManager (Calculates Layout)
      |
      v
onCreateViewHolder (Inflates XML)  <-->  Recycled View Pool
      |
      v
onBindViewHolder (Fills Data)
      |
      v
ViewHolder (Displayed on Screen)
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Multiple Item View Types (Data Polymorphism)
**Khi nào dùng:** When the list contains different categories of data (e.g., Ad vs. Content, Header vs. Footer).

**Tại sao đúng:** Prevents "God ViewHolders" that handle every possibility. Keeps binding logic clean and type-safe.

**Code Demo:**
```kotlin
// 1. Define Data Models (Sealed classes work best)
sealed class ListItem
data class HeaderItem(val title: String) : ListItem()
data class ContentItem(val body: String, val imageUrl: String) : ListItem()

// 2. Define Constants for Types
companion object {
    private const val TYPE_HEADER = 0
    private const val TYPE_CONTENT = 1
}

// 3. Implement getType
override fun getItemViewType(position: Int): Int {
    return when (data[position]) {
        is HeaderItem -> TYPE_HEADER
        is ContentItem -> TYPE_CONTENT
    }
}

// 4. Create ViewHolders
class HeaderViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    val title: TextView = view.findViewById(R.id.header_title)
}
class ContentViewHolder(view: View) : RecyclerView.ViewHolder(view) {
    val body: TextView = view.findViewById(R.id.content_body)
}

// 5. Inflate Correct Layout
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
    return when (viewType) {
        TYPE_HEADER -> {
            val view = LayoutInflater.from(parent.context).inflate(R.layout.item_header, parent, false)
            HeaderViewHolder(view)
        }
        else -> {
            val view = LayoutInflater.from(parent.context).inflate(R.layout.item_content, parent, false)
            ContentViewHolder(view)
        }
    }
}

// 6. Bind Correct Data
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
    when (val item = data[position]) {
        is HeaderItem -> (holder as HeaderViewHolder).title.text = item.title
        is ContentItem -> (holder as ContentViewHolder).body.text = item.body
    }
}
```

### Pattern 2: Click Listeners with Payload
**Khi nào dùng:** When you need to know exactly which item was clicked and handle the event in the Activity/ViewModel.

**Tại sao đúng:** Passes the data object or position immediately. Note: Set click listeners in `onCreateViewHolder` (not `onBindViewHolder`) to avoid re-creation on scroll.

**Code Demo:**
```kotlin
class MyAdapter(
    private val data: List<String>,
    private val onItemClick: (String, Int) -> Unit // Lambda callback
) : RecyclerView.Adapter<MyAdapter.MyViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_row, parent, false)
        val holder = MyViewHolder(view)
        
        // Set listener here once
        view.setOnClickListener {
            val position = holder.adapterPosition
            if (position != RecyclerView.NO_POSITION) {
                onItemClick(data[position], position)
            }
        }
        return holder
    }

    override fun onBindViewHolder(holder: MyViewHolder, position: Int) {
        holder.textView.text = data[position]
    }

    class MyViewHolder(view: View) : RecyclerView.ViewHolder(view) {
        val textView: TextView = view.findViewById(R.id.item_text)
    }
}
```

### Pattern 3: Grid Layout Manager
**Khi nào dùng:** For image galleries, dashboard tiles, or card grids.

**Tại sao đúng:** Native support for multi-column layouts without complex math.

**Code Demo:**
```kotlin
// In Activity/Fragment
val rv = findViewById<RecyclerView>(R.id.rv_grid)

// Option A: Fixed number of columns
rv.layoutManager = GridLayoutManager(context, 3) // 3 columns

// Option B: Adaptive columns based on width (Recommended for responsiveness)
val columnCount = if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) 5 else 3
rv.layoutManager = GridLayoutManager(context, columnCount)

rv.adapter = MyGridAdapter(data)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Logic in `onBindViewHolder`
* **Danger:** Performing heavy operations (Image loading without library, complex calculations, Network calls) inside `onBindViewHolder`.
* **Why:** This method runs every time a view is recycled/scrolls. Heavy logic causes frame drops (Jank). Use `Glide`/`Coil` for images and pre-calculate data in the ViewModel.

### 2. `findViewById` inside `onBindViewHolder`
* **Danger:** Calling `view.findViewById()` repeatedly in `onBindViewHolder`.
* **Why:** It traverses the View tree (O(N) operation). It defeats the purpose of `ViewHolder` caching.
* **Fix:** Always find views once in `ViewHolder` constructor or `onCreateViewHolder` and store them in variables.

### 3. NotifyDatasetChanged Abuse
* **Danger:** Calling `notifyDataSetChanged()` for any tiny change.
* **Why:** It forces the RecyclerView to redraw *everything* immediately, killing performance and animations. It looks like a flicker to the user.
* **Fix:** Use specific notify methods: `notifyItemInserted()`, `notifyItemRemoved()`, `notifyItemChanged()`.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1. **ViewHolder:** Always cache view references inside the ViewHolder class.
2. **Set Listener:** Set click listeners in `onCreateViewHolder`, not `onBindViewHolder`.
3. **Notify Precisely:** Never use `notifyDataSetChanged()` if you can use `notifyItem*`.
4. **View Types:** Use `getItemViewType` when data shapes differ.
5. **Data Handling:** Pass data into the Adapter constructor, do not hardcode inside.
6. **Position:** Always check `holder.adapterPosition != RecyclerView.NO_POSITION` inside listeners.
7. **ID:** Use `android:id="@+id/..."` in item layouts.
8. **DiffUtil:** For large lists, use `DiffUtil` in `AsyncListDiffer` to calculate differences efficiently.
9. **Grid:** Use `GridLayoutManager` for 2D layouts.
10. **Performance:** Keep `onBindViewHolder` lean. It binds ~60 times per second during scrolling.

### If-Else Decision Logic
* **If** you have a list of similar items -> **Single ViewType**
* **If** you have a list of different items (Header, Footer, Content) -> **Multiple ViewTypes**
* **If** you need a static top bar in the list -> **ItemDecoration (Header)**
* **If** you need to handle item click logic -> **Lambda in Adapter Constructor**
* **If** `notifyDataSetChanged` is called -> **Check if you can use a specific notify instead**

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Advanced RecyclerView (Lesson 10)

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **ListAdapter**: A `RecyclerView.Adapter` subclass that uses `DiffUtil` to automatically calculate list updates on a background thread. It simplifies updating the list by handling diffing logic internally.
- **DiffUtil.ItemCallback (Tiêu chí DiffUtil)**: A class that defines how to compare items in a list to determine if they are the same item and if their contents have changed.
- **Binding Adapter (Bộ gắn dữ liệu)**: An annotation that maps a function to an XML attribute, allowing you to set complex data or custom logic directly in XML layouts.

### Why ListAdapter is Better than RecyclerView.Adapter
| Feature | RecyclerView.Adapter (Standard) | ListAdapter |
| :--- | :--- | :--- |
| **Update Logic** | Requires manual `notifyDataSetChanged()` or specific notify calls. | Calls `submitList()` to update. |
| **Performance** | Refreshes all visible items (O(N) or worse) on every update, causing UI stutter. | Calculates diffs in the background (O(N+M)). Updates only changed items. |
| **Simplicity** | High boilerplate. You must calculate position changes manually. | Low boilerplate. Just pass a new list. |

**Reality Check:** `RecyclerView.Adapter` is wasteful because it blindly disposes and recreates views. `ListAdapter` is efficient because it performs surgical updates based on the difference between the old list and the new list.

---

## SECTION 2: DECISION TABLES

### Table: When to use Standard Adapter vs ListAdapter

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Static list (Danh sách cố định)**<br>List never changes after initial load. | `RecyclerView.Adapter` | Overkill to calculate diffs if data never changes. | Using `ListAdapter` unnecessarily increases complexity for static data. |
| **Dynamic list (Danh sách thay đổi)**<br>Sorting, filtering, adding, removing items. | `ListAdapter` | **Efficiency (Hiệu quả)**: `DiffUtil` computes updates on a background thread, preventing UI lag. | Calling `notifyDataSetChanged()` inside `ListAdapter`. You should just call `submitList()`. |
| **Large datasets**<br>Thousands of items. | `ListAdapter` | **Performance (Hiệu năng)**: Minimal view binding overhead. Only binds what is necessary. | Passing the same list reference to `submitList()`. Must pass a *new* list instance. |
| **Sorting animation**<br>Reordering items frequently. | `ListAdapter` | **Smoothness (Mượt mà)**: `DiffUtil` detects moves (insertions/deletions) rather than clearing the whole list. | Firing `submitList()` on the UI thread for large calculations. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy
```text
[RecyclerView] (The Container)
      ^
      |
[ListAdapter] (Manages Data & Diffing)
      |
[DiffUtil.ItemCallback] (The Rules: Are items the same? Are contents the same?)
      |
[ViewHolder] (The View Holder: Holds XML bindings)
      |
[Item XML] (The Layout)
```

### Workflow: Updating a List
1. **User Action**: User clicks "Sort" or "Filter".
2. **ViewModel**: Creates a **new** list object.
3. **submitList()**: Passes the new list to `ListAdapter`.
4. **Background Thread**: `DiffUtil` compares New List vs Old List using `ItemCallback`.
5. **Result**: Adapter receives specific commands (Insert at 3, Remove at 5, Move 1 to 4).
6. **UI Thread**: `RecyclerView` animates changes efficiently.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic ListAdapter Implementation
**Khi nào dùng:** Khi bạn cần hiển thị danh sách động và muốn hiệu năng tối ưu.

**Tại sao đúng:** `ListAdapter` tự động quản lý vòng đời dữ liệu và tối ưu hóa việc cập nhật giao diện.

```kotlin
// 1. Define the DiffUtil Logic
class RowItemDiffCallback : DiffUtil.ItemCallback<Int>() {
    // Kiểm tra ID: Xác định 2 item có phải là cùng 1 đối tượng không (ví dụ: cùng ID database)
    override fun areItemsTheSame(oldItem: Int, newItem: Int): Boolean {
        return oldItem == newItem
    }

    // Kiểm tra Nội dung: Xác định nội dung 2 item có giống nhau không
    override fun areContentsTheSame(oldItem: Int, newItem: Int): Boolean {
        return oldItem == newItem
    }
}

// 2. Create the Adapter
class NumberListAdapter : ListAdapter<Int, NumberListAdapter.IntViewHolder>(RowItemDiffCallback()) {

    class IntViewHolder private constructor(val binding: ItemViewBinding) :
        RecyclerView.ViewHolder(binding.root) {
        
        // Companion object để inflate View (Best Practice)
        companion object {
            fun from(parent: ViewGroup): IntViewHolder {
                val layoutInflater = LayoutInflater.from(parent.context)
                val binding = ItemViewBinding.inflate(layoutInflater, parent, false)
                return IntViewHolder(binding)
            }
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): IntViewHolder {
        return IntViewHolder.from(parent)
    }

    override fun onBindViewHolder(holder: IntViewHolder, position: Int) {
        // getItem(position) là phương thức của ListAdapter, không phải của List thông thường
        val item = getItem(position)
        // Gán dữ liệu vào view (xem Pattern 2 cho Binding Adapter)
        holder.binding.number.text = item.toString()
    }
}

// 3. Usage in Activity/Fragment
// val adapter = NumberListAdapter()
// recyclerView.adapter = adapter
// adapter.submitList(newListOfIntegers) // Không cần gọi notifyDataSetChanged
```

### Pattern 2: Custom Binding Adapter for Views
**Khi nào dùng:** Khi bạn muốn gán dữ liệu trực tiếp vào XML (`android:text` mặc định không hỗ trợ format hoặc logic phức tạp).

**Tại sao đúng:** Tách biệt logic UI khỏi ViewHolder, giữ code ViewHolder sạch sẽ.

```kotlin
// File: BindingAdapters.kt
@BindingAdapter("app:formattedNumber") // Tên attribute tự定义
fun TextView.setFormattedNumber(number: Int?) {
    text = if (number != null) {
        "Number: $number" // Ví dụ: Format string phức tạp
    } else {
        "N/A"
    }
}

// File: item_view.xml
<!-- 
<TextView
    app:formattedNumber="@{viewModel.currentNumber}"
    ... /> 
-->
// Logic format nằm tại Binding Adapter, XML chỉ khai báo dữ liệu.
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Mutable List trong ListAdapter
**Sai lầm:** Truy cập và sửa đổi trực tiếp danh sách bên trong `ListAdapter` (ví dụ: `currentList.add(item)`).
**Tại sao nguy hiểm:** `ListAdapter` không theo dõi thay đổi trực tiếp. Bạn phải tạo **bản sao** (copy) của danh sách, sửa đổi bản sao đó, rồi gọi `submitList()`.

### 2. So sánh sai trong DiffUtil
**Sai lầm:** Implement `areItemsTheSame` chỉ dựa vào dữ liệu hiển thị (ví dụ: tên người dùng).
**Tại sao nguy hiểm:** Nếu người dùng thay đổi tên, `DiffUtil` sẽ coi đó là xóa item cũ và tạo item mới, gây mất trạng thái (ví dụ: mất focus, animation giật cục).
**Đúng:** Dùng ID duy nhất cho `areItemsTheSame`, dùng dữ liệu hiển thị cho `areContentsTheSame`.

### 3. Gọi submitList() quá nhiều
**Sai lầm:** Gọi `submitList()` mỗi khi input thay đổi mà chưa debounce (chờ gõ xong).
**Tại sao nguy hiểm:** Tạo ra quá nhiều công việc diffing background, gây tràn bộ nhớ và treo UI.
**Đúng:** Chỉ gọi `submitList()` khi danh sách thực sự đã được xử lý xong (ví dụ: sau khi search API trả về).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules
- **Standard Adapter**: Dùng cho list tĩnh, ít thay đổi.
- **ListAdapter**: Dùng cho list động, bắt buộc dùng `DiffUtil`.
- **DiffUtil ID**: Phải unique, dùng `areItemsTheSame`.
- **DiffUtil Content**: Phải so sánh data hiện thị, dùng `areContentsTheSame`.

### Decision Logic (If-Else)
```
IF (Data changes frequently) OR (List is large) OR (Sorting is required):
  USE ListAdapter
  
  IF (Item view has complex data format):
    USE Binding Adapter
    
ELSE (Data is static, simple):
  USE RecyclerView.Adapter
```

### Top 3 Things to Remember
1. **Always submit a NEW list**: `list.add()` không hoạt động, phải dùng `oldList + newItem`.
2. **ID > Contents**: ID xác định object là ai, Contents xác định object đang mặc gì.
3. **Background Thread**: `DiffUtil` chạy background, không cần chạy RxJava/Coroutines manual để tối ưu list update.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Advanced RecyclerView

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Data Binding (Ghim dữ liệu)**: Kỹ thuật gắn dữ liệu trực tiếp vào giao diện người dùng (UI) thông qua biểu thức (expressions), loại bỏ việc gọi `findViewById` và cập nhật UI thủ công.
- **Binding Adapter (Bộ điều hợp ghim)**: Một hàm được đánh dấu bằng `@BindingAdapter` để xử lý logic giao diện khi dữ liệu thay đổi, ví dụ: chuyển đổi định dạng dữ liệu trước khi hiển thị.
- **Item View Type (Loại chế độ xem mục)**: Một định danh (Int) để chỉ định bố cục nào sẽ sử dụng cho một mục cụ thể trong danh sách khi có nhiều loại mục dữ liệu khác nhau.

### Key Mental Models
- **Separation of Concerns (Tách biệt trách nhiệm)**: Adapter chỉ định nghĩa "cái gì" và "khi nào" cần cập nhật (khi dữ liệu thay đổi), Binding Adapter định nghĩa "làm thế nào" để hiển thị dữ liệu đó (format, logic UI). Việc này giữ cho Adapter sạch sẽ và tập trung vào việc quản lý danh sách.
- **Polymorphic List (Danh sách đa hình)**: Thay vì tạo nhiều danh sách riêng biệt cho mỗi loại dữ liệu, ta gom chúng vào một danh sách chung. Adapter sẽ đóng vai trò "nhà máy" phân loại dữ liệu (qua `getItemViewType`) và chọn đúng "khuôn" (ViewHolder) để sản xuất ra giao diện phù hợp.

### Why this approach is better than others
- **Tối ưu hóa Performance**: Data Binding tự động chỉ cập nhật những phần UI bị ảnh hưởng khi dữ liệu thay đổi thay vì làm mới toàn bộ View. `executePendingBindings()` buộc cập nhật ngay lập tức, tránh trễ hình.
- **Mở rộng (Scalability)**: Sử dụng `getItemViewType` để xử lý nhiều loại dữ liệu trong một Adapter duy nhất dễ dàng hơn việc maintain nhiều Adapter riêng biệt hoặc các ListView phức tạp. Logic ràng buộc (binding logic) được tách rời, dễ test và tái sử dụng.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Hiển thị dữ liệu thô theo format đặc biệt** (VD: số sang binary) | **Binding Adapter** (`@BindingAdapter`) | **Separation of Concerns (Tách biệt trách nhiệm)**: Tách logic format ra khỏi Adapter/ViewHolder. Dễ tái sử dụng cho nhiều nơi. | Viết logic format trực tiếp trong `onBindViewHolder`. Khó test và gây rối code. |
| **Có nhiều loại item layout trong 1 list** (VD: item số và item màu) | **Multiple View Types** (Override `getItemViewType`) | **Polymorphism (Đa hình)**: Cho phép một danh sách chứa đa dạng dữ liệu. Giảm complexity so với quản lý nhiều RecyclerView/Adapter. | Quên gọi `getItemViewType` hoặc trả về sai `viewType` trong `onCreateViewHolder`, dẫn đến crash hoặc giao diện sai. |
| **Cần cập nhật UI ngay lập tức sau khi set data** | **`executePendingBindings()`** | **Tính nhất quán (Consistency)**: Buộc Data Binding thực hiện các công việc đang chờ (pending bindings) ngay lập tức, tránh hiện tượng giao diện bị trễ, nhấp nháy. | Bỏ qua lệnh này trong `onBindViewHolder` khi dùng Data Binding, dẫn đến UI không phản ánh đúng dữ liệu ngay lập tức. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flowchart: Quy trình render một item trong RecyclerView nâng cao

```text
[Data List (Mixed Types)]
       |
       v
[Adapter: getItemViewType(position)]
       |
       +---> (Logic kiểm tra dữ liệu: is Int? is Color?)
       |
       v
[Trả về Int: View Type]
       |
       v
[onCreateViewHolder(viewType)]
       |
       +---> (Khi viewType == NUMBER) -> Tạo IntViewHolder (layout số)
       +---> (Khi viewType == COLOR)  -> Tạo ColorViewHolder (layout màu)
       |
       v
[onBindViewHolder(holder, position)]
       |
       v
[Set Data: holder.binding.data = item]
       |
       v
[Data Binding Engine]
       |
       +---> [Tìm Binding Adapter @BindingAdapter("...")]
       |
       v
[Chạy Logic Adapter: VD: TextView.setBase2Number(item)]
       |
       v
[Cập nhật UI: holder.binding.executePendingBindings()]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Custom Binding Adapter (Hiển thị Binary)

**Khi nào dùng:** Khi bạn cần hiển thị một thuộc tính dữ liệu (ví dụ: `Int`) dưới một định dạng UI cụ thể (ví dụ: hệ nhị phân) ở nhiều nơi trong app.

**Tại sao đúng:** Tách biệt logic chuyển đổi dữ liệu ra khỏi vòng lặp `onBindViewHolder`, giữ cho Adapter tập trung vào việc gán dữ liệu thô.

**Code Demo:**

```kotlin
// 1. Định nghĩa Binding Adapter
@BindingAdapter("base2Number")
fun TextView.setBase2Number(item: Int) {
    // Logic chuyển đổi số nguyên sang chuỗi nhị phân
    text = Integer.toBinaryString(item)
}

// 2. Sử dụng trong XML
<TextView
    android:id="@+id/base2_number"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textSize="24sp"
    app:base2Number="@{num}" /> <!-- 'num' là biến dữ liệu -->

// 3. Gán dữ liệu trong Adapter
override fun onBindViewHolder(holder: IntViewHolder, position: Int) {
    holder.binding.num = getItem(position) // Gán biến 'num'
    holder.binding.executePendingBindings() // Cập nhật UI ngay
}
```

### Pattern 2: Multiple Item View Types (Đa dạng Item)

**Khi nào dùng:** Khi danh sách cần hiển thị các mục có cấu trúc giao diện hoàn toàn khác nhau (VD: Tiêu đề + Nội dung, hoặc Item A + Item B).

**Tại sao đúng:** Sử dụng một Adapter duy nhất để quản lý danh sách hỗn hợp, tận dụng cơ chế phân loại (polymorphism) của RecyclerView.

**Code Demo:**

```kotlin
// 1. Định nghĩa Enum loại view
enum class ITEM_VIEW_TYPE { NUMBER, COLOR }

// 2. Xử lý phân loại trong Adapter
override fun getItemViewType(position: Int): Int {
    return when(getItem(position)) {
        is Int -> ITEM_VIEW_TYPE.NUMBER.ordinal
        is Color -> ITEM_VIEW_TYPE.COLOR.ordinal // Hoặc class Color
        else -> throw IllegalArgumentException("Unknown type")
    }
}

// 3. Tạo ViewHolder theo loại
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
    return when(viewType) {
        ITEM_VIEW_TYPE.NUMBER.ordinal -> IntViewHolder.from(parent)
        ITEM_VIEW_TYPE.COLOR.ordinal -> ColorViewHolder.from(parent)
        else -> throw IllegalArgumentException("Unknown view type")
    }
}

// 4. Gán dữ liệu theo loại
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
    when (holder) {
        is IntViewHolder -> holder.binding.num = getItem(position) as Int
        is ColorViewHolder -> holder.binding.color = getItem(position) as Color
    }
    holder.binding.executePendingBindings()
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Lặp lại Logic Format trong `onBindViewHolder`:**
    *   **Nguy hiểm:** Code bị trùng lặp, khó bảo trì. Nếu cần thay đổi định dạng, bạn phải sửa lại nhiều nơi.
    *   **Giải pháp:** Luôn dùng **Binding Adapter**.

2.  **Quên `executePendingBindings()`:**
    *   **Nguy hiểm:** Giao diện có thể không cập nhật ngay khi dữ liệu được gán, dẫn đến hiện tượng "chớp tắt" hoặc hiển thị sai lệch tạm thời.
    *   **Giải pháp:** Luôn gọi `holder.binding.executePendingBindings()` cuối hàm `onBindViewHolder` khi dùng Data Binding.

3.  **Lỗi Logic trong `getItemViewType`:**
    *   **Nguy hiểm:** Trả về một giá trị view type không tồn tại hoặc không khớp với `onCreateViewHolder` sẽ gây ra `IllegalArgumentException` hoặc crash.
    *   **Giải pháp:** Luôn sử dụng `else` branch hoặc `default` case để bắt lỗi dữ liệu đầu vào không xác định.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
*   **IF** dữ liệu cần format đặc biệt (biểu diễn, màu sắc theo logic) -> **Dùng Binding Adapter** (`@BindingAdapter`).
*   **IF** danh sách chứa các item layout khác nhau -> **Dùng Multiple View Types** (Override `getItemViewType` + `when`).
*   **IF** đang dùng Data Binding -> **LUÔN** gọi `executePendingBindings()` ở cuối `onBindViewHolder`.

### Top 3 Things To Remember
1.  **Binding Adapter là King**: Để UI tự động update khi data thay đổi mà không cần code thủ công.
2.  **Kiểm tra `viewType` kỹ lưởng**: Đảm bảo `onCreateViewHolder` nhận đúng `viewType` từ `getItemViewType`.
3.  **Tối ưu `executePendingBindings`**: Đảm bảo UI phản ánh dữ liệu tức thì, giảm flicker.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Advanced RecyclerView (Lesson 10)

## SECTION 1: CORE MENTAL MODEL

### Multi-ViewType & Binding Logic
Khi một RecyclerView cần hiển thị nhiều loại layout khác nhau (ví dụ: Header và Item) trong cùng một danh sách.

**Core Logic trong `onBindViewHolder`:**
Phương thức này phải phân loại `ViewHolder` để gán dữ liệu chính xác cho từng view type.

```kotlin
override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
    when (holder) {
        is IntViewHolder -> {
            // Ép kiểu và gán dữ liệu cho view type Integer
            holder.binding.num = getItem(position) as Int
            holder.binding.executePendingBindings()
        }
        is ColorViewHolder -> {
            // Ép kiểu và gán dữ liệu cho view type Color
            holder.binding.color = getItem(position) as Color
            holder.binding.executePendingBindings()
        }
    }
}
```

### LayoutManager & Span Control
`Layout Manager (Trình quản lý bố cục)` quyết định cách các item được sắp xếp.

- **LinearLayoutManager**: Dành cho danh sách dọc/ngang thông thường.
- **GridLayoutManager**: Dành cho bố cục dạng lưới (table).

**Mental Model:** `SpanSizeLookup` cho phép bạn "nối" các ô lưới lại với nhau để tạo ra các item lớn hơn (ví dụ: Header chiếm full width).

## SECTION 2: DECISION TABLES

### Table 1: LayoutManager Selection
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term (VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Danh sách đơn giản (danh bạ, tin nhắn) | `LinearLayoutManager` | Đơn giản, hiệu năng cao cho list chuẩn. | Dùng `GridLayoutManager` với cột=1 (chỉ làm chậm máy). |
| Hiển thị ảnh gallery, sản phẩm shop | `GridLayoutManager` | Tối ưu không gian màn hình, hiển thị nhiều item. | Quên set `orientation` mặc định là dọc. |
| Item có kích thước "lai" (vd: Header full width, item 50%) | `GridLayoutManager` + `SpanSizeLookup` | Cho phép linh hoạt số cột cho từng item. | Set span size quá lớn gây lệch layout (IndexOutOfBoundsException). |

### Table 2: Multiple ViewHolders
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term (VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| List có Section (Header + Content) | `Multiple ViewHolders` trong 1 Adapter | Giữ logic list mượt mà, không cần nest RecyclerView. | Tạo quá nhiều `if-else` rườm rà trong `onCreateViewHolder`. |
| Hiển thị dữ liệu động (Item A hoặc Item B) | `Multiple ViewHolders` | Type safety, dễ bảo trì. | Ép kiểu sai (`as`) trong `onBindViewHolder` gây crash. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow: Hiển thị Grid với Header
```text
[Activity/Fragment]
      |
      v
[RecyclerView]
      |
      +-- setLayoutManager(GridLayoutManager(context, spanCount))
      |
      +-- setAdapter(CustomAdapter)
            |
            |-- getItemViewType(position) -> Int
            |-- onCreateViewHolder(parent, viewType) -> ViewHolder
                  |
                  +-- [View Type A: Header] -> Binding (Full Width)
                  +-- [View Type B: Grid Item] -> Binding (1 span)
            |
            |-- onBindViewHolder(holder, position)
                  |
                  +-- Logic When(holder) gán data vào Binding
            |
            |-- (Optional) SpanSizeLookup
                  |
                  +-- getSpanSize(position) -> Int (Quy định width)
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Grid với Item Full Width (Header)
**Khi nào dùng:** Khi danh sách grid cần chèn tên section (vd: "Món chính") ở trên cùng hoặc xen kẽ.

**Tại sao đúng:** Sử dụng `SpanSizeLookup` để override layout grid mà không cần tạo layout mới quá phức tạp.

```kotlin
// 1. Setup Grid Layout Manager
val manager = GridLayoutManager(this, 2) // 2 cột
recyclerView.layoutManager = manager

// 2. Cấu hình SpanSizeLookup
manager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
    override fun getSpanSize(position: Int): Int {
        return when (position) {
            // Item tại vị trí 0 (Header) chiếm hết 2 cột (Full width)
            0 -> 2 
            // Các item khác chỉ chiếm 1 cột
            else -> 1
        }
    }
}

// 3. Adapter Logic
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
    return if (viewType == TYPE_HEADER) {
        HeaderViewHolder.create(parent)
    } else {
        ItemViewHolder.create(parent)
    }
}

override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
    when (holder) {
        is HeaderViewHolder -> holder.bind(getItem(position) as HeaderData)
        is ItemViewHolder -> holder.bind(getItem(position) as ItemData)
    }
}
```

### Pattern 2: Data Binding với Multiple Types
**Khi nào dùng:** Khi xử lý logic gán dữ liệu trong `onBindViewHolder` cho các model dữ liệu khác nhau.

**Tại sao đúng:** Tránh tạo quá nhiều Adapter con. Xử lý tập trung tại một chỗ, dễ debug.

```kotlin
// Base Adapter
abstract class MultiTypeAdapter : RecyclerView.Adapter<RecyclerView.ViewHolder>() {
    
    // Hàm lấy dữ liệu chung
    abstract fun getItem(position: Int): Any

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        // Logic phân loại xử lý tại đây
        when (holder) {
            is IntViewHolder -> {
                // Xử lý cho số nguyên
                holder.binding.value = getItem(position) as Int
                holder.binding.executePendingBindings() // Cập nhật UI ngay lập tức
            }
            is ColorViewHolder -> {
                // Xử lý cho đối tượng Color
                holder.binding.color = getItem(position) as Color
                holder.binding.executePendingBindings()
            }
        }
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Lỗi Ép Kiểu Trong `onBindViewHolder` (Unsafe Casting):**
    *   **Tại sao nguy hiểm:** Nếu `getItem(position)` trả về sai тип dữ liệu hoặc `viewType` bị sai logic, ứng dụng sẽ crash ngay lập tức (`ClassCastException`).
    *   **Cách tránh:** Luôn kiểm tra `viewType` trong `onCreateViewHolder` trước khi tạo ViewHolder.

2.  **Quên `executePendingBindings()`:**
    *   **Tại sao nguy hiểm:** Data Binding có thể hoãn cập nhật UI để tối ưu. Nếu bạn cần UI cập nhật ngay (tránh flicker khi scroll), việc quên dòng này gây ra hiện tượng UI hiển thị sai hoặc nhấp nháy.

3.  **Tùy chỉnh `SpanSizeLookup` Sai Logic:**
    *   **Tại sao nguy hiểm:** `GridLayoutManager` dựa vào tổng số span để tính dòng mới. Nếu `getSpanSize` trả về số lớn hơn `spanCount` hoặc không bao giờ đạt đủ `spanCount` để hoàn thành dòng, layout sẽ bị vỡ (overlap hoặc tràn ra ngoài màn hình).

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Layout Manager:**
    *   List -> `LinearLayoutManager`
    *   Grid -> `GridLayoutManager`
    *   Grid (Custom Span) -> `GridLayoutManager` + `SpanSizeLookup`
2.  **Multi View Type:**
    *   `onCreateViewHolder` -> `if (viewType == X) HolderA else HolderB`
    *   `onBindViewHolder` -> `when (holder) { is A -> ..., is B -> ... }`
3.  **Data Binding:**
    *   Luôn gọi `executePendingBindings()` nếu UI cần update ngay lập tức trong adapter.

### Top 3 Things to Remember
1.  **SpanCount** là số cột tối đa trong Grid.
2.  **SpanSize** của item Header thường bằng **SpanCount** để full width.
3.  **Multi VH** cần logic `when` chuẩn xác ở cả `onCreate` và `onBind`.

<!-- CHUNK 41-42 -->

# DEVELOPER DECISION GUIDE: Advanced RecyclerView Use Cases

## SECTION 1: CORE MENTAL MODEL

**ListAdapter (Bộ adaptor danh sách):** Là lớp trừu tượng cao cấp giúp quản lý danh sách dữ liệu và tự động xử lý hiệu ứng chuyển cảnh (animation) khi dữ liệu thay đổi. Nó bao gồm DiffUtil để tối ưu hóa việc cập nhật giao diện.

**DiffUtil (Tiện ích hiệu ứng chênh lệch):** Một thư viện cho phép tính toán hiệu quả các thay đổi giữa danh sách cũ và danh sách mới, từ đó chỉ cập nhật những item thực sự thay đổi thay vì làm mới toàn bộ danh sách.

**Binding Adapter (Bộ gắn kết dữ liệu):** Một thành phần của Data Binding cho phép bạn tạo các phương thức tùy chỉnh để gán dữ liệu (data) vào các view (giao diện) một cách tự động thông qua XML.

**Tại sao ListAdapter tốt hơn RecyclerView.Adapter cũ:**
- Giảm boilerplate code: Không cần tự quản lý dataset hay gọi notifyItem... thủ công.
- Tối ưu hiệu năng: DiffUtil chạy trên nền background, tránh freeze UI.
- Hỗ trợ animation sẵn: Item thêm/xóa/sửa sẽ tự động có animation mượt mà.

```kotlin
// Ví dụ ListAdapter cơ bản
class UserAdapter : ListAdapter<User, UserViewHolder>(UserDiffCallback()) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        val binding = ItemUserBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return UserViewHolder(binding)
    }

    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}

// DiffUtil Callback
class UserDiffCallback : DiffUtil.ItemCallback<User>() {
    override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem.id == newItem.id  // So sánh ID duy nhất
    }

    override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
        return oldItem == newItem  // So sánh toàn bộ dữ liệu
    }
}

// ViewHolder
class UserViewHolder(private val binding: ItemUserBinding) : RecyclerView.ViewHolder(binding.root) {
    fun bind(user: User) {
        binding.user = user
        binding.executePendingBindings()
    }
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Adapter Type Selection
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
|-------------------|-------------|---------------|-------------------|
| Danh sách tĩnh hoặc ít thay đổi | `RecyclerView.Adapter` | Đơn giản, overhead thấp, đủ dùng cho data không đổi. | Dùng `ListAdapter` quá phức tạp cho việc hiển thị đơn giản. |
| Danh sách động, hay thêm/xóa/sửa | `ListAdapter` | Tự động xử lý `DiffUtil`, animation mượt mà, code gọn. | Gọi `notifyDataSetChanged()` tràn lan, gây flicker và lag UI. |
| Hiển thị Grid (lưới) | `GridLayoutManager` | Hỗ trợ span count linh hoạt, tối ưu không gian hiển thị. | Dùng `LinearLayoutManager` rồi tự custom view grid, gây thừa code. |
| Cần custom view phức tạp | `RecyclerView.Adapter` | Linh hoạt cao, dễ override từng méthode. | Cố nhét logic vào `ListAdapter` khi cần kiểm soát vòng đời ViewHolder quá chi tiết. |

### Table 2: DiffUtil vs Manual Update
| Tình huống | Nên dùng | Lý do | Sai lầm |
|------------|----------|-------|---------|
| Cập nhật list có dữ liệu mới (API response) | `ListAdapter.submitList()` | Tự động so sánh, update UI mượt mà. | Tạo list mới nhưng không submit, hoặc submit cùng reference. |
| List không đổi, chỉ update UI item | `notifyItemChanged(position)` | Nhanh, không cần tính toán lại list. | Dùng `notifyDataSetChanged()` reset toàn bộ item view. |
| Dữ liệu quá lớn (>1000 items) | `DiffUtil` với `detectMoves = false` | Giảm thời gian tính toán. | Để default `detectMoves = true` gây lag. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy
```
[Activity/Fragment]
       ↓ (quản lý)
   [ViewModel] ↔ [Repository] ↔ [Database/API]
       ↓ (sử dụng)
[ListAdapter] ↔ [DiffUtil.ItemCallback]
       ↓ (tạo)
[RecyclerView.ViewHolder]
       ↓ (gán)
[Item Layout (XML)] ↔ [Binding Adapter]
```

### Data Flow Flowchart
```text
1. Data Source (API/DB) → ViewModel
2. ViewModel → LiveData<List<User>> → Activity/Fragment
3. Activity/Fragment → adapter.submitList(newList)
4. ListAdapter → DiffUtil (Background Thread)
5. DiffUtil → Calculates diff (Added/Removed/Changed)
6. ListAdapter → Notifies RecyclerView
7. RecyclerView → Animates changes → User sees smooth update
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Multi-View Type Grid
**Khi nào dùng:** Hiển thị các item khác nhau trong layout Grid (ví dụ: banner lớn + product nhỏ).

**Tại sao đúng:** `GridLayoutManager` hỗ trợ `SpanSizeLookup` để định nghĩa item nào chiếm bao nhiêu cột.

```kotlin
// 1. Adapter với multiple view types
class MultiAdapter : ListAdapter<MultiItem, RecyclerView.ViewHolder>(MultiDiffCallback()) {
    companion object {
        const val TYPE_BANNER = 1
        const val TYPE_PRODUCT = 2
    }

    override fun getItemViewType(position: Int): Int {
        return when (getItem(position)) {
            is BannerItem -> TYPE_BANNER
            is ProductItem -> TYPE_PRODUCT
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {
        return when (viewType) {
            TYPE_BANNER -> {
                val binding = ItemBannerBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                BannerViewHolder(binding)
            }
            else -> {
                val binding = ItemProductBinding.inflate(LayoutInflater.from(parent.context), parent, false)
                ProductViewHolder(binding)
            }
        }
    }

    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {
        when (holder) {
            is BannerViewHolder -> holder.bind(getItem(position) as BannerItem)
            is ProductViewHolder -> holder.bind(getItem(position) as ProductItem)
        }
    }
}

// 2. Setup Grid Layout
val gridManager = GridLayoutManager(context, 2).apply {
    spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
        override fun getSpanSize(position: Int): Int {
            return when (adapter.getItemViewType(position)) {
                MultiAdapter.TYPE_BANNER -> 2 // Banner chiếm 2 cột (full width)
                else -> 1 // Product chiếm 1 cột
            }
        }
    }
}
recyclerView.layoutManager = gridManager
```

### Pattern 2: Binding Adapter with Click Handler
**Khi nào dùng:** Khi cần gán click listener hoặc xử lý logic view trực tiếp từ XML.

**Tại sao đúng:** Tách biệt logic UI ra khỏi ViewHolder, giữ ViewHolder sạch sẽ.

```kotlin
// 1. Binding Adapter Class
object UserBindingAdapters {
    @JvmStatic
    @BindingAdapter("app:userId", "app:onClickUser", requireAll = false)
    fun setOnClickListener(view: View, userId: String, clickListener: ((String) -> Unit)?) {
        clickListener?.let {
            view.setOnClickListener {
                it(userId)
            }
        }
    }

    @JvmStatic
    @BindingAdapter("app:imageUrl")
    fun setImageUrl(imageView: ImageView, url: String?) {
        // Giả sử dùng Glide/Coil
        if (!url.isNullOrEmpty()) {
            // imageView.load(url) 
            // Placeholder logic here
        }
    }
}

// 2. ViewHolder sử dụng Binding
class UserViewHolder(private val binding: ItemUserBinding) : RecyclerView.ViewHolder(binding.root) {
    fun bind(user: User, clickListener: (String) -> Unit) {
        binding.user = user
        binding.clickListener = clickListener
        binding.executePendingBindings() // Quan trọng: forces update immediately
    }
}

// 3. XML (item_user.xml)
/*
<layout>
    <data>
        <variable name="user" type="com.example.User"/>
        <variable name="clickListener" type="kotlin.Function1"/>
    </data>
    <LinearLayout ... 
        app:userId="@{user.id}" 
        app:onClickUser="@{clickListener}">
        <TextView android:text="@{user.name}"/>
    </LinearLayout>
</layout>
*/
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Cập nhật UI sai cách trong ListAdapter**
- **Sai lầm:** Truy cập `currentList` từ adapter và sửa đổi trực tiếp (mutation).
- **Nguy hiểm:** Gây crash hoặc Sync errors vì ListAdapter immutable. Luôn tạo list mới trước khi submit.
- **Đúng:** `val newList = oldList.toMutableList().apply { add(item) }`, sau đó `adapter.submitList(newList)`.

**2. Không dùng Executor cho DiffUtil**
- **Sai lầm:** Tự implement DiffUtil trên Main Thread cho list lớn.
- **Nguy hiểm:** Giật lag (jank) nặng, UI freeze.
- **Đúng:** ListAdapter đã xử lý background tự động. Nếu custom, phải dùng `DiffUtil.calculateDiff()` với `Executor`.

**3. ViewHolder truy cập Activity/Fragment trực tiếp**
- **Sai lầm:** Passing Activity context vào ViewHolder và giữ reference.
- **Nguy hiểm:** Memory leak (rò rỉ bộ nhớ) khi Activity bị destroy nhưng ViewHolder vẫn sống.
- **Đúng:** Dùng Interface callback hoặc Lambda function truyền từ Adapter/Fragment.

**4. Dùng notifyDataSetChanged() bừa bãi**
- **Sai lầm:** Gọi mỗi khi dữ liệu thay đổi dù nhỏ.
- **Nguy hiểm:** Mất hiệu năng, reset scroll position, flicker màn hình.
- **Đúng:** Dùng `submitList()` hoặc các phương thức `notifyItem...` cụ thể.

**5. Layout XML quá phức tạp**
- **Sai lầm:** Item view có hierarchy quá sâu (> 10 levels).
- **Nguy hiểm:** Measure/Draw chậm, drop frames.
- **Đúng:** Flatten layout (ConstraintLayout), dùng `<merge>` tag nếu có thể.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Luôn dùng ListAdapter** nếu data thay đổi thường xuyên.
2. **DiffUtil là bắt buộc** cho performance, không bao giờ notifyDataSetChanged.
3. **ViewHolder chỉ hold view reference**, không hold context/activity.
4. **Grid Layout:** Dùng SpanSizeLookup cho item đa dạng kích thước.
5. **Binding Adapter:** Dùng cho UI logic tái sử dụng (image, click).

### Decision Logic (If-Else)
- **Data đổi?** → `ListAdapter` → `submitList(newList)`
- **Data static?** → `RecyclerView.Adapter` → `notifyItem...` nếu cần update.
- **Grid layout?** → `GridLayoutManager` + `spanSizeLookup`.
- **Click/Load Image?** → `Binding Adapter` trong XML.
- **Lag khi scroll?** → Kiểm tra ViewHolder (không leak), check layout depth, đảm bảo DiffUtil đang chạy.

### Top 10 Things to Remember
1. `ListAdapter.submitList()` không sửa list hiện tại, phải tạo mới.
2. `DiffUtil.ItemCallback`: `areItemsTheSame` check ID, `areContentsTheSame` check data.
3. `executePendingBindings()` trong ViewHolder để tránh UI trễ.
4. `GridLayoutManager` mặc định stretch item nếu không dùng SpanSizeLookup.
5. Tránh dùng `context` trong ViewHolder (memory leak).
6. Dùng `viewBinding` thay cho `findViewById` (type-safe).
7. Không thay đổi data source của `currentList` trực tiếp.
8. Multi-view type: Override `getItemViewType`.
9. Animation của ListAdapter tự động, không cần can thiệp thủ công.
10. Nếu list quá lớn, custom DiffUtil để bỏ qua detectMoves.