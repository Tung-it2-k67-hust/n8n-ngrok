# DEVELOPER DECISION GUIDE: Lesson 1 Kotlin basics.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:09:06



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Kotlin Basics
**Khai báo biến và suy diễn kiểu:**
```kotlin
val name = "Alice" // String được suy diễn tự động, không thay đổi được
var age = 25       // Int được suy diễn, có thể thay đổi
age = 26           // Hợp lệ

// val location: String = null // Lỗi biên dịch: Null không được phép
val location: String? = null   // Hợp lệ: Biến có thể null
```

**Toán tử và Logic:**
```kotlin
val a = 10
val b = 3

// Toán tử toán học
println(a / b)  // 3 (chia nguyên)
println(a % b)  // 1 (số dư)

// Toán tử so sánh (Trả về Boolean: true/false)
val isGreater = a > b // true
val isEqual = a == b  // false

// Toán tử logic (Boolean logic)
val andResult = (a > 5) && (b > 0) // true (Cả hai đều đúng)
val orResult = (a < 5) || (b > 5)  // true (Một trong hai đúng)
```

## SECTION 2: DECISION TABLES

### Nhóm dữ liệu: Array vs List

| Tình huống sử dụng | Nên dùng gì | Tại sao (Performance / Mutability) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cần danh sách cố định, truy cập nhanh theo chỉ số (index), chỉnh sửa phần tử tại chỗ. | **Array (`IntArray`, `Array<String>`)** | **Fixed-size & Mutable**: Cấu trúc bộ nhớ cố định, tối ưu cho truy cập ngẫu nhiên (O(1)). | Quên khởi tạo với số lượng phần tử cố định (ví dụ `IntArray(5)`). |
| Danh sách thông thường, kích thước thay đổi (thêm/xóa), không cần quan tâm chỉ số. | **List (`listOf`)** | **Read-only mặc định**: `listOf` trả về immutable list. Dùng `mutableListOf` nếu cần sửa đổi. An toàn hơn Array. | Cố gắng sửa đổi List trả về từ `listOf()` (sẽ báo lỗi biên dịch). |

## SECTION 4: CODE PATTERNS

### Pattern : Xử lý Logic Nhánh rẽ (If/Else & When)

**Code Demo:**

```kotlin
fun evaluateScore(score: Int) {
    // Pattern: If-Else cho logic đơn giản
    if (score >= 50) {
        println("Đậu")
    } else {
        println("Rớt")
    }
}

fun checkAnimalType(animal: String) {
    // Pattern: When (biến thành expression)
    val message = when (animal) {
        "Cat" -> "Meow"
        "Dog" -> "Woof"
        "Cow" -> "Moo"
        else -> "Unknown animal" // Bắt buộc nếu không liệt kê hết
    }
    println(message)
}
```

### Pattern : Vòng lặp và Duyệt Collection

**Khi nào dùng:**
Khi cần xử lý từng phần tử trong danh sách (List/Array).

**Tại sao đúng:**
Sử dụng các hàm duyệt sẵn có của Kotlin (`forEach`, `for`) giúp code ngắn gọn, dễ đọc và tránh lỗi truy cập chỉ số (index) ngoài biên.

**Code Demo:**

```kotlin
fun processList() {
    val numbers = listOf(1, 2, 3, 4, 5)

    // Pattern 1: DuyệtforEach
    numbers.forEach { number ->
        println("Number is $number")
    }

    // Pattern 2: Vòng lặp For (truy cập index nếu cần)
    for (i in numbers.indices) {
        if (numbers[i] == 3) {
            println("Found 3 at index $i")
        }
    }
}
```

### Pattern : Null Safety Safe Calls

**Khi nào dùng:**
Khi làm việc với các biến `Nullable` và bạn muốn thực thi một chuỗi hành động nếu nó không phải null.

**Tại sao đúng:**
Tránh được `if (variable != null)` lồng nhau. `?.` trả về `null` nếu đối tượng null thay vì ném ngoại lệ (Crash).

**Code Demo:**

```kotlin
fun printLength(str: String?) {
    // Safe Call Operator (?.)
    // Nếu str là null, in ra "null".
    // Nếu str có giá trị, in ra độ dài.
    println(str?.length) 
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS


3.  **Quên xử lý Null với `!!` (Bang operator):**
    *   **Tại sao nguy hiểm:** `value!!` ép buộc Kotlin tin rằng biến không null. Nếu giá trị thực sự là `null`, app sẽ **Crash** ngay lập tức. Chỉ dùng khi bạn chắc chắn 100% giá trị không bao giờ null.

fun printLength(text: String?) {
    val length = text!!.length
    println(length)
}

fun main() {
    printLength(null)
} //Exception in thread "main" kotlin.KotlinNullPointerException
text có kiểu String? → có thể là null

text!! nói với Kotlin rằng: “Tin tôi đi, nó không null”

Nhưng thực tế truyền vào null → Crash ngay lập tức

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

*   **Biến:** `val` là vua. Chỉ dùng `var` khi giá trị phải đổi.
*   **Kiểu dữ liệu:** Để Kotlin tự suy diễn (`val x = 10`), chỉ khai báo khi cần thiết (`val x: Int`).
*   **String:** Dùng `""` (dấu ngoặc kép kép) cho `"$variable"` để chèn biến dễ dàng.
*   **Null:** `.` để truy cập thường gây lỗi nếu null. Dùng `?.` để an toàn. Dùng `?:` để gán giá trị mặc định nếu null.

### Decision Logic (If-Else Style)

*   **Nếu** cần lưu trữ 1 giá trị vĩnh viễn? → Dùng `val`.
*   **Nếu** cần danh sách thay đổi kích thước? → Dùng `MutableList`.
*   **Nếu** cần danh sách truy cập nhanh theo index? → Dùng `Array`.
*   **Nếu** cần kiểm tra nhiều điều kiện? → Dùng `When`.
*   **Nếu** biến có thể null? → Dùng `Type?` và xử lý bằng `?.` hoặc `?:`.

### Top 3 Things to Remember

1.  **Immutability First:** Code của bạn sẽ ít bug hơn nếu dữ liệu không thay đổi (`val`).
2.  **Null Safety:** Kotlin bảo vệ bạn khỏi Null Pointer Exception, nhưng bạn phải tuân thủ quy tắc (`?`, `!!`).
3.  **Smart Casting:** Bạn không cần ép kiểu `variable as String` sau khi kiểm tra `if (variable is String)`. Kotlin tự động chuyển đổi.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: KOTHIR BASICS - NUMERIC TYPES & OPERATIONS

### Key Mental Models
**"Type Follows Form"**: The result of an operation always matches the operand types, not the "smartest" type.

```kotlin
// Real-world behavior: Integer division truncates
val result1: Int = 50 / 10      // Result: 5 (Int)
val result2: Int = 1 / 2        // Result: 0 (Int) - TRUNCATED!
val result3: Double = 1.0 / 2.0 // Result: 0.5 (Double) - Correct

// Method call syntax works on primitives via auto-boxing
val times: Int = 2.times(3)     // Result: 6 (Int)
val plus: Double = 3.5.plus(4)  // Result: 7.5 (Double)
```



## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Integer Division
**Khi nào dùng**: When dividing integers but you need a decimal result (e.g., calculating averages).
**Tại sao đúng**: Explicitly casting one operand to Double forces floating-point division, preserving precision.

```kotlin
val totalItems: Int = 5
val activeItems: Int = 2

// WRONG: Int division truncates
val wrongAvg: Double = totalItems / activeItems // Result: 2.0 (2/2 is 1, but logic is 2.5?)

// CORRECT: Promote to Double first
val correctAvg: Double = totalItems.toDouble() / activeItems // Result: 2.5
```

### Pattern 2: Overflow-Safe Large Numbers
**Khi nào dùng**: When dealing with IDs, timestamps, or counts that exceed 2 billion.
**Tại sao đúng**: Using `Long` prevents overflow errors.

```kotlin
// Standard Int: Max 2,147,483,647
val userId: Int = 1_000_000_000
val nextId: Int = userId + 1_000_000_000 // Overflow: Becomes negative!

// Safe Long: Max 9,223,372,036,854,775,807
val safeUserId: Long = 1_000_000_000L // Note the 'L' suffix
val nextSafeId: Long = safeUserId + 1_000_000_000L // Result: 2,000,000,000 (Correct)
```

### Pattern 3: Readable Magic Numbers
**Khi nào dùng**: When defining constants that represent large quantities (e.g., memory sizes, currency).
**Tại sao đúng**: Underscores improve readability and reduce counting errors.

```kotlin
// Hard to read
val cacheSize = 1048576
val accountBalance = 5000000000

// Easy to read
val cacheSize = 1_048_576
val accountBalance = 5_000_000_000
val networkPacket = 0b11010010_01101001 // Binary split
```

### Pattern 4: Explicit Type Casting
**Khi nào dùng**: Assigning a larger type (Int) to a smaller type (Byte/Short).
**Tại sao đúng**: Direct assignment causes compile errors (safety). `.toByte()` makes the data loss explicit.

```kotlin
val temperatureCelsius: Int = 25

// Compile Error: Type mismatch
// val byteTemp: Byte = temperatureCelsius 

// Explicit casting (Safe if value fits in Byte range -128 to 127)
val byteTemp: Byte = temperatureCelsius.toByte()
```

---

### Top 3 Things to Remember
1. **1 / 2 = 0**: Integer division truncates. Use `1.0 / 2.0` (Double) or `1 / 2.0` (Double) for 0.5.
2. **Type Follows Operand**: `Int + Int = Int`. `Int + Double = Double`.
3. **Readability**: Use underscores (`_`) for large numbers (e.g., `1_000_000`).

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Kotlin Basics (Lesson 1)

## SECTION 1: CORE MENTAL MODEL

### 1.1. Core Concepts (EN + VI)

**String (Chuỗi ký tự)**
- Chuỗi là chuỗi các ký tự được đặt trong dấu nháy kép (`""`).
- Hỗ trợ các ký tự đặc biệt (escape characters) như `\n`.
- **Raw String (Chuỗi thô)**: Dùng `"""` để chứa văn bản đa dòng, bỏ qua các ký tự escape.

```kotlin
// Chuỗi thông thường
val normalStr = "Hello\nWorld"

// Chuỗi thô (Raw String) - ideal cho SQL, JSON, XML
val rawStr = """
    SELECT * 
    FROM Users 
    WHERE id = 1
"""


**val vs var**
- **`val` (Value)**: Khởi tạo **một lần**, không thể gán lại (immutable). Tương đương `final` trong Java. **LUÔN ưu tiên dùng `val`**.
- **`var` (Variable)**: Có thể thay đổi giá trị và gán lại (mutable).

```kotlin
// val: Không thay đổi được
val userId = 100
// userId = 101 // Lỗi biên dịch

// var: Có thể thay đổi
var counter = 0
counter = 1 // Hợp lệ
```

**String Template (Mẫu chuỗi)**
Cách chèn biến hoặc biểu thức trực tiếp vào chuỗi mà không cần nối chuỗi thủ công (`+`).
- Dấu `$` để chèn biến.
- Dấu `${}` để chèn biểu thức phức tạp.

```kotlin
val balance = 1000
val fee = 50

// Chèn biến
val msg1 = "Số dư: $balance"

// Chèn biểu thức
val msg2 = "Tổng tiền phải trả: ${balance + fee}"
```

### 1.2. Why this approach is better?
- **`val` vs `var`**: Giảm thiểu trạng thái biến đổi (mutability), giúp code dễ debug và an toàn hơn trong đa luồng (multithreading).
- **String Template**: Đọc được intentions (ý định) rõ ràng hơn là nối chuỗi bằng `+`, tránh lỗi logic tính toán.

---

## SECTION 2: DECISION TABLES

### Table 2.2: Chuỗi thường vs Chuỗi thô

| Tình huống sử dụng | Nên dùng gì | Tại sao? (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Chuỗi ngắn, message đơn giản | **`""` (Double Quotes)** | Tiết kiệm chiều dài, dễ nhìn cho các chuỗi 1 dòng. | Dùng `"""` cho chuỗi ngắn导致 code rườm rà. |
| SQL, XML, JSON, HTML hoặc multiline text | **`"""` (Triple Quotes)** | **Raw String**: Giữ nguyên định dạng, không cần escape characters (`\n`, `\"`). | Dùng `""` + `+` + `\n` để build SQL/JSON导致 lỗi syntax khó sửa. |

### Table 2.3: Concatenation (`+`) vs Template (`$`)

| Tình huống sử dụng | Nên dùng gì | Tại sao? (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Ghép nhiều biến hoặc logic phức tạp | **String Template (`${}`)** | Dễ đọc, compact, không cần toán tử nối chuỗi. | Lăn tăn dùng `val s = "A" + x + "B"` thay vì `"A${x}B"`. |
| Nối chuỗi với một phần tử duy nhất | **Template (`$`)** | Trực quan và nhanh hơn so với `+`. | Biến đổi sang `StringBuilder` quá sớm khi chưa cần tối ưu. |

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Safe Initialization" Pattern (Using `val`)

**Tại sao đúng:**
Tuân thủ nguyên lý immutability. Tránh việc vô tình sửa đổi giá trị gốc gây lỗi logic.

```kotlin
class User {
    // Luôn dùng val cho ID hoặc dữ liệu cố định
    val id: Int = 1
    var username: String = ""

    fun updateName(newName: String) {
        // Không sửa id, chỉ sửa username (var)
        username = newName
    }
}
```

### Pattern 2: String Formatting for Logs/Messages

**Khi nào dùng:**
Khi cần tạo log message, thông báo UI hoặc query database có chứa nhiều tham số biến.

**Tại sao đúng:**
Dễ đọc, dễ maintain, không lo lỗi thứ tự tham số như kiểu `printf`.

```kotlin
fun generateOrderMessage(items: Int, total: Double): String {
    val header = "Don Hang Moi"
    
    // Dùng template expression ${} cho logic hoặc format phức tạp
    return """
        $header
        So luong: $items
        Thanh tien: $total VND
        Giam gia: ${if (items > 10) "Co" else "Khong"}
    """.trimIndent() // .trimIndent() xóa khoảng trắng thừa ở đầu dòng
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 2. String Concatenation Hell (`+` quá nhiều)
- **Lý do nguy hiểm:** Code `s1 + s2 + s3` tạo ra nhiều object String rác (garbage) gây tốn bộ nhớ, và rất khó đọc khi có nhiều biến.
- **Khắc phục:** Dùng **String Template** (`$` và `${}`) hoặc nếu loop nối chuỗi thì dùng `StringBuilder`.

### 3. Quên Escape Characters trong String thường
- **Lý do nguy hiểm:** Dùng `"` trong chuỗi `"` làm gãy chuỗi, gây lỗi biên dịch.
- **Khắc phục:** Dùng **Raw String** (`"""`) nếu chuỗi chứa nhiều dấu nháy kép hoặc định dạng phức tạp.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 3 Things To Remember
1.  **Immutability First**: `val` > `var`.
2.  **Readability**: Template (`$`) > Concat (`+`).
3.  **Type Safety**: Kiểu biến không đổi sau khi biên dịch (Static Typing).

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Kotlin Control Flow (Lesson 1)

## SECTION 1: CORE MENTAL MODEL

### Key Mental Model
- **Logic là data**: Trong Kotlin, `if` và `when` là **expressions** (trả về giá trị), không chỉ là statements. Gán kết quả trực tiếp vào biến để thay thế toán tử 3 ngôi (?:).
- **Smart Casting**: Kiểm tra type trong `when` sẽ tự động cast variable sang type đó trong scope.
- **Độ ưu tiên**: `When` > `If-Else` (khi ≥2 điều kiện), `For` với Range/Collection > `While` (trừ trường hợp lặp vô tận).


### Why This Approach
- **Kotlin Style Guide**: `When` được khuyến khích cho branch logic, giúp code "expression-oriented" và dễ bảo trì.
- **Performance**: `When` với `in` range hoặc object check được tối ưu thành `tableswitch` bytecode (O(1) lookup).
- **Null Safety**: `When` bắt buộc xử lý tất cả nhánh hoặc dùng `else`, tránh lỗi runtime.

---

## SECTION 2: DECISION TABLES

### Table 1: If/Else vs When (Điều kiện nhánh)
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN + VI | Sai lầm thường gặp |
|--------------------|-------------|-------------------|---------------------|
| 1-2 điều kiện đơn giản | `if (condition) { } else { }` | **Simplicity**: Code ngắn, dễ đọc cho logic boolean cơ bản | Dùng `when` cho 1 điều kiện → thừa,冗余 |
| ≥3 điều kiện hoặc giá trị enum/string | `when (variable) { ... }` | **Readability & Maintainability**: Dễ thêm nhánh, tối ưu bytecode, compile-time checking | Viết `if (x == A) else if (x == B)...` → khó bảo trì, dễ quên `else` |
| Kiểm tra phạm vi (range) | `when { x in 1..100 -> }` | **Conciseness**: `in` operator directly supported, không cần nested `if` | Dùng `if (x >= 1 && x <= 100)` → verbose, dễ gõ sai toán tử |
| Trả về giá trị | `val result = when { ... }` | **Expression**: Gán trực tiếp, thay thế ternary operator | Gọi `when` xong mới `return` → không dùng được value |

### Table 2: For Loop vs While Loop (Vòng lặp)
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN + VI | Sai lầm thường gặp |
|--------------------|-------------|-------------------|---------------------|
| Lặp qua collection/array | `for (item in collection)` | **Iterator Safety**: Tự động xử lý iterator, tránh lỗi `IndexOutOfBoundsException` | Dùng `while` với index thủ công → dễ tràn index, code dài |
| Lặp có步长 (step) hoặc range | `for (i in 1..100 step 2)` | **Built-in Range Support**: `downTo`, `step` là keywords, không cần tính toán | Tính `i += 2` trong `while` → dễ sai logic, không handle negative range |
| Lặp vô tận hoặc điều kiện phức tạp | `while (condition) { }` hoặc `do { } while` | **Conditional Execution**: Duyệt khi điều kiện thay đổi runtime, không xác định trước số lần | Dùng `for` với vô hạn → compile error hoặc infinite loop không break |
| Cần index + element | `for ((idx, elem) in collection.withIndex())` | **Destructuring**: Truy cập đồng thời index và element, không cần map thủ công | Lặp 2 lần: lần 1 get index, lần 2 get element → inefficiency |

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Range Validation with When
**Khi nào dùng**: Kiểm tra input người dùng (tuổi, số lượng, score) có trong phạm vi hợp lệ.
**Tại sao đúng**: Dùng `in` + `when` để validate rõ ràng, return value trực tiếp.

```kotlin
fun validateAge(age: Int): String {
    return when {
        age < 0 -> "Tuổi không hợp lệ"
        age in 0..17 -> "Người chưa đủ tuổi"
        age in 18..65 -> "Người lao động"
        age > 65 -> "Người cao tuổi"
    }
}

// Usage
val result = validateAge(25) // "Người lao động"
```

### Pattern 2: For Loop with Destructuring
**Khi nào dùng**: Duyệt qua `Map` hoặc `List` cần cả key và value/index.
**Tại sao đúng**: `withIndex()` + destructuring = một dòng code, không cần biến phụ.

```kotlin
val tasks = listOf("Code", "Test", "Deploy")

for ((index, task) in tasks.withIndex()) {
    println("Công việc $index: $task")
}
```

### Pattern 3: While Loop with Break Condition
**Khi nào dùng**: Xử lý queue/stack hoặc retry logic until success.
**Tại sao đúng**: Kiểm tra điều kiện trước, `break` sớm khi đạt mục tiêu, tránh infinite loop.

```kotlin
var attempts = 0
val maxAttempts = 3

while (attempts < maxAttempts) {
    attempts++
    if (connectToServer()) break // Thoát sớm nếu thành công
    println("Thử lại lần $attempts")
}

println("Kết quả: ${if (attempts < maxAttempts) "Thành công" else "Thất bại"}")
```

### Pattern 4: When with Type Check
**Khi nào dùng**: Xử lý polymorphic input (JSON, Message, Event).
**Tại sao đúng**: `is` keyword auto smart cast, không cần manual cast.

```kotlin
fun processInput(input: Any) {
    when (input) {
        is String -> println("Chuỗi có độ dài ${input.length}")
        is Int -> println("Số nguyên: ${input * 2}")
        is List<*> -> println("List có ${input.size} phần tử")
        else -> println("Kiểu không xác định")
    }
}
```

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **If/When**: ≥3 branch → `when`, ≤2 → `if`. Luôn dùng `when` làm expression.
2. **Loop**: Collection/Ranges → `for`. Điều kiện thay đổi/unknown → `while`.
3. **Range**: Không space: `a..b`. Kiểm tra: `in a..b`. Step: `a..b step s`.
4. **Index**: Dùng `withIndex()` + destructuring, không đếm tay.
5. **Break**: Trong `while` luôn có `break` logic để tránh infinite loop.


### Top 10 Things to Remember
1. `when` là expression → gán `val result = when { }`.
2. `in 1..100` kiểm tra phạm vi, không có spaces.
3. `for ((i, v) in list.withIndex())` để lấy index.
4. `for (i in 1..5 step 2)` → 1, 3, 5.
5. `for (i in 5 downTo 1)` → 5, 4, 3, 2, 1.
6. `while` có thể infinite → luôn có điều kiện break.
7. `do/while` chạy ít nhất 1 lần.
8. `when` với `is` auto smart cast.
9. `when` phải exhaustive (có `else` hoặc covering all cases).
10. `for` không cần iterator variable.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Kotlin Basics (Lesson 1)

## SECTION 1: CORE MENTAL MODEL

### Key Mental Models
- **"Val vs Var on Collections"**: If you declare a collection with `val`, you cannot reassign the variable to a new collection. However, if the collection is **Mutable**, you can still change its *internal* contents.
- **Arrays are Low-Level**: Arrays in Kotlin are closer to Java arrays. They are performance-critical for primitives and have a fixed size. Use Lists for general application logic.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Defining a static list of constants** (e.g., menu items, tags) | `listOf("A", "B")` | **Immutability (Bất biến)**: Prevents accidental modification. Optimized for reading. | Trying to `.add()` or `.remove()` items later, causing a compilation error. |
| **Building a list dynamically** (e.g., adding user inputs) | `mutableListOf()` | **Mutability (Có thể thay đổi)**: Required to add/remove items after initialization. | Forgetting to initialize with `val` properly; confusing reassignment with mutation. |
| **Fixed-size collection of primitives** (e.g., pixel buffer, math vectors) | `intArrayOf()`, `arrayOf()` | **Performance (Hiệu suất)**: Avoids boxing overhead for primitives. Fixed size is acceptable. | Trying to change the array size (e.g., adding an element beyond index). |
| **Unknown size or mixed types** | `arrayOf()` or `List` | **Flexibility**: Can hold different types (e.g., `String`, `Int`). | Using this for strictly typed, high-performance loops; leads to casting issues. |

---

### Data Flow
```text
Initialization → Access → Modification
     |              |           (Only for Mutable types)
     v              v           v
 listOf()      [index]      No (Error)
 mutableListOf() [index]    Yes (.add/.remove)
 arrayOf()      [index]      Yes (Index assignment)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Read-Only Pipeline
**Khi nào dùng**: When you have data that shouldn't change once defined (configuration, constants).
**Tại sao đúng**: Enforces data integrity and prevents side effects.

```kotlin
fun main() {
    // 1. Define using val + listOf for safety
    val tools = listOf("Hammer", "Wrench", "Screwdriver")

    // 2. Iterate safely (Standard For-Loop)
    for (tool in tools) {
        println("Tool: $tool")
    }

    // 3. Access by index
    val firstTool = tools[0] // "Hammer"
}
```

### Pattern 2: The Dynamic Builder
**Khi nào dùng**: When processing input or accumulating results (e.g., collecting API responses).
**Tại sao đúng**: `mutableListOf` allows the collection to grow/shrink as data arrives.

```kotlin
fun main() {
    // 1. Initialize empty mutable list
    val userInputs = mutableListOf<String>()

    // 2. Add items dynamically
    userInputs.add("First")
    userInputs.add("Second")
    
    // 3. Remove item (Boolean return)
    val wasRemoved = userInputs.remove("First") 

    println(userInputs) // Output: [Second]
}
```

### Pattern 3: Primitive Arrays for Performance
**Khi nào dùng**: When dealing with large amounts of numbers (integers, doubles) where memory matters.
**Tại sao đúng**: `intArrayOf` stores primitives directly, avoiding the overhead of `List<Int>`.

```kotlin
fun main() {
    // 1. Specific type array
    val scores = intArrayOf(10, 20, 30)

    // 2. Combining arrays
    val newScores = intArrayOf(40, 50)
    val allScores = scores + newScores // [10, 20, 30, 40, 50]

    // 3. Modifying in place
    scores[0] = 100 
}
```


---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
- **`listOf()`**: Read-only. Use for constants.
- **`mutableListOf()`**: Read/Write. Use for dynamic data.
- **`arrayOf()`**: Fixed size. Use for primitives or specific Java interop.
- **`val`**: Cannot reassign the variable.
- **`var`**: Can reassign the variable.
- **Rule of thumb**: If `val` + `mutableListOf()`, you can change contents but not the list object itself.

### Decision Logic
```text
Is the data size fixed?
  YES → Use Array (intArrayOf, arrayOf)
  NO  → Continue

Do you need to add/remove items later?
  YES → Use MutableList
  NO  → Use List (listOf)
```

### Top 3 Things to Remember
1. **Null Safety**: Lists created with `listOf()` are never null (but can be empty). Nulls *inside* the list are allowed unless specified.
2. **Type Inference**: Kotlin infers types. `listOf(1, "A")` creates `List<Any>`.
3. **Combined Arrays**: The `+` operator works for arrays, but it creates a **new** array; it does not modify the original.

<!-- CHUNK 51-59 -->

# DEVELOPER DECISION GUIDE: Kotlin Null Safety
---

## SECTION 2: DECISION TABLES

### Table 1: Handling Null Variables
| Tình huống sử dụng | Nên dùng gì | Tại sao - Safe Call Operator (`?.`) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Truy cập thuộc tính của object có thể null (VD: `user?.name`) | **`?.`** | **Safe Call**: Nếu object null, dòng code bỏ qua việc truy cập thay vì crash. Trả về `null` nếu object null. | Dùng `.` thay cho `?.`导致 crash. |
| Cần trả về giá trị mặc định nếu null (VD: `count ?: 0`) | **`?:`** | **Elvis Operator**: Cung cấp giá trị fallback (mặc định) ngay lập tức nếu biến null. | Viết dài dòng: `if (count != null) count else 0`. |
| Buộc biến không null (khi bạn chắc chắn 100%) (VD: `val len = s!!.length`) | **`!!`** | **Non-null Assertion**: Dùng khi logic code đảm bảo biến không null, hoặc bạn đang build prototype. | Lạm dụng `!!` trong code production, dễ gây crash nếu logic sai. |

### Table 2: Variables Declaration
| Tình huống sử dụng | Nên dùng gì | Tại sao - Nullable Type (`?`) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Biến nhận dữ liệu từ API hoặc User Input | **`Type?`** | **Safety**: Dữ liệu đầu vào không bao giờ an toàn tuyệt đối. Khai báo nullable bắt buộc phải xử lý. | Khai báo `Type` (non-null) nhưng gán `null` được (Compiler error). |
| Biến khởi tạo ngay và không bao giờ thay đổi thành null | **`val: Type`** | **Guarantee**: Compiler đảm bảo biến luôn có giá trị, bạn không cần kiểm tra null mỗi khi dùng. | Khai báo `var` (mutable) khi không cần thiết, làm code phức tạp. |

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Traversal (Duyệt an toàn)
**Khi nào dùng:** Khi truy cập chuỗi các đối tượng có thể null (VD: User có thể có Address, Address có thể có ZipCode).

**Tại sao đúng:** Ngăn ngừa "Chain Null Pointer". Nếu một mắt xích trong chuỗi null, toàn bộ chuỗi trả về null ngay lập tức thay vì crash.

```kotlin
// Mô hình thực tế: Lấy Zip Code an toàn
data class Address(val zipCode: String?)
data class User(val address: Address?)

fun getZipCode(user: User?): String? {
    // Dùng Safe Call nối chuỗi
    return user?.address?.zipCode
}

fun main() {
    val user: User? = User(Address("10000"))
    val userNull: User? = null
    
    println(getZipCode(user))     // In ra: 10000
    println(getZipCode(userNull)) // In ra: null (Không crash)
}
```

### Pattern 2: Default Value Injection (Xử lý giá trị rỗng)
**Khi nào dùng:** Hiển thị dữ liệu lên UI hoặc tính toán số học, nơi `null` không được phép.

**Tại sao đúng:** Biến đổi nullable thành non-null để các function tiếp theo có thể làm việc bình thường.

```kotlin
// Mô hình thực tế: Đếm số lượng sách
fun processBookCount(countInput: Int?): String {
    // Elvis operator để gán mặc định 0 nếu null
    val count = countInput ?: 0
    
    return if (count > 0) "Có $count cuốn sách" else "Không có sách"
}

fun main() {
    println(processBookCount(null))  // In ra: "Không có sách"
    println(processBookCount(5))     // In ra: "Có 5 cuốn sách"
}
```

### Pattern 3: The "Let" Transformation (Biến đổi an toàn)
**Khi nào dùng:** Khi bạn muốn thực thi block code chỉ khi biến không null.

**Tại sao đúng:** Kết hợp `?.` và `let` để scope biến, tránh việc dùng lại tên biến null.

```kotlin
// Mô hình thực tế: Gửi thông báo nếu có token
fun sendNotification(token: String?) {
    // Chỉ vào block này nếu token != null
    token?.let { nonNullToken ->
        println("Sending push to: $nonNullToken")
        // nonNullToken ở đây là String (không cần ?)
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Lạm dụng `!!` (Non-null Assertion Abuse)
**Tại sao nguy hiểm:**
- Viết `val len = s!!.length` là bạn đang "đánh bạc" với compiler.
- Nếu `s` là `null`, app sẽ crash ngay lập tức (`NullPointerException`).
- **Cấm dùng** trong code production trừ khi bạn chắc chắn 100% dữ liệu không null (rất hiếm khi xảy ra).

### 2. Bỏ qua giá trị trả về của Safe Call
**Tại sao nguy hiểm:**
- Biểu thức `user?.name` trả về `String?`.
- Nếu bạn gán `val name: String = user?.name`, compiler sẽ lỗi (không thể gán nullable vào non-null).
- **Luôn luôn** dùng `?:` hoặc kiểm tra null sau khi dùng `?.` nếu bạn cần giá trị cụ thể.

### 3. Kiểm tra null nhưng không "Smart Cast"
**Tại sao nguy hiểm:**
- Sai:
  ```kotlin
  if (x != null) {
      // Phải dùng x!! hoặc x?. vì compiler chưa smart cast (nếu x là mutable var)
  }
  ```
- Đúng: Dùng `val` và `?.`, `?:` hoặc kiểm tra immutable variable trước khi dùng.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

1. **Cần truy cập thuộc tính/ method?**
   - Nếu biến có thể là `null` -> Dùng **`?.`** (VD: `data?.call()`)
   - Nếu biến KHÔNG bao giờ null -> Dùng **`.`** (VD: `data.call()`)

2. **Biến có `null`, nhưng bạn cần một giá trị để làm việc?**
   - Dùng **`?:`** để gán giá trị mặc định (VD: `val x = y ?: 0`)

3. **Bạn chắc chắn biến không null?**
   - Dùng **`!!`** (Cảnh báo: Sẵn sàng crash nếu sai)

4. **Khai báo biến?**
   - Dữ liệu bắt buộc có -> `val name: String`
   - Dữ liệu có thể vắng -> `val name: String?`

### Top 5 Things To Remember
1. **`?`** sau kiểu dữ liệu = Cho phép `null`.
2. **`?.`** = Gọi an toàn, trả về `null` nếu thất bại.
3. **`?:`** = Cung cấp giá trị thay thế (Default).
4. **`!!`** = Ném Exception nếu `null` (Tránh dùng).
5. **Smart Cast**: Compiler tự động xử lý null sau khi kiểm tra `if (x != null)`.