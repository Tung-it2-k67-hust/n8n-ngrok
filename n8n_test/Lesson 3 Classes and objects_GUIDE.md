# DEVELOPER DECISION GUIDE: Lesson 3 Classes and objects.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:19:06



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Classes and Objects

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Primary Constructor vs Secondary Constructor

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Khởi tạo đơn giản, dependency injection | **Primary Constructor** | Native syntax, ngắn gọn, IDE support tốt nhất. | Viết logic phức tạp trong primary constructor (nên dùng `init`). |
| Cần nhiều cách khởi tạo khác nhau (Overloading) | **Secondary Constructor** | Đa dạng hóa cách tạo đối tượng. | Lặp lại code khởi tạo (bỏ qua `this(...)` call). |
| Logic khởi tạo phức tạp (kiểm tra điều kiện) | **Primary + `init` block** | Tách biệt logic khỏi tham số constructor. | Đặt logic nặng ngay trong tham số constructor. |

### Table 2: Constructor Parameters (No modifier vs val/var)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cần dùng tham số chỉ trong lúc khởi tạo (validate/format) | **Không modifier** (ví dụ: `x: Int`) | Tiết kiệm bộ nhớ, không giữ lại sau khi constructor chạy xong. | Khai báo `val` khi không cần giữ giá trị, gây lãng phí. |
| Cần lưu trữ tham số làm thuộc tính Class | **`val` hoặc `var`** | Tự động tạo property (thuộc tính) truy cập được khắp Class. | Quên khai báo `val`/`var` → không thể truy cập biến đó ở hàm khác. |

### Table 3: Default Parameters vs Constructor Overloading

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Các tham số có giá trị mặc định hợp lý (ví dụ: timeout = 5s) | **Default Parameters** | Giảm số lượng constructor, code gọi rõ ràng (Named Arguments). | Viết quá nhiều secondary constructor chỉ để set default value. |
| Các tham số bắt buộc hoặc logic khởi tạo khác nhau hoàn toàn | **Constructor Overloading** | Buộc người dùng phải cung cấp đủ thông tin quan trọng. | Dùng default parameters cho các biến bắt buộc (dễ gây sai lệch logic). |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### Lifecycle & Hierarchy

```text
[Blueprint: Class Definition]
       |
       +--> (Khi gọi: val x = Class(args))
       |
[Memory: Object Instance (Heap)]
       |
       +--> Contains: [Properties] + [Methods]
```

### Dependency Flow (Cú pháp Kotlin)

```text
Class Definition
├── Primary Constructor (Trong header)
│   ├── Parameter (Không modifier)  ---> Scope: Constructor Only
│   └── Parameter (val/var)         ---> Becomes: Class Property
│
└── init Blocks                     ---> Executes on Instantiation
    │
    └── Secondary Constructors      ---> Must call Primary (via this()) or init
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: The Immutable Data Class (DTO)

**Khi nào dùng:** Khi bạn cần truyền dữ liệu giữa các layer (API response, Database row) mà không muốn thay đổi dữ liệu đó.

**Tại sao đúng:** `val` properties đảm bảo dữ liệu không bị thay đổi ngẫu nhiên (thread-safe và dễ debug).

```kotlin
class UserResponse(
    val id: Long,
    val username: String,
    val email: String
) {
    // Logic phụ (ví dụ: tạo display name)
    val displayName: String
        get() = "$username (#$id)"
}
```

### Pattern 2: Configurable Builder (Default Params)

**Khi nào dùng:** Khi khởi tạo một object có nhiều optional settings (ví dụ: API Client, UI View).

**Tại sao đúng:** Tránh "Constructor Hell" (quá nhiều overload), tận dụng Named Arguments để code tự mô tả.

```kotlin
class ApiClient(
    val baseUrl: String,
    val timeout: Int = 30,      // Default
    val retryCount: Int = 3,    // Default
    val loggingEnabled: Boolean = false
)

// Sử dụng linh hoạt
val client1 = ApiClient("https://api.com")
val client2 = ApiClient("https://secure.com", timeout = 60, loggingEnabled = true)
```

### Pattern 3: Initialization Logic (init block)

**Khi nào dùng:** Khi cần validate dữ liệu đầu vào hoặc chuẩn bị resource phức tạp trước khi object hoạt động.

**Tại sao đúng:** Tách biệt logic "setup" khỏi khai báo biến, đảm bảo object luôn ở trạng thái hợp lệ.

```kotlin
class Rectangle(val w: Int, val h: Int) {
    init {
        require(w > 0) { "Width must be positive" }
        require(h > 0) { "Height must be positive" }
        println("Rectangle created with area: ${w * h}")
    }
}
```
--------------------------------

# Developer Decision Guide: Classes & Objects (Lesson 3)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **Class (Lớp):** A blueprint for creating objects. It defines the structure (properties) and behavior (functions) that the objects will have.
*   **Object (Đối tượng):** An instance of a class. It is a concrete entity created from the class blueprint, holding actual data.
*   **Primary Constructor (Constructor chính):** Defined directly in the class header. It is the most concise way to declare properties and initialize an object. It has no body if `init` blocks are not used.
*   **Secondary Constructor (Constructor phụ):** Defined using the `constructor` keyword inside the class body. Used to provide alternative ways to create an object.
*   **Init Block (Khối khởi tạo):** A special block of code (`init`) that is executed when an object is created. It is part of the primary constructor's execution.
*   **Property (Thuộc tính):** Data stored in an object, defined by `val` (read-only) or `var` (mutable). Accessed via dot notation (`object.property`).
*   **Custom Accessors (Truy cập tùy chỉnh):** Logic defined to override the default behavior of getting (`get()`) or setting (`set()`) a property's value.
*   **Member Function (Phương thức thành viên):** A function defined inside a class that performs actions related to the object's state.
---

## SECTION 2: DECISION TABLES

### Primary vs. Secondary Constructors
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Simple object creation** (e.g., `User(id: Int)`)| **Primary Constructor** | Concise syntax; automatically promotes parameters to class properties. | Defining properties inside the class body when they could be defined in the constructor header. |
| **Multiple ways to init** (e.g., `Circle(radius)` vs `Circle(diameter)`)| **Secondary Constructors** | Provides flexibility for different input formats while centralizing logic. | Creating secondary constructors that duplicate logic instead of calling `this(...)`. |
| **Complex initialization logic** (e.g., validation, setup)| **Init Block** | Runs automatically after property assignment; ensures object validity. | Putting complex logic inside the constructor header (syntax error) or forgetting `init`. |

| Custom Accessor Usage | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Value depends on other properties** | **Custom Getter** | Computed properties are efficient (calculated on access) and prevent data duplication. | Storing calculated values in a `var` manually, leading to stale data if dependencies change. |
| **Enforcing validation/formatting** | **Custom Setter** | Protects the object's internal state (Encapsulation) and ensures data integrity. | Forgetting to assign the backing `field` (e.g., `field = value`), effectively making the property read-only. |

---


---

## SECTION 4: CODE PATTERNS

### Pattern: Multiple Constructors with Delegation
**Khi nào dùng:** Khi bạn cần cung cấp nhiều cách để khởi tạo đối tượng, nhưng logic chung chỉ được viết một lần.
**Tại sao đúng:** Tránh lặp lại mã (DRY - Don't Repeat Yourself) và đảm bảo rằng mọi cách khởi tạo đều đi qua cùng một logic khởi tạo chính.

```kotlin
class User(val username: String, val age: Int) {
    
    // Primary Constructor (defining properties)

    // Secondary Constructor 1: Creates a default age
    constructor(name: String) : this(name, 18) {
        // Logic specific to this constructor
        println("User created with default age")
    }

    // Secondary Constructor 2: Creates from a formatted string
    constructor(data: String) : this(data.substringBefore(","), data.substringAfter(",").toInt()) {
        println("User parsed from string")
    }

    init {
        println("User $username initialized. Age: $age")
    }
}

fun main() {
    val u1 = User("Alice") // Calls secondary constructor 1
    val u2 = User("Bob,25") // Calls secondary constructor 2
}
```

### Pattern: Custom Getters & Setters (Computed Properties)
**Khi nào dùng:** Khi một thuộc tính không được lưu trữ trực tiếp, mà là kết quả của logic khác hoặc cần kiểm tra dữ liệu vào/ra.
**Tại sao đúng:** Giảm bộ nhớ (không lưu trữ dữ dư thừa) và tăng tính an toàn của dữ liệu (data integrity).

```kotlin
class FullPerson(var firstName: String, var lastName: String) {

    // Custom Getter: Computed value, not stored
    val fullName: String
        get() = "$firstName $lastName"

    // Custom Setter: Intercepting assignment
    var identifier: String = "INIT"
        set(value) {
            if (value.length < 5) {
                println("Error: Identifier too short!")
            } else {
                // 'field' is the backing field. MUST assign to it.
                field = value 
            }
        }
}

fun main() {
    val p = FullPerson("John", "Doe")
    println(p.fullName) // Triggers getter
    
    p.identifier = "AB" // Triggers setter (prints error)
    p.identifier = "VALID_ID" // Triggers setter (updates field)
    println(p.identifier)
}
```

### Pattern: Init Block for Validation
**Khi nào dùng:** Khi các thuộc tính cần được kiểm tra tính hợp lệ ngay lập tức sau khi tạo đối tượng.
**Tại sao đúng:** Nếu dữ liệu không hợp lệ, đối tượng không bao giờ được tạo thành công (ném ngoại lệ), tránh các lỗi phức tạp về sau.

```kotlin
class BankAccount(val balance: Double) {
    
    init {
        // Logic chạy ngay khi object được tạo
        if (balance < 0) {
            throw IllegalArgumentException("Balance cannot be negative")
        }
        println("Account created with balance: $balance")
    }
}
```
---
## SECTION 2: DECISION TABLES
### Table 1: Inheritance (Class) vs Interface
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Các class có **quan hệ cha con thực sự** (VD: Animal -> Dog) và **chia sẻ trạng thái chung** (properties). | **Inheritance (open class)** | **Code Reusability (Tái sử dụng mã)**: Class con được kế thừa code và state của cha mà không cần viết lại. | Dùng Interface khi cần giữ state chung (bắt buộc phải tự implement lại property). |
| Các class khác biệt về bản chất nhưng cần **thực thi cùng một hành vi** (VD: Savable, Printable). | **Interface** | **Multiple Inheritance (Kế thừa đa hình)**: Một class có thể implement nhiều interface. | Dùng Class cha để ép các class không cùng dòng dõi phải kế thừa, gây rối loạn hierarchy. |

### Table 2: Class Structure Decision
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Class chỉ chứa **logic chưa cài đặt** và bắt buộc class con phải định nghĩa. | **Abstract Class** | **Bắt buộc cài đặt**: Ép buộc override phương thức trừu tượng (`abstract`), nhưng vẫn giữ được logic nền tảng. | Implement sai lệch: Để class trừu tượng có constructor públic (không cần thiết vì không thể khởi tạo trực tiếp). |
| Class cần cho phép **kế thừa hoặc ghi đè** phương thức. | **`open` keyword** | **Control (Kiểm soát)**: Kotlin khóa `final` mặc định để bảo vệ design. Phải dùng `open` để bỏ khóa. | Quên `open` khi cần override, dẫn đến lỗi biên dịch không rõ ràng. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy Text Diagram

```text
[Giả sử chúng ta có hệ thống Hình học]

1. Level Abstract (Khung sườn):
   abstract class Shape (open) -> Define calculateArea() ABSTRACT

2. Level Implementation (Cụ thể):
   class Circle : Shape (override calculateArea)
   class Rectangle : Shape (override calculateArea)

3. Level Interface (Khả năng mở rộng):
   interface Drawable -> fun draw()

4. Level Composite (Kết hợp):
   class ColoredCircle : Shape, Drawable 
   (Kế thừa tính toán từ Shape, Tuân thủ hợp đồng Drawable)
```

### Relationship Rules
*   **Is-A (Là một loại)**: Dùng **Inheritance**. (Ví dụ: Dog là một loại Animal).
*   **Can-Do (Có thể làm)**: Dùng **Interface**. (Ví dụ: Circle có thể được Vẽ - Drawable).
*   **Has-A (Có một)**: Dùng **Property/Composition**. (Ví dụ: Car có Engine - không kế thừa).

---

## SECTION 4: CODE PATTERNS

### Pattern 1: The Strict Hierarchy (Inheritance)

**Khi nào dùng:** Khi bạn có các class con chia sẻ logic cơ bản và state từ class cha, và bạn muốn tái sử dụng code cha.
**Tại sao đúng:** Giảm trùng lặp mã (DRY) và ép buộc cấu trúc tree.

```kotlin
// 1. Base Class (Cha) - Phải open
open class Animal(val name: String) {
    // Phải open nếu muốn override
    open fun makeSound() {
        println("$name makes a sound")
    }
}

// 2. Subclass (Con) - Kế thừa state và logic
class Dog(name: String) : Animal(name) {
    // Override để thay đổi hành vi
    override fun makeSound() {
        println("$name barks: Woof!")
    }
}

// Usage
val myDog = Dog("Buddy")
myDog.makeSound() // Output: Buddy barks: Woof!
```

### Pattern 2: The Contract (Interface)

**Khi nào dùng:** Khi các class cần chia sẻ hành vi nhưng không cùng nguồn gốc hoặc cần đa kế thừa.
**Tại sao đúng:** Tách biệt giữa "là gì" (Class cha) và "có thể làm gì" (Interface).

```kotlin
// 1. Define Contract
interface Reportable {
    fun generateReport(): String
}

// 2. Implement trong class khác nhau
class User : Reportable {
    override fun generateReport() = "User Report"
}

class Order : Reportable {
    override fun generateReport() = "Order Report"
}

// 3. Sử dụng đa hình
fun printReport(item: Reportable) {
    println(item.generateReport())
}
```

### Pattern 3: Default Behavior + Strict Abstraction

**Khi nào dùng:** Khi bạn muốn cung cấp logic mặc định cho một số phương thức, nhưng bắt buộc các class con phải cài đặt các phương thức quan trọng khác.
**Tại sao đúng:** Cân bằng giữa tính linh hoạt và sự nghiêm ngặt.

```kotlin
abstract class BaseController {
    // Abstract: Bắt buộc override
    abstract fun getLayoutId(): Int
    
    // Open: Cho phép override nếu muốn, có sẵn code
    open fun onCreate() {
        println("Base initialization...")
    }
    
    // Final: Không cho phép override (an toàn)
    fun log(tag: String, msg: String) {
        println("[$tag]: $msg")
    }
}

class LoginController : BaseController() {
    override fun getLayoutId() = R.layout.login // Bắt buộc
    
    override fun onCreate() {
        super.onCreate() // Gọi logic cha
        println("Login specific init...")
    }
}
```
---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

*   **Nếu** class cần **kế thừa state (properties)** và **chia sẻ code implementation**: Dùng `open class`.
*   **Nếu** class chỉ cần **định nghĩa hành vi (signature)** để các class khác tuân theo: Dùng `interface`.
*   **Nếu** class đó là **khung sườn nhưng không thể chạy trực tiếp**: Dùng `abstract class`.
*   **Nếu** bạn muốn **thêm method mới** vào class có sẵn (kế thừa `String`, `View`...): Dùng `extension function`.

### Top 5 Things To Remember

1.  **Kotlin Default là Final**: Gõ `open` mới kế thừa được.
2.  **Single Inheritance**: Class cha chỉ có 1 (mặc dù implements được nhiều interface).
3.  **Override là Bắt buộc**: Dùng `override` khi thay đổi method cha/interface.
4.  **Interface không giữ State**: Không lưu trữ biến (`var`, `val`) trong interface (trừ `abstract val`).
5.  **Extension là Vua**: Cố gắng dùng extension function thay vì kế thừa chỉ để thêm tính năng.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Classes and Objects

## SECTION 1: CORE MENTAL MODEL

**Abstract Class (Lớp trừu tượng):** Một lớp cha không thể khởi tạo trực tiếp, dùng để định nghĩa khung chung cho các lớp con.
**Interface (Giao diện):** Hợp đồng kỹ thuật định nghĩa hành vi mà lớp khác phải triển khai.
**Extension Function (Hàm mở rộng):** Thêm phương thức vào lớp hiện có mà không cần sửa đổi mã nguồn gốc.
**Data Class (Lớp dữ liệu):** Lớp đặc biệt tự sinh mã để quản lý dữ liệu (toString, equals, hashCode, copy).

```kotlin
// 1. Abstract Class: Enforces structure
abstract class Vehicle(val brand: String) {
    abstract fun startEngine() // Subclass MUST define this
    fun honk() = println("$brand says: Beep!") // Shared logic
}

// 2. Interface: Defines capabilities
interface Electric {
    fun charge() // Contract for behavior
}

// 3. Data Class: Auto-generated utility methods
data class User(val id: Int, val name: String)

// 4. Extension Function: Add functionality externally
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Abstract Class vs Interface vs Class
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Define strict parent-child hierarchy with shared code logic | **Abstract Class** | Allows implementation sharing (`open` methods) + forces subclasses to implement specifics (`abstract`). Only 1 inheritance allowed. | Making all methods `abstract` when common logic exists. |
| Define capability/contract for unrelated classes | **Interface** | Supports multiple inheritance. Loose coupling. Great for polymorphism across different hierarchies. | Adding state (fields) to interfaces. Use properties or abstract classes instead. |
| Simply store data (DTO, Entity) | **Data Class** | Auto-generates `equals`, `hashCode`, `toString`, `copy`. Reduces boilerplate code significantly. | Using `Data Class` for complex business logic. It is designed purely for holding data. |
| Need to add utility methods to closed classes | **Extension Function** | Doesn't break encapsulation. Keeps core API clean. "Syntactic sugar" for readability. | Accessing private members (cannot). Overusing when a standalone function is better. |

### Table 2: Single vs Multiple Inheritance Strategy
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Class needs base implementation + strict type | **Single Abstract Class** | Kotlin allows 1 `class` inheritance. Use for "Is-A" relationship (e.g., `Car` is a `Vehicle`). | Trying to extend 2 classes (Syntax error). |
| Class needs multiple behaviors | **Multiple Interfaces** | Kotlin allows implementing many interfaces. Use for "Can-Do" relationship (e.g., `Car` can `Drivable`, `Chargeable`). | Confusing "Is-A" (Class) with "Can-Do" (Interface). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy Visualization:**
Kotlin enforces a strict hierarchy: A class can inherit **one** abstract or open class, but can implement **multiple** interfaces. Extension functions exist outside this hierarchy, attaching to the class "virtually".

```text
[ Class Hierarchy & Extensions ]

       Any (Root)
         ^
    [ Abstract Vehicle ]  <-- (Parent Class, 1 only allowed)
         ^
    [ ElectricCar ]       <-- (Concrete Class)
      /      \
  (Implements) (Implements)
    |           |
[ Drivable ]  [ Chargeable ]  <-- (Interfaces, Multiple allowed)
     ^            ^
     |            |
  (Logic)     (Logic)

[ Extension Functions Scope ]
fun ElectricCar.printBattery() { ... }  <-- (Attached to ElectricCar only)
fun Vehicle.clean() { ... }            <-- (Available to all subclasses)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Abstract Class with Common Logic
**When to use (Khi nào dùng):** Khi các lớp con có chung một đoạn mã xử lý nhưng cách triển khai chi tiết khác nhau.
**Why this pattern is correct:** Tránh lặp lại code (DRY) trong khi vẫn ép buộc lớp con phải định nghĩa logic riêng biệt.

```kotlin
// Abstract class defines the skeleton
abstract class DatabaseConnection(val url: String) {
    // Shared logic
    fun connect() {
        println("Connecting to $url...")
        openConnection()
        println("Connected successfully.")
    }

    // Specific logic left to subclass
    abstract fun openConnection()
}

// Concrete implementation
class PostgresConnection(url: String) : DatabaseConnection(url) {
    override fun openConnection() {
        println("Opening Postgres driver...")
    }
}

fun main() {
    val db = PostgresConnection("jdbc:postgresql://localhost:5432")
    db.connect() // Uses shared flow, specific action
}
```

### Pattern 2: Extension Function for Utility
**When to use (Khi nào dùng):** Khi bạn cần định nghĩa hàm tiện ích cho lớp mà bạn không sở hữu (library classes) hoặc muốn giữ logic gốc sạch sẽ.
**Why this pattern is correct:** Tách biệt trách nhiệm. Logic "nhà bếp" không làm bẩn cấu trúc class chính.

```kotlin
// Logic added to Int, but Int class is not modified
fun Int.isOdd(): Boolean {
    return this % 2 != 0
}

// Logic added to String
fun String.toTitleCase(): String {
    return this.split(" ")
        .joinToString(" ") { it.replaceFirstChar { char -> char.uppercaseChar() } }
}

fun main() {
    val number = 7
    val text = "hello world"

    if (number.isOdd()) { // Looks like native method
        println("$number is odd")
    }
    
    println(text.toTitleCase()) // "Hello World"
}
```

### Pattern 3: Data Class for Model Objects
**When to use (Khi nào dùng):** Luôn luôn dùng cho class chỉ chứa dữ liệu (data holders), đặc biệt trong MVVM, API responses, hoặc Database Entities.
**Why this pattern is correct:** Tiết kiệm hàng trăm dòng code. Đảm bảo các object dữ liệu so sánh đúng (equals) và in ra dễ đọc (toString).

```kotlin
data class UserProfile(
    val uid: String,
    val name: String,
    var isActive: Boolean = true
)

fun main() {
    val user1 = UserProfile("u1", "Alice")
    val user2 = UserProfile("u1", "Alice")
    
    // 1. Equals (so sánh nội dung)
    println(user1 == user2) // true (không cần tự viết logic so sánh)
    
    // 2. Copy (immutable pattern)
    val user3 = user1.copy(isActive = false)
    println(user3) // UserProfile(uid=u1, name=Alice, isActive=false)
    
    // 3. Destructuring
    val (id, name) = user1
    println("ID: $id, Name: $name")
}
```

### Pattern 4: Pair/Tuple for Temporary Returns
**When to use (Khi nào dùng):** Trả về 2-3 giá trị tạm thời từ hàm mà không cần tạo `data class` riêng.
**Why this pattern is correct:** Nhanh cho code ngắn, nhưng không nên dùng cho model phức tạp vì tên thuộc tính `.first`, `.second` không tự mô tả.

```kotlin
// Returns a Pair of Int and String
fun getUserStatus(): Pair<Int, String> {
    return 200 to "OK"
}

fun main() {
    val (code, message) = getUserStatus()
    println("Status: $code - $message")
}
```

---
## SECTION 6: MASTER CHEAT SHEET

**Quick Decision Logic (If-Else):**

*   **IF** you need to share implementation code between related classes -> **Abstract Class**.
*   **IF** you need to define behavior for unrelated classes -> **Interface**.
*   **IF** you just hold data and need `toString`, `copy`, `equals` -> **Data Class**.
*   **IF** you need to add helper methods to `Int`, `String`, or library classes -> **Extension Function**.
*   **IF** you need to inherit multiple types -> **Use Interfaces** (Kotlin allows 1 Class, N Interfaces).

--------------------------------
**Core Definitions**
- **Pair (Cặp dữ liệu)**: Cấu trúc dữ liệu chứa chính xác 2 giá trị, có thể thuộc 2 kiểu dữ liệu khác nhau. Thường dùng để biểu diễn một cặp ý nghĩa (ví dụ: Key-Value).
- **Triple (Bộ ba dữ liệu)**: Tương tự Pair nhưng chứa 3 giá trị.
- **Enum Class (Lớp liệt kê)**: Kiểu dữ liệu người dùng định nghĩa để giới hạn giá trị thuộc một tập hợp các hằng số xác định (ví dụ: hướng Bắc, Nam, Đông, Tây). Đảm bảo an toàn kiểu dữ liệu.
- **Object (Đối tượng)**: Khai báo một lớp chỉ có **duy nhất một thực thể** (Singleton). Dùng cho các utility không cần giữ state hoặc singleton.
- **Companion Object (Đối tượng đi kèm)**: Các biến và hàm **chung** cho tất cả instances của một class. Tương đương với `static` trong Java nhưng linh hoạt hơn.

**Key Mental Models**
- **Pair/Triple**: Là "cấu trúc nhanh" (quick structs). Khi bạn cần trả về 2-3 giá trị từ hàm mà không muốn tạo class thừa.
- **Enum**: Là "ranh giới cứng" (hard boundary). Khi bạn muốn code chỉ được phép nhận các giá trị cụ thể, không nhận lung tung.
- **Object/Companion**: Là "kho chứa chung" (global shared storage). Khi logic không gắn với instance cụ thể nào mà gắn với chính class đó.

**Why this approach is better**
- **Pair/Triple**: Tránh tạo quá nhiều data class nhỏ cho việc tạm thời, giúp code gọn và đọc được ngay ý nghĩa (dùng infix `to`).
- **Enum**: Phòng ngừa lỗi biên dịch (compile-time safety). Tránh việc gõ sai chuỗi string hoặc số enum.
- **Object/Companion**: Tiết kiệm bộ nhớ (chỉ 1 instance), tránh phải khởi tạo đối tượng lặp lại.

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

**Hierarchy Diagram (Text-Based)**

```text
[ ROOT: Kotlin File ]
      |
      |-- [ Top Level Functions/Variables ] (Nếu cần dùng lung tung)
      |
      |-- [ DATA STRUCTURES ]
      |     |
      |     |-- Pair<V1, V2> -----------------> Dùng cho cặp key-value tạm
      |     |-- Triple<V1, V2, V3> -----------> Dùng cho bộ 3 dữ liệu tạm
      |     `-- Enum Class -------------------> Dùng khi data chỉ nằm trong 1 tập giá trị c cụ thể
      |
      |-- [ ORGANIZATION ]
      |     |
      |     |-- Single File ------------------> Chưa phân biệt class nào là chính (nếu file nhỏ)
      |     `-- Multi File ------------------> Phân loại logic theo module/component
      |
      `-- [ SINGLETON & STATIC LOGIC ]
            |
            |-- Object Name ------------------> Dùng khi chỉ cần 1 instance duy nhất (Utility)
            `-- class ClassName
                  |
                  `-- companion object ------> Dùng cho hằng số/ham chung của class
```

**Relationships**
- **Enum vs Object**: Enum là tập giá trị (data), Object là instance duy nhất (behavior). Ví dụ: `Enum Status` -> `Object StatusTracker` (theo dõi trạng thái chung).
- **Companion vs Top-level**: Companion thuộc về class (truy cập qua tên class), Top-level thuộc về file (truy cập trực tiếp tên hàm).

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Infix Pair for Maps & Returns
**Khi nào dùng:** Khi tạo Map hoặc trả về 2 giá trị từ hàm.
**Tại sao đúng:** Dùng `to` giúp code như tiếng Việt, giảm độ phức tạp cú pháp.

```kotlin
// 1. Tạo Map
// Cũ/Rườm rà: mapOf(Pair(1, "One"), Pair(2, "Two"))
// Mới/Đẹp:
val map = mapOf(1 to "One", 2 to "Two")

// 2. Trả về 2 giá trị từ hàm
fun findMinMax(list: List<Int>): Pair<Int, Int> {
    return list.min() to list.max() // Infix return
}

fun main() {
    val (min, max) = findMinMax(listOf(1, 5, 9))
    println("Min: $min, Max: $max")
}
```

### Pattern 2: Enum with Properties (State Machine)
**Khi nào dùng:** Khi các hằng số cần thêm metadata (giá trị hiển thị, màu sắc).
**Tại sao đúng:** Enum Class có thể có constructor và property, biến nó thành nhiều hơn là chỉ một tên gọi.

```kotlin
enum class NetworkState(val code: Int, val message: String) {
    LOADING(100, "Loading..."),
    SUCCESS(200, "OK"),
    ERROR(500, "Internal Error")
}

fun handleState(state: NetworkState) {
    // Không cần khiếu nại if/else string, dùng Enum an toàn
    println("Code: ${state.code} - Msg: ${state.message}")
}

fun main() {
    handleState(NetworkState.SUCCESS)
}
```

### Pattern 3: Utility Object
**Khi nào dùng:** Khi cần tập hợp các hàm helper (như tính toán, format).
**Tại sao đúng:** Tiết kiệm bộ nhớ, không cần `new Utility()`.

```kotlin
object StringUtils {
    fun capitalizeWords(str: String): String {
        return str.split(" ").joinToString(" ") { it.capitalize() }
    }
}

fun main() {
    // Truy cập trực tiếp qua tên Object
    println(StringUtils.capitalizeWords("hello world")) // Hello World
}
```

### Pattern 4: Companion Object for Constants & Factory
**Khi nào dùng:** Khi Class cần hằng số riêng hoặc logic khởi tạo đặc biệt (Factory pattern).
**Tại sao đúng:** Duy trì tính đóng gói (encapsulation), `MyClass.CONST` rõ ràng hơn `CONST` nằm lung tung.

```kotlin
class User private constructor(val name: String, val type: String) {
    
    companion object {
        const val DEFAULT_NAME = "Guest"
        
        // Factory method pattern
        fun createAdmin(name: String): User {
            return User(name, "ADMIN")
        }
        
        fun createGuest(): User {
            return User(DEFAULT_NAME, "GUEST")
        }
    }
}

fun main() {
    val admin = User.createAdmin("Alice")
    println(admin.type) // ADMIN
    
    val guest = User.createGuest()
    println(guest.name) // Guest
    
    // Access constant
    println(User.DEFAULT_NAME)
}
```

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Quick Reference Rules**
1. **Pair/To**: Dùng `val (a, b) = x to y` hoặc `mapOf(1 to "A")`.
2. **Enum**: Dùng khi giá trị thuộc tập hợp có giới hạn và cần type-safety.
3. **Object**: Dùng cho Utility (hàm helper) hoặc Singleton (chỉ 1 instance).
4. **Companion**: Dùng cho hằng số class (`const val`) và Factory method (`create()`).

**Decision Logic (If-Else)**
- *If* bạn có 2-3 giá trị tạm muốn return -> **Pair/Triple**.
- *Else if* bạn muốn return nhiều thuộc tính + có tên rõ ràng -> **Data Class**.
- *If* bạn có tập hợp giá trị cố định (ví dụ: RED, GREEN, BLUE) -> **Enum**.
- *If* bạn cần 1 object dùng chung toàn app -> **Object**.
- *If* object đó thuộc về 1 Classspecific -> **Companion Object**.

**Top 3 Things to Remember**
1. **Infix `to`**: Viết code nhanh như nói.
2. **Enum is Type-Safe**: Tránh lỗi runtime.
3. **Object là Singleton**: Không dùng `new`.


### **Package (Gói)**
Cơ chế để tổ chức code thành các thư mục logic, tránh xung đột tên gọi (namespace). Tên thường viết thường, phân cấp bằng dấu chấm.

```kotlin
// Khai báo trong dòng đầu tiên (không tính comment)
package org.example.game

class Player {
    // Code here thuộc về package org.example.game
}
```
### **Hierarchy (Mô hình cấp bậc)**
Cách tổ chức các class từ tổng quát đến chi tiết. Tránh lặp lại logic bằng cách kế thừa thuộc tính/phương thức từ cha.

```kotlin
open class Vehicle // Cha chung
class Car : Vehicle() // Con của Vehicle
class Moped : Vehicle() // Con của Vehicle
```

## SECTION 2: DECISION TABLES

### Table 1: Chọn Visibility Modifier

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI giải thích | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Logic nội bộ class, không cho phép thay đổi từ ngoài | `private` | **Encapsulation (Đóng gói):** Bảo vệ tính toàn vẹn dữ liệu, tránh side effects. | Để `public` cho tất cả biến, dẫn đến数据 bừa bãi từ khắp nơi. |
| Thuộc tính/Method cần truy cập bởi class con (subclass) | `protected` | **Extensibility (Mở rộng):** Cho phép con kế thừa và tùy biến khi cần. | Dùng `private` chặn luôn con hoặc `public` lộ chi tiết implementation. |
| API cho các phần khác của app | `public` | **Interface (Giao diện):** Cam kết giao tiếp giữa các module. |滥用 `public` cho mọi thứ, phá vỡ tính modular. |


## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Class & Encapsulation Basic
**Khi nào dùng:** Khi cần tạo một đối tượng có trạng thái và hành vi, đồng thời bảo vệ dữ liệu.
**Tại sao đúng:** Sử dụng `private` cho biến và `public` cho getter/setter (hoặc `val`/`var`) để kiểm soát truy cập.

```kotlin
class User(private var username: String) {

    // Getter (Tự động sinh ra khi dùng val/var)
    fun getUsername(): String = username

    // Setter với logic kiểm tra
    fun setUsername(newName: String) {
        if (newName.isNotBlank()) {
            username = newName
        }
    }
}
```

### Pattern 2: Sealed Class (Logic Phân nhánh)
**Khi nào dùng:** Khi cần định nghĩa các class con bị giới hạn trong một file (thường dùng cho `when` expression).
**Tại sao đúng:** Đảm bảo xử lý tất cả các trường hợp, tránh lỗi Missing Default Branch.

```kotlin
sealed class NetworkResult {
    data class Success(val data: String) : NetworkResult()
    data class Error(val message: String) : NetworkResult()
    object Loading : NetworkResult()
}

fun handleResult(result: NetworkResult) {
    when (result) {
        is NetworkResult.Success -> println("Data: ${result.data}")
        is NetworkResult.Error -> println("Error: ${result.message}")
        NetworkResult.Loading -> println("Loading...")
    }
}
```
