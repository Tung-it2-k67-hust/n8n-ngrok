# DEVELOPER DECISION GUIDE: Lesson 3 Classes and objects.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:19:06



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Classes and Objects

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Class (Lớp)**
Định nghĩa cấu trúc dữ liệu và hành vi. Đây là bản thiết kế (blueprint) để tạo ra các đối tượng cụ thể.

**Object Instance (Đối tượng)**
Một thực thể cụ thể được khởi tạo từ Class. Mỗi instance sở hữu bản sao riêng của dữ liệu (state).

**Mental Model:**
Hãy tưởng tượng Class là "Khuôn bánh quy". Object là "chiếc bánh quy" thực tế bạn ăn được. Bạn không thể ăn cái khuôn, nhưng bạn có thể tạo ra hàng trăm chiếc bánh từ nó.

**Tại sao approach này hiệu quả?**
- **Mã tái sử dụng:** Viết một lần (Class), dùng nhiều lần (Instances).
- **Bảo trì:** Sửa lỗi ở Class → Cập nhật tự động cho mọi Instance.
- **Code Organization:** Gom nhóm dữ liệu (data) và hành vi (behavior) vào cùng một nơi.

```kotlin
// Class (Blueprint)
class Car(val brand: String, var speed: Int = 0) {
    fun accelerate(increment: Int) {
        speed += increment
    }
}

// Object Instances (Actual things)
val myToyota = Car("Toyota")
val yourHonda = Car("Honda", 100)

myToyota.accelerate(20) // myToyota.speed = 20
// yourHonda vẫn giữ speed = 100
```

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Primary Constructor vs Secondary Constructor

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Khởi tạo đơn giản, dependency injection | **Primary Constructor** | Native syntax, ngắn gọn, IDE support tốt nhất. | Viết logic phức tạp trong primary constructor (nên dùng `init`). |
| Cần nhiều cách khởi tạo khác nhau (Overloading) | **Secondary Constructor** | Đa dạng hóa cách tạo đối tượng. | Lặp lại code khởi tạo (bỏ qua `this(...)` call). |
| Logic khởi tạo phức tạp (kiểm tra điều kiện) | **Primary + `init` block** | Tách biệt logic khỏi tham số constructor. | Đặt logic nặng ngay trong tham số constructor. |

### Table 2: Constructor Parameters (No modifier vs val/var)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cần dùng tham số chỉ trong lúc khởi tạo (validate/format) | **Không modifier** (ví dụ: `x: Int`) | Tiết kiệm bộ nhớ, không giữ lại sau khi constructor chạy xong. | Khai báo `val` khi không cần giữ giá trị, gây lãng phí. |
| Cần lưu trữ tham số làm thuộc tính Class | **`val` hoặc `var`** | Tự động tạo property (thuộc tính) truy cập được khắp Class. | Quên khai báo `val`/`var` → không thể truy cập biến đó ở hàm khác. |

### Table 3: Default Parameters vs Constructor Overloading

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Các tham số có giá trị mặc định hợp lý (ví dụ: timeout = 5s) | **Default Parameters** | Giảm số lượng constructor, code gọi rõ ràng (Named Arguments). | Viết quá nhiều secondary constructor chỉ để set default value. |
| Các tham số bắt buộc hoặc logic khởi tạo khác nhau hoàn toàn | **Constructor Overloading** | Buộc người dùng phải cung cấp đủ thông tin quan trọng. | Dùng default parameters cho các biến bắt buộc (dễ gây sai lệch logic). |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### Lifecycle & Hierarchy

```text
[Blueprint: Class Definition]
       |
       +--> (Khi gọi: val x = Class(args))
       |
[Memory: Object Instance (Heap)]
       |
       +--> Contains: [Properties] + [Methods]
```

### Dependency Flow (Cú pháp Kotlin)

```text
Class Definition
├── Primary Constructor (Trong header)
│   ├── Parameter (Không modifier)  ---> Scope: Constructor Only
│   └── Parameter (val/var)         ---> Becomes: Class Property
│
└── init Blocks                     ---> Executes on Instantiation
    │
    └── Secondary Constructors      ---> Must call Primary (via this()) or init
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: The Immutable Data Class (DTO)

**Khi nào dùng:** Khi bạn cần truyền dữ liệu giữa các layer (API response, Database row) mà không muốn thay đổi dữ liệu đó.

**Tại sao đúng:** `val` properties đảm bảo dữ liệu không bị thay đổi ngẫu nhiên (thread-safe và dễ debug).

```kotlin
class UserResponse(
    val id: Long,
    val username: String,
    val email: String
) {
    // Logic phụ (ví dụ: tạo display name)
    val displayName: String
        get() = "$username (#$id)"
}
```

### Pattern 2: Configurable Builder (Default Params)

**Khi nào dùng:** Khi khởi tạo một object có nhiều optional settings (ví dụ: API Client, UI View).

**Tại sao đúng:** Tránh "Constructor Hell" (quá nhiều overload), tận dụng Named Arguments để code tự mô tả.

```kotlin
class ApiClient(
    val baseUrl: String,
    val timeout: Int = 30,      // Default
    val retryCount: Int = 3,    // Default
    val loggingEnabled: Boolean = false
)

// Sử dụng linh hoạt
val client1 = ApiClient("https://api.com")
val client2 = ApiClient("https://secure.com", timeout = 60, loggingEnabled = true)
```

### Pattern 3: Initialization Logic (init block)

**Khi nào dùng:** Khi cần validate dữ liệu đầu vào hoặc chuẩn bị resource phức tạp trước khi object hoạt động.

**Tại sao đúng:** Tách biệt logic "setup" khỏi khai báo biến, đảm bảo object luôn ở trạng thái hợp lệ.

```kotlin
class Rectangle(val w: Int, val h: Int) {
    init {
        require(w > 0) { "Width must be positive" }
        require(h > 0) { "Height must be positive" }
        println("Rectangle created with area: ${w * h}")
    }
}
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

**1. Mutable Public Properties (var)**
- **Tại sao nguy hiểm:** Bất kỳ ai cũng có thể thay đổi state của object mà không kiểm soát, dẫn đến bugs khó lường (side effects).
- **Fix:** Luôn ưu tiên `val`. Nếu cần thay đổi, dùng `private var` + hàm public để update.

**2. Logic Nặng trong Primary Constructor**
- **Tại sao nguy hiểm:** Khi class được load, constructor chạy ngay. Logic nặng (call API, heavy math) làm chậm startup và khó unit test.
- **Fix:** Dùng `init` block hoặc Lazy Loading.

**3. Secondary Constructor không gọi Primary**
- **Tại sao nguy hiểm:** Viết lại code khởi tạo (boilerplate) và dễ quên logic chuẩn (như validation trong `init`).
- **Fix:** Luôn gọi `this(...)` từ secondary constructor về primary.

**4. Default Parameters trong Primary Constructor của Subclass**
- **Tại sao nguy hiểm:** Kotlin yêu cầu tham số default phải là `val` hoặc `var`. Nếu không, subclass không thể Override đúng chuẩn OOP.
- **Fix:** Cẩn thận khi kế thừa, ưu tiên Pass parameters явно.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Quick Rules:**
1. **Class** là blueprint, **Object** là instance.
2. Constructor Parameter không có `val`/`var` → chỉ dùng trong `init` hoặc `constructor`.
3. Constructor Parameter có `val`/`var` → trở thành Property của Class.
4. Dùng `init` cho logic startup.
5. Dùng Default Parameters để减少 Constructor Overloading.

**Decision Logic (If-Else):**
- IF (Cần giữ giá trị cho Class) → THEN (Dùng `val`/`var`).
- IF (Cần dùng 1 lần khi tạo) → THEN (Không dùng modifier).
- IF (Có nhiều optional params) → THEN (Dùng Default Params + Named Args).
- IF (Logic khởi tạo phức tạp) → THEN (Dùng `init` block).

**Top 3 Things to Remember:**
1. **KISS Principle:** Primary Constructor là tốt nhất trừ khi bạn cần secondary.
2. **Immutability:** Dùng `val` làm default, chỉ dùng `var` khi thật cần thiết.
3. **Validation:** Đặt trong `init` block để đảm bảo tính toàn vẹn dữ liệu (Data Integrity).

<!-- CHUNK 11-20 -->

# Developer Decision Guide: Classes & Objects (Lesson 3)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **Class (Lớp):** A blueprint for creating objects. It defines the structure (properties) and behavior (functions) that the objects will have.
*   **Object (Đối tượng):** An instance of a class. It is a concrete entity created from the class blueprint, holding actual data.
*   **Primary Constructor (Constructor chính):** Defined directly in the class header. It is the most concise way to declare properties and initialize an object. It has no body if `init` blocks are not used.
*   **Secondary Constructor (Constructor phụ):** Defined using the `constructor` keyword inside the class body. Used to provide alternative ways to create an object.
*   **Init Block (Khối khởi tạo):** A special block of code (`init`) that is executed when an object is created. It is part of the primary constructor's execution.
*   **Property (Thuộc tính):** Data stored in an object, defined by `val` (read-only) or `var` (mutable). Accessed via dot notation (`object.property`).
*   **Custom Accessors (Truy cập tùy chỉnh):** Logic defined to override the default behavior of getting (`get()`) or setting (`set()`) a property's value.
*   **Member Function (Phương thức thành viên):** A function defined inside a class that performs actions related to the object's state.

### Key Mental Models
*   **Construction Chain (Chuỗi khởi tạo):** A strict flow. When creating an object, the primary constructor runs first (including its properties and `init` blocks). Secondary constructors *must* delegate to the primary constructor (or another secondary that eventually delegates to primary). The primary constructor is the root of initialization.
*   **Property vs. Field:** In Kotlin, a property is not just a variable; it is a complex structure that can contain logic (getters/setters). `field` is the backing field that actually stores the data, accessible only within accessors.
*   **Encapsulation (Bao tộm):** Hide complexity. By using custom getters/setters, you can expose a simple API (e.g., `fullName`) while performing complex logic internally (e.g., splitting a string).

### Why This Approach
*   **Secondary Constructors vs. Default Arguments:** Kotlin's default arguments are more powerful than secondary constructors in most cases. Use secondary constructors primarily for dependency injection frameworks or strict API constraints.
*   **Init Blocks vs. Constructor Body:** For Primary Constructors, `init` is the *only* body. It ensures that initialization logic is executed immediately after property initialization, guaranteeing the object is in a valid state before use.

---

## SECTION 2: DECISION TABLES

### Primary vs. Secondary Constructors
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Simple object creation** (e.g., `User(id: Int)`)| **Primary Constructor** | Concise syntax; automatically promotes parameters to class properties. | Defining properties inside the class body when they could be defined in the constructor header. |
| **Multiple ways to init** (e.g., `Circle(radius)` vs `Circle(diameter)`)| **Secondary Constructors** | Provides flexibility for different input formats while centralizing logic. | Creating secondary constructors that duplicate logic instead of calling `this(...)`. |
| **Complex initialization logic** (e.g., validation, setup)| **Init Block** | Runs automatically after property assignment; ensures object validity. | Putting complex logic inside the constructor header (syntax error) or forgetting `init`. |

| Custom Accessor Usage | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Value depends on other properties** | **Custom Getter** | Computed properties are efficient (calculated on access) and prevent data duplication. | Storing calculated values in a `var` manually, leading to stale data if dependencies change. |
| **Enforcing validation/formatting** | **Custom Setter** | Protects the object's internal state (Encapsulation) and ensures data integrity. | Forgetting to assign the backing `field` (e.g., `field = value`), effectively making the property read-only. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Object Initialization Flow
```text
[Call Constructor] -> [Evaluate Constructor Arguments] -> [Assign Properties]
     |
     V
[Run Primary Constructor Body (Init Blocks)] -> [Run Secondary Constructor Body]
     |
     V
[Object Ready]
```

### Property Structure
```text
class User {
    var name: String = ""
      /             \
     / (Getter/Setter) \
    <------------------- [ Backing Field (field) ]
     \                 /
      \ (Logic Here)  /
```

---

## SECTION 4: CODE PATTERNS

### Pattern: Multiple Constructors with Delegation
**Khi nào dùng:** Khi bạn cần cung cấp nhiều cách để khởi tạo đối tượng, nhưng logic chung chỉ được viết một lần.
**Tại sao đúng:** Tránh lặp lại mã (DRY - Don't Repeat Yourself) và đảm bảo rằng mọi cách khởi tạo đều đi qua cùng một logic khởi tạo chính.

```kotlin
class User(val username: String, val age: Int) {
    
    // Primary Constructor (defining properties)

    // Secondary Constructor 1: Creates a default age
    constructor(name: String) : this(name, 18) {
        // Logic specific to this constructor
        println("User created with default age")
    }

    // Secondary Constructor 2: Creates from a formatted string
    constructor(data: String) : this(data.substringBefore(","), data.substringAfter(",").toInt()) {
        println("User parsed from string")
    }

    init {
        println("User $username initialized. Age: $age")
    }
}

fun main() {
    val u1 = User("Alice") // Calls secondary constructor 1
    val u2 = User("Bob,25") // Calls secondary constructor 2
}
```

### Pattern: Custom Getters & Setters (Computed Properties)
**Khi nào dùng:** Khi một thuộc tính không được lưu trữ trực tiếp, mà là kết quả của logic khác hoặc cần kiểm tra dữ liệu vào/ra.
**Tại sao đúng:** Giảm bộ nhớ (không lưu trữ dữ dư thừa) và tăng tính an toàn của dữ liệu (data integrity).

```kotlin
class FullPerson(var firstName: String, var lastName: String) {

    // Custom Getter: Computed value, not stored
    val fullName: String
        get() = "$firstName $lastName"

    // Custom Setter: Intercepting assignment
    var identifier: String = "INIT"
        set(value) {
            if (value.length < 5) {
                println("Error: Identifier too short!")
            } else {
                // 'field' is the backing field. MUST assign to it.
                field = value 
            }
        }
}

fun main() {
    val p = FullPerson("John", "Doe")
    println(p.fullName) // Triggers getter
    
    p.identifier = "AB" // Triggers setter (prints error)
    p.identifier = "VALID_ID" // Triggers setter (updates field)
    println(p.identifier)
}
```

### Pattern: Init Block for Validation
**Khi nào dùng:** Khi các thuộc tính cần được kiểm tra tính hợp lệ ngay lập tức sau khi tạo đối tượng.
**Tại sao đúng:** Nếu dữ liệu không hợp lệ, đối tượng không bao giờ được tạo thành công (ném ngoại lệ), tránh các lỗi phức tạp về sau.

```kotlin
class BankAccount(val balance: Double) {
    
    init {
        // Logic chạy ngay khi object được tạo
        if (balance < 0) {
            throw IllegalArgumentException("Balance cannot be negative")
        }
        println("Account created with balance: $balance")
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Ignoring the `field` identifier in custom setters:**
    *   **Danger:** If you write `set(value) { name = value }` inside the property `name`, you actually call the setter recursively (StackOverflowError).
    *   **Fix:** Always use `field = value` to update the actual data storage inside accessors.

2.  **Secondary constructors calling other secondaries in a loop:**
    *   **Danger:** Every secondary constructor must eventually call the **Primary** constructor. Circular calls (`A -> B -> A`) result in compilation errors.
    *   **Fix:** Ensure the "final" secondary constructor in the chain calls `this(...)` pointing to the primary.

3.  **Primary Constructor with unused parameters:**
    *   **Danger:** If you define a parameter in the primary constructor but don't use it in an `init` block or declare it as a property, it is useless and confusing.
    *   **Fix:** Either use it in `init` or promote it to a property (add `val`/`var`).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Constructor:** Put simple parameters in `class MyType(val a: Int)`.
2.  **Init:** Use `init { ... }` for logic that runs immediately.
3.  **Secondary:** Use `constructor(...): this(...) { ... }` for alternative creation.
4.  **Getters:** Use `val name get() = ...` for calculated values.
5.  **Setters:** Use `var name = ... set(value) { field = value }` for validation.

### Top 5 Things to Remember
1.  **Delegation is Mandatory:** Secondary constructors *must* call `this(...)` (Primary).
2.  **Primary is First:** `init` blocks run in the Primary constructor only.
3.  **Back 'field' Up:** Inside `set()`, assign to `field`, not the property name.
4.  **Dot Notation:** Use `.` to access properties (`obj.prop`).
5.  **Computed Properties:** Use `get()` to avoid storing data that can be calculated.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Classes & Objects (Lesson 3)

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **Inheritance (Kế thừa)**: Cơ chế cho phép một class mới (subclass) mượn tính năng và trạng thái từ một class hiện có (superclass). Kotlin chỉ h hỗ trợ **kế thừa đơn cha mẹ** (single-parent class inheritance).
*   **Interface (Giao diện)**: Một hợp đồng (contract) quy định các phương thức và thuộc tính mà class thực thi phải cung cấp. Một class có thể thực thi **nhiều interface**.
*   **Open Keyword (Từ khóa mở)**: Chỉ thị rằng một class hoặc thành viên (method/property) có thể được kế thừa hoặc ghi đè. Theo mặc định, các class trong Kotlin là `final`.
*   **Abstract Class (Lớp trừu tượng)**: Class không thể khởi tạo instancia (không thể `new`), dùng làm nền tảng cho các class con. Kết hợp giữa trạng thái (state) của class và tính trừu tượng của interface.

### Key Mental Models

1.  **"Mặc Định Là Cố Định"**: Hãy coi mọi class đều là `final`. Chỉ mở rộng khi cần thiết. Điều này buộc bạn phải suy nghĩ kỹ về thiết kế trước khi cho phép kế thừa.
2.  **"Giao Diện Trươc, Cài Sau"**: Khi cần chia sẻ hành vi giữa các class không cùng dòng dõi (is-a relationship), hãy định nghĩa Interface. Khi cần chia sẻ **mã nguồn và trạng thái chung**, hãy dùng Abstract Class hoặc Inheritance.
3.  **"Mở Rộng Không Đụng Chạm"**: Extension functions cho phép thêm chức năng mới vào class có sẵn mà không cần sửa đổi source code gốc hoặc tạo class con.

---

## SECTION 2: DECISION TABLES

### Table 1: Inheritance (Class) vs Interface
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Các class có **quan hệ cha con thực sự** (VD: Animal -> Dog) và **chia sẻ trạng thái chung** (properties). | **Inheritance (open class)** | **Code Reusability (Tái sử dụng mã)**: Class con được kế thừa code và state của cha mà không cần viết lại. | Dùng Interface khi cần giữ state chung (bắt buộc phải tự implement lại property). |
| Các class khác biệt về bản chất nhưng cần **thực thi cùng một hành vi** (VD: Savable, Printable). | **Interface** | **Multiple Inheritance (Kế thừa đa hình)**: Một class có thể implement nhiều interface. | Dùng Class cha để ép các class không cùng dòng dõi phải kế thừa, gây rối loạn hierarchy. |

### Table 2: Class Structure Decision
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Class chỉ chứa **logic chưa cài đặt** và bắt buộc class con phải định nghĩa. | **Abstract Class** | **Bắt buộc cài đặt**: Ép buộc override phương thức trừu tượng (`abstract`), nhưng vẫn giữ được logic nền tảng. | Implement sai lệch: Để class trừu tượng có constructor públic (không cần thiết vì không thể khởi tạo trực tiếp). |
| Class cần cho phép **kế thừa hoặc ghi đè** phương thức. | **`open` keyword** | **Control (Kiểm soát)**: Kotlin khóa `final` mặc định để bảo vệ design. Phải dùng `open` để bỏ khóa. | Quên `open` khi cần override, dẫn đến lỗi biên dịch không rõ ràng. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy Text Diagram

```text
[Giả sử chúng ta có hệ thống Hình học]

1. Level Abstract (Khung sườn):
   abstract class Shape (open) -> Define calculateArea() ABSTRACT

2. Level Implementation (Cụ thể):
   class Circle : Shape (override calculateArea)
   class Rectangle : Shape (override calculateArea)

3. Level Interface (Khả năng mở rộng):
   interface Drawable -> fun draw()

4. Level Composite (Kết hợp):
   class ColoredCircle : Shape, Drawable 
   (Kế thừa tính toán từ Shape, Tuân thủ hợp đồng Drawable)
```

### Relationship Rules
*   **Is-A (Là một loại)**: Dùng **Inheritance**. (Ví dụ: Dog là một loại Animal).
*   **Can-Do (Có thể làm)**: Dùng **Interface**. (Ví dụ: Circle có thể được Vẽ - Drawable).
*   **Has-A (Có một)**: Dùng **Property/Composition**. (Ví dụ: Car có Engine - không kế thừa).

---

## SECTION 4: CODE PATTERNS

### Pattern 1: The Strict Hierarchy (Inheritance)

**Khi nào dùng:** Khi bạn có các class con chia sẻ logic cơ bản và state từ class cha, và bạn muốn tái sử dụng code cha.
**Tại sao đúng:** Giảm trùng lặp mã (DRY) và ép buộc cấu trúc tree.

```kotlin
// 1. Base Class (Cha) - Phải open
open class Animal(val name: String) {
    // Phải open nếu muốn override
    open fun makeSound() {
        println("$name makes a sound")
    }
}

// 2. Subclass (Con) - Kế thừa state và logic
class Dog(name: String) : Animal(name) {
    // Override để thay đổi hành vi
    override fun makeSound() {
        println("$name barks: Woof!")
    }
}

// Usage
val myDog = Dog("Buddy")
myDog.makeSound() // Output: Buddy barks: Woof!
```

### Pattern 2: The Contract (Interface)

**Khi nào dùng:** Khi các class cần chia sẻ hành vi nhưng không cùng nguồn gốc hoặc cần đa kế thừa.
**Tại sao đúng:** Tách biệt giữa "là gì" (Class cha) và "có thể làm gì" (Interface).

```kotlin
// 1. Define Contract
interface Reportable {
    fun generateReport(): String
}

// 2. Implement trong class khác nhau
class User : Reportable {
    override fun generateReport() = "User Report"
}

class Order : Reportable {
    override fun generateReport() = "Order Report"
}

// 3. Sử dụng đa hình
fun printReport(item: Reportable) {
    println(item.generateReport())
}
```

### Pattern 3: Default Behavior + Strict Abstraction

**Khi nào dùng:** Khi bạn muốn cung cấp logic mặc định cho một số phương thức, nhưng bắt buộc các class con phải cài đặt các phương thức quan trọng khác.
**Tại sao đúng:** Cân bằng giữa tính linh hoạt và sự nghiêm ngặt.

```kotlin
abstract class BaseController {
    // Abstract: Bắt buộc override
    abstract fun getLayoutId(): Int
    
    // Open: Cho phép override nếu muốn, có sẵn code
    open fun onCreate() {
        println("Base initialization...")
    }
    
    // Final: Không cho phép override (an toàn)
    fun log(tag: String, msg: String) {
        println("[$tag]: $msg")
    }
}

class LoginController : BaseController() {
    override fun getLayoutId() = R.layout.login // Bắt buộc
    
    override fun onCreate() {
        super.onCreate() // Gọi logic cha
        println("Login specific init...")
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Lạm dụng Inheritance (Inheritance Abuse)
*   **Biểu hiện:** Dùng kế thừa khi chỉ muốn chia sẻ một hàm utility nhỏ hoặc khi class cha quá lớn.
*   **Nguy hiểm:** Tạo ra **God Object** (Class cha biết tất cả). Nếu sửa class cha, có thể làm vỡ hàng trăm class con. Cấu trúc cây quá sâu dẫn đến code khó hiểu (Fragile Base Class Problem).
*   **Đúng là:** Dùng **Composition** hoặc **Extension Functions** thay vì kế thừa class.

### 2. Quên `override` trong Interface/Abstract Class
*   **Biểu hiện:** Implement class con nhưng không gõ `override` cho phương thức từ interface hoặc abstract class.
*   **Nguy hiểm:** Compiler sẽ hiểu đó là một phương thức mới hoàn toàn, không liên quan đến hợp đồng cũ. Logic cha sẽ không bao giờ được gọi.
*   **Fix:** Luôn dùng `override` (Kotlin bắt buộc để đảm bảo bạn đang sửa đúng cái cần sửa).

### 3. Tránh dùng `open` một cách bừa bãi
*   **Biểu hiện:** Đánh dấu `open` cho mọi class để "cho chắc chắn".
*   **Nguy hiểm:** Mở rộng lớp phủ (attack surface) của code. Người khác có thể kế thừa và thay đổi logic không mong muốn, gây khó khăn khi bảo trì.
*   **Quy tắc:** Chỉ `open` khi bạn **thiết kế rõ ràng** cho việc kế thừa.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

*   **Nếu** class cần **kế thừa state (properties)** và **chia sẻ code implementation**: Dùng `open class`.
*   **Nếu** class chỉ cần **định nghĩa hành vi (signature)** để các class khác tuân theo: Dùng `interface`.
*   **Nếu** class đó là **khung sườn nhưng không thể chạy trực tiếp**: Dùng `abstract class`.
*   **Nếu** bạn muốn **thêm method mới** vào class có sẵn (kế thừa `String`, `View`...): Dùng `extension function`.

### Top 5 Things To Remember

1.  **Kotlin Default là Final**: Gõ `open` mới kế thừa được.
2.  **Single Inheritance**: Class cha chỉ có 1 (mặc dù implements được nhiều interface).
3.  **Override là Bắt buộc**: Dùng `override` khi thay đổi method cha/interface.
4.  **Interface không giữ State**: Không lưu trữ biến (`var`, `val`) trong interface (trừ `abstract val`).
5.  **Extension là Vua**: Cố gắng dùng extension function thay vì kế thừa chỉ để thêm tính năng.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Classes and Objects

## SECTION 1: CORE MENTAL MODEL

**Abstract Class (Lớp trừu tượng):** Một lớp cha không thể khởi tạo trực tiếp, dùng để định nghĩa khung chung cho các lớp con.
**Interface (Giao diện):** Hợp đồng kỹ thuật định nghĩa hành vi mà lớp khác phải triển khai.
**Extension Function (Hàm mở rộng):** Thêm phương thức vào lớp hiện có mà không cần sửa đổi mã nguồn gốc.
**Data Class (Lớp dữ liệu):** Lớp đặc biệt tự sinh mã để quản lý dữ liệu (toString, equals, hashCode, copy).

**Why this approach is better:**
Thay vì kế thừa đa lớp (không thể trong Kotlin), việc kết hợp `abstract class` (trùng lặp logic cơ bản) và `interface` (đa năng, linh hoạt) tạo ra hệ thống dễ bảo trì. `Extension functions` ngăn cách logic phụ trợ khỏi lớp gốc, tránh vi phạm nguyên tắc Single Responsibility.

```kotlin
// 1. Abstract Class: Enforces structure
abstract class Vehicle(val brand: String) {
    abstract fun startEngine() // Subclass MUST define this
    fun honk() = println("$brand says: Beep!") // Shared logic
}

// 2. Interface: Defines capabilities
interface Electric {
    fun charge() // Contract for behavior
}

// 3. Data Class: Auto-generated utility methods
data class User(val id: Int, val name: String)

// 4. Extension Function: Add functionality externally
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Abstract Class vs Interface vs Class
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Define strict parent-child hierarchy with shared code logic | **Abstract Class** | Allows implementation sharing (`open` methods) + forces subclasses to implement specifics (`abstract`). Only 1 inheritance allowed. | Making all methods `abstract` when common logic exists. |
| Define capability/contract for unrelated classes | **Interface** | Supports multiple inheritance. Loose coupling. Great for polymorphism across different hierarchies. | Adding state (fields) to interfaces. Use properties or abstract classes instead. |
| Simply store data (DTO, Entity) | **Data Class** | Auto-generates `equals`, `hashCode`, `toString`, `copy`. Reduces boilerplate code significantly. | Using `Data Class` for complex business logic. It is designed purely for holding data. |
| Need to add utility methods to closed classes | **Extension Function** | Doesn't break encapsulation. Keeps core API clean. "Syntactic sugar" for readability. | Accessing private members (cannot). Overusing when a standalone function is better. |

### Table 2: Single vs Multiple Inheritance Strategy
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Class needs base implementation + strict type | **Single Abstract Class** | Kotlin allows 1 `class` inheritance. Use for "Is-A" relationship (e.g., `Car` is a `Vehicle`). | Trying to extend 2 classes (Syntax error). |
| Class needs multiple behaviors | **Multiple Interfaces** | Kotlin allows implementing many interfaces. Use for "Can-Do" relationship (e.g., `Car` can `Drivable`, `Chargeable`). | Confusing "Is-A" (Class) with "Can-Do" (Interface). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy Visualization:**
Kotlin enforces a strict hierarchy: A class can inherit **one** abstract or open class, but can implement **multiple** interfaces. Extension functions exist outside this hierarchy, attaching to the class "virtually".

```text
[ Class Hierarchy & Extensions ]

       Any (Root)
         ^
    [ Abstract Vehicle ]  <-- (Parent Class, 1 only allowed)
         ^
    [ ElectricCar ]       <-- (Concrete Class)
      /      \
  (Implements) (Implements)
    |           |
[ Drivable ]  [ Chargeable ]  <-- (Interfaces, Multiple allowed)
     ^            ^
     |            |
  (Logic)     (Logic)

[ Extension Functions Scope ]
fun ElectricCar.printBattery() { ... }  <-- (Attached to ElectricCar only)
fun Vehicle.clean() { ... }            <-- (Available to all subclasses)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Abstract Class with Common Logic
**When to use (Khi nào dùng):** Khi các lớp con có chung một đoạn mã xử lý nhưng cách triển khai chi tiết khác nhau.
**Why this pattern is correct:** Tránh lặp lại code (DRY) trong khi vẫn ép buộc lớp con phải định nghĩa logic riêng biệt.

```kotlin
// Abstract class defines the skeleton
abstract class DatabaseConnection(val url: String) {
    // Shared logic
    fun connect() {
        println("Connecting to $url...")
        openConnection()
        println("Connected successfully.")
    }

    // Specific logic left to subclass
    abstract fun openConnection()
}

// Concrete implementation
class PostgresConnection(url: String) : DatabaseConnection(url) {
    override fun openConnection() {
        println("Opening Postgres driver...")
    }
}

fun main() {
    val db = PostgresConnection("jdbc:postgresql://localhost:5432")
    db.connect() // Uses shared flow, specific action
}
```

### Pattern 2: Extension Function for Utility
**When to use (Khi nào dùng):** Khi bạn cần định nghĩa hàm tiện ích cho lớp mà bạn không sở hữu (library classes) hoặc muốn giữ logic gốc sạch sẽ.
**Why this pattern is correct:** Tách biệt trách nhiệm. Logic "nhà bếp" không làm bẩn cấu trúc class chính.

```kotlin
// Logic added to Int, but Int class is not modified
fun Int.isOdd(): Boolean {
    return this % 2 != 0
}

// Logic added to String
fun String.toTitleCase(): String {
    return this.split(" ")
        .joinToString(" ") { it.replaceFirstChar { char -> char.uppercaseChar() } }
}

fun main() {
    val number = 7
    val text = "hello world"

    if (number.isOdd()) { // Looks like native method
        println("$number is odd")
    }
    
    println(text.toTitleCase()) // "Hello World"
}
```

### Pattern 3: Data Class for Model Objects
**When to use (Khi nào dùng):** Luôn luôn dùng cho class chỉ chứa dữ liệu (data holders), đặc biệt trong MVVM, API responses, hoặc Database Entities.
**Why this pattern is correct:** Tiết kiệm hàng trăm dòng code. Đảm bảo các object dữ liệu so sánh đúng (equals) và in ra dễ đọc (toString).

```kotlin
data class UserProfile(
    val uid: String,
    val name: String,
    var isActive: Boolean = true
)

fun main() {
    val user1 = UserProfile("u1", "Alice")
    val user2 = UserProfile("u1", "Alice")
    
    // 1. Equals (so sánh nội dung)
    println(user1 == user2) // true (không cần tự viết logic so sánh)
    
    // 2. Copy (immutable pattern)
    val user3 = user1.copy(isActive = false)
    println(user3) // UserProfile(uid=u1, name=Alice, isActive=false)
    
    // 3. Destructuring
    val (id, name) = user1
    println("ID: $id, Name: $name")
}
```

### Pattern 4: Pair/Tuple for Temporary Returns
**When to use (Khi nào dùng):** Trả về 2-3 giá trị tạm thời từ hàm mà không cần tạo `data class` riêng.
**Why this pattern is correct:** Nhanh cho code ngắn, nhưng không nên dùng cho model phức tạp vì tên thuộc tính `.first`, `.second` không tự mô tả.

```kotlin
// Returns a Pair of Int and String
fun getUserStatus(): Pair<Int, String> {
    return 200 to "OK"
}

fun main() {
    val (code, message) = getUserStatus()
    println("Status: $code - $message")
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1. **Creating Data Classes with Logic:** Dùng `data class` để chứa business logic là sai. Nó sinh ra để chứa dữ liệu thuần túy.
   *   *Why:* `copy()`, `equals()` sẽ không hoạt động đúng nếu logic thay đổi internal state quá nhiều. Vi phạm nguyên tắc Single Responsibility.

2. **Inheritance Abuse (Lạm dụng Kế thừa):** Kế thừa lớp cha chỉ để reuse code mà không có quan hệ "Is-A" thực sự.
   *   *Why:* Tạo ra sự ràng buộc chặt chẽ (tight coupling). Dùng `Composition` hoặc `Interface` + `Extension Functions` thay thế.

3. **Extension Functions accessing private members:** Cố gắng truy cập biến private của lớp bên trong extension function.
   *   *Why:* Extension functions chỉ là hàm static. Chúng không thể truy cập `private` hoặc `protected` của lớp đó.

4. **Interface with State:** Khai báo biến biến mutable trong Interface.
   *   *Why:* Interface không nên chứa state. Chúng nên định nghĩa hành vi. State nên ở trong `class` hoặc `abstract class`.

---

## SECTION 6: MASTER CHEAT SHEET

**Quick Decision Logic (If-Else):**

*   **IF** you need to share implementation code between related classes -> **Abstract Class**.
*   **IF** you need to define behavior for unrelated classes -> **Interface**.
*   **IF** you just hold data and need `toString`, `copy`, `equals` -> **Data Class**.
*   **IF** you need to add helper methods to `Int`, `String`, or library classes -> **Extension Function**.
*   **IF** you need to inherit multiple types -> **Use Interfaces** (Kotlin allows 1 Class, N Interfaces).

**Top 5 Things to Remember:**
1.  **1 Class, N Interfaces:** You can extend only one class (abstract or open), but implement unlimited interfaces.
2.  **Data Class is Final:** Data classes cannot be inherited (unless `open` is explicitly added, but usually avoid).
3.  **Extensions are "Fake" Methods:** They are compiled to static functions (e.g., `ExtensionsKt.isOdd(myInt)`). They cannot access private members.
4.  **Abstract vs Open:** Abstract classes are implicitly `open` for inheritance, but their members may be `abstract` (must override) or concrete.
5.  **Pair is a Data Class:** `Pair(A, B)` is just a predefined data class. Use it for quick returns, but name your own data classes for clarity in public APIs.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Classes and Objects (Lesson 3)

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------
**Core Definitions**
- **Pair (Cặp dữ liệu)**: Cấu trúc dữ liệu chứa chính xác 2 giá trị, có thể thuộc 2 kiểu dữ liệu khác nhau. Thường dùng để biểu diễn một cặp ý nghĩa (ví dụ: Key-Value).
- **Triple (Bộ ba dữ liệu)**: Tương tự Pair nhưng chứa 3 giá trị.
- **Enum Class (Lớp liệt kê)**: Kiểu dữ liệu người dùng định nghĩa để giới hạn giá trị thuộc một tập hợp các hằng số xác định (ví dụ: hướng Bắc, Nam, Đông, Tây). Đảm bảo an toàn kiểu dữ liệu.
- **Object (Đối tượng)**: Khai báo một lớp chỉ có **duy nhất một thực thể** (Singleton). Dùng cho các utility không cần giữ state hoặc singleton.
- **Companion Object (Đối tượng đi kèm)**: Các biến và hàm **chung** cho tất cả instances của một class. Tương đương với `static` trong Java nhưng linh hoạt hơn.

**Key Mental Models**
- **Pair/Triple**: Là "cấu trúc nhanh" (quick structs). Khi bạn cần trả về 2-3 giá trị từ hàm mà không muốn tạo class thừa.
- **Enum**: Là "ranh giới cứng" (hard boundary). Khi bạn muốn code chỉ được phép nhận các giá trị cụ thể, không nhận lung tung.
- **Object/Companion**: Là "kho chứa chung" (global shared storage). Khi logic không gắn với instance cụ thể nào mà gắn với chính class đó.

**Why this approach is better**
- **Pair/Triple**: Tránh tạo quá nhiều data class nhỏ cho việc tạm thời, giúp code gọn và đọc được ngay ý nghĩa (dùng infix `to`).
- **Enum**: Phòng ngừa lỗi biên dịch (compile-time safety). Tránh việc gõ sai chuỗi string hoặc số enum.
- **Object/Companion**: Tiết kiệm bộ nhớ (chỉ 1 instance), tránh phải khởi tạo đối tượng lặp lại.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Pair/Triple vs Data Class
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Trả về 2 giá trị tạm thời từ hàm (ví dụ: tọa độ x,y) | **Pair** hoặc **to** infix | Pair (Cặp dữ liệu) là cấu trúc không immutable, lightweight, không cần khai báo trước. | Tạo một Data Class chỉ để dùng 1 lần duy nhất, làm code rườm rà. |
| Truy cập giá trị qua tên biến rõ ràng (ví dụ: `result.name`) | **Data Class** | Data Class tự sinh getter, có tên thuộcmeaningful. Pair dùng `.first`, `.second` gây khó đọc. | Lạm dụng Pair cho logic phức tạp, dẫn đến code khó bảo trì khi requirements thay đổi. |
| Định nghĩa các cặp Key-Value cho Map | **Infix `to`** | `1 to "A"` tạo Pair cực kỳ ngắn gọn và đọc được như câu tự nhiên. | Dùng `Pair(1, "A")` dài dòng không cần thiết. |

### Table 2: Enum Class vs Constant (const val)
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Một tập hợp giá trị có liên quan logic với nhau (ví dụ: Status) | **Enum Class** | Enum (Lớp liệt kê) có thể chứa property và method, đảm bảo chỉ nhận đúng các giá trị định nghĩa. | Dùng `const val` hoặc `String` cứng, dẫn đến lỗi runtime khi truyền giá trị không tồn tại. |
| Chỉ cần hằng số số nguyên/văn bản đơn giản, độc lập | **const val** | Đơn giản, không cần overhead của object/class. | Viết Enum chỉ để chứa 1 giá trị duy nhất, gây thừa thãi. |

### Table 3: Object vs Companion Object vs Class
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cung cấp utility function không cần state (ví dụ: Calculator) | **Object** | Object (Đối tượng) là Singleton, truy cập trực tiếp qua tên, không cần khởi tạo instance. | Dùng Class thông thường rồi phải tạo instance mới dùng được, lãng phí. |
| Khai báo hằng số hoặc factory method thuộc về Class (ví dụ: `MyClass.create()`) | **Companion Object** | Companion Object (Đối tượng đi kèm) cho phép truy cập qua tên class, tách biệt logic static với instance. | Đặt variable/function ở level file (top-level) gây rối namespace, khó tìm kiếm. |
| Cần nhiều instances có state riêng biệt | **Class** | Class dùng để tạo nhiều object độc lập về dữ liệu. | Dùng Object (Singleton) cho các class cần nhiều instances, gây lỗi logic shared state. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

**Hierarchy Diagram (Text-Based)**

```text
[ ROOT: Kotlin File ]
      |
      |-- [ Top Level Functions/Variables ] (Nếu cần dùng lung tung)
      |
      |-- [ DATA STRUCTURES ]
      |     |
      |     |-- Pair<V1, V2> -----------------> Dùng cho cặp key-value tạm
      |     |-- Triple<V1, V2, V3> -----------> Dùng cho bộ 3 dữ liệu tạm
      |     `-- Enum Class -------------------> Dùng khi data chỉ nằm trong 1 tập giá trị c cụ thể
      |
      |-- [ ORGANIZATION ]
      |     |
      |     |-- Single File ------------------> Chưa phân biệt class nào là chính (nếu file nhỏ)
      |     `-- Multi File ------------------> Phân loại logic theo module/component
      |
      `-- [ SINGLETON & STATIC LOGIC ]
            |
            |-- Object Name ------------------> Dùng khi chỉ cần 1 instance duy nhất (Utility)
            `-- class ClassName
                  |
                  `-- companion object ------> Dùng cho hằng số/ham chung của class
```

**Relationships**
- **Enum vs Object**: Enum là tập giá trị (data), Object là instance duy nhất (behavior). Ví dụ: `Enum Status` -> `Object StatusTracker` (theo dõi trạng thái chung).
- **Companion vs Top-level**: Companion thuộc về class (truy cập qua tên class), Top-level thuộc về file (truy cập trực tiếp tên hàm).

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Infix Pair for Maps & Returns
**Khi nào dùng:** Khi tạo Map hoặc trả về 2 giá trị từ hàm.
**Tại sao đúng:** Dùng `to` giúp code như tiếng Việt, giảm độ phức tạp cú pháp.

```kotlin
// 1. Tạo Map
// Cũ/Rườm rà: mapOf(Pair(1, "One"), Pair(2, "Two"))
// Mới/Đẹp:
val map = mapOf(1 to "One", 2 to "Two")

// 2. Trả về 2 giá trị từ hàm
fun findMinMax(list: List<Int>): Pair<Int, Int> {
    return list.min() to list.max() // Infix return
}

fun main() {
    val (min, max) = findMinMax(listOf(1, 5, 9))
    println("Min: $min, Max: $max")
}
```

### Pattern 2: Enum with Properties (State Machine)
**Khi nào dùng:** Khi các hằng số cần thêm metadata (giá trị hiển thị, màu sắc).
**Tại sao đúng:** Enum Class có thể có constructor và property, biến nó thành nhiều hơn là chỉ một tên gọi.

```kotlin
enum class NetworkState(val code: Int, val message: String) {
    LOADING(100, "Loading..."),
    SUCCESS(200, "OK"),
    ERROR(500, "Internal Error")
}

fun handleState(state: NetworkState) {
    // Không cần khiếu nại if/else string, dùng Enum an toàn
    println("Code: ${state.code} - Msg: ${state.message}")
}

fun main() {
    handleState(NetworkState.SUCCESS)
}
```

### Pattern 3: Utility Object
**Khi nào dùng:** Khi cần tập hợp các hàm helper (như tính toán, format).
**Tại sao đúng:** Tiết kiệm bộ nhớ, không cần `new Utility()`.

```kotlin
object StringUtils {
    fun capitalizeWords(str: String): String {
        return str.split(" ").joinToString(" ") { it.capitalize() }
    }
}

fun main() {
    // Truy cập trực tiếp qua tên Object
    println(StringUtils.capitalizeWords("hello world")) // Hello World
}
```

### Pattern 4: Companion Object for Constants & Factory
**Khi nào dùng:** Khi Class cần hằng số riêng hoặc logic khởi tạo đặc biệt (Factory pattern).
**Tại sao đúng:** Duy trì tính đóng gói (encapsulation), `MyClass.CONST` rõ ràng hơn `CONST` nằm lung tung.

```kotlin
class User private constructor(val name: String, val type: String) {
    
    companion object {
        const val DEFAULT_NAME = "Guest"
        
        // Factory method pattern
        fun createAdmin(name: String): User {
            return User(name, "ADMIN")
        }
        
        fun createGuest(): User {
            return User(DEFAULT_NAME, "GUEST")
        }
    }
}

fun main() {
    val admin = User.createAdmin("Alice")
    println(admin.type) // ADMIN
    
    val guest = User.createGuest()
    println(guest.name) // Guest
    
    // Access constant
    println(User.DEFAULT_NAME)
}
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1. **Pair Abuse (Lạm dụng Pair)**
   - **Tại sao nguy hiểm:** Khi một `Pair` chứa quá nhiều logic hoặc được truyền đi khắp nơi, việc truy cập `.first` và `.second` sẽ làm code cực kỳ khó hiểu và dễ nhầm lẫn thứ tự.
   - **Fix:** Nếu giữ Pair quá 10 dòng code hoặc dùng > 2 lần, hãy tạo `data class`.

2. **Enum bloat (Enum thừa)**
   - **Tại sao nguy hiểm:** Tạo một `enum class` chỉ với 1 hằng số hoặc dùng enum để thay thế cho `boolean` (True/False) là không cần thiết.
   - **Fix:** Dùng `Boolean` cho True/False. Dùng `const val` cho hằng số đơn lẻ.

3. **Companion Object Chaos (Trộn lẫn logic)**
   - **Tại sao nguy hiểm:** Đặt cả logic instance (phải có `this`) vào Companion Object. Companion chỉ nên dùng cho logic **không** cần state của instance.
   - **Fix:** Logic dùng state của object phải là method của class (không có `companion`).

4. **Truy cập Object qua Instance**
   - **Tại sao nguy hiểm:** `val obj = Calculator` rồi gọi `obj.add()`. Sai bản chất của Singleton. Object là static access.
   - **Fix:** Truy cập trực tiếp: `Calculator.add()`.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Quick Reference Rules**
1. **Pair/To**: Dùng `val (a, b) = x to y` hoặc `mapOf(1 to "A")`.
2. **Enum**: Dùng khi giá trị thuộc tập hợp có giới hạn và cần type-safety.
3. **Object**: Dùng cho Utility (hàm helper) hoặc Singleton (chỉ 1 instance).
4. **Companion**: Dùng cho hằng số class (`const val`) và Factory method (`create()`).

**Decision Logic (If-Else)**
- *If* bạn có 2-3 giá trị tạm muốn return -> **Pair/Triple**.
- *Else if* bạn muốn return nhiều thuộc tính + có tên rõ ràng -> **Data Class**.
- *If* bạn có tập hợp giá trị cố định (ví dụ: RED, GREEN, BLUE) -> **Enum**.
- *If* bạn cần 1 object dùng chung toàn app -> **Object**.
- *If* object đó thuộc về 1 Classspecific -> **Companion Object**.

**Top 3 Things to Remember**
1. **Infix `to`**: Viết code nhanh như nói.
2. **Enum is Type-Safe**: Tránh lỗi runtime.
3. **Object là Singleton**: Không dùng `new`.

<!-- CHUNK 51-56 -->

# DEVELOPER DECISION GUIDE: Classes and Objects (Lesson 3)

## SECTION 1: CORE MENTAL MODEL

### **Package (Gói)**
Cơ chế để tổ chức code thành các thư mục logic, tránh xung đột tên gọi (namespace). Tên thường viết thường, phân cấp bằng dấu chấm.

```kotlin
// Khai báo trong dòng đầu tiên (không tính comment)
package org.example.game

class Player {
    // Code here thuộc về package org.example.game
}
```

### **Visibility Modifiers (Bộ điều chế hiển thị)**
Công cụ kiểm soát quyền truy cập của các phần tử (class, function, property) từ bên ngoài.

*   **`public` (Mặc định):** Mọi nơi đều thấy.
*   **`private`:** Chỉ class/file đó thấy.
*   **`protected`:** Class đó và các class con (subclasses) thấy.

### **Hierarchy (Mô hình cấp bậc)**
Cách tổ chức các class từ tổng quát đến chi tiết. Tránh lặp lại logic bằng cách kế thừa thuộc tính/phương thức từ cha.

```kotlin
open class Vehicle // Cha chung
class Car : Vehicle() // Con của Vehicle
class Moped : Vehicle() // Con của Vehicle
```

## SECTION 2: DECISION TABLES

### Table 1: Chọn Visibility Modifier

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI giải thích | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Logic nội bộ class, không cho phép thay đổi từ ngoài | `private` | **Encapsulation (Đóng gói):** Bảo vệ tính toàn vẹn dữ liệu, tránh side effects. | Để `public` cho tất cả biến, dẫn đến数据 bừa bãi từ khắp nơi. |
| Thuộc tính/Method cần truy cập bởi class con (subclass) | `protected` | **Extensibility (Mở rộng):** Cho phép con kế thừa và tùy biến khi cần. | Dùng `private` chặn luôn con hoặc `public` lộ chi tiết implementation. |
| API cho các phần khác của app | `public` | **Interface (Giao diện):** Cam kết giao tiếp giữa các module. |滥用 `public` cho mọi thứ, phá vỡ tính modular. |

## SECTION 3: ARCHITACHURE & RELATIONSHIPS

### Structure Hierarchy
Dạng cây thư mục thể hiện cấu trúc package và class.

```
org.example.vehicle
├── Vehicle (Base Class)
│   └── [Properties: speed, fuel]
│   └── [Methods: drive()]
│
├── Moped (Subclass)
│   ├── Moped50cc
│   └── Moped100cc
│
└── Car (Subclass)
    ├── Sedan
    └── Hatchback
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Class & Encapsulation Basic
**Khi nào dùng:** Khi cần tạo một đối tượng có trạng thái và hành vi, đồng thời bảo vệ dữ liệu.
**Tại sao đúng:** Sử dụng `private` cho biến và `public` cho getter/setter (hoặc `val`/`var`) để kiểm soát truy cập.

```kotlin
class User(private var username: String) {

    // Getter (Tự động sinh ra khi dùng val/var)
    fun getUsername(): String = username

    // Setter với logic kiểm tra
    fun setUsername(newName: String) {
        if (newName.isNotBlank()) {
            username = newName
        }
    }
}
```

### Pattern 2: Sealed Class (Logic Phân nhánh)
**Khi nào dùng:** Khi cần định nghĩa các class con bị giới hạn trong một file (thường dùng cho `when` expression).
**Tại sao đúng:** Đảm bảo xử lý tất cả các trường hợp, tránh lỗi Missing Default Branch.

```kotlin
sealed class NetworkResult {
    data class Success(val data: String) : NetworkResult()
    data class Error(val message: String) : NetworkResult()
    object Loading : NetworkResult()
}

fun handleResult(result: NetworkResult) {
    when (result) {
        is NetworkResult.Success -> println("Data: ${result.data}")
        is NetworkResult.Error -> println("Error: ${result.message}")
        NetworkResult.Loading -> println("Loading...")
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Thiếu `open` keyword:**
    *   **Lỗi:** `class Child : Parent()` (nếu `Parent` không có `open`).
    *   **Nguy hiểm:** Kotlin mặc định `final` (không cho kế thừa). Code sẽ báo lỗi compile. Luôn nhớ thêm `open` nếu định cho phép class con kế thừa.

2.  **滥用 `public` mặc định:**
    *   **Lỗi:** Để mọi thứ là `public` vì lười khai báo.
    *   **Nguy hiểm:** Phá vỡ encapsulation. Class bên ngoài phụ thuộc vào implementation nội bộ, khiến việc refactor (sửa code) sau này cực kỳ khó khăn và dễ gây lỗi.

3.  **Quên package khai báo:**
    *   **Lỗi:** File code không có dòng `package ...`.
    *   **Nguy hiểm:** File thuộc về "default package", gây khó khăn trong việc import và quản lý project lớn. Có thể gây xung đột tên.

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
*   **Nếu bạn cần một thực thể duy nhất (Singleton):** Dùng `object`.
*   **Nếu bạn cần cấu trúc dữ liệu đơn giản (POJO):** Dùng `data class`.
*   **Nếu bạn cần định nghĩa hành vi để class khác kế thừa:** Dùng `open class`.
*   **Nếu bạn cần định nghĩa giao thức (contract) mà không cần implementation:** Dùng `interface`.
*   **Nếu bạn cần xử lý logic dựa trên loại đối tượng:** Dùng `sealed class`.

### Top 5 Things to Remember
1.  **Package:** Khai báo đầu file, viết thường, phân cấp bằng chấm (`.`).
2.  **Visibility:**
    *   `public`: Toàn cầu (Mặc định).
    *   `private`: Nội bộ file/class.
    *   `protected`: Nội bộ + Class con.
3.  **Inheritance:** Class cha cần `open`, class con dùng `:`.
4.  **Data Class:** Tự động sinh `toString()`, `equals()`, `hashCode()`.
5.  **Object:** Là Singleton (chỉ có 1 instance duy nhất trong app).