{
  "file": "Kotlin_Coroutines_Labs.pdf",
  "total_pages": 68,
  "analysis_merged": [
    {
      "summary": "Danh sách các bài học và lab về Kotlin Coroutines, bao gồm các chủ đề cơ bản như xây dựng coroutine, context, dispatcher, async/await, scope, exception handling, sequence, và flow.",
      "code_blocks": [],
      "title": "Mục lục bài học Coroutines"
    },
    {
      "summary": "Hướng dẫn thiết lập môi trường cho Project Kotlin Coroutines. Bao gồm việc tạo project và thêm dependency kotlinx-coroutines-android vào file build.gradle.kt.",
      "code_blocks": [
        {
          "language": "Groovy/Kotlin DSL",
          "code": "implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9\")",
          "explanation": "Thêm thư viện kotlinx-coroutines-android version 1.3.9 vào dependencies của app module để sử dụng Coroutines trên Android."
        }
      ],
      "title": "Bước 1: Tạo Project và thêm Dependencies"
    },
    {
      "summary": "Hướng dẫn các bước tạo file Kotlin và chạy chương trình: Tạo package 'firstcoroutines', tạo file 'BuildFirstCoroutines.kt', viết hàm main và chạy bằng phím tắt Run.",
      "code_blocks": [],
      "title": "Bước 2: Cấu trúc file và chạy code"
    },
    {
      "summary": "Lab 1: minh họa cách tạo Coroutine đầu tiên sử dụng GlobalScope.launch. Kết quả in ra 'World ' ngay lập tức, sau đó 2 giây in ra 'Hello ' do delay bên trong coroutine.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "package vn.edu.hust.soict.gv.quangnh.coroutineexample.firstcoroutines\n\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\n\nfun main() {\n    GlobalScope.launch {\n        delay(1000)\n        print(\"Hello \")\n    }\n    print(\"World \")\n    Thread.sleep(2000)\n}",
          "explanation": "Khởi tạo một coroutine toàn cục (GlobalScope) để thực thi công việc có delay 1 giây. Thread chính tiếp tục chạy và in 'World ' ngay lập tức. Thread.sleep(2000) giữ main thread sống đủ lâu để coroutine hoàn thành và in 'Hello '."
        }
      ],
      "title": "Lab 1. Chương trình coroutine đầu tiên"
    },
    {
      "summary": "Lab 2: Sử dụng runBlocking để tạo coroutine. Hàm này block thread hiện tại cho đến khi coroutine bên trong hoàn thành. Yêu cầu xác định kết quả in ra và tên thread của từng đoạn code.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "fun main() {\n    runBlocking {\n        delay(1000)\n        println(\"Hello \")\n        delay(1000)\n        println(\"World \")\n    }\n    println(\"After runBlocking\")\n}\nprintln(\"Current Thread: ${Thread.currentThread().name}\")",
          "explanation": "runBlocking tạo một Scope coroutine và block thread gọi nó cho đến khi khối code bên trong hoàn thành. Các lệnh delay bên trong sẽ dừng luồng执行 (main thread) thực sự, khác với GlobalScope là chỉ hoãn nội bộ."
        }
      ],
      "title": "Lab 2: runBlocking"
    },
    {
      "summary": "Bài 2. Coroutine Context: Giới thiệu Dispatchers - thành phần quyết định Thread nào sẽ chạy Coroutine.",
      "code_blocks": [],
      "title": "2.1. Dispatchers"
    },
    {
      "summary": "Lab 3: Test các loại Dispatchers khác nhau (Default, IO, Unconfined, Main) để xem chúng chạy trên Thread nào.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "object TestDispatchers {\n    fun runMyFirstCoroutines() {\n        GlobalScope.launch(Dispatchers.Default) {\n            Log.d(..., \"Dispatchers Default run on ${Thread.currentThread().name}\")\n        }\n        GlobalScope.launch(Dispatchers.IO) {\n            Log.d(..., \"Dispatchers IO run on ${Thread.currentThread().name}\")\n        }\n        GlobalScope.launch(Dispatchers.Unconfined) {\n            Log.d(..., \"Dispatchers Unconfined run on ${Thread.currentThread().name}\")\n        }\n        GlobalScope.launch(Dispatchers.Main) {\n            Log.d(..., \"Dispatchers Main run on ${Thread.currentThread().name}\")\n        }\n    }\n}",
          "explanation": "Mỗi GlobalScope.launch được gán một Dispatcher cụ thể để kiểm tra thread chạy. \n- Default: Sử dụng thread nền (CPU-bound).\n- IO: Sử dụng thread pool cho tác vụ I/O.\n- Unconfined: Bắt đầu trên thread hiện tại nhưng có thể chuyển sang thread khác.\n- Main: Yêu cầu chạy trên UI Thread."
        }
      ],
      "title": "Lab 3: Dispatcher"
    },
    {
      "summary": "File MainActivity để gọi TestDispatchers.runMyFirstCoroutines(), đảm bảo chạy trong Context của Android UI Thread.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        TestDispatchers.runMyFirstCoroutines()\n    }\n}",
          "explanation": "Activity chính gọi hàm test coroutine. Lưu ý việc gọi Dispatchers.Main yêu cầu code phải chạy trên Main Thread của Android."
        }
      ],
      "title": "File MainActivity.kt"
    },
    {
      "title": "Dispatchers.Unconfined và Dispatchers.Main",
      "summary": "Phần này giải thích về hành vi của Dispatchers. Dispatchers.Main và Dispatchers.Unconfined đều thực thi trên Main Thread ban đầu. Tuy nhiên, Dispatchers.Unconfined có thể chuyển sang Thread khác nếu có thao tác blocking (như delay) và sau đó không chuyển trở lại Thread ban đầu.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "GlobalScope.launch(Dispatchers.Unconfined) {\n    Log.d(..., \"Before delay - run on ${Thread.currentThread().name}\")\n    delay(1000)\n    Log.d(..., \"After delay - run on ${Thread.currentThread().name}\")\n}\nGlobalScope.launch(Dispatchers.Main) {\n    Log.d(..., \"Dispatchers Main run on ${Thread.currentThread().name}\")\n}",
          "explanation": "Code minh họa sự khác biệt: luồng Unconfined có thể đổi Thread sau delay, trong khi Main luôn giữ nguyên luồng UI."
        }
      ]
    },
    {
      "title": "withContext để chuyển ngữ cảnh",
      "summary": "Giới thiệu hàm `withContext(Dispatchers.Main)` để chuyển đổi luồng thực thi từ luồng nền (ví dụ: IO) về Main Thread. Đây là cách an toàn để cập nhật UI sau khi hoàn thành tác vụ dài.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "GlobalScope.launch(Dispatchers.IO) {\n    // Chạy task nặng\n    delay(2000)\n    withContext(Dispatchers.Main) {\n        // Cập nhật UI\n    }\n}",
          "explanation": "Dùng `withContext` để đảm bảo code cập nhật UI chạy trên Main Thread."
        }
      ]
    },
    {
      "title": "Quản lý Job và thứ tự thực thi",
      "summary": "Sử dụng đối tượng `Job` để quản lý Coroutine. Có thể dùng `job.join()` để chờ một Coroutine khác hoàn thành trước khi thực hiện tiếp.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "val job1 = GlobalScope.launch { delay(2000); println(\"Hello\") }\nval job2 = GlobalScope.launch {\n    job1.join() // Chờ job1\n    delay(1000); println(\"World\")\n}",
          "explanation": "Job2 phải chờ Job1 hoàn thành mới chạy."
        }
      ]
    },
    {
      "title": "Hủy bỏ Coroutine",
      "summary": "Giới thiệu cách hủy Coroutine bằng hàm `cancel()`. Tuy nhiên, nếu Coroutine đang thực hiện vòng lặp tính toán (computation loop) mà không kiểm tra trạng thái, nó sẽ tiếp tục chạy cho đến hết vòng lặp.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "val job = launch {\n    repeat(1000) {\n        delay(500)\n        println(\"Sleeping $it\")\n    }\n}\ndelay(1500)\njob.cancel()",
          "explanation": "Hủy job sau 1.5s. Nếu không có `isActive` hoặc `yield`, vòng lặp repeat có thể vẫn chạy."
        }
      ]
    },
    {
      "title": "Kiểm tra tính năng hoạt động (isActive)",
      "summary": "Để Coroutine có thể phản ứng với lệnh hủy ngay lập tức, cần kiểm tra `isActive` trong vòng lặp CPU-bound.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "while (isActive) {\n    // computation loop\n    if (System.currentTimeMillis() >= nextPrintTime) {\n        // print\n    }\n}\n// ... job.cancelAndJoin()",
          "explanation": "Vòng lặp sẽ dừng ngay khi `isActive` trả về false do lệnh hủy."
        }
      ]
    },
    {
      "title": "Xử lý finally khi hủy",
      "summary": "Khi hủy Coroutine, khối `finally` sẽ được thực thi để giải phóng tài nguyên, đảm bảo các tác vụ dọn dẹp được thực hiện.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "try {\n    repeat(1000) { delay(100); println(\"Hello\") }\n} finally {\n    println(\"Print from finally\")\n}\n// ... job.cancel()",
          "explanation": "In ra 'Print from finally' ngay cả khi `cancel()` được gọi."
        }
      ]
    },
    {
      "title": "Xử lý finally và NonCancellable khi hủy Coroutine",
      "summary": "Phần này giải thích cách xử lý khối 'finally' khi Coroutine bị hủy. Ví dụ 11 cho thấy khối 'finally' được thực thi khi gọi 'job.cancel()'. Tuy nhiên, nếu khối 'finally' chứa các suspend function như 'delay', nó có thể bị hủy theo. Để tránh điều này, Ví dụ 12 sử dụng 'withContext(NonCancellable)' để đảm bảo các tác vụ dọn dẹp trong 'finally' được thực thi hoàn toàn.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "try {\n  repeat(1000) {\n    delay(100)\n    println(\"Hello Coroutine\")\n  }\n} finally {\n  println(\"Print from finally\")\n  withContext(NonCancellable) {\n    repeat(2) {\n      delay(100)\n      println(\"Print from NonCancellable\")\n    }\n  }\n}",
          "explanation": "Khối 'finally' được thực thi khi Coroutine bị hủy. 'withContext(NonCancellable)' được dùng trong 'finally' để cho phép các lệnh 'delay' hoặc các tác vụ Suspended khác tiếp tục chạy mà không bị hủy, đảm bảo việc giải phóng tài nguyên."
        }
      ]
    },
    {
      "title": "Timeouts (Ví dụ 13)",
      "summary": "Giới thiệu cơ chế 'Timeouts' bằng cách sử dụng hàm 'withTimeout'. Nếu Coroutine chạy quá thời gian chỉ định (ví dụ 1800ms), nó sẽ bị hủy tự động và ném ra ngoại lệ TimeoutCancellationException.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "withTimeout(1800) {\n  repeat(1000) {\n    println(\"I'm sleeping $it\")\n    delay(500)\n  }\n}",
          "explanation": "Đoạn code này đảm bảo Coroutine chỉ chạy tối đa 1800ms. Nếu không hoàn thành trong khoảng thời gian này, nó sẽ bị dừng đột ngột."
        }
      ]
    },
    {
      "title": "Xử lý Exception với withTimeoutOrNull (Ví dụ 14 & 15)",
      "summary": "Giới thiệu 'withTimeoutOrNull' làm phương án an toàn hơn so với 'withTimeout'. Nếu Coroutine vượt quá thời gian giới hạn, hàm sẽ trả về giá trị 'null' thay vì ném ra exception. Đoạn code cũng minh họa trường hợp Coroutine hoàn thành trước timeout thì trả về giá trị bình thường.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "val result = withTimeoutOrNull(1800) {\n  repeat(1000) {\n    println(\"I'm sleeping $it\")\n    delay(500)\n  }\n  \"Done\"\n}\nprintln(\"Result = $result\")",
          "explanation": "Hàm này thực thi Coroutine nhưng sẽ hủy nó nếu quá 1800ms và trả về 'null', giúp việc xử lý logic tiếp theo dễ dàng hơn mà không cần try-catch."
        }
      ]
    },
    {
      "title": "Async và Await (Ví dụ 16 & 17)",
      "summary": "Phân tích sự khác biệt giữa việc gọi tuần tự và gọi song song các suspend functions. Ví dụ 16 thực thi tuần tự (tốn ~2 giây), trong khi Ví dụ 17 sử dụng 'async' để khởi chạy song song và 'await' để lấy kết quả, giảm thời gian thực thi đáng kể (tốn ~1 giây).",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "val a: Deferred<Int> = async { doSomethingFunny1() }\nval b: Deferred<Int> = async { doSomethingFunny2() }\nprintln(a.await() + b.await())",
          "explanation": "Sử dụng 'async' để chạy các tác vụ lấy giá trị 'a' và 'b' một cách song song. 'await()' được gọi để lấy kết quả khi cả hai hoàn thành, tối ưu hóa thời gian chờ."
        }
      ]
    },
    {
      "title": "Khái niệm CoroutineScope",
      "summary": "Tóm tắt khái niệm phạm vi Coroutine. Mọi Coroutine (thông qua 'runBlocking', 'launch', 'async') đều chạy bên trong một CoroutineScope, giúp quản lý vòng đời và kế thừa context.",
      "code_blocks": []
    },
    {
      "title": "Tính chất kế thừa của Job và Hủy bỏ theo Hierarchy",
      "summary": "Ví dụ 18 min họa cách Coroutine Scope hoạt động theo cấu trúc cha-con. Khi một Job cha (job1) bị hủy, các coroutine con chạy bên trong nó cũng bị hủy theo ngay lập tức, thể hiện cơ chế 'cancellation propagates downwards' (hủy bỏ lan truyền từ trên xuống).",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "runBlocking {\n  val job1 = launch {\n    launch { /* ... */ }\n    launch { /* ... */ }\n  }\n  delay(500)\n  job1.cancel()\n}",
          "explanation": "Hành động gọi `job1.cancel()` sẽ hủy bỏ cả 2 coroutine con bên trong nó."
        }
      ]
    },
    {
      "title": "GlobalScope và tính độc lập của Coroutine",
      "summary": "Ví dụ 19 giới thiệu `GlobalScope`. Các coroutine được khởi chạy trong `GlobalScope` không thuộc về bất kỳ scope nào khác (không có cha), nên việc hủy bỏ job cha trong `runBlocking` không ảnh hưởng đến chúng. Điều này được dùng cho các tác vụ cần chạy độc lập và không bị gián đoạn.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "GlobalScope.launch {\n  delay(500)\n  job1.cancel() // Job này vẫn chạy dù job1 bị hủy\n  println(\"coroutine 3: Hello\")\n}",
          "explanation": "Coroutine này chạy trong GlobalScope, tách biệt với scope cha, nên không bị hủy bỏ theo hierarchy."
        }
      ]
    },
    {
      "title": "Join và cấu trúc các coroutine con",
      "summary": "Phân tích sự khác biệt giữa Ví dụ 20 (coroutine trực tiếp) và Ví dụ 21 (coroutine cha tạo các coroutine con). Trong cả hai trường hợp, `job.join()` đều chờ đợi cho đến khi công việc hoàn tất. Điều này cho thấy tính chất 'chained' (dây chuyền) của job: job cha chỉ hoàn thành khi tất cả các job con đã hoàn thành.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "// Ví dụ 21\nlaunch {\n  repeat(3) {\n    launch { /* ... */ } // Tạo các coroutine con\n  }\n  println(\"Print from parent\")\n}\njob.join()",
          "explanation": "Dòng `println` cha in ra sau cùng, sau khi tất cả các coroutine con hoàn thành, và `job.join()` sẽ trả về."
        }
      ]
    },
    {
      "title": "Cách Exceptions hoạt động trong Launch và Async",
      "summary": "Ví dụ 22 và 23 min họa cách xử lý lỗi: `launch` ném exception sẽ tự động đóng (cancel) parent scope và propagate lỗi, trong khi `async` (vốn là một Deferred) chỉ ném exception khi gọi hàm `await()`.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val deferred = GlobalScope.async {\n  throw IndexOutOfBoundsException()\n}\n// Chưa có exception ngay\ndeferred.await() // Lỗi được ném ra ở đây",
          "explanation": "Lỗi trong `async` bị 'nuốt' cho đến khi giá trị được yêu cầu qua `await()`."
        }
      ]
    },
    {
      "title": "Bắt lỗi nội bộ với Try-Catch và CoroutineExceptionHandler",
      "summary": "Ví dụ 24 và 25 trình bày 2 cách xử lý lỗi:\n1. Dùng `try-catch` bọc quanh `launch` hoặc `await` để xử lý lỗi ở mức độ gọi.\n2. Dùng `CoroutineExceptionHandler` (Ví dụ 25) như một phần của Context để bắt lỗi bất đồng bộ một cách tổng quát, tương tự như `catch` block trong các cấu trúc khác.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val handler = CoroutineExceptionHandler { _, exception ->\n  println(\"Error here: ${exception.toString()\")\n}\nval job = GlobalScope.launch(handler) {\n  throw NullPointerException()\n}",
          "explanation": "Sử dụng `CoroutineExceptionHandler` để bắt lỗi ném ra từ coroutine mà không cần try-catch trực tiếp trong block code."
        }
      ]
    },
    {
      "title": "Hạn chế của CoroutineExceptionHandler với async",
      "summary": "Ví dụ 26 minh họa một hạn chế quan trọng: `CoroutineExceptionHandler` không bắt được lỗi khi dùng với `async`. Trong khi `launch` có thể bắt lỗi và gửi đến handler, `async` ném lỗi ra khi gọi `await()`. Nếu `async` không có `await()`, lỗi có thể bị nuốt hoặc không xử lý được.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val deferred = GlobalScope.async(handler) {\n    println(\"Throw Exception from Async\")\n    throw IndexOutOfBoundsException()\n}\ndeferred.await()",
          "explanation": "Lỗi ném ra trong khối `async` không kích hoạt `CoroutineExceptionHandler` ngay lập tức. Lỗi sẽ được trả về như một kết quả thất bại của `Deferred` và chỉ được xử lý khi `await()` được gọi."
        }
      ]
    },
    {
      "title": "Hành vi của lỗi trong Coroutine cha với nhiều con",
      "summary": "Ví dụ 27 cho thấy rằng nếu một coroutine con ném lỗi, nó sẽ làm hỏng (cancel) các coroutine anh em khác trong cùng scope. Cả hai coroutine sau đều bị dừng lại ngay cả khi chưa hoàn thành công việc của chúng (ví dụ: Coroutine 1 và 3 chỉ in được một phần).",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val job = GlobalScope.launch(handle) {\n    launch { /* ... throw ... */ } // Coroutine 1\n    launch { /* ... throw ... */ } // Coroutine 2\n    launch { /* ... throw ... */ } // Coroutine 3\n}\njob.join()",
          "explanation": "Khi Coroutine 2 throw Exception, nó lan truyền lỗi lên cha, hủy bỏ toàn bộ job và các coroutine con còn lại (1 và 3) bị hủy bất kể độ trễ."
        }
      ]
    },
    {
      "title": "Xử lý lỗi bị che giấu (Suppressed Exceptions)",
      "summary": "Ví dụ 28 minh họa cơ chế 'suppressed exceptions'. Trong một khối cha, nếu nhiều coroutine con ném lỗi cùng lúc, các lỗi phụ (suppressed) được tổng hợp lại vào một lỗi chính. `CoroutineExceptionHandler` có thể truy cập list `suppressed` này để log đầy đủ.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val handle = CoroutineExceptionHandler { _, exception ->\n    println(\"Exception: $exception with suppressed ${exception.suppressed.contentToString()}\")\n}",
          "explanation": "Handler này ghi lại lỗi chính và danh sách các lỗi phụ bị 'suppressed', giúp xử lý tình huống nhiều lỗi cùng 발생."
        }
      ]
    },
    {
      "title": "Giới thiệu SupervisorJob và SupervisorScope",
      "summary": "Phần này giải thích cách tránh việc lỗi con hủy cha bằng `SupervisorJob`. Khác với `Job` thường (vốn có quan hệ cha-con lây lan lỗi và hủy bỏ), `SupervisorJob` cho phép các con thất bại độc lập mà không ảnh hưởng đến cha hoặc các anh em. Ví dụ 29 và 30 minh họa việc sử dụng `SupervisorJob` trực tiếp và `supervisorScope` để tạo scope quản lý.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "val supervisorJob = SupervisorJob()\nwith(CoroutineScope(coroutineContext + supervisorJob)) {\n    val firstChild = launch { throw NullPointerException() }\n    val secondChild = launch { /* ... */ }\n}",
          "explanation": "Sử dụng `SupervisorJob` để tạo scope. Khi `firstChild` ném lỗi, `secondChild` vẫn tiếp tục chạy chứ không bị hủy theo."
        },
        {
          "language": "kotlin",
          "code": "supervisorScope {\n    val firstChild = launch { throw NullPointerException() }\n    val secondChild = launch { /* ... */ }\n}",
          "explanation": "Cách khác để tạo scope an toàn, thường dùng trong các hàm suspending."
        }
      ]
    },
    {
      "title": "Sequence trong Kotlin (Lazy Execution)",
      "summary": "Ví dụ 31 và phần sau đó giới thiệu `Sequence`. Đây là một cấu trúc dữ liệu lazily evaluated (tính toán trễ) cho phép xử lý các chuỗi dữ liệu lớn một cách hiệu quả (tương tự stream trong Java). Các phép toán như `map` được thực thi tuần tự.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "fun foo(n: Int) : Sequence<Int> = sequence {\n    for (i in 0..n) {\n        if (i % 2 == 0) yield(i)\n    }\n}\nfun main() {\n    foo(10).map{ it * it }.forEach { println(it) }\n}",
          "explanation": "Hàm `foo` trả về một `Sequence` sử dụng builder `sequence` và từ khóa `yield` để trả về giá trị mà không cần lưu trữ toàn bộ bộ nhớ. `map` ở đây được gọi trên chuỗi Sequence, thực thi các phép tính trên từng phần tử."
        }
      ]
    },
    {
      "title": "Kết hợp Sequence với Filter và giới thiệu Flow",
      "summary": "Chương này chuyển từ cấu trúc Sequence (tính toán trễ cơ bản) sang Flow trong Kotlin Coroutines. Flow cho phép xử lý bất đồng bộ (asynchronous) và có thể h hủy (cancellable), được bao bọc trong `runBlocking` để chạy. Đoạn code minh họa cách tạo Flow bằng `flow { }`, emit dữ liệu với `delay()`, và xử lý với các operator như `collect`. Lưu ý lỗi đánh máy trong output mẫu (87 thay cho 8, 7).",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "fun main() {\nfoo(10).filter { it < 8 }.forEach {\nprintln(it)\n}\n}\n// ...\nfun foo(n : Int): Flow<Int> = flow {\nfor(i in 0..n) {\ndelay(1000)\nemit(i)\n}\n}",
          "explanation": "So sánh Sequence (code đầu) cho phép lọc tuần tự, trong khi Flow (code sau) được tạo để emit giá trị theo thời gian, sẵn sàng cho các tác vụ bất đồng bộ."
        }
      ]
    },
    {
      "title": "Huỷ bỏ Flow (Flow Cancellation)",
      "summary": "Minh họa cơ chế huỷ bỏ tác vụ trong Flow. Sử dụng `withTimeoutOrNull(3000)` để giới hạn thời gian thực thi. Flow sẽ tự động bị hủy nếu thời gian timeout kết thúc mà chưa xử lý xong toàn bộ dữ liệu (ví dụ: `foo(10)` nhưng chỉ in ra khoảng 3 giá trị do delay 1s mỗi giá trị).",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "withTimeoutOrNull(3000) {\nfoo(10).collect {\nprintln(\"i = $it\")\n}\n}",
          "explanation": "Sử dụng `withTimeoutOrNull` để hủy Flow nếu nó chạy quá 3 giây, tránh treo program."
        }
      ]
    },
    {
      "title": "Toán tử transform và map",
      "summary": "Phân tích sự khác biệt giữa `transform` và `map`. `map` chỉ biến đổi 1-1 (mỗi đầu vào cho 1 đầu ra), trong khi `transform` linh hoạt hơn, cho phép emit nhiều giá trị hoặc thay đổi kiểu dữ liệu trong quá trình xử lý.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "list.asFlow().transform {\nemit(it * it)\nit * it * it\n}.collect { ... }",
          "explanation": "`transform` cho phép emit cả bình phương và lập phương của mỗi phần tử, tạo ra nhiều giá trị hơn."
        },
        {
          "language": "kotlin",
          "code": "list.asFlow().map {\nit * it\n}.collect { ... }",
          "explanation": "`map` chỉ trả về bình phương, giữ nguyên số lượng phần tử."
        }
      ]
    },
    {
      "title": "Các toán tử xử lý dữ liệu: take, filter",
      "summary": "Giới thiệu các toán tử cơ bản để kiểm soát luồng dữ liệu. `take(n)` lấy n giá trị đầu tiên (giúp dừng sớm), `filter` loại bỏ các giá trị không thỏa mãn điều kiện.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "list.asFlow().take(3).collect { ... }",
          "explanation": "Lấy 3 phần tử đầu tiên và kết thúc."
        },
        {
          "language": "kotlin",
          "code": "list.asFlow().filter { it % 2 == 0 }.collect { ... }",
          "explanation": "Lọc và chỉ giữ lại các số chẵn."
        }
      ]
    },
    {
      "title": "Toán tử kết quả: reduce và fold",
      "summary": "Cách tính toán tổng kết (aggregation) trên Flow. `reduce` tính toán cộng dồn mà không có giá trị khởi tạo, `fold` cho phép đặt giá trị ban đầu (ví dụ bắt đầu từ 5). Cả hai đều duyệt tuần tự qua các phần tử.",
      "code_blocks": [
        {
          "language": "kotlin",
          "code": "list.asFlow().reduce { acc, value -> acc + value }",
          "explanation": "Tính tổng các phần tử, `acc` là tổng trước đó."
        },
        {
          "language": "kotlin",
          "code": "list.asFlow().fold(5) { acc, value -> acc + value }",
          "explanation": "Tính tổng bắt đầu từ giá trị khởi tạo là 5."
        }
      ]
    },
    {
      "title": "Kết hợp nhiều hàm (Operator Chaining)",
      "summary": "Phần này giới thiệu cách kết hợp chuỗi các toán tử xử lý Flow như filter, map, và take. Các toán tử này trả về một Flow mới cho phép xây dựng pipeline xử lý dữ liệu tuần tự trước khi gọi collect.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "list.asFlow().filter { it % 2 == 0 }.map { it * 2 }.take(2).collect { println(\"value = $it\") }",
          "explanation": "Lọc các số chẵn, nhân đôi chúng, và chỉ lấy 2 giá trị đầu tiên trước khi in ra kết quả."
        }
      ]
    },
    {
      "title": "Hàm single() và singleOrNull()",
      "summary": "Hàm single() dùng để kiểm tra tính duy nhất của giá trị trong Flow. Nếu Flow emit nhiều hơn hoặc ít hơn 1 giá trị, nó sẽ ném ngoại lệ. singleOrNull() là phiên bản an toàn hơn, trả về null nếu Flow rỗng và ngoại lệ nếu có nhiều giá trị.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "(1..10).asFlow().single()",
          "explanation": "Thử lấy duy nhất một giá trị từ dải số 1-10, nhưng sẽ ném ngoại lệ vì có nhiều giá trị được emit."
        },
        {
          "language": "Kotlin",
          "code": "listOf<Int>().asFlow().singleOrNull()",
          "explanation": "Kiểm tra Flow rỗng, trả về null thay vì gây crash."
        }
      ]
    },
    {
      "title": "Hàm zip",
      "summary": "Hàm zip kết hợp hai Flow lại với nhau theo cặp. Nó sẽ đợi cả hai Flow emit giá trị tương ứng, sau đó sử dụng lambda transform để xử lý và emit kết quả.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "nums.zip(strs) { num, str -> \"(num = $num and str = $str)\" }.collect { println(it) }",
          "explanation": "Kết hợp flow số (1,2,3) với flow chuỗi (\"one\", \"two\",...\") thành các cặp (1, \"one\"),..."
        }
      ]
    },
    {
      "title": "So sánh Zip và Combine",
      "summary": "Ví dụ minh họa sự khác biệt giữa zip và combine khi xử lý thời gian delay. Zip chỉ emit khi cả hai nguồn đều có giá trị mới. Combine emit ngay khi một trong hai nguồn thay đổi giá trị, sử dụng giá trị mới nhất của nguồn còn lại.",
      "code_blocks": [
        {
          "language": "Kotlin",
          "code": "// Ví dụ 45 & 46\nnums.zip(strs) { ... } // Tốc độ chậm hơn (theo từng cặp)\nnums.combine(strs) { ... } // Tốc độ nhanh hơn (theo biến đổi của nums)",
          "explanation": "Trong ví dụ, nums delay 100ms, strs delay 400ms. Zip emit 3 lần sau ~400ms. Combine emit 3 lần sau ~300ms vì emit theo nhịp nhanh hơn của nums và lấy giá trị gần nhất của strs."
        }
      ]
    }
  ]
}