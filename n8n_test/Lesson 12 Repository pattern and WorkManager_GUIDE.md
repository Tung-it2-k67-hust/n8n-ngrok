# DEVELOPER DECISION GUIDE: Lesson 12 Repository pattern and WorkManager.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:15:24



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Repository & WorkManager

## SECTION 1: CORE MENTAL MODEL

### 1.1. Repository Pattern (Mẫu Kho lưu trữ)
**Definition:** Lớp trung gian (Mediator) giữa UI/ViewModel và các nguồn dữ liệu thực tế (Database, Network, Cache). Nó cung cấp một API duy nhất để truy xuất dữ liệu bất kể nguồn gốc.

**Why use it?**
- **Abstraction (Trừu tượng):** UI không cần biết dữ liệu từ đâu đến (API hay DB).
- **Single Source of Truth (Nguồn Sự Thật Duy Nhất):** Dữ liệu nhất quán.
- **Responsiveness (Phản hồi nhanh):** Trả về dữ liệu cache/local ngay lập trình, cập nhật UI khi có dữ liệu mạng mới.

**Code Demo:**
```kotlin
// Interface abstraction
interface UserRepository {
    suspend fun getUsers(): List<User>
    suspend fun insertUser(user: User)
}

// Implementation (The "Logic" hub)
class UserRepositoryImpl(
    private val api: UserApi,
    private val dao: UserDao
) : UserRepository {
    
    override suspend fun getUsers(): List<User> {
        // 1. Try local first (Fast)
        val localUsers = dao.getAll()
        if (localUsers.isNotEmpty()) return localUsers

        // 2. Fetch remote (Slow)
        val remoteUsers = api.fetchUsers()
        
        // 3. Cache locally
        dao.insertAll(remoteUsers)
        
        return remoteUsers
    }
    
    override suspend fun insertUser(user: User) {
        // Update local immediately, sync to remote in background
        dao.insert(user)
        // Optional: Launch coroutine to sync to API
    }
}
```

### 1.2. WorkManager
**Definition:** Thư viện nền tảng (AndroidX) để lên lịch các tác vụ nền đảm bảo (Deferrable) và garantuée (Guaranteed). Dù app tắt hay device restart, tác vụ vẫn chạy.

**Why use it?**
- **Guaranteed Execution (Đảm bảo chạy):** Không bị kill bởi hệ thống.
- **Battery Friendly (Tiết kiệm pin):** Tuân thủ Doze mode, Battery Optimization.
- **Chained Tasks (Nối tiếp):** Dễ dàng tạo chuỗi tác vụ (A xong mới làm B).

**Code Demo:**
```kotlin
// 1. Define the Work (What to do)
class SyncDataWorker(appContext: Context, params: WorkerParameters) 
    : CoroutineWorker(appContext, params) {
    
    override suspend fun doWork(): Result {
        return try {
            // Logic: Gọi Repository để sync data
            repository.syncData()
            Result.success()
        } catch (e: Exception) {
            Result.retry() // Hoặc Result.failure()
        }
    }
}

// 2. Schedule the Work (When to do)
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.CONNECTED)
    .setRequiresBatteryNotLow(true)
    .build()

val uploadWork = OneTimeWorkRequestBuilder<SyncDataWorker>()
    .setConstraints(constraints)
    .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
    .build()

WorkManager.getInstance(context).enqueue(uploadWork)
```

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **UI hiển thị danh sách data** | **Repository Pattern** | **Separation of Concerns (Tách biệt trách nhiệm):** UI chỉ quan tâm đến data, không quan tâm data từ API hay DB. Dễ thay đổi source sau này. | Để logic gọi API trực tiếp trong ViewModel. Khi đổi API phải sửa lại ViewModel. |
| **App cần tắt mạng vẫn lưu được data** | **Repository + Room** | **Offline Support (Hỗ trợ ngoại tuyến):** Repository sẽ check local DB nếu không có mạng. | Chỉ gọi API, không lưu cache. App sẽ bị "đóng băng" khi mất mạng. |
| **Sync data định kỳ (e.g., 24h)** | **PeriodicWorkRequest (WorkManager)** | **Background Execution (Chạy nền):** Đảm bảo app có thể bị kill nhưng request vẫn được thực hiện vào đúng thời điểm. | Dùng `Timer` hay `Thread` thuần. System sẽ kill app khi app background, tác vụ bị trễ hoặc mất. |
| **Xử lý task nặng khi app đã đóng** | **OneTimeWorkRequest (WorkManager)** | **Guaranteed Execution (Đảm bảo):** WorkManager quản lý queue, chạy khi resources sẵn sàng (sạc, mạng). | Dùng IntentService cũ. Không còn được khuyến khích, không linh hoạt bằng WorkManager. |
| **Upload file lớn (continuation)** | **WorkManager (Chained)** | **Chained Work (Chuỗi tác vụ):** Dễ dàng setup "Upload 1 -> Upload 2 -> Notify UI". Dễ quản lý dependencies. | Viết thủ công Coroutine scope trong Service. Khó xử lý lỗi và retry logic. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### 3.1. Architecture Flow (Layered)

```text
[ UI Layer (Activity/Fragment) ]
       ↓ (Observer)
[ ViewModel ] 
       ↓ (Call methods)
[ Repository ] <--- Kiểm soát luồng dữ liệu (Data Strategy)
       ↓
   +-------------------+
   |                   |
[ Local Data ]    [ Remote Data ]
  (Room DB)         (Retrofit API)
```

**Key Relationship:**
- **ViewModel** không bao giờ gọi trực tiếp Room hoặc Retrofit.
- **Repository** là nơi viết logic: `Nếu có mạng -> Gọi API -> Cập nhật DB`. `Nếu không mạng -> Trả về DB`.
- **WorkManager** là tác nhân độc lập, có thể gọi **Repository** để thực hiện tác vụ nền.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Cache-First Repository (Ưu tiên Cache)
**Khi nào dùng:** Hiển thị danh sách đọc (Read-heavy) như tin tức, danh sách sản phẩm. Cần tốc độ load UI nhanh.

**Tại sao đúng:** Tối ưu trải nghiệm người dùng (UX). UI hiển thị ngay lập tức, dữ liệu mới nhất được cập nhật sau.

```kotlin
class NewsRepository(
    private val api: NewsApi,
    private val dao: NewsDao
) {
    // Trả về LiveData/Flow để UI tự update
    fun getNews(): Flow<List<News>> {
        return flow {
            // 1. Emit local cache ngay lập tức
            emit(dao.getNews())

            // 2. Fetch remote
            try {
                val freshNews = api.getNews()
                // 3. Cập nhật cache (Single Source of Truth)
                dao.insertAll(freshNews)
                // 4. Flow tự emit giá trị mới từ DB
            } catch (e: Exception) {
                // Bỏ qua lỗi mạng, UI vẫn dùng data cũ
            }
        }
    }
}
```

### Pattern 2: WorkManager for Database Sync
**Khi nào dùng:** Cần upload dữ liệu thay đổi (Log/Trạng thái) lên server khi người dùng không cần biết ngay lập tức.

**Tại sao đúng:** Tách biệt logic network ra khỏi UI thread. Đảm bảo dữ liệu không bị mất nếu app tắt.

```kotlin
// Worker
class UploadLogWorker(appContext: Context, params: WorkerParameters) 
    : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result {
        // Inject hoặc gọi trực tiếp Repository
        val logDao = AppDatabase.getInstance(applicationContext).logDao()
        val logs = logDao.getUnsyncedLogs()

        if (logs.isEmpty()) return Result.success()

        return try {
            // Gọi API
            ApiService.uploadLogs(logs)
            // Đánh dấu đã sync trong DB
            logDao.markAsSynced(logs.map { it.id })
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}

// Schedule
val request = OneTimeWorkRequestBuilder<UploadLogWorker>()
    .setConstraints(Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build())
    .build()

WorkManager.getInstance(context).enqueue(request)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. God ViewModel (ViewModel Chúa Trời)
**Hành vi:** ViewModel chứa logic truy cập trực tiếp API hoặc Database.
**Tại sao nguy hiểm:** Khó test (Unit Test), vi phạm nguyên tắc Single Responsibility. Khi thay đổi source data (ví dụ từ REST API sang GraphQL), phải sửa lại ViewModel.

### 2. Repository gọi UI (Circular Dependency)
**Hành vi:** Repository gọi callback hoặc update UI trực tiếp.
**Tại sao nguy hiểm:** Violates Dependency Injection. Repository phải là "dumb" (ngu ngốc), chỉ biết xử lý data, không biết UI là gì. Luôn trả数据 cho ViewModel qua LiveData/Flow.

### 3. WorkManager cho Task Time-critical (Thời gian nhạy cảm)
**Hành vi:** Dùng WorkManager để gửi thông báo "Đã đến giờ" (Alarm clock).
**Tại sao nguy hiểm:** WorkManager được tối ưu để tiết kiệm pin, nó có thể trì hoãn execution (lùi lại vài phút) nếu device vào Doze mode. Nên dùng `AlarmManager` hoặc `Notification` với trigger time chính xác cho việc này.

### 4. Không xử lý Offline trong Repository
**Hành vi:** Nếu mạng lỗi thì crash hoặc báo lỗi ngay, không chịu đọc DB local.
**Tại sao nguy hiểm:** App không "Resilient" (Mềm dẻo). Người dùng không thể sử dụng app khi đi tàu điện ngầm/mất mạng.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Repository:** Để ở giữa ViewModel và Data Source. Luôn hoạt động异步 (Coroutine/Flow).
2. **WorkManager:** Dùng cho tác vụ cần **Quá trình (Process)** đảm bảo chạy, không cần UI phản hồi ngay.
3. **Room/Retrofit:** Đặt trong Repository, không bao giờ trong ViewModel.
4. **Constraints:** Luôn set `NetworkType.CONNECTED` cho tác vụ upload/download.

### Decision Logic (If-Else)
```text
IF (Task must run even if app is closed) 
   → Use WorkManager

ELSE IF (Task must finish immediately and user sees result)
   → Use Repository + Coroutine (Trong ViewModel)

ELSE IF (Data needs to survive app restart)
   → Use Room (via Repository)

ELSE 
   → Use ViewModel logic only (for simple in-memory data)
```

### Top 5 Things to Remember
1. **Repository is King:** Nơi duy nhất được quyết định lấy data từ đâu.
2. **WorkManager ≠ Thread:** Đừng dùng nó cho task nhỏ chạy dưới 10 giây. Dùng Coroutine.
3. **Single Source of Truth:** Database (Room) là nguồn dữ liệu cuối cùng cho UI.
4. **Flow/LiveData:** Dùng nó để connect Repository và UI. Không dùng callback.
5. **Constraints:** Luôn set điều kiện cho WorkManager để tiết kiệm pin.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: WorkManager

---

## SECTION 1: CORE MENTAL MODEL

**WorkManager (Quản lý Công việc)**: Thành phần kiến trúc Jetpack để thực thi tác vụ nền (background tasks), ngay cả khi ứng dụng bị đóng hoặc thiết bị khởi động lại. Nó đảm bảo việc thực thi (guaranteed execution).

**Mental Model**: Think of **WorkManager** as một hệ thống quản lý hàng đợi công việc (job queue) độc lập. Bạn ném công việc vào ("Hey, upload hình ảnh"), nó sẽ tự xử lý khi điều kiện phù hợp (có mạng, thiết bị sạc, không đang làm việc khác). Bạn không cần lo lắng về việc giữ process chạy.

**Why it's better**:
- **Worker**: Chạy trong thread riêng, không block UI.
- **Constraint**: Tự động chờ điều kiện (mạng, pin...), không cần code lằng nhằm.
- **Guaranteed**: Không bị kill bởi hệ thống, tự động retry.

---

## SECTION 2: DECISION TABLES

### Table 1: Worker Type Selection
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Logic có Coroutine (API, DB) | **CoroutineWorker** | **Suspend function**: Tránh blocking thread, quản lý lifecycle tự động. | Dùng `Worker` thường + blocking call làm treo thread nền. |
| Logic đơn giản, không异步 | **Worker** | **Synchronous**: Đơn giản, ít boilerplate cho tác vụ CPU nhẹ. | Cố gắng chạy network request trực tiếp trong `Worker` thường (gây ANR). |
| Task phải chạy lặp lại | **PeriodicWorkRequest** | **Recurring**: Tự động lặp theo chu kỳ, tiết kiệm pin. | Dùng `while(true)` trong Worker (chết pin, bị hệ thống giết). |
| Task chạy 1 lần | **OneTimeWorkRequest** | **One-off**: Xử lý tác vụ đơn lẻ, xóa sau khi xong. | Lặp lại manual bằng cách schedule lại chính nó. |

### Table 2: Execution Type
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Phải chạy đúng giờ (Đăng ký push通知) | **Exact Alarm (AlarmManager)** | **Exact Execution**: Đảm bảo run đúng milisecond. | Dùng WorkManager (WorkManager là **Inexact**, +/- vài chục phút). |
| Chạy ngay nhưng được hoãn (Sync data) | **WorkManager** | **Deferrable**: Tối ưu pin, gom nhóm tác vụ. | Dùng Service nền (tốn pin, dễ bị system kill). |
| Cần user active | **In-App Logic** | **User Interaction**: Không dùng background tools. | Dùng WorkManager (sẽ fail hoặc treo vô thời hạn). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Diagram
```text
[ Application Code ]
       |
       v
[ WorkRequest (OneTime/Periodic) ]  <--- Chứa Constraint & InputData
       |
       v
[ WorkManager (System Service) ]  <--- Schedules, Queues, Reschedules on Reboot
       |
       v
[ Worker (CoroutineWorker/Worker) ]  <--- Executes logic doWork()
       |
       v
[ Result (Success/Failure/Retry) ]
```

**Quan hệ Logic**:
1. **Worker**: Class bạn viết (Business Logic).
2. **WorkRequest**: Object cấu hình (Khi nào chạy, điều kiện gì).
3. **WorkManager**: "Ông chủ" nhận request và decides khi nào tung Worker ra.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: One-Time Upload (Basic)
**Khi nào dùng**: Gửi data lên server một lần.

```kotlin
// 1. Define Worker
class UploadWorker(appContext: Context, workerParams: WorkerParameters) :
    CoroutineWorker(appContext, workerParams) {

    override suspend fun doWork(): Result {
        return try {
            // Logic thực tế (VD: Upload API)
            uploadImages()
            Result.success() // Thành công
        } catch (e: Exception) {
            Result.retry() // Thử lại sau
        }
    }
}

// 2. Schedule
val uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .build()

WorkManager.getInstance(context).enqueue(uploadWorkRequest)
```

### Pattern 2: Periodic Sync with Constraints
**Khi nào dùng**: ĐỒng bộ dữ liệu định kỳ (VD: 1 ngày/lần) chỉ khi có WiFi và đang sạc.

```kotlin
val syncWorkRequest = PeriodicWorkRequestBuilder<SyncWorker>(1, TimeUnit.DAYS)
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.UNMETERED) // WiFi
            .setRequiresCharging(true)
            .build()
    )
    .setFlexTimeInterval(1, TimeUnit.HOURS) // Window linh hoạt
    .build()

WorkManager.getInstance(context).enqueue(syncWorkRequest)
```

### Pattern 3: Input & Output Data
**Khi nào dùng**: Chuyền tham số vào Worker và nhận kết quả ra.

```kotlin
// Trong Activity/Fragment
val data = workDataOf("KEY_USER_ID" to 123, "KEY_URL" to "https://...")

val request = OneTimeWorkRequestBuilder<UploadWorker>()
    .setInputData(data)
    .build()

// Trong Worker
class UploadWorker(...) : CoroutineWorker(...) {
    override suspend fun doWork(): Result {
        val userId = inputData.getInt("KEY_USER_ID", 0)
        // ...
        return Result.success()
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Dùng WorkManager cho Task yêu cầu chính xác về thời gian (Deadline严格的)**
- **Tại sao nguy hiểm**: WorkManager là **Deferrable (có thể hoãn)**. Nó chạy ước lượng +/- 10-30 phút để tiết kiệm pin. Nếu bạn cần run đúng 8:00 AM, hãy dùng **AlarmManager** hoặc **ExactAlarm**.

**2. Để logic UI trong Worker**
- **Tại sao nguy hiểm**: Worker chạy trong background thread hoặc process bị sát. Gọi `Toast` hay `Snackbar` trong `doWork()` sẽ crash hoặc bị ignored. Chỉ xử lý data.

**3. Tự tạo Thread hay GlobalScope trong Worker**
- **Tại sao nguy hiểm**: Worker đã có cơ chế quản lý thread/routine. Nếu bạn tự tạo Thread hoặc `GlobalScope.launch`, WorkManager không thể track process, gây đứt luồng hoặc drain pin oan.

**4. Quên `CoroutineWorker` khi có async work**
- **Tại sao nguy hiểm**: Nếu dùng `Worker` và call `suspend function` sẽ crash (Blocking code not allowed). Hoặc phải dùng-blocking call, làm chậm hệ thống.

---

## SECTION 6: MASTER CHEAT SHEET

**Top 5 Rules to Remember**
1. **Worker** là nơi code logic (Business Logic).
2. **WorkRequest** là nơi cấu hình (OneTime hay Periodic, Constraint).
3. **Constraint** là luật (Mạng, Sạc, Idle...), không thỏa là chưa chạy.
4. **PeriodicWorkRequest** luôn cần `setFlexInterval` (khoảng window chạy).
5. **WorkManager** không phải cho task thời gian chính xác (Exact).

**Quick Decision Logic (If-Else)**
```text
IF (Task phải chạy đúng 1 giây c cụ thể) -> Use AlarmManager.
ELSE IF (Task lặp lại, có thể trễ sớm vài giờ) -> Use PeriodicWorkRequest.
ELSE IF (Task mạng mỏng/năng lượng thấp) -> Use Constraints trong WorkRequest.
ELSE -> Use OneTimeWorkRequest.
```

**Cheat Code Dependencies**
```gradle
implementation "androidx.work:work-runtime-ktx:$work_version"
```

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: WorkManager & Repository Pattern

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **WorkManager (Quản lý tác vụ nền)**: System-managed background task scheduler handling deferral, guarantee, and persistence.
- **PeriodicWorkRequest (Yêu cầu định kỳ)**: Task repeats automatically at specific intervals.
- **OneTimeWorkRequest (Yêu cầu một lần)**: Task executes exactly once.
- **Constraints (Ràng buộc)**: Conditions (Network, Charging, Idle) required to run the task.
- **Input/Output Data (Dữ liệu đầu vào/ra)**: Serialized key-value pairs passed to/from Workers.

### Mental Model
- **WorkManager is not "Real-time"**: It is for **Deferrable** (tạm hoãn) and **Guaranteed** (bảo đảm) tasks. Do not use for instantaneous UI updates.
- **OS decides execution time**: You set constraints, the OS picks the exact moment to save battery.
- **Database survives reboot**: Tasks are stored in Room/SQLite. If the phone reboots, tasks reschedule automatically.

### Why WorkManager?
- **Better than AlarmManager**: Handles Android Doze mode (Nền tảng tiết kiệm pin) automatically.
- **Better than Service**: No memory leaks, no lifecycle management hell. OS handles process termination.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Sync data every hour | `PeriodicWorkRequest` | **Guaranteed Execution**: Bắt buộc chạy theo chu kỳ, ngay cả khi app đang đóng. | Setting `interval < 15 phút`. Android giới hạn khoảng cách tối thiểu là 15 phút. |
| Upload a file after user clicks save | `OneTimeWorkRequest` | **Deferrable**: Chạy ngay khi có thể (offline也会queued). Không block UI. | Chạy synchronous (await) ngay trên Main Thread. Làm giật/freeze app. |
| Need to run only when Charging + Wifi | `Constraints` trong WorkRequest | **Battery Optimization**: Tiết kiệm pin bằng cách chỉ chạy khi điều kiện tối ưu. | Bỏ qua Constraints. Gây tốn pin và khả năng bị hệ thống kill app. |
| Need to pass 5MB data to Worker | `None` (Avoid) | **IPC Limit**: WorkManager dùng Binder. Dữ liệu lớn gây ANR/Crash. | Truyền bitmap hoặc list lớn qua `inputData`. Nén dữ liệu hoặc lưu file, truyền URI. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Flowchart
```text
[ App UI / ViewModel ]
       |
       | (enqueue)
       v
[ WorkManager System ] <-----> [ SQLite Database (Persistence) ]
       |
       | (Schedules via OS Scheduler)
       v
[ WorkManager Worker Process ]
       |
       | (Constraints Check: Wifi? Charging?)
       |
       v
[ CoroutineWorker.doWork() ]
       |
       +---> [ Network / DB / CPU Logic ]
       |
       +---> [ Result.success(data) ] --> Sync back to UI (Optional: LiveData/Flow)
       +---> [ Result.retry() ]        --> Reschedule based on Backoff Policy
       +---> [ Result.failure() ]      --> Mark as Failed (Stop retry)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Periodic Sync with Constraints
**Khi nào dùng:** Đồng bộ dữ liệu backend định kỳ (Email, Feed, Backup).

**Tại sao đúng:** Đảm bảo chạy đúng chu kỳ nhưng chỉ khi pin tốt + wifi để tránh tốn data.

```kotlin
// 1. Define Constraints
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.UNMETERED) // Wifi không giới hạn
    .setRequiresCharging(true)                     // Phải đang sạc
    .setRequiresBatteryNotLow(true)                // Pin không thấp
    .build()

// 2. Build Request (Min interval: 15 mins)
val repeatingRequest = PeriodicWorkRequestBuilder<RefreshDataWorker>(
    1, TimeUnit.HOURS,   // Lặp lại mỗi 1 giờ
    15, TimeUnit.MINUTES // Linh hoạt +/- 15 phút để OS tối ưu hóa
)
    .setConstraints(constraints)
    .build()

// 3. Enqueue Unique (Tránh tạo trùng lặp)
WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "SYNC_DATA_WORKER",
    ExistingPeriodicWorkPolicy.KEEP, // Nếu đã có, giữ cái cũ (không tạo mới)
    repeatingRequest
)
```

### Pattern 2: OneTimeWork with Input/Output
**Khi nào dùng:** Xử lý logic phức tạp (Tính toán, Cắt ảnh) và trả kết quả.

**Tại sao đúng:** Tách biệt logic nặng ra background, truyền tham số sạch qua `Data`.

```kotlin
// 1. The Worker (Logic)
class MathWorker(context: Context, params: WorkerParameters) : 
    CoroutineWorker(context, params) {

    override suspend fun doWork(): Result {
        // Nhận dữ liệu
        val x = inputData.getInt(KEY_X_ARG, 0)
        val y = inputData.getInt(KEY_Y_ARG, 0)

        // Logic nặng (tại sao dùng Worker)
        val result = x * y 

        // Trả kết quả
        val output = workDataOf(KEY_RESULT to result)
        return Result.success(output)
    }
}

// 2. Send Input Data
val mathWork = OneTimeWorkRequestBuilder<MathWorker>()
    .setInputData(
        workDataOf(
            "X_ARG" to 42,
            "Y_ARG" to 421
        )
    )
    .build()

WorkManager.getInstance(context).enqueue(mathWork)

// 3. Lấy Output (Quan trọng)
// Trong ViewModel hoặc Activity:
WorkManager.getInstance(context)
    .getWorkInfoByIdLiveData(mathWork.id)
    .observe(this) { workInfo ->
        if (workInfo != null && workInfo.state == WorkInfo.State.SUCCEEDED) {
            val result = workInfo.outputData.getInt("KEY_RESULT", 0)
            // Cập nhật UI
        }
    }
```

### Pattern 3: Retry with Backoff
**Khi nào dùng:** Khi tác vụ có thể thất bại tạm thời (Mất mạng, Server 500).

**Tại sao đúng:** Tránh spam request gây overload server, tuân theo Exponential Backoff.

```kotlin
val uploadWork = OneTimeWorkRequestBuilder<UploadWorker>()
    .setBackoffCriteria(
        BackoffPolicy.EXPONENTIAL, // 30s, 60s, 120s...
        30, TimeUnit.SECONDS
    )
    .build()
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Dùng WorkManager cho Task thời gian thực (Real-time)
- **Lý do nguy hiểm:** WorkManager là **Best Effort Scheduling**. OS có thể delay task hàng tiếng nếu cần tiết kiệm pin. Dùng RxJava/Coroutine với `GlobalScope` hoặc `Foreground Service` cho việc cần realtime.

### 2. Quên xử lý Result.failure()
- **Lý do nguy hiểm:** Nếu task fail và bạn không có cơ chế retry hoặc thông báo, người dùng sẽ không bao giờ biết dữ liệu bị sync hỏng. Luôn xử lý `WorkInfo.State.FAILED` trong Observer.

### 3. Pass Object Complex qua InputData
- **Lý do nguy hiểm:** `workDataOf` chỉ hỗ trợ primitives (Int, String, Boolean...). Đừng cố truyền `User` class. Hãy chuyển object thành JSON String hoặc lưu vào DB, rồi truyền ID qua Worker.

### 4. Sử dụng `ExistingPeriodicWorkPolicy.REPLACE` không đúng
- **Lý do nguy hiểm:** Nếu bạn `REPLACE` mỗi khi người dùng mở app, bạn sẽ liên tục reset chu kỳ, khiến task chạy liên tục, gây tốn pin và load server. Chỉ dùng `REPLACE` khi logic thay đổi hẳn.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules
1. **Dữ liệu lớn:** Lưu vào file/DB -> Truyền **URI/ID** qua Worker.
2. **Lặp lại:** Dùng `PeriodicWorkRequest` (Min 15p).
3. **Một lần:** Dùng `OneTimeWorkRequest`.
4. **Ràng buộc:** Luôn set `Constraints` (Network, Charging) để bảo vệ pin.
5. **Trùng lặp:** Dùng `enqueueUnique...` với `ExistingPeriodicWorkPolicy.KEEP`.

### Decision Logic (If-Else)
- **Nếu** task lặp lại theo giờ/ngày?
  -> `PeriodicWorkRequest`.
- **Nếu** task phải chạy ngay lập tức?
  -> `OneTimeWorkRequest` + `setExpedited()` (Android 12+) hoặc Foreground Service.
- **Nếu** task phụ thuộc vào mạng?
  -> Set `setRequiredNetworkType(ConnectivityType.CONNECTED)`.
- **Nếu** task chạy xong cần update UI?
  -> Quan sát `WorkInfo` bằng `LiveData` hoặc `Flow`.

### Top 3 Things to Remember
1. **Worker là độc lập:** Không được đảm bảo UI Thread, không được đảm bảo Process sống.
2. **OS là ông chủ:** OS có thể kill process của Worker bất cứ lúc nào nếu cần RAM. Worker phải tự lưu trạng thái (Idempotent).
3. **Input/Output là tốn kém:** Dữ liệu qua IPC (Binder) có giới hạn 1MB. Giữ nó nhỏ gọn.

<!-- CHUNK 31-33 -->

# DEVELOPER DECISION GUIDE: Repository Pattern & WorkManager

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **Repository (Kho lưu trữ):** Lớp trung gian cô lập nguồn dữ liệu (API, Database, Cache) khỏi phần còn lại của ứng dụng. ViewModel chỉ tương tác với Repository, không biết dữ liệu đến từ đâu.
*   **Worker (Công nhân):** Lớp định nghĩa tác vụ nền sẽ thực thi. Nó tách biệt hoàn toàn khỏi vòng đời UI.
*   **WorkRequest (Yêu cầu công việc):** Đối tượng cấu hình cho một tác vụ (khi nào chạy, điều kiện mạng, loại công việc Một lần hoặc Định kỳ).
*   **WorkManager (Trình quản lý công việc):** Hệ thống đảm bảo tác vụ nền sẽ được thực thi ngay cả khi ứng dụng tắt hoặc khởi động lại thiết bị.

### Why This Approach?
*   **Single Source of Truth (Nguồn Chân Lý Đơn):** ViewModel nhận dữ liệu từ Repository. Repository quyết định trả về dữ liệu mạng hay database. Điều này loại bỏ việc UI hiển thị dữ liệu lỗi thời hoặc không nhất quán.
*   **Background Reliability (Độ Tin Cậy Nền):** Thay vì dùng `Thread` hay `Timer` dễ bị hệ điều hành giết进程, `WorkManager` dùng `JobScheduler`, `AlarmManager`... tối ưu hóa pin và tài nguyên, đảm bảo tác vụ hoàn thành.
*   **Separation of Concerns (Tách Rẽ Trách Nhiệm):** Logic mạng và database được bao bọc trong Repository. Logic tác vụ nền được bao bọc trong Worker. ViewModel chỉ lo việc xử lý UI.

---

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Lưu trữ dữ liệu cho UI (Network/DB)** | **Repository Pattern** | Cô lập logic dữ liệu. Cho phép dễ dàng thay đổi nguồn dữ liệu (API -> DB) mà không sửa UI. | Viết code gọi API trực tiếp trong `ViewModel` hoặc `Activity`. |
| **Tác vụ chạy ngay cả khi app đóng (Sync data)** | **WorkManager** | Đảm bảo tác vụ chạy (Exactly-once). Tối ưu pin (Battery friendly). Chịu lỗi (Survive reboot). | Dùng `Thread` hoặc `GlobalScope`. Tác vụ bị giết khi app crash. |
| **Tác vụ lặp lại (Periodic Sync)** | **WorkManager (PeriodicWorkRequest)** | Hỗ trợ lặp lại với khoảng thời gian cố định. Quản lý tài nguyên hệ thống tốt nhất. | Dùng `AlarmManager` trực tiếp (khó quản lý, tốn pin hơn). |
| **Tác vụ cần chạy trước khi app tắt (Cleanup)** | **WorkManager (OneTimeWorkRequest)** | Đảm bảo tác vụ được thực thi. | Tin tưởng vào `onDestroy()` (không bao giờ đảm bảo 100% gọi). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Diagram

```text
[ UI Layer: Compose / XML ]
       |
       v
[ ViewModel ] <-- LiveData / StateFlow
       |
       | (Truy vấn dữ liệu)
       v
[ Repository Interface ]
       |
   +---+------------------------+
   |                            |
[ Local Data Source ]    [ Remote Data Source ]
(SQLite / Room)          (Retrofit / API)
   |                            |
   +---+------------------------+
       |
       v
[ Data (trả về cho ViewModel) ]

------------------- BACKGROUND -------------------

[ WorkManager ] <-- Tạo và enqueue
       |
       v
[ Worker Class ] <-- Thực thi logic (doanh nghiệp)
       |
       v
[ Repository ] (Có thể gọi để Sync data)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Repository với Single Source of Truth
*Khi nào dùng:* Khi app cần load data từ nhiều nguồn (API, DB) và đảm bảo UI luôn nhất quán.

**Lý do đúng:** `flow` kết hợp Room và API cho phép dữ liệu DB cập nhật ngay lập tức cho UI, trong khi dữ liệu mạng chạy nền để update DB.

```kotlin
// Entity (Room)
@Entity(tableName = "users")
data class User(val id: Int, val name: String)

// DAO (Room)
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getAll(): Flow<List<User>> // Flow để lắng nghe thay đổi

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(users: List<User>)
}

// Repository
class UserRepository(private val apiService: ApiService, private val userDao: UserDao) {
    
    // Flow: Luôn trả về data mới nhất
    fun getAllUsers(): Flow<List<User>> = flow {
        // 1. emit dữ liệu từ DB ngay lập tức (Source of Truth)
        emitAll(userDao.getAll())

        // 2. Fetch data mới từ API (Background)
        try {
            val usersFromApi = apiService.getUsers()
            userDao.insertAll(usersFromApi) // Cập nhật DB -> Flow tự emit
        } catch (e: Exception) {
            // Xử lý lỗi network, không làm gián đoạn Flow
        }
    }
}
```

### Pattern 2: One-Time WorkRequest
*Khi nào dùng:* Chạy một tác vụ nền duy nhất (VD: Gửi log lỗi, Upload file sau khi sửa xong).

**Lý do đúng:** Dễ dàng cấu hình ràng buộc (Chỉ khi có mạng, chỉ khi sạc pin) và tự động xử lý lỗi, retry.

```kotlin
// 1. Định nghĩa Worker (Logic tác vụ)
class UploadWorker(appContext: Context, params: WorkerParameters) 
    : CoroutineWorker(appContext, params) {

    override suspend fun doWork(): Result {
        return try {
            // Logic upload tại đây
            // Ví dụ: Gọi repository để sync
            println("Đang upload...")
            Result.success()
        } catch (e: Exception) {
            Result.retry() // Hoặc Result.failure()
        }
    }
}

// 2. Tạo và Enqueue WorkRequest (Trong ViewModel hoặc Activity)
val uploadWorkRequest = OneTimeWorkRequestBuilder<UploadWorker>()
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED) // Chỉ khi có mạng
            .setRequiresCharging(true) // Chỉ khi sạc
            .build()
    )
    .build()

// 3. Đẩy vào hàng đợi
WorkManager.getInstance(context).enqueue(uploadWorkRequest)
```

### Pattern 3: PeriodicWorkRequest
*Khi nào dùng:* Sync dữ liệu định kỳ (VD: Cập nhật Widget, Kiểm tra thông báo mới mỗi giờ).

**Lý do đúng:** Đảm bảo tác vụ chạy lặp lại tiết kiệm pin. Lưu ý: Thời gian lặp lại tối thiểu là 15 phút.

```kotlin
// Tác vụ lặp lại
val periodicWorkRequest = PeriodicWorkRequestBuilder<SyncWorker>(1, TimeUnit.HOURS)
    .setConstraints(
        Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()
    )
    .build()

WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "SyncDataWork", // Tên duy nhất, tránh tạo trùng lặp
    ExistingPeriodicWorkPolicy.KEEP, // Nếu đã có, giữ cái cũ
    periodicWorkRequest
)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Chôn Repository trong Worker:**
    *   **Hành vi:** Viết logic fetch API trực tiếp trong `Worker` mà không dùng `Repository`.
    *   **Nguy hiểm:** Duplicated code. Nếu logic auth/token thay đổi, bạn phải sửa lại cả Worker.

2.  **ViewModel gọi API trực tiếp:**
    *   **Hành vi:** `ViewModel` gọi Retrofit và xử lý JSON.
    *   **Nguy hiểm:** UI bị lock hoặc crash nếu network lag. Khó unit test. Code rối loạn Responsibility.

3.  **Sử dụng `Thread.sleep()` trong Worker:**
    *   **Hành vi:** Làm chậm tác vụ để thử nghiệm.
    *   **Nguy hiểm:** `WorkManager` có giới hạn thời gian thực thi. Nếu vượt quá timeout (phút), hệ thống sẽ kill tác vụ và coi là thất bại.

4.  **Quên `ExistingWorkPolicy` khi enqueue:**
    *   **Hành vi:** Gọi `enqueue` nhiều lần mà không kiểm tra.
    *   **Nguy hiểm:** Tạo ra hàng trăm tác vụ nền cùng chạy, gây treo máy và tốn pin.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things To Remember
1.  **Repository:** Là nơi chứa logic Data, UI (ViewModel) không đụng tới API/DB trực tiếp.
2.  **Source of Truth:** Luôn ưu tiên Database (Room) làm nguồn dữ liệu chính cho UI.
3.  **Worker Class:** Phải có Constructor rỗng hoặc constructor với `Context, WorkerParameters`.
4.  **WorkManager:** Không phù hợp cho tác vụ tức thời (< 10 giây). Dùng cho tác vụ lâu dài hoặc cần đảm bảo chạy.
5.  **Constraints:** Luôn thiết lập `Constraints` (Network, Charging) để tối ưu pin.
6.  **Unique Work:** Dùng `enqueueUnique...` để tránh lặp lại tác vụ.
7.  **Coroutine:** Dùng `CoroutineWorker` thay vì `Worker` thường để hỗ trợ suspend function.
8.  **Flow + Repository:** Kết hợp `Room` (Observable) + `Retrofit` để có UI auto-update.
9.  **Vòng đời:** Worker chạy tách biệt UI, không bị hủy theo Activity/Fragment.
10. **NetworkType:** `CONNECTED` yêu cầu mạng kết nối, `UNMETERED` yêu cầu Wifi (tiết kiệm data).

### Decision Logic (If-Else)

```text
IF (Task needs to run NOW and MUST complete immediately on UI) 
   -> Use Coroutine trong ViewModel (Scope IO).

ELSE IF (Task needs to run EVEN IF APP IS CLOSED)
   -> Use WorkManager (OneTimeWorkRequest).

ELSE IF (Task needs to run REPEATEDLY (Hourly/Daily))
   -> Use WorkManager (PeriodicWorkRequest).
```

### Fetch Data Flow

```text
UI (ViewModel)
  -> get data from Repository
Repository
  -> Query Local DB (emit flow)
  -> Background: Fetch API -> Update Local DB -> Flow emits new data automatically
UI
  -> Receives new data from Flow
```