{
  "file": "Kotlin_Coroutines_Basics.pdf",
  "total_pages": 61,
  "analysis_merged": [
    {
      "concept_name_en": "Coroutines",
      "what_it_is_vi": "Coroutines là các đơn vị thực thi có thể tạm dừng (suspendable) cho phép viết mã bất đồng bộ theo kiểu tuần tự.",
      "when_why_use_vi": "Sử dụng khi cần thực hiện nhiều tác vụ cùng lúc (concurrency) nhưng muốn code dễ đọc như tuần tự, và để tối ưu tài nguyên thread (không block thread khi chờ).",
      "code_appearance": {
        "keywords": [
          "suspend",
          "launch",
          "concurrent",
          "parallel"
        ],
        "apis": [
          "kotlinx.coroutines"
        ]
      },
      "common_mistakes_vi": "Lầm tưởng coroutines chạy trên thread riêng của chúng; thực tế chúng chạy trên thread do OS quản lý và có thể suspend để nhường thread cho coroutine khác.",
      "minimal_code_example": "suspend fun processData() { /* concurrent work here */ }"
    },
    {
      "concept_name_en": "Suspending Functions",
      "what_it_is_vi": "Hàm được khai báo bằng từ khóa `suspend`, có thể tạm dừng và tiếp tục执行 sau này.",
      "when_why_use_vi": "Để thực hiện các thao tác mất thời gian (như gọi API, đọc file) mà không làm block thread, và có thể gọi các hàm bất đồng bộ khác trong nó.",
      "code_appearance": {
        "keywords": [
          "suspend"
        ],
        "apis": [
          "suspend fun"
        ]
      },
      "common_mistakes_vi": "Gọi trực tiếp hàm suspend từ hàm thường (non-suspend) sẽ gây lỗi biên dịch; phải gọi từ ngữ cảnh coroutine hoặc hàm suspend khác.",
      "minimal_code_example": "suspend fun greet() { println(\"Hello\") }"
    },
    {
      "concept_name_en": "Main Entry Point",
      "what_it_is_vi": "Hàm `main` có thể được đánh dấu là `suspend` để trở thành entry point cho coroutine.",
      "when_why_use_vi": "Khi viết ứng dụng Kotlin thuần (console/app) và cần bắt đầu logic bất đồng bộ ngay từ đầu.",
      "code_appearance": {
        "keywords": [
          "suspend",
          "main"
        ],
        "apis": [
          "suspend fun main()"
        ]
      },
      "common_mistakes_vi": "Quên import thư viện coroutines hoặc biến IDE không nhận diện được `suspend fun main`.",
      "minimal_code_example": "suspend fun main() { showUserInfo() }"
    },
    {
      "concept_name_en": "kotlinx.coroutines Library",
      "what_it_is_vi": "Thư viện chính thức của JetBrains cung cấp các API cho coroutines (như launch, async, delay, v.v.).",
      "when_why_use_vi": "Cần thêm dependency này vào project để sử dụng các tính năng nâng cao của coroutines ngoài core Kotlin.",
      "code_appearance": {
        "keywords": [
          "implementation",
          "org.jetbrains.kotlinx:kotlinx-coroutines-core"
        ],
        "apis": [
          "build.gradle.kts"
        ]
      },
      "common_mistakes_vi": "Chỉ khai báo `suspend` nhưng không add thư viện coroutines, dẫn đến thiếu các builders như `launch`.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "Coroutine Scope",
      "what_it_is_vi": "Một bối cảnh định nghĩa vòng đời của coroutine, thường dùng `withContext` hoặc `CoroutineScope`.",
      "when_why_use_vi": "Để quản lý thời gian sống (lifecycle) của coroutine và cung cấp context cho việc chạy.",
      "code_appearance": {
        "keywords": [
          "withContext",
          "CoroutineScope"
        ],
        "apis": [
          "CoroutineScope.launch"
        ]
      },
      "common_mistakes_vi": "Tạo coroutine mà không có scope (ví dụ gọi `launch` lung tung) sẽ gây lỗi hoặc rò rỉ bộ nhớ.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "Coroutine Builders",
      "what_it_is_vi": "Các hàm như `launch` dùng để khởi chạy một coroutine mới từ một scope.",
      "when_why_use_vi": "Khi muốn bắt đầu một tác vụ bất đồng bộ mới.",
      "code_appearance": {
        "keywords": [
          "launch"
        ],
        "apis": [
          "CoroutineScope.launch"
        ]
      },
      "common_mistakes_vi": "Sử dụng `launch` nhưng không theo dõi kết quả (nếu cần) hoặc không cancel khi không cần thiết.",
      "minimal_code_example": "launch { /* work */ }"
    },
    {
      "concept_name_en": "Dispatchers",
      "what_it_is_vi": "Bộ định tuyến xác định coroutine sẽ chạy trên thread nào (Main, IO, Default).",
      "when_why_use_vi": "Để kiểm soát threading model: UI thread cho việc cập nhật giao diện, IO thread cho network/database.",
      "code_appearance": {
        "keywords": [
          "Dispatchers.Main",
          "Dispatchers.IO",
          "Dispatchers.Default"
        ],
        "apis": [
          "withContext"
        ]
      },
      "common_mistakes_vi": "Chạy code CPU nặng trên Main thread (gây lag UI) hoặc không switch dispatcher đúng cách.",
      "minimal_code_example": "withContext(Dispatchers.IO) { /* network call */ }"
    },
    {
      "concept_name_en": "Suspending Functions",
      "what_it_is_vi": "Hàm có thể tạm dừng thực thi và sau đó tiếp tục lại mà không block thread.",
      "when_why_use_vi": "Sử dụng khi cần thực hiện các tác vụ I/O (như network, database) hoặc delay để tránh làm block thread chính.",
      "code_appearance": {
        "keywords": [
          "suspend",
          "delay()"
        ],
        "apis": []
      },
      "common_mistakes_vi": "Quên thêm từ khóa 'suspend' trước khi khai báo hàm có chứa thao tác bất đồng bộ.",
      "minimal_code_example": "suspend fun greet() { println(\"Hi\"); delay(1000L) }"
    },
    {
      "concept_name_en": "Coroutine Dispatchers",
      "what_it_is_vi": "Xác định thread pool nào sẽ chạy coroutine (ví dụ: IO, Default, Main).",
      "when_why_use_vi": "Sử dụng Dispatchers.Default để tận dụng thread pool có sẵn của CPU cho các tác vụ CPU-intensive hoặc concurrent.",
      "code_appearance": {
        "keywords": [
          "Dispatchers.Default"
        ],
        "apis": [
          "withContext"
        ]
      },
      "common_mistakes_vi": "Lạm dụng Dispatchers.Default cho các tác vụ I/O thuần túy (nên dùng Dispatchers.IO thay thế).",
      "minimal_code_example": "withContext(Dispatchers.Default) { /* code */ }"
    },
    {
      "concept_name_en": "withContext Builder",
      "what_it_is_vi": "Hàm bât đồng bộ cho phép chuyển đổi Context (Dispatcher) thực thi và block thread hiện tại cho đến khi khối code hoàn thành.",
      "when_why_use_vi": "Dùng để thiết lập entry point cho coroutine trong các môi trường không hỗ trợ hàm suspend trực tiếp (như hàm main thông thường).",
      "code_appearance": {
        "keywords": [
          "withContext"
        ],
        "apis": [
          "Dispatchers"
        ]
      },
      "common_mistakes_vi": "Nghĩ rằng withContext không block thread, trong khi thực tế nó block thread hiện tại cho đến khi coroutine nội bộ hoàn thành.",
      "minimal_code_example": "fun main() { runBlocking { withContext(Dispatchers.Default) { launch { greet() } } } }"
    },
    {
      "concept_name_en": "Structured Concurrency (CoroutineScope)",
      "what_it_is_vi": "Phạm vi chứa các coroutine, đảm bảo chúng được quản lý tập trung (khi scope hủy thì tất cả coroutine bên trong cũng hủy).",
      "when_why_use_vi": "Đảm bảo tính an toàn, tránh rò rỉ bộ nhớ và đảm bảo các tác vụ con được hoàn thành đúng cách.",
      "code_appearance": {
        "keywords": [
          "this: CoroutineScope",
          "this.launch"
        ],
        "apis": [
          "launch"
        ]
      },
      "common_mistakes_vi": "Tạo scope mới một cách tùy tiện mà không quản lý vòng đời (lifecycle) của nó.",
      "minimal_code_example": "withContext(Dispatchers.Default) { this.launch { greet() } }"
    },
    {
      "concept_name_en": "runBlocking Entry Point",
      "what_it_is_vi": "Hàm xây dựng coroutine bridge, dùng để kết nối code blocksynchronous và suspending functions.",
      "when_why_use_vi": "Sử dụng trong unit tests hoặc khi main function không được hỗ trợ suspend.",
      "code_appearance": {
        "keywords": [
          "runBlocking"
        ],
        "apis": []
      },
      "common_mistakes_vi": "Dùng runBlocking trong production code quá nhiều gây cản trở tính phản hồi (responsive) của ứng dụng.",
      "minimal_code_example": "fun main() = runBlocking { launch { greet() } }"
    },
    {
      "concept_name_en": "Structured Concurrency",
      "what_it_is_vi": "Một nguyên tắc where các coroutines tạo thành cây phân cấp cha-con với vòng đời được liên kết.",
      "when_why_use_vi": "Để quản lý vòng đời của các coroutine, đảm bảo rằng khi coroutine cha bị hủy hoặc lỗi, tất cả coroutine con sẽ bị hủy theo một cách an toàn và dễ đoán.",
      "code_appearance": {
        "keywords": [
          "structured concurrency",
          "parent",
          "child",
          "lifecycle"
        ],
        "apis": []
      },
      "common_mistakes_vi": "Quên rằng hủy coroutine cha sẽ tự động hủy tất cả coroutine con, dẫn đến rò rỉ resource nếu không xử lý đúng.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "CoroutineScope",
      "what_it_is_vi": "Đối tượng quản lý vòng đời và context của các coroutine được tạo ra bên trong nó.",
      "when_why_use_vi": "Bắt buộc phải có scope để khởi tạo coroutine (sử dụng `launch` hoặc `async`) trong ứng dụng, đảm bảo các coroutine được quản lý theo structured concurrency.",
      "code_appearance": {
        "keywords": [
          "scope",
          "CoroutineScope"
        ],
        "apis": [
          "launch",
          "async"
        ]
      },
      "common_mistakes_vi": "Thiếu CoroutineScope khi gọi `launch` trong một hàm thông thường (không phải suspend function hoặc extension function trên scope).",
      "minimal_code_example": "suspend fun task() { coroutineScope { launch { ... } } }"
    },
    {
      "concept_name_en": "coroutineScope Builder",
      "what_it_is_vi": "Một hàm tạo ra một scope mới (coroutine subtree) và chờ tất cả coroutine bên trong nó hoàn thành.",
      "when_why_use_vi": "Khi bạn cần tạo một khối code chứa nhiều coroutine song song và muốn đợi tất cả chúng hoàn thành trước khi tiếp tục执行 phần code sau, hoặc khi cần hủy cả nhóm nếu có lỗi xảy ra.",
      "code_appearance": {
        "keywords": [
          "coroutineScope"
        ],
        "apis": [
          "coroutineScope"
        ]
      },
      "common_mistakes_vi": "Sử dụng `GlobalScope` thay vì `coroutineScope` khi chỉ cần scope cục bộ, dẫn đến việc không thể hủy bỏ an toàn.",
      "minimal_code_example": "coroutineScope { launch { delay(1000) } }"
    },
    {
      "concept_name_en": "Coroutine Builders (launch)",
      "what_it_is_vi": "Các hàm extension trên CoroutineScope (như `launch`) dùng để bắt đầu một coroutine mới.",
      "when_why_use_vi": "Để thực thi code một cách bất đồng bộ.",
      "code_appearance": {
        "keywords": [
          "launch"
        ],
        "apis": [
          "CoroutineScope.launch"
        ]
      },
      "common_mistakes_vi": "Lãng phí mã nguồn khi thêm `this.` trước `launch` (ví dụ: `this.launch`) trong khi `launch` là đủ do nó là extension function.",
      "minimal_code_example": "scope.launch { /* work */ }"
    },
    {
      "concept_name_en": "Coroutine Inheritance",
      "what_it_is_vi": "Cơ chế tự động kế thừa `CoroutineContext` từ scope cha sang coroutine con khi được khởi tạo.",
      "when_why_use_vi": "Để đảm bảo các coroutine con có cùng dispatcher hoặc các thuộc tính execution khác với coroutine cha nếu không chỉ định rõ.",
      "code_appearance": {
        "keywords": [
          "inherit",
          "context"
        ],
        "apis": [
          "Dispatchers.Default"
        ]
      },
      "common_mistakes_vi": "Hiểu lầm rằng coroutine con kế thừa dispatcher một cách máy móc mà không biết rằng nếu context cha rỗng, nó sẽ mặc định sử dụng Dispatchers.Default.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "Debugging Coroutines (VM Option)",
      "what_it_is_vi": "Cấu hình JVM để hiển thị tên của coroutine bên cạnh tên thread trong log.",
      "when_why_use_vi": "Khi Debug để theo dõi luồng execution của các coroutine và xác định coroutine nào đang chạy trên thread nào.",
      "code_appearance": {
        "keywords": [
          "-Dkotlinx.coroutines.debug"
        ],
        "apis": []
      },
      "common_mistakes_vi": "Chỉ xem log của thread mà không nhận ra các coroutine khác nhau có thể chạy chung một thread, dẫn đến khó khăn khi debug.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "CoroutineScope receiver in builder functions",
      "what_it_is_vi": "Khi một hàm nhận tham số là một lambda, lambda đó có thể có 'receiver' (bộ nhận), nghĩa là các lời gọi hàm bên trong lambda sẽ được thực hiện trên đối tượng receiver đó thay vì phải gọi trực tiếp.",
      "when_why_use_vi": "Để các hàm builder như `launch` hay `async` có thể được gọi mà không cần tiền tố (vd: `launch { }` thay vì `scope.launch { }`) khi đang ở bên trong một lambda của `coroutineScope`.",
      "code_appearance": {
        "keywords": [
          "receiver",
          "this"
        ],
        "apis": [
          "CoroutineScope",
          "coroutineScope",
          "launch"
        ]
      },
      "common_mistakes_vi": "Gọi các coroutine builder (như `launch`) trực tiếp trong một hàm thông thường không có receiver type là `CoroutineScope` sẽ gây lỗi biên dịch.",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "Coroutine builder functions",
      "what_it_is_vi": "Các hàm dùng để tạo và khởi chạy một coroutine mới, chấp nhận một block code có kiểu `suspend`.",
      "when_why_use_vi": "Là điểm bắt đầu để thực thi các tác vụ bất đồng bộ trong Kotlin Coroutines.",
      "code_appearance": {
        "keywords": [
          "suspend"
        ],
        "apis": [
          "launch",
          "async",
          "runBlocking",
          "withContext",
          "coroutineScope"
        ]
      },
      "common_mistakes_vi": "",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "CoroutineScope.launch()",
      "what_it_is_vi": "Một builder mở rộng (extension function) trên `CoroutineScope`, dùng để tạo coroutine mới nhưng không chặn luồng hiện tại.",
      "when_why_use_vi": "Khi cần chạy các tác vụ nền (background) không cần đợi kết quả trả về, hoặc muốn chạy song song với các tác vụ khác.",
      "code_appearance": {
        "keywords": [
          "launch"
        ],
        "apis": [
          "CoroutineScope",
          "delay"
        ]
      },
      "common_mistakes_vi": "",
      "minimal_code_example": "scope.launch { /* task */ }"
    },
    {
      "concept_name_en": "CoroutineScope.async() and Deferred",
      "what_it_is_vi": "Một builder mở rộng trên `CoroutineScope`, tạo một coroutine tính toán song song và trả về đối tượng `Deferred` (chứa kết quả tương lai).",
      "when_why_use_vi": "Khi cần thực thi nhiều tác vụ độc lập song song và cần đợi kết quả trả về từ chúng.",
      "code_appearance": {
        "keywords": [
          "async",
          "await",
          "val"
        ],
        "apis": [
          "Deferred",
          "withContext"
        ]
      },
      "common_mistakes_vi": "Quên gọi `.await()` trên đối tượng `Deferred` trả về từ `async` sẽ khiến khối code đó không đợi kết quả mà thực hiện ngay lập tức.",
      "minimal_code_example": "val result = scope.async { calculation() }; result.await()"
    },
    {
      "concept_name_en": "Passing CoroutineScope to helper functions",
      "what_it_is_vi": "Để trích xuất các logic launch ra một hàm riêng, hàm đó cần khai báo tham số là `CoroutineScope` (thường là extension function).",
      "when_why_use_vi": "Để tái sử dụng logic khởi chạy coroutine hoặc phân tách code gọn gàng hơn.",
      "code_appearance": {
        "keywords": [
          "fun",
          "this"
        ],
        "apis": [
          "CoroutineScope"
        ]
      },
      "common_mistakes_vi": "Viết hàm chứa `launch` nhưng không khai báo `CoroutineScope` làm receiver会导致 lỗi biên dịch vì `launch` không t tồn tại scope để gọi.",
      "minimal_code_example": "fun CoroutineScope.launchAll() { this.launch { ... } }"
    },
    {
      "concept_name_en": "runBlocking",
      "what_it_is_vi": "Hàm tạo coroutine scope và bloque luồng hiện tại直到 các coroutines trong scope đó hoàn thành.",
      "when_why_use_vi": "Chỉ sử dụng khi cần gọi code suspending từ code không suspending (ví dụ: trong hàm main hoặc hàm interface không hỗ trợ suspend).",
      "code_appearance": {
        "keywords": [
          "runBlocking",
          "suspend"
        ],
        "apis": [
          "runBlocking"
        ]
      },
      "common_mistakes_vi": "Lạm dụng runBlocking trong các function suspending hoặc trong Coroutine scope khác, gây bloque thread không cần thiết.",
      "minimal_code_example": "interface Repository { fun readItem(): Int }\nobject MyRepository : Repository {\n    override fun readItem(): Int = runBlocking { myReadItem() }\n}\nsuspend fun myReadItem(): Int = 4"
    },
    {
      "concept_name_en": "Coroutine Dispatchers",
      "what_it_is_vi": "Bộ điều khiển xác định thread hoặc thread pool nào sẽ thực thi coroutine.",
      "when_why_use_vi": "Để kiểm soát nơi coroutine chạy (Main, IO, Default), tối ưu hiệu năng và tránh chiếm dụng thread chính.",
      "code_appearance": {
        "keywords": [
          "Dispatchers.Default",
          "Dispatchers.IO",
          "Dispatchers.Main",
          "launch",
          "async"
        ],
        "apis": [
          "Dispatchers",
          "withContext"
        ]
      },
      "common_mistakes_vi": "Quên chỉ định dispatcher khi chuyển từ thread này sang thread khác, hoặc hiểu lầm rằng coroutines mặc định chạy trên Main thread.",
      "minimal_code_example": "suspend fun runWithDispatcher() = coroutineScope {\n    launch(Dispatchers.Default) {\n        println(\"Running on ${Thread.currentThread().name}\")\n    }\n}"
    },
    {
      "concept_name_en": "withContext",
      "what_it_is_vi": "Hàm suspending để chuyển đổi context (dispatcher) của khối code bên trong nó.",
      "when_why_use_vi": "Khi cần thực thi một đoạn code trên dispatcher cụ thể (ví dụ: chuyển về Main để update UI) mà không cần tạo coroutine mới.",
      "code_appearance": {
        "keywords": [
          "withContext",
          "async",
          "await"
        ],
        "apis": [
          "withContext"
        ]
      },
      "common_mistakes_vi": "Sử dụng nhiều nested withContext không cần thiết hoặc gọi block CPU nặng trong Dispatchers.Main.",
      "minimal_code_example": "suspend fun main() = withContext(Dispatchers.Default) {\n    val result = async { (1L..500_000L).sum() }\n    println(\"Total: ${result.await()}\")\n}"
    },
    {
      "concept_name_en": "Coroutine Inheritance & Default Dispatcher",
      "what_it_is_vi": "Coroutines kế thừa dispatcher từ parent scope và sử dụng Dispatchers.Default nếu không có dispatcher nào được chỉ định.",
      "when_why_use_vi": "Hiểu cơ chế mặc định để tránh chỉ định thừa dispatcher hoặc debug lỗi context.",
      "code_appearance": {
        "keywords": [
          "coroutineScope",
          "Dispatchers.Default"
        ],
        "apis": []
      },
      "common_mistakes_vi": "Tạo coroutine mà không để ý scope nào là parent, dẫn đến việc chạy sai dispatcher kỳ vọng.",
      "minimal_code_example": "coroutineScope { // inherits parent dispatcher\n    launch { /* runs with parent dispatcher */ }\n}"
    },
    {
      "concept_name_en": "Coroutine vs Thread Scalability",
      "what_it_is_vi": "So sánh mức độ sử dụng tài nguyên và khả năng mở rộng giữa coroutine và thread.",
      "when_why_use_vi": "Hiểu rõ tại sao coroutine lightweight hơn thread (chia sẻ thread pool, không block thread khi suspend) và nên dùng khi cần xử lý lượng tác vụ concurrency lớn.",
      "code_appearance": {
        "keywords": [
          "delay",
          "launch",
          "repeat",
          "thread",
          "Thread.sleep",
          "suspend"
        ],
        "apis": [
          "coroutineScope",
          "kotlin.concurrent.thread"
        ]
      },
      "common_mistakes_vi": "Tạo quá nhiều thread (ví dụ 50k) thay vì dùng coroutine sẽ gây OutOfMemoryError do mỗi thread tốn bộ nhớ stack riêng (có thể lên tới 100GB).",
      "minimal_code_example": "suspend fun printPeriods() = coroutineScope {\n  repeat(50_000) {\n    launch { delay(5000L); print(\".\") }\n  }\n}\n// VS\nfun main() = repeat(50_000) {\n  thread { Thread.sleep(5000L); print(\".\") }\n}"
    },
    {
      "concept_name_en": "Coroutine Thread Agnosticism",
      "what_it_is_vi": "Khả năng của coroutine suspend trên một thread và resume trên thread khác.",
      "when_why_use_vi": "Cho phép nhiều coroutine chia sẻ chung một thread pool hiệu quả, tránh việc block thread khi chờ I/O.",
      "code_appearance": {
        "keywords": [
          "suspend",
          "resume",
          "thread pool"
        ],
        "apis": [
          "launch",
          "async"
        ]
      },
      "common_mistakes_vi": "Lầm tưởng rằng coroutine 'giống' thread và chiếm tài nguyên như thread (trong khi coroutine nhẹ hơn rất nhiều).",
      "minimal_code_example": ""
    },
    {
      "concept_name_en": "Adapter Pattern",
      "what_it_is_vi": "Một design pattern cho phép các lớp có interface không tương thích làm việc cùng nhau.",
      "when_why_use_vi": "Khi cần integrate một component mới với codebase hiện có mà không sửa đổi code gốc (theo nguyên tắc Open/Closed Principle).",
      "code_appearance": {
        "keywords": [
          "implements",
          "extends",
          "override"
        ],
        "apis": [
          "View",
          "Adapter",
          "RecyclerView.Adapter"
        ]
      },
      "common_mistakes_vi": "Thực hiện logic phức tạp trong Adapter thay vì chỉ chuyển đổi dữ liệu; Adapter quá lớn (giữ quá nhiều trách nhiệm).",
      "minimal_code_example": "class MyAdapter(private val data: List<Item>) : RecyclerView.Adapter<MyViewHolder>() { ... }"
    },
    {
      "concept_name_en": "RecyclerView",
      "what_it_is_vi": "Component UI để hiển thị danh sách dữ liệu hiệu suất cao, thay thế cho ListView.",
      "when_why_use_vi": "Khi cần hiển thị danh sách dài hoặc động, tối ưu hiệu năng bằng cơ chế tái sử dụng View (recycling).",
      "code_appearance": {
        "keywords": [
          "RecyclerView",
          "LayoutManager",
          "setAdapter"
        ],
        "apis": [
          "RecyclerView.Adapter",
          "RecyclerView.ViewHolder",
          "LinearLayoutManager"
        ]
      },
      "common_mistakes_vi": "Quên gọi notify... khi dữ liệu thay đổi; không set LayoutManager导致 crash.",
      "minimal_code_example": "recyclerView.layoutManager = LinearLayoutManager(context); recyclerView.adapter = myAdapter;"
    },
    {
      "concept_name_en": "ViewHolder Pattern",
      "what_it_is_vi": "Một pattern để cache référence đến các View bên trong item list.",
      "when_why_use_vi": "Để tránh findViewById lặp lại mỗi khi scroll, tối ưu performance.",
      "code_appearance": {
        "keywords": [
          "class",
          "inner class",
          "findViewById"
        ],
        "apis": [
          "RecyclerView.ViewHolder"
        ]
      },
      "common_mistakes_vi": "Định nghĩa ViewHolder quá sâu hoặc phức tạp; không tối ưu binding logic.",
      "minimal_code_example": "class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val textView: TextView = itemView.findViewById(R.id.text) }"
    },
    {
      "concept_name_en": "DiffUtil",
      "what_it_is_vi": "Một utility class để tính toán hiệu quả các cập nhật cho Adapter.",
      "when_why_use_vi": "Thay vì notifyDataSetChanged() reload toàn bộ, DiffUtil chỉ cập nhật item thay đổi để hiệu năng tốt hơn và animation mượt hơn.",
      "code_appearance": {
        "keywords": [
          "calculateDiff",
          "DiffUtil.Callback"
        ],
        "apis": [
          "DiffUtil",
          "DiffUtil.DiffResult"
        ]
      },
      "common_mistakes_vi": "Implement các phương thức của Callback sai logic (như areItemsTheSame so sánh sai).",
      "minimal_code_example": "val diffResult = DiffUtil.calculateDiff(MyDiffCallback(oldList, newList)); diffResult.dispatchUpdatesTo(adapter);"
    },
    {
      "concept_name_en": "DiffUtil.Callback",
      "what_it_is_vi": "Lớp trừu tượng để cung cấp logic so sánh item cho DiffUtil.",
      "when_why_use_vi": "Để DiffUtil biết cách nhận diện item nào giống nhau và nội dung item nào thay đổi.",
      "code_appearance": {
        "keywords": [
          "override fun",
          "getOldListSize",
          "getNewListSize",
          "areItemsTheSame",
          "areContentsTheSame"
        ],
        "apis": [
          "DiffUtil.Callback"
        ]
      },
      "common_mistakes_vi": "Phương thức areItemsTheSame trả về true cho các item khác biệt ID (trùng lặp ID).",
      "minimal_code_example": "override fun areItemsTheSame(oldPos: Int, newPos: Int): Boolean = oldList[oldPos].id == newList[newPos].id"
    },
    {
      "concept_name_en": "ListUpdateCallback",
      "what_it_is_vi": "Interface để xử lý các sự kiện cập nhật list từ DiffUtil.",
      "when_why_use_vi": "Khi bạn muốn kiểm soát quá trình insert/update/remove item một cách thủ công thay vì tự động gọi adapter methods.",
      "code_appearance": {
        "keywords": [
          "onInserted",
          "onRemoved",
          "onChanged"
        ],
        "apis": [
          "ListUpdateCallback"
        ]
      },
      "common_mistakes_vi": "Lẫn lộn giữa ListUpdateCallback với Adapter callback.",
      "minimal_code_example": "val callback = object : ListUpdateCallback { override fun onInserted(...) { ... } }"
    }
  ]
}