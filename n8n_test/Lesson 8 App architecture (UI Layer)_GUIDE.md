# DEVELOPER DECISION GUIDE: Lesson 8 App architecture (UI Layer).pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:32:31



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: UI Layer Architecture

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Separation of Concerns (Tách biệt trách nhiệm)**: Nguyên tắc tách biệt giao diện người dùng (UI), logic nghiệp vụ (Business Logic), và dữ liệu (Data) để code dễ bảo trì và test.
- **ViewModel (Mô hình hiển thị)**: Component lưu trữ trạng thái UI và logic nghiệp vụ, sống sót khi thay đổi cấu hình (configuration changes) như xoay màn hình.
- **LiveData (Dữ liệu quan sát được)**: Container giữ dữ liệu cho phép UI quan sát (observe) và tự động cập nhật khi dữ liệu thay đổi, có vòng đời an toàn (lifecycle-aware).

### Key Mental Models
**Reality Check**: Activity/Fragment chỉ là "người điều khiển" (UI Controller). Đừng nhét logic vào đó. Hãy để ViewModel làm việc nặng.
- **Activity/Fragment**: Chỉ xử lý UI events (click, input) và render data từ ViewModel.
- **ViewModel**: Giữ state (dữ liệu) và xử lý logic (gọi API, tính toán).
- **LiveData**: Cầu nối 2 chiều giữa ViewModel và UI. UI "nghe" LiveData và update khi data thay đổi.

**Why better?**
Nếu để logic trong Activity, khi xoay màn hình, Activity bị destroy và recreate, logic bị chạy lại từ đầu, mất trạng thái. ViewModel giữ nguyên trạng thái, code gọn gàng, dễ test độc lập.

---

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao (EN: Lifecycle-aware) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Lưu trữ dữ liệu UI cần survive xoay màn hình** | ViewModel + LiveData | ViewModel sống sót qua configuration change. LiveData đảm bảo UI update đúng vòng đời, tránh leak memory. | Lưu dữ liệu trực tiếp trong Activity. Dùng biến thường (var) trong ViewModel mà không có LiveData -> UI không tự update. |
| **Xử lý event one-time (Navigation, Show Toast)** | SingleLiveEvent / UiEvent (StateFlow) | LiveData/StateFlow giữ giá trị cũ,导致 event bị trigger lại không mong muốn. | Dùng LiveData thường cho event. Lỗi "nổ" UI liên tục khi quay lại screen. |
| **Chỉ hiện UI tĩnh, không thay đổi dữ liệu** | Không cần ViewModel/LiveData | Tránh rườm rà. Đơn giản là best. | Viết View Model cho layout chỉ có text fixed, tốn công maintance. |

| Tình huống sử dụng | Nên dùng gì | Tại sao (EN: Data Binding) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Layout phức tạp, data binding 2-way** | Data Binding (layout với `<data>`) | Giảm boilerplate findViewById, bind data tự động, support 2-way binding. | Dùng Data Binding cho layout đơn giản quá mức -> Code XML phức tạp khó debug. |
| **Layout đơn giản, cần hiệu suất tối đa** | View Binding (hoặc findViewById cũ) | Nhanh hơn Data Binding, compile-time safety. | Dùng Data Binding khi chỉ cần hiện 1 text view -> Tăng overhead không cần thiết. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Diagram
```text
[ User Interaction ]
       |
       v
[ Activity / Fragment ] <---------> [ ViewModel ] <---------> [ Data Layer (Repository) ]
       |   (UI Controller)          |                            |
       |                            | (Sử dụng Coroutines/Flow) |
       |                            |                            v
       |                    [ Local Data (DB) / Remote (API) ]
       |
(Quan sát LiveData/StateFlow để update UI)
```

### Component Relationships
1. **Activity/Fragment observer ViewModel LiveData**:
   - `viewModel.myData.observe(this) { updateUI(it) }`
2. **Activity/Fragment send events to ViewModel**:
   - Button click -> `viewModel.loadData()`
3. **ViewModel fetch data from Repository**:
   - `viewModelScope.launch { val data = repo.getData() }`

**Mối quan hệ 1 chiều (Unidirectional Data Flow):**
- UI -> Event -> ViewModel -> Data -> LiveData -> UI Update

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Basic ViewModel + LiveData Setup
**Khi nào dùng**: Khi app cần giữ dữ liệu khi xoay màn hình và update UI tự động.

**Tại sao đúng**: Tách biệt logic ra khỏi UI controller, lifecycle an toàn.

**Code Demo Hoàn Chỉnh**:

```kotlin
// File: MainViewModel.kt
import androidx.lifecycle.*
import kotlinx.coroutines.launch

class MainViewModel(private val repository: AppRepository) : ViewModel() {
    
    // Private LiveData để giữ dữ liệu
    private val _userData = MutableLiveData<User>()
    
    // Public immutable LiveData cho UI quan sát
    val userData: LiveData<User> = _userData

    // Trạng thái loading
    private val _isLoading = MutableLiveData<Boolean>(false)
    val isLoading: LiveData<Boolean> = _isLoading

    fun fetchUser(userId: String) {
        _isLoading.value = true
        viewModelScope.launch {
            try {
                val user = repository.getUser(userId)
                _userData.value = user
            } catch (e: Exception) {
                // Xử lý lỗi
            } finally {
                _isLoading.value = false
            }
        }
    }
}

// File: MainActivity.kt
class MainActivity : AppCompatActivity() {
    // Dùng by viewModels() để lifecycle an toàn
    private val viewModel: MainViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Observer LiveData
        viewModel.userData.observe(this) { user ->
            // Update UI
            findViewById<TextView>(R.id.tvName).text = user.name
        }

        viewModel.isLoading.observe(this) { isLoading ->
            // Show/Hide progress bar
            findViewById<ProgressBar>(R.id.progressBar).visibility = 
                if (isLoading) View.VISIBLE else View.GONE
        }

        // Event từ UI
        findViewById<Button>(R.id.btnLoad).setOnClickListener {
            viewModel.fetchUser("123")
        }
    }
}
```

### Pattern 2: Data Binding with ViewModel
**Khi nào dùng**: Layout phức tạp, muốn减少 Java/Kotlin code trong Activity/Fragment.

**Tại sao đúng**: Auto-update UI khi LiveData thay đổi, clean code.

**Code Demo Hoàn Chỉnh**:

```xml
<!-- activity_main.xml -->
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="viewModel"
            type="com.example.MainViewModel" />
        <variable
            name="activity"
            type="androidx.appcompat.app.AppCompatActivity" />
    </data>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical">

        <!-- Bind LiveData directly -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{viewModel.userData.name}" 
            android:visibility="@{viewModel.isLoading ? View.GONE : View.VISIBLE}" />

        <!-- Bind click handler -->
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Load"
            android:onClick="@{() -> viewModel.fetchUser("123")}" />
            
    </LinearLayout>
</layout>
```

```kotlin
// MainActivity.kt với Data Binding
class MainActivity : AppCompatActivity() {
    private val viewModel: MainViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Setup Data Binding
        val binding: ActivityMainBinding = DataBindingUtil.setContentView(
            this, R.layout.activity_main
        )
        
        binding.lifecycleOwner = this // CRITICAL: Để LiveData hoạt động
        binding.viewModel = viewModel
    }
}
```

### Pattern 3: Shared ViewModel (Fragment - Activity)
**Khi nào dùng**: Multiple fragments need share data hoặc navigate giữ state.

**Tài sao đúng**: Scope activity lifecycle, data flow linh hoạt không phải pass args rườm rà.

**Code Demo Hoàn Chỉnh**:

```kotlin
// Activity level
class ParentActivity : AppCompatActivity() {
    // Shared ViewModel scope theo Activity
    private val sharedViewModel: SharedViewModel by viewModels()
}

// Fragment 1
class FragmentA : Fragment() {
    private val sharedViewModel: SharedViewModel by activityViewModels()

    fun onUserSelect(user: User) {
        sharedViewModel.selectUser(user)
        // Navigate to Fragment B
    }
}

// Fragment 2
class FragmentB : Fragment() {
    private val sharedViewModel: SharedViewModel by activityViewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        sharedViewModel.selectedUser.observe(viewLifecycleOwner) { user ->
            // Update UI with selected user
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Logic trong Activity/Fragment (God Activity)
**Danger**: Khi Activity có 1000+ lines code, chứa cả API call, DB logic, validation.
**Why dangerous**: Khó test, khó reuse, hard to debug. Khi xoay màn hình, code chạy lại gây crash hoặc lost data.

### 2. Truy cập UI từ ViewModel
**Danger**: ViewModel gọi `findViewById()` hoặc `activity.findViewById()`.
**Why dangerous**: Vi phạm MVVM, memory leak nếu Activity destroyed nhưng ViewModel vẫn giữ reference đến View. ViewModel không bao giờ được biết về View.

### 3. Dùng LiveData không lifecycle-aware
**Danger**: Tạo `LiveData` trong ViewModel nhưng không quan sát qua `observe()`, hay dùng `getValue()` trực tiếp.
**Why dangerous**: Race condition, UI không update đúng lúc, dễ crash NullPointerException.

### 4. Hardcode string trong code
**Danger**: `textView.text = "Xin chào"`
**Why dangerous**: Khó dịch thuật (i18n), không thể update khi thay đổi design.

### 5. DataContext trong XML không có LifecycleOwner
**Danger**: Quên `binding.lifecycleOwner = this`.
**Why dangerous**: LiveData không update UI dù dữ liệu thay đổi.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **ViewModel**: Giữ state, xử lý logic, không refer View.
2. **LiveData**: Dùng cho UI observation, lifecycle-aware.
3. **Activity**: Chỉ render UI, dispatch event sang ViewModel.
4. **Data Binding**: Dùng khi layout phức tạp, nhớ `lifecycleOwner`.
5. **Scope**: `viewModelScope` cho coroutine an toàn với ViewModel.

### Decision Logic (If-Else Style)
```text
IF (Cần giữ dữ liệu khi xoay màn hình) 
   -> Use ViewModel + LiveData

ELSE IF (Layout phức tạp, nhiều binding)
   -> Use Data Binding

ELSE IF (Cần share data giữa Fragments)
   -> Use Shared ViewModel (activityViewModels())

ELSE 
   -> Simple View Binding, no ViewModel needed
```

### Top 10 Things to Remember
1. **Never** put business logic in Activity/Fragment.
2. **Always** use `viewModelScope` for coroutines.
3. **Always** set `lifecycleOwner` for Data Binding.
4. **Never** reference View in ViewModel.
5. **Use** `MutableLiveData` (private) vs `LiveData` (public).
6. **Avoid** `getValue()` in ViewModel, use observers.
7. **Separate** Data Layer (Repository) from UI Layer.
8. **Handle** loading/error states in ViewModel.
9. **Use** `by viewModels()` for lifecycle safety.
10. **Test** ViewModel without Android framework dependency.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: UI Layer & ViewModel

## SECTION 1: CORE MENTAL MODEL

**ViewModel (Mô hình quan sát)**
Object that prepares and manages data for the UI. It survives configuration changes (like screen rotation) because it is scoped to the screen's lifecycle, not the UI controller (Activity/Fragment) instance.

**Why is this better?**
Without `ViewModel`, data loss occurs on rotation. With `ViewModel`, data persists automatically, keeping the UI logic clean and testable.

**Dependency Injection via `by viewModels()`**
```kotlin
// Delegate provided by androidx.activity:activity-ktx
val viewModel: ScoreViewModel by viewModels()
```
**Mental Model:** Think of `ViewModel` as a "screen-level brain" that stays alive while the screen is visible, even if the screen rotates. `Activity`/`Fragment` are just temporary "hands" that display the data.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Storing UI Data** (Lưu trữ dữ liệu UI) | **ViewModel** | **Lifecycle Scoping (Phạm vi vòng đời):** Automatically cleared when the screen is destroyed, preventing memory leaks. | Storing data directly in `Activity` variables (lost on rotation). |
| **Holding References** | **Do NOT use ViewModel** | **Lifecycle Mismatch:** `ViewModel` lives longer than the View. Storing an `Activity` reference causes memory leaks (zombie objects). | Passing `Context` or `View` into `ViewModel` constructor. |
| **Data Binding** (Ràng buộc dữ liệu) | **ViewModel + Data Binding** | **Two-way sync:** The View observes the ViewModel automatically. No manual `findViewById` or `setText` calls needed. | Updating `TextView` manually inside `ViewModel` (breaks separation of concerns). |
| **Simple Counters/State** | **ViewModel + MutableState** | **Reactive:** The UI reacts to data changes automatically. | Using `Int` or `String` directly without observability (UI won't update). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy & Data Flow**
```text
[ USER INTERACTION ] (Clicks, Inputs)
       ⬇
[ UI CONTROLLER ] (Activity / Fragment)
       ⬇  (Gets instance via: by viewModels())
       ⬇
[ VIEWMODEL ] (Holds State & Logic)
       ⬇  (Exposes: LiveData / StateFlow)
       ⬇
[ DATA BINDING / OBSERVERS ] (Updates XML / Views)
```

**Lifecycle Flow:**
1. **Activity Start:** `ViewModel` is created (if new) or retained.
2. **Rotation:** `Activity` is destroyed and recreated. **`ViewModel` stays.**
3. **Activity Finish:** `ViewModel` receives `onCleared()` and is destroyed.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic State Holding
**When to use:** Simple apps, counters, toggles, passing data between config changes.

**Why correct:** Keeps data safe from rotation. Logic is unit-testable (no Android framework dependency).

```kotlin
// ViewModel Definition
import androidx.lifecycle.ViewModel

class ScoreViewModel : ViewModel() {
    // Public mutable state (can be changed internally)
    var scoreA: Int = 0
        private set // Setter is private so only ViewModel can modify it

    var scoreB: Int = 0
        private set

    fun incrementScore(isTeamA: Boolean) {
        if (isTeamA) {
            scoreA++
        } else {
            scoreB++
        }
    }
}

// Usage in Activity
class MainActivity : AppCompatActivity() {
    // Dependency injection delegate
    val viewModel: ScoreViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val scoreViewA: TextView = findViewById(R.id.scoreA)
        val plusOneButtonA: Button = findViewById(R.id.plusOne_teamA)

        // Initial state
        scoreViewA.text = viewModel.scoreA.toString()

        // Interaction updates ViewModel, then View updates manually
        plusOneButtonA.setOnClickListener {
            viewModel.incrementScore(true)
            scoreViewA.text = viewModel.scoreA.toString()
        }
    }
}
```

### Pattern 2: Data Binding with ViewModel
**When to use:** Reducing boilerplate `findViewById` and manual UI updates. Complex layouts.

**Why correct:** Decouples UI logic from the Controller. XML becomes the "View", ViewModel is the "Model".

```kotlin
// ViewModel (Same as above, but exposed via LiveData/Flow ideally, 
// though the text allows direct var access for simple binding)
class ScoreViewModel : ViewModel() {
    var scoreA: Int = 0
        private set
    
    fun incrementScore(isTeamA: Boolean) {
        if (isTeamA) scoreA++ 
    }
}

// XML Layout (activity_main.xml snippet)
/*
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="viewModel"
            type="com.example.ScoreViewModel" />
    </data>

    <LinearLayout ... >
        <TextView
            android:id="@+id/scoreA"
            android:text="@{String.valueOf(viewModel.scoreA)}" /> 
        
        <Button
            android:id="@+id/plusOne_teamA"
            android:onClick="@{() -> viewModel.incrementScore(true)}" />
    </LinearLayout>
</layout>
*/

// Activity Setup
class MainActivity : AppCompatActivity() {
    val viewModel: ScoreViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val binding: ActivityMainBinding = DataBindingUtil.setContentView(
            this, R.layout.activity_main
        )
        
        // Bind lifecycle owner so updates happen
        binding.lifecycleOwner = this
        binding.viewModel = viewModel
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Leaking View References**
*   **Code:** `class MyViewModel(val activity: Activity) : ViewModel()`
*   **Why dangerous:** The `ViewModel` outlives the `Activity`. Holding a reference prevents the Garbage Collector from reclaiming memory when the user closes the screen, causing crashes (Out of Memory).

**2. Storing UI Logic in View**
*   **Code:** Putting `if/else` calculations inside `MainActivity` instead of `ViewModel`.
*   **Why dangerous:** You cannot unit test the logic without running the full app (instrumentation tests are slow).

**3. Ignoring `by viewModels()`**
*   **Code:** `val viewModel = ScoreViewModel()` (Manual instantiation).
*   **Why dangerous:** Manually created ViewModels are not scoped to the lifecycle. They will be re-created on every rotation (losing data) or never destroyed (causing leaks).

---

## SECTION 6: MASTER CHEAT SHEET

**Top 10 Things to Remember**
1.  **Dependency:** Add `androidx.lifecycle:lifecycle-viewmodel-ktx`.
2.  **Delegate:** Always use `by viewModels()` in Activities/Fragments.
3.  **Rule #1:** No `Context`, `View`, or `Activity` references in `ViewModel`.
4.  **Rule #2:** UI Controller (`Activity`) observes the `ViewModel`.
5.  **Survival:** `ViewModel` survives rotation.
6.  **Death:** `ViewModel` dies only when the screen is finished (not rotated).
7.  **Data Binding:** Use `binding.viewModel = viewModel` + `binding.lifecycleOwner = this`.
8.  **Updates:** `ViewModel` updates data -> UI updates automatically (if using Observables/DataBinding).
9.  **Initialization:** Initialize data in `init` block of ViewModel.
10. **Testability:** Put all logic in `ViewModel` to make it easy to test.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: UI Layer Architecture (Lesson 8)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Data Binding (RBinding dữ liệu)**: Kỹ thuật cho phép UI components trong XML tự động cập nhật dữ liệu từ ViewModel mà không cần code thủ công trong Activity/Fragment.
- **LiveData (Dữ liệu quan sát được)**: Wrapper dữ liệu thông minh, tự động thông báo thay đổi cho UI khi dữ liệu thay đổi và có khả năng lifecycle-aware (chỉ update khi UI đang hiển thị).
- **MutableLiveData (Dữ liệu thay đổi được)**: Phiên bản LiveData cho phép thay đổi dữ liệu nội bộ (private), dùng trong ViewModel.
- **Observer (Người quan sát)**: Mẫu thiết kế (Design Pattern) cho phép một đối tượng (UI) theo dõi thay đổi của đối tượng khác (LiveData) và tự động phản ứng lại.

### Key Mental Models
1. **Two-Way Street**: Data Binding là đường 2 chiều.
   - **XML → ViewModel**: Gọi hàm (`android:onClick="@{viewModel::incrementScore}"`).
   - **ViewModel → XML**: Hiển thị dữ liệu (`android:text="@{viewModel.scoreA}"`).
2. **UI là functions of State**: UI của bạn chỉ là một hàm số của State (trạng thái). Khi State thay đổi (qua LiveData), UI tự động render lại.

### Why This Approach?
- **Giảm Boilerplate**: Không cần `findViewById` hay `setText` hàng loạt.
- **Chủ động (Reactive)**: UI tự động update khi data thay đổi, không cần can thiệp thủ công.
- **Lifecycle Safety**: Không lo crash do update UI khi Activity/Fragment đã bị hủy.

---

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao (EN + VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Lưu trữ dữ liệu UI thay đổi** | `private val _data = MutableLiveData<T>()`<br>Public `val data: LiveData<T>` | **Encapsulation (Bao bọc)**: Tránh các class khác sửa đổi data lung tung. Chỉ ViewModel mới sửa được `_data`. | Dùng `MutableLiveData` public públic cho phép UI (Activity) sửa data trực tiếp, phá vỡ quy tắc Architecture. |
| **UI quan sát thay đổi** | `data.observe(this) { newValue -> ... }` | **Lifecycle-Aware (Cảnh giác vòng đời)**: Tự động ngắt quan sát khi Activity/Fragment bị hủy, tránh rò rỉ bộ nhớ (Memory Leak). | Dùng `Thread` hay `Handler` để polling data, gây lag và crash. |
| **Bấm nút thực hiện logic** | `android:onClick="@{viewModel::incrementScore}"` trong XML | **Separation of Concerns (Tách biệt trách nhiệm)**: Activity không chứa logic, chỉ là giao diện trung gian. | Đặt logic xử lý tính toán, sửa data trực tiếp trong Activity. |
| **Hiển thị list dữ liệu** | `RecyclerView` + `ListAdapter` (hoặc `observableList` trong DataBinding) | **Performance (Hiệu năng)**: Tối ưu việc cập nhật item riêng lẻ thay vì reload cả list. | Dùng `notifyDatasetChanged()` mọi lúc, gây giật lag UI. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Flow
1. **ViewModel**: Giữ State (trạng thái) và Logic. Chứa `MutableLiveData`.
2. **Data Binding (XML)**: Kết nối View ↔ ViewModel thông qua biến `viewModel`.
3. **Activity/Fragment**: Tạo ViewModel, gán data binding, đăng ký Observer.

### Text-Based Diagram
```text
[ Data Source / Logic ]
       ↓ (Thay đổi)
[ ViewModel: _scoreA (MutableLiveData) ]
       ↓ (Tự động update khi UI Active)
[ Data Binding Layer (XML) ]
       ↓ (Hiển thị)
[ View (TextView, Button) ]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Data Binding Setup
**Khi nào dùng**: Bắt đầu mọi Activity có UI phức tạp cần update nhiều view.

**Tại sao đúng**: Kết nối XML với Code một cách mạnh mẽ, cho phép dùng ViewModel trực tiếp trong XML.

```kotlin
// activity_main.xml
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <variable
            name="viewModel"
            type="com.example.kabaddikounter.ScoreViewModel" />
    </data>
    <androidx.constraintlayout.widget.ConstraintLayout>
        <TextView
            android:text="@{viewModel.scoreA.toString()}" />
        <Button
            android:onClick="@{viewModel::incrementScore}" />
    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>

// MainActivity.kt
class MainActivity : AppCompatActivity() {
    // Khai báo ViewModel
    val viewModel: ScoreViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Set layout và gán data
        val binding: ActivityMainBinding = DataBindingUtil.setContentView(
            this, R.layout.activity_main
        )
        binding.viewModel = viewModel
        binding.lifecycleOwner = this // Quan trọng để LiveData hoạt động!
    }
}
```

### Pattern 2: LiveData Encapsulation in ViewModel
**Khi nào dùng**: Khi cần lưu trữ và thay đổi dữ liệu (score, name, status) trong ViewModel.

**Tại sao đúng**: Bảo vệ data khỏi bị thay đổi sai chỗ (Encapsulation), chỉ cho phép sửa qua function của ViewModel.

```kotlin
class ScoreViewModel : ViewModel() {
    // Private, chỉ ViewModel sửa được
    private val _scoreA = MutableLiveData<Int>(0)
    
    // Public, UI chỉ được đọc (observe)
    val scoreA: LiveData<Int>
        get() = _scoreA

    // Logic xử lý thay đổi
    fun incrementScore(isTeamA: Boolean) {
        if (isTeamA) {
            // Lấy giá trị hiện tại, cộng 1, gán lại
            _scoreA.value = (_scoreA.value ?: 0) + 1
        }
    }
}
```

### Pattern 3: Observing LiveData (Auto-Update UI)
**Khi nào dùng**: Để UI tự động phản ứng khi data trong ViewModel thay đổi.

**Tại sao đúng**: Tự động hóa việc update UI, đảm bảo UI luôn đồng bộ với State.

```kotlin
// Trong Activity (nếu không dùng binding adapter tự động)
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    // ... setup binding ...

    // Quan sát LiveData
    viewModel.scoreA.observe(this) { newScore ->
        // Code này chạy mỗi khi scoreA thay đổi
        binding.scoreViewA.text = newScore.toString()
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1. **Thay đổi data trong Activity thay vì ViewModel**
   - *Nguy hiểm*: Vi phạm MVVM, khiến logic nằm rải rác, khó bảo trì và test.
   - *Đúng*: Dùng Function trong ViewModel (`viewModel.incrementScore()`).

2. **Dùng `getValue()` trong XML**
   - *Nguy hiểm*: `@{viewModel.scoreA.getValue()}` thường gây lỗi hoặc không hoạt động đúng với LiveData.
   - *Đúng*: Dùng trực tiếp biến: `@{viewModel.scoreA}` (Data Binding tự động xử lý LiveData).

3. **Quên `binding.lifecycleOwner = this`**
   - *Nguy hiểm*: LiveData sẽ không tự động update giá trị lên UI.
   - *Đúng*: Luôn gán `lifecycleOwner` cho binding trong Activity/Fragment.

4. **Dùng MutableLiveData trong Public Property**
   - *Nguy hiểm*: Activity/Fragment có thể gọi `viewModel.scoreA.value = 100`, phá vỡ kiểm soát logic.
   - *Đúng*: `val data: LiveData<T>` (read-only) và `private val _data: MutableLiveData<T>`.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **XML**: Dùng `@{viewModel.tenBien}` để bind data.
2. **ViewModel**: Luôn private `MutableLiveData`, public `LiveData` (get-only).
3. **Activity**: `binding.viewModel = viewModel` + `binding.lifecycleOwner = this`.

### Decision Logic (If-Else)
- **IF**: Cần update UI khi data thay đổi?
  - **THEN**: Dùng `LiveData` trong ViewModel + `Observer` trong Activity (hoặc tự động qua DataBinding).
- **IF**: Cần thay đổi data từ UI (Button click)?
  - **THEN**: Gọi function ViewModel trong XML (`android:onClick="@{viewModel::function}"`).
- **IF**: Data chỉ để đọc, không thay đổi?
  - **THEN**: Dùng `LiveData<T>` (hoặc `val` trong Kotlin).

### Top 10 Things to Remember
1. `MutableLiveData` là `private`.
2. `LiveData` là `public`.
3. `LiveData` là observable (có thể quan sát).
4. XML kết nối ViewModel qua tag `<data>`.
5. `by viewModels()` để tạo ViewModel.
6. `DataBindingUtil.setContentView` để set layout.
7. `binding.lifecycleOwner` là bắt buộc.
8. Logic xử lý số hay string -> Đưa vào ViewModel.
9. Hiển thị -> Để trong XML.
10. `value` để sửa data trong ViewModel, `toString()` để hiển thị.

<!-- CHUNK 31-40 -->

# Developer Decision Guide: UI Layer Architecture (Lesson 8)

## SECTION 1: CORE MENTAL MODEL

**Core Definitions**
- **ViewModel (Người quản lý dữ liệu giao diện)**: Lớp giữ gìn dữ liệu giao diện, tách biệt khỏi vòng đời UI Controller (Activity/Fragment), chịu trách nhiệm chuẩn bị dữ liệu cho UI.
- **LiveData (Dữ liệu quan sát được)**: Nơi chứa dữ liệu có thể quan sát (observe). Khi dữ liệu thay đổi, UI tự động cập nhật mà không cần code thủ công.
- **Data Binding (Rắn dữ liệu)**: Kỹ thuật gắn trực tiếp biến trong code (ViewModel) vào layout XML, loại bỏ việc findViewById và cập nhật UI thủ công.

**Key Mental Models**
- **Luồng một chiều (One-way Flow)**: Người dùng tương tác -> Gọi hàm ViewModel -> ViewModel cập nhật dữ liệu -> LiveData thông báo -> UI tự render lại.
- **Sự cô lập (Separation of Concerns)**: Activity/Fragment chỉ là "người dẫn chương trình". Logic tính toán và dữ liệu phải nằm trong ViewModel.

**Why this approach is better**
Thay vì để Activity giữ dữ liệu (dễ mất khi xoay màn hình) và phải tự tay cập nhật từng TextView (dễ lỗi), cách này cho phép **tự động hóa** việc hiển thị và **tách biệt** logic để dễ bảo trì.

---

## SECTION 2: DECISION TABLES

### Table 1: Observer Trực tiếp (Code) vs Data Binding (XML)

| Tiêu chí | Observer Trực tiếp (Code) | Data Binding (XML) |
| :--- | :--- | :--- |
| **Tình huống sử dụng** | Khi logic cập nhật UI phức tạp (nếu > 10, highlight màu đỏ...), hoặc cần debug dòng lệnh. | Khi chỉ cần hiển thị giá trị thô (số điểm, tên người dùng) từ ViewModel. |
| **Nên dùng gì** | **Data Binding** (nếu đơn giản), hoặc **Code Observer** (nếu logic phức tạp). | **Data Binding** (Ưu tiên cho UI đơn giản). |
| **Tại sao** | **Observing Pattern (Mẫu quan sát)**: Code trực tiếp giúp kiểm soát luồng execution chặt chẽ. | **Two-way Binding (Rắn hai chiều)**: Giảm thiểu boilerplate code (findViewById, setText), dễ đọc. |
| **Sai lầm thường gặp** | Quên remove observer gây rò rỉ bộ nhớ (Memory Leak). | Để logic phức tạp (business logic) trong XML Expression (`@{...}`), làm khó debug. |

### Table 2: MutableLiveData (Private) vs LiveData (Public)

| Tiêu chí | MutableLiveData (Private) | LiveData (Public) |
| :--- | :--- | :--- |
| **Tình huống sử dụng** | Dùng bên trong ViewModel để gán/ghi đè giá trị (`_score.value = ...`). | Dùng bên ngoài (UI/Activity) để đọc và quan sát. |
| **Nên dùng gì** | **Private `val _score`** | **Public `val score`** |
| **Tại sao** | **Encapsulation (Đóng gói)**: Chỉ ViewModel được quyền thay đổi dữ liệu. UI không thể thay đổi trực tiếp. | **Immutability (Bất biến)**: Bảo vệ dữ liệu không bị thay đổi ngoài ý muốn. |
| **Sai lầm thường gặp** | Khai báo `public val` cho MutableLiveData. | Gán giá trị trực tiếp lên UI mà không thông qua LiveData. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy Flow (Text Diagram)**

```text
[ USER INTERACTION ]
       │
       ▼
[ VIEW (Activity/Fragment) ] ──── Tại đây bạn gọi viewModel.incrementScore()
       │                                 │
       │                                 ▼
       │                          [ VIEWMODEL ]
       │                            (Xử lý logic)
       │                                 │
       │                          Cập nhật vào Private LiveData
       │                                 │
       │                                 ▼
       │                         [ LIVE DATA (Mutable) ]
       │                                 │
       │ (Notify Change)                 │
       │                                 ▼
       ├── [ OBSERVER (Code) ] ──── Cập nhật TextView
       │
       └── [ DATA BINDING (XML) ] ──── Tự động cập nhật TextView
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Setup ViewModel & LiveData (Basic)

**Khi nào dùng:** Khi bắt đầu tạo screen mới cần lưu giữ state (trạng thái).

**Tại sao đúng:** Tách biệt logic ra khỏi UI, đảm bảo dữ liệu sống sót khi xoay màn hình.

**Code Demo:**

```kotlin
// File: ScoreViewModel.kt
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

class ScoreViewModel : ViewModel() {
    // 1. Private Mutable Source (Write Only)
    private val _scoreA = MutableLiveData<Int>(0)
    
    // 2. Public Immutable Public Interface (Read Only)
    val scoreA: LiveData<Int>
        get() = _scoreA

    // 3. Business Logic Method
    fun incrementScore(isTeamA: Boolean) {
        if (isTeamA) {
            _scoreA.value = (_scoreA.value ?: 0) + 1
        }
    }
}
```

### Pattern 2: Observer Pattern in Activity (Manual)

**Khi nào dùng:** Khi cần thực thi hành động phức tạp mỗi khi dữ liệu thay đổi (Ví dụ: Play animation, navigate screen).

**Tại sao đúng:** Cho phép bạn can thiệp vào luồng execution ngay tại nơi nhận dữ liệu.

**Code Demo:**

```kotlin
// File: MainActivity.kt
class MainActivity : AppCompatActivity() {
    private val viewModel: ScoreViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 1. Setup Click Listener
        binding.plusOneButtonA.setOnClickListener {
            viewModel.incrementScore(true)
        }

        // 2. Define Observer logic
        val scoreObserver = Observer<Int> { newValue ->
            // Logic phức tạp có thể viết ở đây
            binding.scoreViewA.text = newValue.toString()
        }

        // 3. Attach Observer to LiveData
        viewModel.scoreA.observe(this, scoreObserver)
    }
}
```

### Pattern 3: Two-Way Data Binding (XML)

**Khi nào dùng:** Khi chỉ cần hiển thị giá trị ViewModel lên UI đơn giản.

**Tại sao đúng:** Loại bỏ hoàn toàn code Observer và `setText` trong Activity. UI "kéo" dữ liệu từ ViewModel tự động.

**Code Demo (XML):**

```xml
<!-- File: activity_main.xml -->
<layout xmlns:android="http://schemas.android.com/apk/res/android">
    <data>
        <!-- Khai báo biến ViewModel -->
        <variable
            name="viewModel"
            type="com.example.kabaddikounter.ScoreViewModel" />
    </data>

    <androidx.constraintlayout.widget.ConstraintLayout ...>
        <TextView
            android:id="@+id/scoreViewA"
            /* Rắn trực tiếp giá trị từ ViewModel */
            android:text="@{viewModel.scoreA.toString()}" 
            ... />
    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>
```

**Code Demo (Activity binding):**

```kotlin
// File: MainActivity.kt (Phần setup Data Binding)
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    // Phải dùng DataBindingUtil
    val binding: ActivityMainBinding = DataBindingUtil
        .setContentView(this, R.layout.activity_main)
        
    binding.viewModel = viewModel
    binding.lifecycleOwner = this // QUAN TRỌNG: Để LiveData hoạt động
}
```

### Pattern 4: Transformations (Map/SwitchMap)

**Khi nào dùng:** Khi ViewModel cần dữ liệu gốc (Raw), nhưng UI cần dữ liệu đã xử lý (Processed).

**Tại sao đúng:** Logic chuyển đổi dữ liệu vẫn nằm trong ViewModel (không leak ra Activity), nhưng chỉ tính toán khi cần thiết.

**Code Demo:**

```kotlin
// File: ScoreViewModel.kt
import androidx.lifecycle.Transformations

class ScoreViewModel : ViewModel() {
    private val _scoreA = MutableLiveData<Int>(0)
    val scoreA: LiveData<Int> = _scoreA

    // Tạo LiveData mới phụ thuộc vào scoreA
    val winnerStatus: LiveData<String> = Transformations.map(scoreA) { score ->
        // Logic transform ngay trong ViewModel
        if (score > 10) "Team A Wins!" else "Keep Playing"
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Chứa Logic UI trong ViewModel**
    *   *Lý do nguy hiểm*: ViewModel không nên biết về `View`, `Context` hay `Toast`. Nó phải là "Plain Kotlin Class". Nếu không, khó test và gây rò rỉ bộ nhớ.

2.  **Quên `binding.lifecycleOwner = this`**
    *   *Lý do nguy hiểm*: Nếu không set lifecycle owner trong Data Binding, LiveData sẽ không tự động cập nhật giao diện khi giá trị thay đổi.

3.  **Ghi đè dữ liệu trong `onCreate()` thay vì `init` block**
    *   *Lý do nguy hiểm*: `onCreate()` có thể gọi lại (ví dụ sau khi cấu hình lại màn hình), làm reset dữ liệu đang có. Logic khởi tạo ViewModel phải nằm trong `init { }`.

4.  **Sử dụng `getValue()` sai cách**
    *   *Lý do nguy hiểm*: `liveData.value` trả về `null` nếu dữ liệu chưa có. Luôn xử lý null hoặc dùng `?.` khi truy cập.

---

## SECTION 6: MASTER CHEAT SHEET

**Quick Reference Rules**
1.  **Write**: Dùng `MutableLiveData` (private), không bao giờ expose nó ra ngoài.
2.  **Read**: Dùng `LiveData` (public) để UI observe.
3.  **UI Update**: Ưu tiên **Data Binding** cho hiển thị đơn giản. Dùng **Observer** cho logic phức tạp.
4.  **Transform**: Dùng `Transformations.map` nếu muốn thay đổi format dữ liệu (vd: Int -> String).

**Decision Logic**
*   **IF** (Tôi cần UI tự động update khi ViewModel thay đổi) **THEN** (Dùng LiveData + Observer/Data Binding).
*   **IF** (Tôi xoay màn hình mà không muốn mất dữ liệu) **THEN** (Lưu dữ liệu trong ViewModel, không trong Activity).
*   **IF** (Tôi muốn update 1 TextView với dữ liệu thô) **THEN** (Dùng Data Binding `@{viewModel.data}`).

**Top 3 Things to Remember**
1.  **Separation of Concerns**: Activity là "tay sai", ViewModel là "bộ não".
2.  **Lifecycle Awareness**: Luôn `setLifecycleOwner` để kết nối LiveData với UI.
3.  **Immutability**: UI chỉ đọc dữ liệu, chỉ ViewModel được quyền sửa.

<!-- CHUNK 41-42 -->

# DEVELOPER DECISION GUIDE: UI Layer Architecture
**Source: Lesson 8 - App architecture (UI Layer)**

---

## SECTION 1: CORE MENTAL MODEL

### 1.1. Core Definitions

*   **ViewModel (Người quản lý dữ liệu UI):**
    *   **EN:** Class designed to store and manage UI-related data in a lifecycle-conscious way.
    *   **VN:** Lớp lưu trữ và quản lý dữ liệu UI, sống sót qua các thay đổi cấu hình (như xoay màn hình) nhưng bị hủy khi UI hoàn toàn kết thúc.
    *   **Behavior:** Giữ dữ liệu trạng thái (State) cho UI. Không tham chiếu trực tiếp đến View (Activity/Fragment) để tránh rò rỉ bộ nhớ.

*   **State Hoisting (Nâng cao trạng thái):**
    *   **EN:** The practice of moving state to a higher level in the composable tree to share it.
    *   **VN:** Đẩy state (dữ liệu thay đổi) lên component cha để chia sẻ cho các con hoặc đồng bộ trạng thái. Trong Jetpack Compose, `mutableStateOf` nên được giữ trong `ViewModel` hoặc `StateHolder`.

### 1.2. Mental Model: The "Source of Truth"
**ViewModel là Single Source of Truth (Nguồn Sự Thật Độc Quyền) cho UI.**
Khi UI (View) cần hiển thị dữ liệu, nó quan sát (observe) ViewModel.
1.  **Input:** Người dùng tương tác -> UI gửi sự kiện (Event) đến ViewModel.
2.  **Process:** ViewModel xử lý logic, cập nhật data source (Room, API).
3.  **Output:** ViewModel cập nhật `State` -> UI tự động render lại.

### 1.3. Why this approach?
*   **Survive Configuration Changes:** Dữ liệu không bị mất khi xoay màn hình (không cần `onSaveInstanceState` cồng kềnh).
*   **Clean Separation:** UI (View) chỉ lo hiển thị, ViewModel lo logic. Dễ test unit logic mà không cần UI.

---

## SECTION 2: DECISION TABLES

### Table 1: Where to store UI State?
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Data cần survive xoay màn hình (Config Change)** | **ViewModel** (chứa `StateFlow` / `LiveData`) | **Lifecycle Owner:** ViewModel không bị hủy khi Activity recreate. | Lưu trữ state trong Activity/Fragment -> Mất dữ liệu khi xoay, rò rỉ memory. |
| **Data chỉ cần trong 1 frame (Transient)** | **StateHolder trong Compose** (`remember { mutableStateOf }`) | **Scope:** Sống cùng Composable function, không cần survive. | Đẩy hết vào ViewModel -> Tăng độ phức tạp không cần thiết cho dữ liệu temp. |
| **Data rỗng hoặc Loading ban đầu** | **Default values trong ViewModel** | **Stability:** Đảm bảo UI luôn có giá trị để render ngay lập tức. | Để state `null` không được xử lý -> UI bị Crash NullPointerException. |

### Table 2: UI Event Handling
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **User Click / Input (One-off Events)** | **Channel / SharedFlow** (Trong ViewModel) | **Delivery Guarantee:** Đảm bảo event được xử lý 1 lần duy nhất (không bị replay lại khi xoay màn hình). | Dùng `LiveData` cho Event -> Gây ra tình trạng "Double Click" hoặc Navigation bị gọi lại sai. |
| **UI State (Data to Display)** | **StateFlow / LiveData** | **Stream of Data:** Liên tục cập nhật giá trị mới cho UI quan sát (Observe). | Dùng Channel cho Data -> Mất khả năng replay giá trị cuối cùng cho view mới attach. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Diagram: Data Flow
```text
[ USER INTERACTION ]
       ⬇
[ UI (Activity/Fragment/Composable) ]
   • Gửi Event (onClick, textChange)
   • Quan sát State (collectAsState)
       ⬇
[ VIEWMODEL ]
   • Chứa Logic Business
   • Giữ "Source of Truth" (StateFlow)
   • Xử lý IO (Coroutine)
       ⬇
[ REPOSITORY / DOMAIN ]
   • Lấy data từ Network hoặc Database
```

### Component Relationship Rules
1.  **ViewModel -> UI:** **One-way data flow.** ViewModel không bao giờ được gọi trực tiếp hàm của UI (update View).
2.  **UI -> ViewModel:** UI gọi hàm public trên ViewModel.
3.  **ViewModel -> Repository:** Tương tác Data Layer qua Interface (Dependency Injection).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: ViewModel với StateFlow (MVVM)
**Khi nào dùng:** Khi xây dựng UI hiện đại (Compose hoặc XML) cần responsive data stream.

```kotlin
// 1. UI State Data Class (Immutable)
data class LoginUiState(
    val username: String = "",
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)

// 2. ViewModel
class LoginViewModel : ViewModel() {
    // State Hoisting: Dùng StateFlow làm Source of Truth
    private val _uiState = MutableStateFlow(LoginUiState())
    val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()

    // Xử lý Logic
    fun onUsernameChanged(newUsername: String) {
        // Cập nhật State
        _uiState.update { current ->
            current.copy(username = newUsername)
        }
    }

    fun login() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                // Giả lập API call
                delay(1000) 
                _uiState.update { it.copy(isLoading = false, errorMessage = null) }
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, errorMessage = "Login failed") }
            }
        }
    }
}

// 3. Composable UI (Collecting State)
@Composable
fun LoginScreen(viewModel: LoginViewModel = viewModel()) {
    // CollectAsState lifecycle aware
    val state by viewModel.uiState.collectAsStateWithLifecycle()

    Column {
        TextField(
            value = state.username,
            onValueChange = { viewModel.onUsernameChanged(it) } // Gọi ViewModel
        )
        
        if (state.isLoading) {
            CircularProgressIndicator()
        }
        
        Button(onClick = { viewModel.login() }) {
            Text("Login")
        }
    }
}
```

### Pattern 2: One-Time Event (Navigation/Toast)
**Khi nào dùng:** Khi cần thực hiện hành động chỉ 1 lần (Navigation, Show Toast, Show Dialog) tránh lặp lại khi xoay màn hình.

```kotlin
// ViewModel
class SignupViewModel : ViewModel() {
    // Dùng Channel cho Event
    private val _navigationEvent = Channel<String>(Channel.BUFFERED)
    val navigationEvent = _navigationEvent.receiveAsFlow()

    fun submit() {
        viewModelScope.launch {
            // ... logic ...
            _navigationEvent.send("home_screen") // Gửi event đi 1 lần
        }
    }
}

// UI
@Composable
fun SignupScreen(viewModel: SignupViewModel = viewModel()) {
    LaunchedEffect(Unit) {
        // Lắng nghe event Loop
        viewModel.navigationEvent.collect { route ->
            // Logic navigates here. 
            // LaunchedEffect với key Unit sẽ restart khi screen bị recreate, 
            // nhưng Channel đảm bảo event nếu chưa xử lý sẽ được xử lý.
            navController.navigate(route)
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern | Mô tả | Tại sao NGUY HIỂM (Lý do) |
| :--- | :--- | :--- |
| **Holding Context in ViewModel** | ViewModel持有 Activity/Fragment Context hoặc View Reference. | **Memory Leak:** ViewModel sống lâu hơn Activity. Nếu giữ Context, Activity không bị Garbage Collection -> Hết RAM -> Crash. |
| **Logic trong UI (View/Activity)** | Viết code xử lý nghiệp vụ (kiểm tra dữ liệu, gọi API) trực tiếp trong `onCreate` hoặc `onClick` của View. | **Hard to Test:** Code UI很难 test tự động. **God Activity:** Activity trở nên cồng kềnh, khó maintain (vi phạm MVC/MVVM). |
| **Updating UI directly from ViewModel** | ViewModel gọi `view.text = "..."` hoặc `activity.finish()`. | **Violation Lifecycle:** View có thể bị hủy trong khi ViewModel vẫn chạy -> Crash `NullPointerException`. Phải dùng Observer Pattern (Data → Observer → UI). |
| **Dùng GlobalScope** | `GlobalScope.launch { ... }` trong ViewModel. | **Unpredictable Leak:** GlobalScope không bị ràng buộc lifecycle của ViewModel. Nếu người dùng đóng app, coroutine vẫn chạy ngầm và gây leak tài nguyên. **Luôn dùng `viewModelScope`.** |

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **ViewModels are for data, Views are for display.**
2.  **Never** hold View references in ViewModel.
3.  **Always** use `viewModelScope` for coroutines in ViewModel.
4.  **Events** go via Channel/Flow. **State** goes via StateFlow/LiveData.

### Decision Logic (If-Else)
*   **IF** data needs to survive screen rotation -> **Use ViewModel**.
*   **IF** data is temporary (scroll position, input focus) -> **Use remember()**.
*   **IF** user clicks a button -> **Send Event to ViewModel**.
*   **IF** data updates the screen (List of items) -> **ViewModel exposes State**.
*   **IF** you need to Navigate -> **Send Navigation Event, don't navigate directly**.

### Top 5 Things to Remember
1.  **Source of Truth:** ViewModel là cha của State.
2.  **Lifecycle:** ViewModel onCleared() -> Hủy mọi Coroutine đang chạy.
3.  **Clean Code:** View chỉ nói chuyện với ViewModel. Repository chỉ nói chuyện với ViewModel.
4.  **StateFlow:** Luôn dùng `.stateIn` (trong ViewModel) hoặc `.asStateFlow()` để expose dữ liệu an toàn.
5.  **Unit Test:** Logic trong ViewModel phải có thể test được mà không cần Android Framework (tức là không dùng Context/Toast).