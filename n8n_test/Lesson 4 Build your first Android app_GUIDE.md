# DEVELOPER DECISION GUIDE: Lesson 4 Build your first Android app.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:21:58



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Build Your First Android App

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Activity (Hoạt động)**
Một thành phần ứng dụng cung cấp một màn hình giao diện người dùng (UI) tương tác. Mỗi Activity là một lớp Java/Kotlin độc lập, đóng gói các logic xử lý giao diện và sự kiện người dùng.

```kotlin
// MyActivity.kt - Cấu trúc cơ bản của một Activity
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity

class MyActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main) // Gắn layout giao diện
        
        // Logic khởi tạo UI tại đây
    }
}
```

**Layout (Bố cục)**
Tệp XML định nghĩa giao diện người dùng. Các view (Button, TextView, EditText...) được cấu trúc theo树 (tree) hierarchy.

```xml
<!-- activity_main.xml - Ví dụ layout cơ bản -->
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    
    <TextView
        android:id="@+id/tvHello"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Hello World!" />
        
    <Button
        android:id="@+id/btnClick"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Click Me" />
</LinearLayout>
```

**Gradle (Hệ thống build)**
Công cụ tự động hóa build process. Có 2 file quan trọng:
- `build.gradle (Project)`: Cấu hình toàn project
- `build.gradle (Module)`: Cấu hình app cụ thể

### Key Mental Models
1. **Android Manifest là "constitution" (Hiến pháp)**: Khai báo tất cả components (Activity, Service, Receiver...), permission, và entry point.
2. **UI Thread (Main Thread)**: Chỉ xử lý UI. Không chạy tác vụ nặng (network, database) trên thread này sẽ gây ANR (Application Not Responding).
3. **Resource System**: String, drawable, color... được quản lý集中 trong `res/` folder, tự động tối ưu theo device configuration (màn hình, ngôn ngữ).

### Why This Approach Is Better
- **Separation of Concerns**: Logic (Kotlin) tách biệt UI (XML) → Dễ维护 và test.
- **Declarative UI**: XML cho phép preview layout mà không cần chạy app.
- **Build Automation**: Gradle tự động xử lý dependency, variant build (debug/release), packaging.

## SECTION 2: DECISION TABLES

### Table 1: API Level Selection (SDK Version)
| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|---|---|---|---|
| App mới, không ràng buộc legacy | `minSdkVersion 24` (Nougat) | Che ~95% devices market. `minSdkVersion` quá cao (29+) → mất 30% users. | Setting `minSdkVersion` theo target device thay vì market share |
| App cần hỗ trợ device cũ | `minSdkVersion 21` (Lollipop) | API 21 introduces Material Design. Below 21 → fragmentation nightmares. | Setting `minSdkVersion 19` بدون cần thiết, tăng testing surface area |
| Enterprise app, locked devices | Match company standard | Some enterprises lock devices at specific API levels. | Assuming user will upgrade device |

### Table 2: Layout Choice
| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|---|---|---|---|
| Simple, vertical form | `LinearLayout` | Predictable stacking. Easy for beginners. | Nesting multiple LinearLayouts → performance issues |
| Complex, overlapping UI | `ConstraintLayout` | Flat hierarchy, powerful constraints. Best performance. | Using ConstraintLayout without understanding constraints → UI breaks |
| Reusable UI component | Create custom view | Encapsulation. DRY principle. | Duplicating UI code across multiple activities |

### Table 3: Resource Folder Structure
| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|---|---|---|---|
| Different screen sizes | `res/drawable-` folders | Android automatically picks right asset. | Using single drawable for all densities → blurry on high-res screens |
| Language support | `res/values-` folders | Automatic string replacement based on locale. | Hardcoding strings in code → cannot translate later |
| Landscape orientation | `res/layout-land/` | Optimized layout for horizontal screen. | Forcing portrait only → bad user experience on tablets |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Flowchart: App Launch Sequence
```
User Taps App Icon
    ↓
Android OS reads AndroidManifest.xml
    ↓
Finds LAUNCHER Activity (MainActivity)
    ↓
Calls onCreate() of MainActivity
    ↓
setContentView(R.layout.activity_main)
    ↓
Inflates XML → View hierarchy
    ↓
UI appears on screen
    ↓
User interacts (onClick)
    ↓
Event triggers Kotlin logic
```

### Component Hierarchy
```
App Module (build.gradle)
    ↓ depends on
Android Manifest
    ↓ declares
Activities / Services / Broadcast Receivers / Content Providers
    ↓ use
Resources (res/) + Kotlin Code
    ↓ compiled into
APK (Android Package)
```

### Dependency Flow
```
Gradle Script
    ↓ resolves
Libraries (implementation 'androidx...')
    ↓ packages into
APK
    ↓ installed on
Android Device (minSdkVersion ≤ Device API)
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Activity Setup with View Binding
**When to use (Khi nào dùng)**: Luôn luôn khi tạo Activity mới. Tránh findViewById() lỗi runtime.

**Why this pattern is correct**: View Binding type-safe, null-safe, tự động generated code.

```kotlin
// build.gradle (Module) - Thêm dependency
android {
    viewBinding {
        enabled = true
    }
}

// MainActivity.kt
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.example.app.databinding.ActivityMainBinding // Tự động generate

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding // Khai báo global
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater) // Inflate
        setContentView(binding.root) // Set root view
        
        // Sử dụng binding để truy cập view
        binding.btnClick.setOnClickListener {
            binding.tvHello.text = "Button clicked!"
        }
    }
}
```

### Pattern 2: Handling Button Clicks
**When to use (Khi nào dùng)**: Khi cần tương tác người dùng.

**Why this pattern is correct**: Listener pattern tách biệt UI event với logic. Lambda syntax gọn.

```kotlin
// Trong onCreate() của Activity
binding.btnSubmit.setOnClickListener {
    // 1. Lấy dữ liệu
    val name = binding.etName.text.toString()
    
    // 2. Validate (nếu cần)
    if (name.isBlank()) {
        binding.tvError.text = "Name cannot be empty"
        return@setOnClickListener
    }
    
    // 3. Xử lý logic
    val message = "Hello, $name!"
    binding.tvResult.text = message
    
    // 4. Tương tác khác (navigation, API call, etc.)
}
```

### Pattern 3: String Resources for Localization
**When to use (Khi nào dùng)**: Luôn luôn cho text hiển thị UI. Không hardcode string.

**Why this pattern is correct**: Dễ dịch, centrally managed, giúp enforce consistency.

```xml
<!-- res/values/strings.xml -->
<resources>
    <string name="app_name">My First App</string>
    <string name="welcome_message">Welcome, %1$s!</string>
    <string name="btn_submit">Submit</string>
</resources>

<!-- res/values-vi/strings.xml (Vietnamese) -->
<resources>
    <string name="app_name">Ứng dụng đầu tiên</string>
    <string name="welcome_message">Chào mừng, %1$s!</string>
    <string name="btn_submit">Gửi</string>
</resources>
```

```kotlin
// Sử dụng trong Kotlin
binding.tvWelcome.text = getString(R.string.welcome_message, "An")
// Hoặc với View Binding: resources.getString(R.string.welcome_message, "An")
```

### Pattern 4: Register Activity in Manifest
**When to use (Khi nào dùng)**: Bắt buộc cho mỗi Activity tạo mới.

**Why this pattern is correct**: Android không tự động discover Activity. Manifest là registry trung tâm.

```xml
<!-- AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.myapp">

    <application ... >
        <!-- MainActivity là entry point -->
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        
        <!-- DetailActivity (không phải entry point) -->
        <activity
            android:name=".DetailActivity"
            android:exported="false" /> <!-- Chỉ app内部调用 -->
    </application>
</manifest>
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Hardcoding Dimensions in Layout XML
```xml
<!-- ANTI-PATTERN -->
<Button
    android:layout_width="150dp" <!-- NGUY HIỂM -->
    android:layout_height="50dp"
    android:text="Click" />
```
**Why dangerous**: Không responsive trên các screen size khác nhau. Luôn dùng `wrap_content`, `match_parent`, hoặc resource dimension.

### 2. Not Handling Configuration Changes
```kotlin
// ANTI-PATTERN - Mất dữ liệu khi xoay màn hình
class MainActivity : AppCompatActivity() {
    var userInput = "" // Biến instance sẽ lost khi rotate
    
    override fun onCreate(savedInstanceState: Bundle?) {
        // ... không kiểm tra savedInstanceState
    }
}
```
**Why dangerous**: UI state lost on rotation. Phải dùng `savedInstanceState` hoặc ViewModel.

### 3. Running Network on Main Thread
```kotlin
// ANTI-PATTERN - Gây ANR (App Not Responding)
binding.btnFetch.setOnClickListener {
    // This crashes on Android 9+
    val data = URL("http://api.example.com").readText() 
    binding.tvResult.text = data
}
```
**Why dangerous**: UI freeze. Phải dùng Coroutine hoặc Thread.

### 4. Forgetting to Set Content View
```kotlin
// ANTI-PATTERN - Trắng screen
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Quên setContentView() → UI không hiển thị
    }
}
```
**Why dangerous**: Activity không render gì cả. Luôn call `setContentView()`.

### 5. Using Deprecated API Levels Without Justification
```kotlin
// ANTI-PATTERN
minSdkVersion 14 // API 14 (Ice Cream Sandwich) - Deprecated
```
**Why dangerous**: Security risks, cannot use modern features, testing nightmare. Use API 21+.

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **API Level**: `minSdkVersion 21` cho大多数 projects.
2. **Layout**: Bắt đầu với `ConstraintLayout` cho complex UI, `LinearLayout` cho simple forms.
3. **View Access**: Dùng `View Binding` - không `findViewById()`.
4. **Strings**: Không hardcode. Luôn dùng `res/values/strings.xml`.
5. **Manifest**: Khai báo Activity ở đây, `exported="true"` chỉ cho LAUNCHER.

### Decision Logic (If-Else Style)

```
IF (creating new Activity) THEN
    - Add <activity> in AndroidManifest.xml
    - Create layout XML in res/layout/
    - Inflate in onCreate() using View Binding
    - Set click listeners if needed

ELSE IF (choosing minSdkVersion) THEN
    IF (need maximum market coverage) THEN use 21
    ELSE IF (need latest features only) THEN use 26
    ELSE IF (enterprise constraint) THEN match their requirement

ELSE IF (building layout) THEN
    IF (simple stacking) THEN use LinearLayout
    IF (complex positioning) THEN use ConstraintLayout
    IF (reusable component) THEN create custom view

ELSE IF (adding text) THEN
    - Create string resource
    - Reference in XML via @string/name
    - Reference in code via R.string.name
```

### Top 10 Things to Remember

1. **MainActivity** extends `AppCompatActivity`
2. **onCreate()** calls `super.onCreate()`, then `setContentView()`
3. **AndroidManifest.xml** is mandatory for every component
4. **View Binding** eliminates null pointer errors
5. **String resources** = localization-ready
6. **ConstraintLayout** = best performance for complex UI
7. **API 21+** = modern Android development baseline
8. **Gradle sync** after any build.gradle change
9. **Build > Clean Project** before rebuilding if weird errors
10. **Run on device/emulator** with API ≥ minSdkVersion

### Final Checklist Before Running App
- [ ] Gradle sync completed successfully?
- [ ] Activity declared in AndroidManifest.xml?
- [ ] setContentView() called with correct layout?
- [ ] Views accessed via binding (not findViewById)?
- [ ] No hardcoded strings in XML or code?
- [ ] minSdkVersion set in build.gradle?
- [ ] Build → Clean Project → Rebuild?

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Lesson 4 - Build Your First Android App

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------
**Core Definitions:**

*   **View (Giao diện người dùng)**: Một khối xây dựng giao diện người dùng, chiếm một hình chữ nhật trên màn hình. Chịu trách nhiệm vẽ (drawing) và xử lý sự kiện (event handling). Ví dụ: `TextView`, `Button`.
*   **Layout (Bố cục)**: Các file XML định nghĩa cấu trúc phân cấp của các `View`. Đây là nơi bạn sắp xếp giao diện thay vì code logic.
*   **Activity (Hoạt động)**: Một thành phần đơn lẻ trong app, thường đại diện cho một màn hình. Nó tải giao diện từ file XML Layout.

**Mental Model Reality Check:**
Bộ não của app là Kotlin, nhưng cơ thể (giao diện) là XML. Khi app chạy, `Activity` sẽ "inflate" (nạp) file XML thành các đối tượng `View` thực tế để hiển thị.

**Why this approach is better:**
Tách biệt Logic (Kotlin) và Giao diện (XML) giúp code sạch hơn, dễ bảo trì, và cho phép dùng Layout Editor kéo-thả mà không sợ làm vỡ logic.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Nên dùng Layout Editor hay XML Code?

| Tiêu chí | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Tình huống**: Thiết kế giao diện cơ bản, xem trước (Preview). | **Layout Editor (Design View)** | **Visual Feedback (Phản hồi trực quan)**: Xem ngay kết quả mà không cần chạy app. | Dùng Editor cho layout quá phức tạp, gây ra code thừa (bloat) và khó kiểm soát thuộc tính. |
| **Tình huống**: Hiệu chỉnh chính xác, sửa lỗi layout, tối ưu. | **XML Code (Split/Text View)** | **Control (Kiểm soát)**: Đọc và sửa chính xác từng thuộc tính, dễ dàng copy/paste. | Chỉ dùng Editor mà không kiểm tra XML, dẫn đến lầm tưởng layout đã đúng nhưng thực tế có lỗi ẩn. |

### Table 2: Chọn Component cho Layout

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Hiển thị một dòng text ngắn, nhãn. | **TextView** | **Semantics (Ngữ nghĩa)**: Đọc được, tối ưu cho text. | Dùng `Button` cho text chỉ để đọc (không click), gây hiểu nhầm UX. |
| Nhập liệu hoặc thực hiện hành động. | **Button** | **Interaction (Tương tác)**: Có trạng thái click, dễ nhìn là nút bấm. | Dùng `TextView` bắt sự kiện click, người dùng không biết chỗ nào bấm được. |
| Sắp xếp các View con theo chiều ngang/dọc. | **LinearLayout** | **Simplicity (Đơn giản)**: Dễ sắp xếp hàng/dọc cơ bản. | Lồng quá nhiều `LinearLayout` (nesting), gây performance thấp. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

**Hierarchy Flow:**
1.  **Android OS** gọi **Activity**.
2.  **Activity** tải file **XML Layout** (trong `res/layout`).
3.  XML được "inflate" thành **View Hierarchy** (Cây View: Layout cha -> View con).
4.  **User** tương tác với **View** (ví dụ: bấm Button).
5.  **View** gửi sự kiện lên **Activity** (hoặc Fragment) để xử lý logic.

```text
[Android Manifest] -> [Activity Class (.kt)] -> [R.layout.activity_main.xml]
                                                  |
                                                  v
                                          [View Root (ConstraintLayout)]
                                                  |
                       -----------------------------|
                       |                           |
                [TextView (ID: tv_hello)]    [Button (ID: btn_submit)]
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Inflate & Set Content
**Khi nào dùng:** Luôn dùng khi bắt đầu một `Activity` mới để load giao diện từ XML.

**Tại sao đúng:** `setContentView` liên kết Activity với layout, cho phép truy cập các View con qua ID.

**Code Demo:**
```kotlin
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 1. Nạp layout XML vào Activity
        setContentView(R.layout.activity_main)

        // 2. Tham chiếu View từ XML (ID: btn_hello, tv_status)
        val myButton: Button = findViewById(R.id.btn_hello)
        val myText: TextView = findViewById(R.id.tv_status)

        // 3. Logic sự kiện
        myButton.setOnClickListener {
            myText.text = "Đã bấm nút!"
        }
    }
}
```

### Pattern 2: XML Attribute Binding
**Khi nào dùng:** Khi cần hiển thị text cố định hoặc đặt thuộc tính cơ bản (màu, kích thước) cho View.

**Tại sao đúng:** Tránh hardcode string trong Kotlin code, hỗ trợ đa ngôn ngữ và quản lý tài nguyên tập trung.

**Code Demo (File `res/layout/activity_main.xml`):**
```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- TextView với thuộc tính XML -->
    <TextView
        android:id="@+id/tv_hello"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Xin chào Android" 
        android:textSize="24sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1.  **Xử lý Logic phức tạp trong XML:**
    *   **Tại sao nguy hiểm:** XML chỉ để định nghĩa giao diện. Logic phức tạp (tính toán, gọi API) trong XML không được hỗ trợ và làm code khó đọc.
2.  **Lồng quá nhiều Layout (Nested Layouts):**
    *   **Tại sao nguy hiểm:** `LinearLayout` lồng trong `LinearLayout` lặp lại nhiều tầng sẽ làm việc vẽ giao diện (render) chậm, gây giật lag app.
3.  **Bỏ qua ID của View:**
    *   **Tại sao nguy hiểm:** Nếu không đặt `android:id="@+id/..."`, bạn không thể truy cập View đó trong Kotlin code để sửa đổi hoặc bắt sự kiện.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Quick Reference Rules:**
*   **Code Logic:** Dùng Kotlin (`.kt`).
*   **Giao diện:** Dùng XML (`res/layout`).
*   **ID:** Luôn đặt `@+id/tên_gọi` để kết nối XML ↔ Kotlin.

**Decision Logic:**
*   **IF** app chạy yếu/nhớn: **KIỂM TRA** việc lồng quá nhiều Layout (Nested Views).
*   **IF** text không hiển thị: **KIỂM TRA** `android:text` trong XML hoặc `setText()` trong Kotlin.
*   **IF** app crash khi bấm nút: **KIỂM TRA** `findViewById` có khớp ID trong XML không.

**Top 3 Things to Remember:**
1.  `setContentView(R.layout.ten_file)` là dòng đầu tiên trong `onCreate`.
2.  `findViewById(R.id.ten_id)` là cách lấy control từ XML sang Kotlin.
3.  Layout Editor là công cụ Preview, XML là source of truth.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Android UI & Resources

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **View (Khung nhìn)**: The basic building block for UI components. Anything drawn on the screen.
- **ViewGroup (Nhóm khung nhìn)**: A special View that can contain other Views (children). It defines the layout structure.
- **Resource (Tài nguyên)**: External files (layouts, strings, images) stored in `res/` folder, separate from code.
- **Resource ID (Mã định danh tài nguyên)**: Unique integer reference generated by `R` class to access resources programmatically.
- **DP (Điểm t tỷ lệ độc lập - Density-independent Pixel)**: Unit of measurement that scales based on screen density, ensuring consistent UI sizes across devices.

### Key Mental Model
The Android UI is a **Tree Hierarchy (Cây phân cấp)**. The `ViewGroup` is the parent; it orchestrates the position and size of its child `Views`. XML defines this static tree structure. At runtime, you inflate XML into View objects and use `R.id` to modify them.

### Why This Approach is Better
- **Separation of Concerns (Tách biệt mối quan tâm)**: UI design (XML) is separated from logic (Kotlin), allowing designers to work independently of developers.
- **Performance**: XML layouts are compiled efficiently into binary format, reducing parsing overhead.
- **Adaptability**: Using `ViewGroup` logic (like `ConstraintLayout`) handles various screen sizes automatically, unlike hardcoded pixel positions.

---

## SECTION 2: DECISION TABLES

### Layout Managers (ViewGroup Selection)
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Simple, single layer or stacking** | `FrameLayout` | **Layering (Chồng lớp)**: Renders children on top of each other. Minimal overhead. | Using it for complex lists; nesting causes "UI Trashing" (giao diện bị đơ). |
| **Linear list (row or column)** | `LinearLayout` | **Alignment (Căn chỉnh)**: Distributes space sequentially. Easy for simple forms. | Using `weight` attributes excessively; it triggers expensive measurement passes. |
| **Complex, responsive layouts** | `ConstraintLayout` | **Flat Hierarchy (Phẳng)**: Most performant. Solves positioning constraints relative to siblings/parents. | Creating deep nested hierarchies; flattens the view tree for better performance. |

### Size Attributes (Layout Params)
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Content dictates size** | `wrap_content` | **Dynamic Fit (Phù hợp nội dung)**: The View shrinks or grows exactly to fit its content. | Forgetting to set on `TextView` inside `ScrollView`, causing layout collapse. |
| **Fill available space** | `match_parent` | **Expansion (Mở rộng)**: The View expands to fill the remaining space of its parent. | Setting on root View inside a list item, causing overlapping items. |
| **Fixed size** | `48dp` (or specific) | **Precision (Chính xác)** | Using `px` (pixels) instead of `dp`, causing UI to look huge/small on different phones. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Resource Hierarchy
Resources are not code; they are assets compiled into the app.

```text
Project Root
└── app/
    └── src/
        └── main/
            └── res/                <-- The Resource Container
                ├── drawable/       <-- Images & XML Drawables
                ├── layout/         <-- View Hierarchies (XML)
                ├── mipmap/         <-- App Icons
                └── values/         <-- Strings, Colors, Styles
```

### The View Hierarchy (Runtime)
When XML is inflated, it becomes this object tree.

```text
ViewGroup (Root)
├── View (Child 1)
├── ViewGroup (Child 2 - Container)
│   ├── View (Grandchild)
│   └── View (Grandchild)
└── View (Child 3)
```

### Access Flow
1. **Define**: `res/layout/activity_main.xml`
2. **Reference**: `@id/my_view` (XML) or `R.layout.activity_main` (Code)
3. **Inflate**: `setContentView(R.layout.activity_main)` creates View objects.
4. **Manipulate**: `findViewById(R.id.my_view)` to update properties.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic View Definition & ID
**When to use (Khi nào dùng):** Creating any interactive or textual UI element that needs to be accessed programmatically.
**Why this pattern is correct:** Defines the visual property (`text`) and the programmatic hook (`id`) simultaneously in XML.

```xml
<!-- res/layout/activity_main.xml -->
<TextView
    android:id="@+id/helloTextView"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Hello World!" />
```

### Pattern 2: Accessing Views in Kotlin
**When to use (Khi nào dùng):** When you need to change text, listen for clicks, or manipulate the View after the layout loads.
**Why this pattern is correct:** `findViewById` retrieves the actual View object associated with the ID generated by the `R` class.

```kotlin
// MainActivity.kt
import android.os.Bundle
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 1. Find the view using the ID generated in XML
        val helloTextView: TextView = findViewById(R.id.helloTextView)

        // 2. Modify it programmatically
        helloTextView.text = "Chao the gioi!"
    }
}
```

### Pattern 3: Nested Layouts for Structure
**When to use (Khi nào dùng):** Arranging multiple elements in a specific order (vertical or horizontal) inside the screen.
**Why this pattern is correct:** `LinearLayout` handles alignment logic automatically without complex coordinate math.

```xml
<!-- Vertical Stack -->
<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Title" />

    <Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Submit" />
</LinearLayout>
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Hardcoding Dimensions (Lỗi cố định kích thước):**
    *   **Dangers:** Avoid using raw pixels (`px`). On high-density screens, 100px is tiny. On low-density, it's huge. This destroys layout consistency.
    *   **Fix:** Always use `dp` (density-independent pixels) for width/height and `sp` (scale-independent pixels) for font sizes.

2.  **Deep Nesting (Chồng lớp quá sâu):**
    *   **Dangers:** Nesting `LinearLayout` inside `LinearLayout` inside `FrameLayout` causes the "Measure & Layout" phase to run recursively, leading to slow rendering and "jank" (giật lag).
    *   **Fix:** Use `ConstraintLayout` to keep the hierarchy flat (usually only 1 level deep).

3.  **Ignoring Resource IDs:**
    *   **Dangers:** Trying to find a View without an `android:id` attribute in XML. You cannot modify a specific View in Kotlin without an ID.
    *   **Fix:** Always add `android:id="@+id/viewName"` to Views you intend to interact with.

4.  **Missing Orientation (LinearLayout):**
    *   **Dangers:** `LinearLayout` defaults to horizontal if `orientation` is not set. This often breaks layouts unexpectedly.
    *   **Fix:** Explicitly set `android:orientation="vertical"` or `"horizontal"`.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
*   **DP vs SP:** Use `dp` for boxes/buttons, `sp` for text.
*   **ID Syntax:** `@+id/name` (in XML), `R.id.name` (in Kotlin).
*   **Parent Size:** Use `match_parent`. Use `wrap_content` only if the view needs to shrink.

### Decision Logic (If-Else)
*   **IF** you have a list of items vertically -> **Use** `LinearLayout` (vertical) or `RecyclerView`.
*   **IF** you have a complex landing page -> **Use** `ConstraintLayout`.
*   **IF** you have a single background image with text on top -> **Use** `FrameLayout`.
*   **IF** you need to access the view in code -> **Add** `android:id="@+id/viewName"`.

### Top 3 Things to Remember
1.  **Res Folder:** All static UI files go here (`res/layout/`).
2.  **R Class:** Do not edit `R.java`. It is auto-generated.
3.  **Hierarchy:** Flatter is faster. Avoid nesting.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Lesson 4 - Activities & UI Interaction

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Activity (Hoạt động)**: A single screen in an Android app representing one user task. It acts as the entry point for user interaction and manages the UI lifecycle.
- **Layout Inflation (Nạp bố cục)**: The process of converting an XML layout file into a hierarchy of View objects (ViewGroup và View) that can be rendered on screen.
- **View (Khung nhìn)**: The basic building block for UI components (e.g., `TextView`, `Button`) that user sees and interacts with.
- **Callback (Hồi gọi)**: A method provided by the system (like `onCreate()`) that executes at specific lifecycle events, allowing you to insert custom logic.
- **View Hierarchy (Phân cấp View)**: A tree structure representing the relationships between UI elements (parent containers and child views).

### Key Mental Model: The Lifecycle-UI Relationship
An Activity is a controller. It doesn't hold data permanently; its job is to:
1. **Bootstrap**: Inflate XML into Views (`onCreate`).
2. **Bridge**: Connect logic to UI (finding Views, setting listeners).
3. **Manage**: Handle state changes (rotate, background, destroy).

### Why this approach is better
- **Separation of Concerns**: XML defines *what* it looks like, Kotlin defines *how* it behaves.
- **Automatic Memory Management**: The system manages the lifecycle, preventing memory leaks if you follow the rules (cleanup in `onDestroy`).
- **Reusability**: Components (Activities, Views) are modular and can be reused across the app.

---

## SECTION 2: DECISION TABLES

### Table: View Access Patterns
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
|---|---|---|---|
| Accessing a View inside a Fragment/Activity (Lifecycle-aware) | `view.findViewById()` or Jetpack View Binding (Pref) | **Null Safety & Lifecycle**: Views are only valid when the Fragment/Activity view hierarchy exists. Accessing too early causes crashes. | Calling `findViewById()` in `onCreate()` (before `setContentView`) or holding View references in a static variable causing leaks. |
| Accessing a View in a generic `View` class or Custom View | Kotlin Synthetic (Kotlin Android Extensions) or View Binding | **Conciseness**: Avoids boilerplate code. (Note: Kotlin Synthetic is deprecated, prefer View Binding). | Using `findViewById()` everywhere, making code verbose and harder to read. |
| Updating a View | Direct property access (e.g., `textView.text = "New"`) | **Performance & Directness**: The View object is already in memory. Direct mutation is faster than re-rendering the layout. | Triggering a full layout refresh (`setContentView` again) just to update text. |

### Table: Listener Registration vs. XML Attributes
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
|---|---|---|---|
| Simple navigation or boolean logic (e.g., Checkboxes, Toggles) | XML `android:onClick` attribute | **Simplicity**: Less code, couples the method to the view ID directly in layout. | Using this for complex logic; it couples UI structure to business logic. |
| Complex logic, multiple views, or requiring context/data | Kotlin Lambda Listener (e.g., `setOnClickListener { ... }`) | **Flexibility**: Allows complex logic, access to Activity state, and easy toggling of listeners. | Not cleaning up listeners in `onDestroy` if they hold heavy references (rarely an issue with anonymous listeners, but critical for custom callbacks). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Flow: User Interaction to UI Update

```text
[User Taps Button]
      |
      v
[System Detects Event]
      |
      v
[Event Dispatched to View]
      |
      v
[Listener Callback Executed] (set in Activity)
      |
      v
[Activity Logic Runs] (finds other Views, updates data)
      |
      v
[View Property Mutation] (e.g., TextView.text = ...)
      |
      v
[System Re-renders Layout] (Only the changed portion)
```

### Activity Lifecycle Flow (Simplified)
```text
Launch App
  |
  +--> onCreate()  [Initialize UI, Inflate Layout]
  |
  +--> onStart()   [Visible to user]
  |
  +--> onResume()  [User can interact]
  |
  |     (User leaves app / Screen rotates)
  |
  +--> onPause()   [App partially obscured or going to background]
  |
  +--> onStop()    [No longer visible]
  |
  +--> onDestroy() [Cleanup resources, Listeners, Threads]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Basic Setup & View Binding
**Khi nào dùng**: Khi bạn cần truy cập View một cách an toàn và hiệu quả trong Activity.
**Tại sao đúng**: Tránh lỗi `NullPointerException` và lỗi truy cập View đã bị huỷ (Recycled).

```kotlin
// build.gradle (Module level)
// android { ... buildFeatures { viewBinding true } ... }

class MainActivity : AppCompatActivity() {
    
    // Declare binding variable
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 1. Inflate layout
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // 2. Setup interaction logic
        setupButtonListener()
    }

    private fun setupButtonListener() {
        // 3. Access views via binding object (Type-safe)
        binding.myButton.setOnClickListener {
            updateResultText("Button Clicked!")
        }
    }

    private fun updateResultText(newText: String) {
        binding.resultTextView.text = newText
    }
}
```

### Pattern 2: Manual findViewById (Legacy/Exam)
**Khi nào dùng**: When View Binding is unavailable or strictly forbidden (legacy code, specific exam constraints).
**Tại sao đúng**: Understanding the underlying mechanism of how Android maps IDs to Views.

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 1. Find the View (Cast is required)
        val button: Button = findViewById(R.id.myButton)
        val textView: TextView = findViewById(R.id.resultTextView)

        // 2. Set Listener
        button.setOnClickListener {
            textView.text = "Updated via findViewById"
        }
    }
}
```

### Pattern 3: XML onClick Attribute
**Khi nào dùng**: Rapid prototyping or extremely simple View logic that doesn't require external data.
**Tại sao đúng**: Keeps the logic close to the UI definition in XML.

```kotlin
// 1. In MainActivity.kt: Method MUST be public and accept a View parameter
fun showMessage(view: View) {
    // Logic here
    if (view is Button) {
        view.text = "Clicked"
    }
}

// 2. In XML layout file
<!--
<Button
    android:id="@+id/myButton"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Click Me"
    android:onClick="showMessage" />
-->
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Zombie View" Reference
**Practice**: Storing a View in a global variable or static field and using it later.
**Why dangerous**: When the Activity is destroyed (e.g., rotation), the View is destroyed. Your variable still points to the old object, causing a memory leak or crash when touched.
**Fix**: Always access Views via `findViewById` or `binding` inside the current lifecycle state (e.g., `onCreate`, `onClickListener`). Do not store them in `companion object`.

### 2. Logic in `onCreate` that blocks the UI thread
**Practice**: Doing heavy computation (e.g., long loops, reading large files) directly inside `onCreate`.
**Why dangerous**: `onCreate` runs on the Main Thread (UI Thread). Blocking it freezes the app and triggers "Application Not Responding" (ANR) errors.
**Fix**: Only initialize UI and set listeners in `onCreate`. Move heavy work to background threads (Coroutines/WorkManager).

### 3. Ignoring `savedInstanceState`
**Practice**: Relying only on member variables to store UI state (like text input).
**Why dangerous**: When the system kills the app (low memory) and restores it, `onCreate` is called again, member variables are reset to null/initial, and the user loses their data.
**Fix**: Save critical data in `onSaveInstanceState` and restore it in `onCreate` if `savedInstanceState` is not null.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  **Activity = One Screen**. Use multiple activities for distinct tasks (Login -> Home).
2.  **Lifecycle is King**: `onCreate` is for init, `onDestroy` is for cleanup.
3.  **Always inflate**: `setContentView(R.layout.x)` is mandatory to see UI.
4.  **Null Safety**: Use View Binding or safe casts (`as?`) when finding views.
5.  **Don't store Views**: Access them when needed, don't keep them in variables forever.
6.  **Listeners**: Use lambdas for flexibility, XML attributes for simplicity.
7.  **XML is static**: To change UI at runtime, you *must* use Kotlin code to touch the View objects.
8.  **Main Thread**: Never block `onCreate` or listeners.
9.  **The View Tree**: Parent containers (ConstraintLayout) hold Children (TextView). If you delete the parent, children vanish.
10. **Binding is Better**: `binding.viewId` is faster and safer than `findViewById<View>(R.id.viewId)`.

### Quick Decision Logic (If-Else)
- **If** you need to update a View based on user action:
  - **Then**: Get a reference (Binding), find the View, set a `listener`.
- **If** the system kills the app and brings it back:
  - **Then**: Check `savedInstanceState` in `onCreate` to restore data.
- **If** you want to run code when the Activity starts:
  - **Then**: Put it in `onCreate` (for setup) or `onResume` (for active logic).
- **If** you are accessing a View in XML:
  - **Then**: Use `android:id="@+id/viewName"` and reference it in Kotlin.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Lesson 4

## SECTION 1: CORE MENTAL MODEL

### Event Handling (Xử lý sự kiện)
**Mental Model:** Think of `View` (Button, Text) as a child shouting "I was clicked!" Your `Activity` is the parent listening. You don't poll the child; you register a **Callback (Hàm gọi lại)** that executes only when the event happens.

**Why better than others:** Separates UI logic from flow control. It keeps the UI thread responsive without `while(true)` loops checking for clicks.

### SAM (Single Abstract Method) (Giao thức trừu tượng đơn)
**Definition:** An interface with exactly one abstract method.
**Mental Model:** Kotlin treats `Interface { lambda }` as just the `lambda`. The compiler creates the object wrapper automatically.

**Why better:** Removes boilerplate `object : Interface { override fun... }`.

### lateinit (Khởi tạo muộn)
**Definition:** Tells the compiler: "I promise I will assign this variable before I use it, but I can't do it right now (e.g., inside `onCreate`)."
**Mental Model:** It's a contract. Break the contract = Crash.

### Gradle (Hệ thống tự động hóa build)
**Definition:** The factory assembly line for your app.
**Mental Model:** You write a recipe (build.gradle), Gradle executes tasks in order: Download libraries -> Compile code -> Package APK -> Install.

---

## SECTION 2: DECISION TABLES

### Event Handling Strategy

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Activity implement logic** | `Activity()`, `View.OnClickListener` | Khi logic xử lý nằm trong class chính, cần truy cập biến instance (tình huống：Activity implements OnClickListener). | Trả về `this` trong `onCreate` quá sớm trước khi View được khởi tạo. |
| **Logic ngắn, 1 dòng** | SAM (Lambda) `setOnClickListener({ ... })` | Code gọn, đọc liền mạch, không cần khai báo hàm riêng (Code简洁, không rườm rà). | Quên dấu `{}` hoặc nhầm lẫn thứ tự tham số (view là nullable). |
| **Logic xử lý phức tạp** | Lambda có tên hoặc hàm riêng | Dễ debug và tái sử dụng code (Dễ maintain). | Đặt quá nhiều logic vào hàm lambda làm code "rối". |

### Lateinit vs Lazy

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Biến có thể null hoặc chưa có giá trị** | `lateinit var` | Dành cho variable không thể khởi tạo ngay tại declaration (vd: `findViewById` trong `onCreate`). | Gọi variable trước khi gán giá trị (Crash: `UninitializedPropertyAccessException`). |
| **Giá trị tính toán 1 lần** | `lazy { ... }` | Tối ưu hiệu năng: tính toán chỉ khi cần và cache kết quả. | Dùng `lateinit` cho các kiểu dữ liệu cơ bản (Int, Boolean) - `lateinit` không hỗ trợ primitive. |

### Gradle Configuration

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **App cần Kotlin & Android features** | `plugins { id 'com.android.application' id 'kotlin-android' }` | Bật chức năng biên dịch và mở rộng Kotlin cho Android SDK. | Quên plugin `kotlin-android`, dẫn đến file Kotlin không biên dịch được. |
| **Kiểm soát phiên bản SDK** | `compileSdkVersion`, `minSdkVersion`, `targetSdkVersion` | Đảm bảo app chạy được trên thiết bị cũ nhất và tận dụng tính năng mới nhất. | `minSdkVersion` quá cao (mất người dùng) hoặc `targetSdkVersion` không update (app lỗi trên Android mới). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Event Handling Hierarchy
```text
[ View (Button) ] ---- setOnClickListener() ----> [ Listener Interface ]
                                                        |
                                          (Lambda or Activity)
                                                        |
                                                        v
                                              [ Callback Logic ]
                                                        |
                                              (Update UI / Data)
```

### Gradle Build Flow
```text
[ build.gradle ] (Configuration)
       |
       v
[ Gradle Wrapper ] (Execution Engine)
       |
       +---> [ Dependencies ] (Download Libraries)
       |
       +---> [ Compilation ] (Kotlin -> Java Bytecode)
       |
       +---> [ Packaging ] (Generate APK/AAB)
       |
       v
[ Device / Emulator ]
```

### Lateinit Lifecycle
```text
Declaration: lateinit var result: TextView
            |
            (Variable exists but is undefined)
            |
            v
Assignment:  result = findViewById(...) inside onCreate()
            |
            (Promise kept: Ready to use)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Activity as Listener
**Khi nào dùng:** Khi bạn cần xử lý nhiều View hoặc truy cập biến Activity từ Event.

```kotlin
class MainActivity : AppCompatActivity(), View.OnClickListener {

    private lateinit var message: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        message = findViewById(R.id.message_text)
        val btn: Button = findViewById(R.id.btn_submit)
        btn.setOnClickListener(this) // Gọi onClick khi bấm
    }

    override fun onClick(v: View?) {
        when (v?.id) {
            R.id.btn_submit -> {
                message.text = "Submitted!"
            }
        }
    }
}
```

### Pattern 2: SAM (Lambda) Listener
**Khi nào dùng:** Khi logic xử lý ngắn, chỉ quan tâm đến 1 View, muốn code gọn.

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val btn: Button = findViewById(R.id.btn_action)
        
        // SAM Conversion: Compiler tự tạo object Runnable/OnClickListener
        btn.setOnClickListener { 
            view -> 
            // view là biến đại diện cho nút được bấm
            Toast.makeText(this, "Clicked!", Toast.LENGTH_SHORT).show()
        }
    }
}
```

### Pattern 3: Lateinit Property
**Khi nào dùng:** Khởi tạo View hoặc Data sau `onCreate` nhưng trước khi dùng.

```kotlin
class MainActivity : AppCompatActivity() {
    // 1. Khai báo (chưa gán giá)
    private lateinit var adapter: CustomAdapter

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 2. Gán giá (bắt buộc phải có logic này)
        adapter = CustomAdapter(listOf("Item 1", "Item 2"))
        
        // 3. Sử dụng như bình thường
        recyclerView.adapter = adapter
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Truy cập lateinit trước khi gán (Accessing lateinit too early)
```kotlin
// SAI
lateinit var txt: TextView
override fun onCreate(savedInstanceState: Bundle?) {
    // Chưa gán giá đã dùng
    txt.text = "Hello" // CRASH!
}
```
**Tại sao nguy hiểm:** `lateinit` chỉ trì hoãn việc cấp phát bộ nhớ, không phải `null`. Gọi trước khi gán sẽ ném ra `UninitializedPropertyAccessException`.

### 2. Lồng Activity vào Listener (Complexity in Activity implements)
```kotlin
// KHÔNG NÊN
class MainActivity : AppCompatActivity(), View.OnClickListener, 
                      AdapterView.OnItemClickListener, ... {
    // Khi interface quá nhiều, class trở nên cồng kềnh và khó đọc
}
```
**Tại sao nguy hiểm:** Vi phạm **Single Responsibility Principle**. `MainActivity` sẽ trở thành "God Class" (thao túng mọi thứ), khó bảo trì. Nên dùng Lambda hoặc Presenter.

### 3. Viền code xử lý quá dài trong Lambda (Long Lambda)
```kotlin
btn.setOnClickListener {
    // 50 dòng code ở đây...
}
```
**Tại sao nguy hiểm:** Khó debug (Stacktrace không rõ ràng), khó tái sử dụng. Nên extract thành hàm riêng nếu logic > 3 dòng.

### 4. Cấu hình Gradle sai thứ tự (Gradle Order)
```groovy
android {
    // ...
}
dependencies {
    implementation "..."
}
// Sai nếu depends trên plugin chưa apply
```
**Tại sao nguy hiểm:** Biên dịch lỗi. `dependencies` block phải nằm cuối file hoặc sau khi các plugin và cấu hình Android đã được định nghĩa đầy đủ.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Decision Logic

**Event Handling:**
*   IF `Activity` cần giữ state của nhiều View -> **Implement Interface**
*   IF Logic là 1-2 dòng -> **Lambda**
*   IF cần bind với XML (Data Binding) -> **View Binding**

**Initialization:**
*   IF Variable có thể null -> **`var x: Type? = null`**
*   IF Variable KHÔNG null nhưng chưa thể gán ngay (trong `onCreate`) -> **`lateinit var`**
*   IF Variable tính toán nặng, dùng 1 lần -> **`by lazy`**

**Gradle:**
*   IF Add library -> **`dependencies { implementation ... }`**
*   IF Change API level -> **`android { compileSdkVersion ... }`**
*   IF Add Kotlin features -> **`plugins { kotlin-android }`**

### Top 4 Things to Remember

1.  **`lateinit` is a Promise:** Biến này không bao giờ null, hãy đảm bảo bạn gán nó.
2.  **SAM is Smart:** `View.OnClickListener { ... }` là Kotlin sugar code.
3.  **Gradle is the Builder:** Đừng build manual, hãy để Gradle quản lý Task và Dependencies.
4.  **Avoid `this` in Listener:** Trừ khi bạn implement Interface, nếu không hãy dùng Lambda để code rõ ràng hơn.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: Lesson 4

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Dependency Management (Quản lý phụ thuộc):** Hệ thống khai báo các thư viện bên ngoài mà ứng dụng cần để tự động tải và kết nối chúng.
Mental Model: Think of `build.gradle` as a shopping list. You write down what you need (libs), where to buy it (repositories), and Gradle handles the procurement and integration.

**Accessibility (Khả năng truy cập):** Quá trình thiết kế app để người khuyết tật (khiếm thị, motor skills) có thể sử dụng được.
Mental Model: Accessibility isn't a feature; it's a baseline requirement. If a screen reader can't read it, it doesn't exist for a segment of your users. High contrast and large touch targets benefit everyone, not just disabled users.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Repository Source Selection

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| App cần thư viện chuẩn của Kotlin hoặc Android | `mavenCentral()` hoặc `google()` | **Maven Central (Kho lưu trữ trung tâm):** Kho lớn nhất, an toàn. **Google():** Thư viện chính thức của Google. | Dùng `jcenter()` vì nó đã bị deprecated (vô hiệu hóa) và có thể lỗi bảo mật. |
| App cần thư viện mới nhất từ GitHub | `jitpack.io` | **JitPack (Dịch vụ tích hợp):** Biến repo GitHub thành thư viện mà không cần publish lên kho chính thức. | Dùng các kho không rõ nguồn gốc (random GitHub Gists) gây rủi ro virus/backdoor. |

### Table 2: Accessibility Handling

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Hiển thị hình ảnh có ý nghĩa (icon, avatar) | `android:contentDescription="Mô tả ngắn"` | **Content Description:** Giúp Screen Reader (Trình đọc màn hình) thông báo nội dung cho người dùng. | Để trống `contentDescription`. Người dùng khiếm thị sẽ nghe "Unlabeled image" (Hình không có nhãn). |
| Hình ảnh trang trí (decorative) | `android:importantForAccessibility="no"` | **Important for Accessibility:** Tắt quyền truy cập để Screen Reader bỏ qua, không gây nhiễu thông tin. | Dùng `contentDescription` cho hình trang trí. Người dùng phải nghe mô tả rác không cần thiết. |
| Chữ nhỏ vs Chữ lớn | Tỷ lệ tương phản 4.5:1 (nhỏ) / 3.0:1 (lớn) | **Contrast Ratio:** Đảm bảo người khiếm thị hoặc dùng ngoài trời nắng vẫn đọc được. | Dùng màu quá sáng trên nền sáng (Vàng/trắng). |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

**Build System Hierarchy (Mối quan hệ hệ thống build):**

```text
[Developer Actions]
      |
      v
[Gradle (Công cụ build)] ----> [build.gradle (Cấu hình)]
      |
      +---> [repositories] --(Tìm kiếm)--> Google(), MavenCentral
      |
      +---> [dependencies] --(Tải về)--> androidx, kotlin-stdlib
      |
      v
[Android OS] --(Chạy)--> [Ứng dụng]
```

**Accessibility Relationship (Mối quan hệ truy cập):**

```text
[UI Element (ImageView/TextView)]
      |
      +---> [contentDescription] -----> [Screen Reader (Voice Access)]
      |
      +---> [Touch Target Size] -----> [Motor Impairment (Người run tay)]
      |
      +---> [Contrast Ratio] ---------> [Vision (Mắt người)]
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Basic Dependency Declaration
**Khi nào dùng:** Khi thêm thư viện mới (ví dụ: xử lý ảnh, network).
**Tại sao đúng:** Khai báo rõ ràng version giúp tránh lỗi xung đột phiên bản (version conflict).
**Code Demo:**
```groovy
// File: build.gradle (Module: app)
dependencies {
    // Chuẩn Kotlin
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
    
    // UI Component
    implementation 'androidx.appcompat:appcompat:1.2.0'
    implementation 'com.google.android.material:material:1.2.1'
    
    // Custom Lib (Nếu có)
    // implementation 'com.squareup.retrofit2:retrofit:2.9.0'
}
```

### Pattern 2: Accessible Image View
**Khi nào dùng:** Khi sử dụng `ImageView` để hiển thị icon hoặc ảnh thông tin.
**Tại sao đúng:** Đảm bảo người dùng khiếm thị không bị "mù" thông tin khi dùng Screen Reader.
**Code Demo:**
```xml
<!-- file: res/layout/activity_main.xml -->

<!-- TỐT: Có contentDescription -->
<ImageView
    android:id="@+id/iv_warning"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@drawable/ic_warning"
    android:contentDescription="Cảnh báo nguy hiểm" />

<!-- TỐT: Loại bỏ nhiễu âm thanh cho ảnh trang trí -->
<ImageView
    android:id="@+id/iv_background_pattern"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:src="@drawable/bg_texture"
    android:importantForAccessibility="no" />

<!-- KÉM: Không có nhãn -->
<ImageView
    android:id="@+id/iv_bad"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:src="@drawable/ic_icon" />
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1.  **Ignoring Accessibility (Bỏ qua khả năng truy cập):**
    *   **Lỗi:** Để `contentDescription` trống hoặc không kiểm tra contrast.
    *   **Nguy hiểm:** App bị loại khỏi các cửa hàng doanh nghiệp hoặc kiện tụng (đặc biệt ở Mỹ/EU). Làm mất đi 15% lượng người dùng tiềm năng (người khuyết tật/người già).

2.  **Wrong Repositories (Dùng kho thư viện sai):**
    *   **Lỗi:** Chỉ dùng `jcenter()` hoặc xóa hết repositories.
    *   **Nguy hiểm:** Không tải được thư viện, build fail, hoặc tải phải mã độc từ kho đã bị bỏ hoang.

3.  **Small Touch Targets (Kích thước nút quá nhỏ):**
    *   **Lỗi:** Đặt nút click kích thước 20dp x 20dp.
    *   **Nguy hiểm:** Người dùng (đặc biệt trên điện thoại lớn) sẽ bấm sai, gây khó chịu. Tiêu chuẩn tối thiểu là **48dp x 48dp**.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Quick Reference Rules
1.  **Repo:** Luôn có `google()` và `mavenCentral()` ở đầu file.
2.  **Dep:** Dùng `implementation` cho app, `api` cho library module.
3.  **A11y (Accessibility):**
    *   Ảnh ý nghĩa -> `contentDescription`.
    *   Ảnh décor -> `importantForAccessibility="no"`.
    *   Nút/Text -> Tối thiểu 48dp hoặc tỷ lệ tương phản 4.5:1.

### Decision Logic (If-Else)
*   **If:** `ImageView` có nội dung cần nghe -> **THEN:** `contentDescription`.
*   **If:** `View` chỉ để làm đẹp nền -> **THEN:** `importantForAccessibility="no"`.
*   **If:** Build báo lỗi "Could not find..." -> **THEN:** Kiểm tra lại `repositories`.

### Top 3 Things to Remember (Lesson 4)
1.  **4.5:1** là tỷ lệ tương phản bắt buộc cho text nhỏ.
2.  **48dp** là kích thước touch target tối thiểu.
3.  **mavenCentral()** là nơi lấy thư viện an toàn nhất hiện tại.

<!-- CHUNK 61-68 -->

# DEVELOPER DECISION GUIDE - Lesson 4: Build Your First Android App

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**TalkBack (Trình đọc màn hình)**
- Google screen reader built into Android. Provides audio feedback for UI elements.
- **Usage:** Navigate device via gestures without looking at screen.

**Switch Access (Truy cập bằng nút bấm)**
- Control device using physical switches or buttons (volume keys, external keyboard).
- **Usage:** Scans UI sequentially, highlights items for selection.

**Android Accessibility Suite (Bộ công cụ trợ năng)**
- Collection: TalkBack, Switch Access, Accessibility Menu, Select to Speak.
- **Usage:** Enable eyes-free or switch-based device control.

### Mental Model: Accessibility is Not Optional
Android users interact via screen readers and switches. Your UI structure **must** be semantic. Code written without accessibility consideration creates "invisible walls" for users.

---

## SECTION 2: DECISION TABLES

### Table 1: Accessibility Tool Selection

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| User blind / visually impaired | **TalkBack** | TalkBack (Trình đọc màn hình) reads UI text and descriptions aloud | Relying on color alone; not setting `contentDescription` |
| User cannot use touchscreen | **Switch Access** | Switch Access (Truy cập bằng nút bấm) lets users navigate via external switches or keys | Building UI that requires complex gestures (swipe, pinch) without alternatives |
| General UI testing | **Android Accessibility Suite** | Android Accessibility Suite (Bộ công cụ trợ năng) provides comprehensive testing tools | Testing only on emulator, not on real device with tools enabled |

### Table 2: Accessibility Implementation Priority

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Image-only button | **contentDescription** | contentDescription (Mô tả nội dung) provides text alternative for non-text elements | Leaving `contentDescription` empty or setting it to the image name |
| Complex data visualizations | **Semantic properties + Labels** | Semantic properties (Thuộc tính ngữ nghĩa) structure data for screen readers | Treating charts as static images (png) without describing data |
| Interactive elements | **Focusability + Click handlers** | Focusability (Khả năng tập trung) ensures Switch Access can highlight and select items | Missing `android:clickable` or `android:focusable` on custom views |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy: Accessibility Flow in Android

```
[User Interaction]
      |
      +-- [Input Method] --> TalkBack / Switch Access / Physical Switch
      |
      v
[Android OS Accessibility Framework]
      |
      +-- Scans View hierarchy
      |
      v
[Your App Views]
      |
      +-- contentDescription, isImportantForAccessibility, etc.
      |
      v
[User Perception] (Audio / Visual Highlight)
```

**Relationship Map:**
- `Activity` → Contains `ViewGroup` → Contains `View`
- `View` → Has `contentDescription` → Consumed by TalkBack
- `View` → Has `focusable` flag → Consumed by Switch Access
- **Critical:** If View is invisible to accessibility framework, it's invisible to users of these tools.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Descriptive Content Description

**When to use (Khi nào dùng):** Any `ImageView` or `Icon` that conveys meaning.
**Why this pattern is correct:** contentDescription (Mô tả nội dung) provides text alternative; without it, screen reader says "Unlabeled".

```kotlin
// BAD: Screen reader says "Button"
<ImageButton
    android:id="@+id/btnSend"
    android:src="@drawable/ic_send"
    android:contentDescription="@string/send_message" />

// GOOD: Screen reader says "Send message"
<ImageButton
    android:id="@+id/btnSend"
    android:src="@drawable/ic_send"
    android:contentDescription="Gửi tin nhắn" />
```

### Pattern 2: Decorative Images

**When to use (Khi nào dùng):** Image is purely visual, adds no information.
**Why this pattern is correct:** Setting `importantForAccessibility="no"` prevents screen reader from announcing irrelevant content.

```kotlin
// Decorative background image - should be ignored by TalkBack
<ImageView
    android:layout_width="match_parent"
    android:layout_height="200dp"
    android:src="@drawable/decorative_background"
    android:importantForAccessibility="no" />
```

### Pattern 3: Accessible Buttons

**When to use (Khi nào dùng):** Any interactive element (Button, Custom View).
**Why this pattern is correct:** Ensures focusability for Switch Access and proper announcement by TalkBack.

```kotlin
// Button with full accessibility attributes
<Button
    android:id="@+id/btnSubmit"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="Submit"
    android:contentDescription="Nút gửi biểu mẫu"
    android:focusable="true"
    android:clickable="true" />
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### ❌ Anti-Pattern: Silent Images
**Danger:** Using images as buttons without `contentDescription`.
**Why dangerous:** TalkBack reads "Button" or image file name. User has no idea what the button does.

### ❌ Anti-Pattern: Color-Only Indicators
**Danger:** Relying on red/green colors to show status (error/success).
**Why dangerous:** Colorblind users and TalkBack users cannot perceive color differences. Always use text or icons + description.

### ❌ Anti-Pattern: Non-Focusable Custom Views
**Danger:** Custom `View` without `android:focusable="true"`.
**Why dangerous:** Switch Access cannot highlight or select the view. It becomes invisible to switch users.

### ⚠️ Warning: Accessibility is Not Optional
**Context:** Lesson 4 summary explicitly includes "Follow best practices to make your apps more accessible."
**Action:** Test your app with TalkBack and Switch Access **before** release. It's part of the build process, not an afterthought.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Image Button?** → Must have `contentDescription`.
2. **Decorative Image?** → Set `importantForAccessibility="no"`.
3. **Interactive Element?** → Must be `focusable` and `clickable`.
4. **Complex Data?** → Provide semantic labels.

### Decision Logic (If-Else Style)

```
IF view is interactive THEN
   Set android:clickable="true"
   Set android:focusable="true"
   Set android:contentDescription="Descriptive text"

ELSE IF view is decorative THEN
   Set android:importantForAccessibility="no"

ELSE IF view contains text THEN
   Ensure text is readable (contrast, size)
```

### Top 5 Things to Remember
1. TalkBack reads `contentDescription`, not file names.
2. Switch Access scans focusable items sequentially.
3. Android Accessibility Suite includes testing tools.
4. Accessibility is required, not optional.
5. Test on real device with tools enabled.

### Build Checklist
- [ ] All images have `contentDescription` or are marked decorative
- [ ] All buttons are focusable and clickable
- [ ] Color is not the only indicator of state
- [ ] Tested with TalkBack (Settings > Accessibility > TalkBack)
- [ ] Tested with Switch Access (Settings > Accessibility > Switch Access)