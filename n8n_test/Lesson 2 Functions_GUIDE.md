# DEVELOPER DECISION GUIDE: Lesson 2 Functions.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:17:14



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Functions

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Function (Hàm)**: Một khối mã có tên, nhận đầu vào (nếu có), thực hiện tác vụ, và trả về kết quả (nếu có). Nó là đơn vị tái sử dụng mã.
- **Entry Point (Điểm bắt đầu)**: `main()` là hàm bắt buộc trong Kotlin, nơi JVM bắt đầu thực thi chương trình.
- **Parameter (Tham số)**: Biến được định nghĩa trong khai báo hàm (`args: Array<String>`).
- **Argument (Đối số)**: Giá trị thực tế được truyền vào hàm khi gọi ("Kotlin").
- **String Template (Mẫu chuỗi)**: Biểu thức `${variable}` để chèn giá trị trực tiếp vào chuỗi.
- **Unit (Đơn vị)**: Kiểu trả về mặc định của hàm Kotlin nếu không có giá trị trả về (tương đương `void` trong Java).

### Key Mental Models
Hàm là các khối Lego của code. `main()` là điểm tựa. Kotlin yêu cầu khai báo rõ ràng `fun` cho mọi hàm.
Mọi hàm đều có thể là выражение (expression) hoặc statement (lệnh).
Truyền arguments là cách để kết nối các phần của chương trình.

### Why Kotlin Approach?
Kotlin loại bỏ boilerplate của Java (không cần `public static void main(String[] args)` rườm rà).
`main()` function là **required**.
Hàm Kotlin support **default arguments** và **named arguments**, giảm lỗi khi truyền tham số.

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Run code once** | `main()` function | **Entry Point (Điểm bắt đầu)**: JVM cần `main()` để bắt đầu execution. | Quên khai báo `fun main()` hoặc viết sai cú pháp `main(String[] args)`. |
| **Reuse logic多次** | Custom Function (`fun name()`) | **DRY Principle (Nguyên tắc lặp lại)**: Tránh duplication, easier maintenance. | Viết code lặp lại (copy-paste) thay vì tạo hàm. |
| **Access runtime data** | Command Line Arguments | **Dynamic Input (Đầu vào động)**: Cho phép chương trình linh hoạt mà không sửa code. | Assuming args exist without handling index out of bounds (`args[0]`). |
| **Format string output** | String Template (`${}`) | **Readability (Tính dễ đọc)**: Dễ nhìn thấy cấu trúc chuỗi hơn concatenation (`+`). | Quên `$` hoặc dùng `"{args[0]}"` thay vì `"${args[0]}"`. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy of Execution
```text
[Program Process]
       |
       v
[main(args: Array<String>)] <--- Entry Point
       |
       +---> (Arguments Parser)
       |
       v
[Function Calls] <--- Custom Logic
       |
       v
[Output / Return Value]
```

### Data Flow
1. **Input**: JVM / User passes arguments.
2. **Storage**: `args` is an `Array<String>`.
3. **Processing**: `main` calls other functions.
4. **Output**: `println()` writes to console.

## SECTION 4: CODE PATTERNS

### Pattern 1: The Basic Entry Point
**When to use (Khi nào dùng)**: Luôn luôn cho mọi file Kotlin executable.
**Why this pattern is correct**: Cú pháp chuẩn, tối thiểu, chuẩn bị environment cho JVM.
```kotlin
// File: Main.kt
fun main() {
    println("Program started.")
}
```

### Pattern 2: Entry Point with Arguments
**When to use (Khi nào dùng)**: Khi cần thay đổi hành vi program mà không recompile code.
**Why this pattern is correct**: `Array<String>` lưu trữ biến runtime. `${}` giúp formatting an toàn.
```kotlin
fun main(args: Array<String>) {
    if (args.isNotEmpty()) {
        val name = args[0]
        println("Hello, $name")
    } else {
        println("Hello, stranger")
    }
}
```

### Pattern 3: Standard Function (Reusability)
**When to use (Khi nào dùng)**: Khi logic phức tạp hoặc cần dùng lại ở nhiều nơi.
**Why this pattern is correct**: Tách biệt logic, `Unit` return type mặc định, clean code.
```kotlin
fun printUserScore(username: String, score: Int) {
    println("$username has $score points")
}

fun main() {
    printUserScore("Dev1", 100)
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Magic Index" Anti-Pattern
**Code**: `val name = args[0]` inside `main` without check.
**Why it's dangerous**: Nếu không có arguments, chương trình sẽ crash (`ArrayIndexOutOfBoundsException`).
**Fix**: Luôn kiểm tra `args.isNotEmpty()` trước khi truy cập.

### 2. The "Void vs Unit" Confusion
**Code**: Khai báo `fun test(): void` (Java style).
**Why it's dangerous**: Kotlin không dùng `void`, chỉ dùng `Unit` hoặc bỏ qua. Cú pháp sai sẽ không compile.
**Fix**: Dùng `fun test() { ... }` hoặc `fun test(): Unit { ... }`.

### 3. The "Static Main" Misconception
**Code**: `public static void main` (Java style).
**Why it's dangerous**: Kotlin không cần `static` keyword cho `main` trong file. `static` là invalid keyword在此处.
**Fix**: Chỉ cần `fun main(args: Array<String>)`.

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **File header**: `fun main(args: Array<String>) { ... }`
2. **Variable inside string**: Use `${variable}`.
3. **Check args**: `if (args.isNotEmpty()) { ... }`
4. **Get arg**: `args[0]` (index 0 based).
5. **Print**: `println("Text")`.

### Decision Logic (If-Else)
```text
IF (Program is standalone) -> MUST have main()
ELSE IF (Need input) -> Add args: Array<String>
ELSE IF (Logic repeats) -> Create new fun name()
ELSE -> Use String Template for output
```

### Top 5 Things to Remember
1. **Kotlin is Case Sensitive**: `main` is correct, `Main` is not.
2. **Arrays are 0-indexed**: First arg is `args[0]`.
3. **Arrays are fixed size**: Cannot add items after creation.
4. **Package matters**: File must match project structure (usually at top of file).
5. **Run Configurations**: Arguments are set in "Edit Configurations" in IDE, not in code.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Functions (Kotlin)

## SECTION 1: CORE MENTAL MODEL

### Core Concepts (Tư duy cốt lõi)

**1. Everything is an Expression (Mọi thứ là biểu thức)**
- Hầu hết mọi thứ trong Kotlin trả về giá trị, kể cả `if/else`.
- Kết quả của một khối mã là giá trị của biểu thức cuối cùng.

```kotlin
// Cổ điển (Java): Phải dùng biến và if
val isHotJava: Boolean
if (temperature > 40) {
    isHotJava = true
} else {
    isHotJava = false
}

// Kotlin: Gọn gàng, là biểu thức (Expression)
val temperature = 20
val isHot = if (temperature > 40) true else false 
```

**2. Unit Type (Đơn vị)**
- Tương đương `void` trong Java, nhưng là một **Object**.
- Nếu hàm không return gì, Kotlin mặc định trả về `Unit`.
- `Unit` là singleton (chỉ có 1 instance duy nhất).

```kotlin
// 2 cách này equivalent (tương đương)
fun logMessage(msg: String): Unit {
    println(msg)
}

fun logMessage(msg: String) {
    println(msg) // Return type Unit là mặc định
}
```

### Why this approach? (Tại sao nên dùng?)
- **Null Safety**: Dùng `Unit` giúp Kotlin type system xử lý uniform.
- **Expressiveness**: `if/else` là expression giúp code ngắn hơn, biến immutable được dễ dàng.

---

## SECTION 2: DECISION TABLES

### Table 1: Function Return Types

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Hàm thực hiện việc in/log, không cần giá trị trả về | Không khai báo return type (dùng `Unit` ngầm) | **Default Behavior**: Tránh dư thừa mã. Codebase clean. | Khai báo `Unit` everywhere (rất dài dòng). |
| Cần trả về kết quả tính toán | Khai báo rõ kiểu trả về (vd: `Int`, `String`) | **Type Safety**: Tránh lỗi khi gọi hàm. | Để trống return type khi cần trả về giá trị -> Lỗi biên dịch. |

### Table 2: Parameters & Arguments

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Parameter có giá trị mặc định, gọi hàm linh hoạt | Dùng **Default Parameters** (`name: String = "default"`) | **Flexibility**: Giảm số lượng overload hàm (hàm cùng tên, tham số khác nhau). | Viết nhiều hàm重载 (overload) thay vì dùng default value. |
| Gọi hàm có nhiều tham số, khó nhớ thứ tự | Dùng **Named Arguments** (`func(a = 1, b = 2)`) | **Readability**: Rõ ràng tham số nào đang được gán giá trị gì. | Bỏ qua named arguments khi tham số nhiều -> Dễ bị nhầm thứ tự. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Function Lifecycle Flow (Luồng sống của hàm)

```text
[ Gọi Hàm ]
     |
     v
[ Kiểm Tra Tham Số ]
     |------------------> [ Dùng Giá Trị Mặc Định (Nếu thiếu) ]
     |
     v
[ Thực Thi Khối Code (Body) ]
     |
     v
[ Biểu Thức Cuối Cùng ] -------------> [ Trả Về Giá Trị (Return) ]
     |                                         |
     |                                         v
     +----------------------------------> [ Hoặc Unit (Nếu không có return) ]
```

### Parameter Hierarchy (Xử lý tham số)
1. **Named Arguments**: Ưu tiên cao nhất khi gọi.
2. **Default Values**: Khi tham số bị bỏ trống.
3. **Positional Arguments**: Nếu không dùng named.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Expression Function (Hàm biểu thức)
**Khi nào dùng**: Khi logic ngắn gọn, chỉ cần return một giá trị đơn giản.
**Tại sao đúng**: Loại bỏ `return` keyword rườm rà, tăng độ đọc.

```kotlin
// Pattern: Body là một biểu thức
fun calculateArea(width: Int, height: Int) = width * height

// Sử dụng
val area = calculateArea(10, 20) // area = 200
```

### Pattern 2: Flexible API with Default Params (API linh hoạt)
**Khi nào dùng**: Xây dựng hàm utility hoặc hàm config cho library.
**Tại sao đúng**:backward compatibility tốt. Người dùng cũ không cần sửa code khi thêm tham số mới.

```kotlin
// Pattern: Parameter với default value
fun createNotification(
    message: String, 
    title: String = "Alert", 
    isUrgent: Boolean = false
) {
    println("[$title] $message (Urgent: $isUrgent)")
}

// Sử dụng linh động
createNotification("Chập chờn điện") 
// Output: [Alert] Chập chờn điện (Urgent: false)

createNotification("Sập nguồn", "CRITICAL", true)
// Output: [CRITICAL] Sập nguồn (Urgent: true)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### ❌ 1. Explicitly Writing `: Unit`
**Tại sao nguy hiểm**: Code rác (boilerplate). Làm giảm khả năng đọc.
**Sửa ngay**: Xóa `: Unit`. Chỉ giữ nó nếu bạn đang override một interface yêu cầu(Unit).

### ❌ 2. Using If/Else Statement mà không gán giá trị
**Tại sao nguy hiểm**: Phá vỡ tính "Expression" của Kotlin. Viết dài dòng hơn cần thiết.
**Sửa ngay**: Chuyển sang dùng `val x = if (condition) a else b`.

### ❌ 3. Overusing Named Arguments Everywhere
**Tại sao nguy hiểm**: Nếu hàm chỉ có 1 tham số, named argument là多余 (trừ khi tên param không tự giải thích được).
**Sửa ngay**: Chỉ dùng khi cần clarity hoặc thứ tự tham số gây confusion.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules (Quy tắc nhanh)

1. **Expression Rule**: `if`, `when`, `try/catch` đều là expressions. Dùng để gán giá trị.
2. **Unit Rule**: Hàm không return = `Unit`. Không cần khai báo显式.
3. **Default Rule**: Dùng `param: Type = value` thay vì viết nhiều hàm重载.
4. **Call Rule**: Dùng `name = value` khi tham số > 2 hoặc dễ nhầm lẫn.

### Decision Logic (If-Else Style)

**Nếu** hàm không trả về giá trị => **Then** bỏ qua `: Unit`.
**Nếu** có nhiều tham số >= 3 => **Then** dùng Named Arguments khi gọi.
**Nếu** tham số có thể thay đổi/optional => **Then** gán Default Value.
**Nếu** logic return chỉ 1 dòng => **Then** dùng Expression Function (dấu `=`).

### Top 3 Things to Remember (Top 3 cần nhớ)
1. **Kotlin là Expression-Oriented**: Gọi hàm cũng là expression, nó trả về giá trị.
2. **Default Parameters là King**: Giúp code linh hoạt, dễ bảo trì.
3. **Unit là Object**: Đừng viết `fun a(): Unit = {}` nếu không cần thiết.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Functions

## SECTION 1: CORE MENTAL MODEL

**First-Class Function (Hàm cấp 1)**
Khả năng của hàm trong Kotlin được treated như một biến dữ liệu thông thường (lưu trữ, truyền làm tham số, trả về).

```kotlin
// 1. Lưu trữ trong biến
val filter: (Int) -> Int = { level -> level / 2 }

// 2. Trả về từ hàm khác
fun getMultiplier(factor: Int): (Int) -> Int {
    return { x -> x * factor }
}

// 3. Truyền làm tham số
fun calculate(a: Int, b: Int, op: (Int, Int) -> Int): Int = op(a, b)
```

**Single-Expression Function (Hàm biểu thức đơn)**
Shortcut để return giá trị trực tiếp mà không cần khối `{} và return`. Giảm boilerplate cho logic đơn dòng.

```kotlin
// Tránh: Khối thừa cho logic đơn giản
fun squareOld(x: Int): Int {
    return x * x
}

// Nên: Gọn, rõ ràng
fun square(x: Int): Int = x * x
```

**Argument Passing Strategy (Chiến lược truyền đối số)**
Kotlin ưu tiên **Named Arguments** để tránh nhầm lẫn thứ tự tham số, đặc biệt khi hàm có nhiều tham số hoặc có tham số mặc định.

---

## SECTION 2: DECISION TABLES

### Table 1: Positional vs Named Arguments

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Hàm có 1-2 tham số đơn giản | **Positional Arguments** | Trực quan, ngắn gọn. Caller không cần gõ tên biến. | Lạm dụng tên biến cho hàm `max(a, b)`. |
| Hàm > 2 tham số hoặc có tham số mặc định | **Named Arguments** | **Readability** (Đọc được). Tránh sai thứ tự, bỏ qua tham số mặc định không cần thiết. | Bỏ qua tên biến → Crash hoặc logic sai do truyền sai thứ tự. |
| Khi refactoring hàm cũ | **Named Arguments** | **Safety** (An toàn). Dù hàm thay đổi thứ tự tham số, code gọi vẫn đúng. | Sửa hàm xong, code gọi bị sai logic im lìm. |

### Table 2: Standard Function vs Lambda vs Single-Expression

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Logic phức tạp, nhiều dòng code | **Standard Function** (`fun name() { ... }`) | Dễ debug, tách biệt logic rõ ràng. | Ép vào lambda quá dài, khó đọc. |
| Logic ngắn gọn, trả về ngay, cần truyền vào hàm khác | **Lambda** (`{ ... }`) | **Conciseness** (Ngắn gọn). Rất phù hợp với collection operations (filter, map). | Viết lambda quá dài, không có return type rõ ràng. |
| Logic chỉ là 1 biểu toán hoặc 1 hàm đơn giản | **Single-Expression** (`fun name() = ...`) | **Readability** (Đọc được). Loại bỏ boilerplate `return`. | Quên `=` khi cần return, hoặc dùng `fun name() { ... }` thừa. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Logic Hierarchy of Function Definitions

```text
[ Function Definition ]
       |
       +-- [ Signature ]
       |     |-- Name
       |     |-- Parameters (Input)
       |     |-- Return Type (Output)
       |
       +-- [ Body ]
             |-- Standard Block: { ... }
             |     |-- Complex Logic
             |     |-- Multiple Statements
             |
             |-- Single Expression: = ...
                   |-- Simple Calculation
                   |-- Direct Return
```

### Data Flow: Higher-Order Function

```text
[ Caller Code ]
      |
      v
[ Higher-Order Function ] (e.g., encodeMsg)
      | Receives: Data (String) + Logic (Function)
      | Action: Wraps Data with Logic
      v
[ Lambda / Function Reference ]
      | Executes specific operation
      v
[ Result ]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Function with Defaults & Named Args

**Khi nào dùng:** Khi thiết kế API hoặc utility functions có nhiều option, muốn giữ backward compatibility và dễ đọc.

**Tại sao đúng:** Giúp caller chỉ cần truyền dữ liệu bắt buộc, tự động dùng setting mặc định an toàn mà không cần nhớ thứ tự.

**Code Demo Hoàn Chỉnh:**

```kotlin
// Definition
fun reformat(
    str: String,
    wordSeparator: Char = '_',
    normalizeCase: Boolean = true,
    divideByCamelHumps: Boolean = false
) {
    var result = str
    if (normalizeCase) result = result.lowercase()
    if (divideByCamelHumps) {
        // Logic tách camel case
        result = result.replace(Regex("([a-z])([A-Z])"), "$1$wordSeparator$2")
    }
    println("Result: $result")
}

// Usage
fun main() {
    // Case 1: Gọi cơ bản (dùng mặc định)
    reformat("HelloWorld") 
    
    // Case 2: Đặt tên rõ ràng cho tham số tùy chọn
    reformat(
        str = "HelloWorld", 
        divideByCamelHumps = true, 
        wordSeparator = '-'
    )
}
```

### Pattern 2: Lambda as Parameter (Higher-Order)

**Khi nào dùng:** Khi muốn một hàm thực hiện khung logic cố định (template), nhưng cho phép tùy chỉnh chi tiết xử lý qua tham số.

**Tại sao đúng:** Tách biệt giữa thuật toán và chi tiết nghiệp vụ (Decoupling).

**Code Demo Hoàn Chỉnh:**

```kotlin
// Definition
fun processSensorData(
    rawData: Int, 
    sensorType: String, 
    validator: (Int, String) -> Boolean
): String {
    return if (validator(rawData, sensorType)) {
        "Valid data: $rawData"
    } else {
        "Invalid data"
    }
}

// Usage
fun main() {
    // Logic nghiệp vụ được truyền vào dưới dạng Lambda
    val isSafe = processSensorData(100, "Temp") { value, type ->
        value < 120 && type == "Temp"
    }
    
    // Logic khác cho cùng hàm khung
    val isPressureSafe = processSensorData(900, "Pressure") { value, _ ->
        value in 800..1000
    }
}
```

### Pattern 3: Function Type Variable

**Khi nào dùng:** Khi cần lưu trữ logic vào danh sách hoặc biến để gọi động sau này.

**Tại sao đúng:** Biến hàm là dữ liệu, có thể di chuyển và sử dụng linh hoạt.

**Code Demo Hoàn Chỉnh:**

```kotlin
fun main() {
    // Khai báo biến持有 hàm
    val waterFilter: (Int) -> Int = { level -> level / 2 }
    val airFilter: (Int) -> Int = { level -> level - 10 }

    // Lưu vào List
    val filters = listOf(waterFilter, airFilter)

    // Gọi động
    val dirtLevel = 20
    filters.forEach { filter ->
        println("Filtered level: ${filter(dirtLevel)}")
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Overusing Positional Arguments in Complex Functions**
    *   **Danger:** Gây ra lỗi logic khó phát hiện. Nếu developer đổi chỗ 2 tham số cùng type (ví dụ `true/false`), compiler không báo lỗi nhưng program chạy sai.
    *   **Solution:** Dùng **Named Arguments** hoặc tách hàm nhỏ hơn.

2.  **Optional Parameters Before Required Parameters**
    *   **Danger:** Violates logic đọc code. Caller bắt buộc phải pass arguments cho các parameter đầu tiên dù nó là optional.
    *   **Code Sai:**
        ```kotlin
        fun log(tag: String = "App", msg: String) // Lỗi: Msg không thể omit được nếu không dùng tên biến
        ```
    *   **Solution:** Luôn để tham số bắt buộc (Required) trước, tham số mặc định (Default) sau.

3.  **Returning Null from Single-Expression Functions**
    *   **Danger:** Dùng `=` cho single-expression nhưng `if` return `null` trong khi function type không nullable.
    *   **Code Sai:**
        ```kotlin
        fun check(x: Int): Int = if (x > 0) x else null // Compiler Error hoặc Runtime Error
        ```

---

## SECTION 6: MASTER CHEAT SHEET

**Top 5 Quick Rules**

1.  **Single-Expression:** Dùng `=` thay vì `{ return ... }` nếu logic chỉ là 1 dòng tính toán.
2.  **Positional:** Dùng cho < 2 tham số hoặc hàm private/internal logic đơn giản.
3.  **Named:** Bắt buộc cho hàm public nhiều tham số hoặc tham số mặc định.
4.  **Default:** Đặt sau cùng, sau các tham số bắt buộc.
5.  **Lambda:** Dùng `{ -> ... }` khi logic cần truyền vào hàm khác (Higher-Order).

**Decision Logic (If-Else)**

*   **IF:** Function body chỉ là `return <expression>` **THEN:** `fun name() = <expression>`
*   **IF:** Có `Boolean` hoặc `String` constants **AND** > 2 tham số **THEN:** Dùng Named Arguments (`name = value`)
*   **IF:** Cần truyền logic vào hàm khác **THEN:** Dùng Lambda (`{ it -> ... }`) hoặc Function Type Variable (`val fn: (Int) -> Int = { ... }`)

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Higher-Order Functions & Collections

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **Higher-Order Function (HOF - Hàm bậc cao):** A function that accepts another function as a parameter or returns a function. Used to abstract behavior.
*   **Function Type (Loại hàm):** Defines the signature of a function variable (e.g., `(String) -> String`).
*   **Lambda (Hàm ẩn danh):** An anonymous function passed inline. Defined by curly braces `{}`.
*   **Function Reference (Tham chiếu hàm):** Using `::` to pass a named function as an argument.
*   **Last Parameter Call Syntax (Kỹ thuật gọi tham số cuối):** Allows moving a lambda argument outside the parentheses `()`.

### Key Mental Model
Think of functions as "behavior variables." Instead of writing specific logic inside a function (hardcoded), you pass the *logic* itself as an argument. This makes your API generic.

**Why is this better?**
*   **Standard Library:** Kotlin uses this for almost everything (`filter`, `map`, `repeat`). If you don't master it, you can't read standard Kotlin.
*   **Flexibility:** You write one function that handles the structure (e.g., connecting to a DB), and the user provides the specific action (e.g., processing the data).

```kotlin
// 1. Define the HOF signature
fun processUser(name: String, action: (String) -> Unit) {
    // Logic here...
    action(name) 
}

// 2. Usage: Passing logic dynamically
fun main() {
    // Case A: Lambda (Inline logic)
    processUser("Alice") { user -> println("Processing $user") }

    // Case B: Function Reference (Reusable logic)
    processUser("Bob", ::sendEmail)
}

fun sendEmail(user: String) {
    println("Email sent to $user")
}
```

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Logic is used ONCE only.** | **Lambda (inline)** | **Conciseness:** Keeps logic visible right where it's called. No need to jump to another function definition. | Defining a named function when it's only called once (clutters namespace). |
| **Logic is used MULTIPLE times.** | **Function Reference (`::`)** | **Reusability:** Follows DRY (Don't Repeat Yourself) principle. Easier to unit test. | Copy-pasting the same lambda block in 3 different places. |
| **Iterating a List with 1 parameter.** | **Implicit `it`** | **Readability:** Reduces boilerplate. Standard Kotlin idiomatic style. | Writing `{ x -> x > 0 }` instead of `{ it > 0 }`. |
| **Filtering large datasets.** | **Sequence (Lazy)** | **Performance:** Prevents creating intermediate collections in memory. Evaluation stops early if possible. | Using `List.filter().filter()` on massive lists instead of `asSequence()`. |
| **Simple iteration (void return).** | **`repeat()` / `forEach()`** | **Clarity:** Explicit intent to iterate without managing indices (`for` loops). | Using a `for (i in 0..10)` loop when `repeat(10) { ... }` is cleaner. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Execution Flow
This diagram shows how a HOF accepts a function type argument. The **Implementation** (Lambda/Ref) is injected into the **HOF** to be executed.

```text
[ Caller ]
    |
    | 1. Calls
    v
[ Higher-Order Function (HOF) ]
    | Logic Structure (e.g., Loop, Connect, Validate)
    |
    | 2. Injects & Executes
    +-------------------------> [ Function Argument ]
                                    (The "Behavior")
                                        |
                                        | 3. Runs specific logic
                                        v
                                    [ Result / Side Effect ]
```

### Syntax Variations
*   **Standard:** `encodeMsg("abc", { it.toUpperCase() })`
*   **Last Param Syntax (Trailing):** `encodeMsg("abc") { it.toUpperCase() }`
*   **Function Reference:** `encodeMsg("abc", ::enc2)`

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Standard Filter
**When to use:** You need to extract a subset of a list based on a condition.

```kotlin
fun main() {
    val colors = listOf("red", "green", "blue", "red-orange")
    
    // Pattern: collection.filter { condition }
    val reds = colors.filter { color ->
        color.contains("red")
    }
    
    println(reds) // [red, red-orange]
}
```

### Pattern 2: Implicit "it" Iteration
**When to use:** The lambda takes exactly one parameter and you want to minimize code noise.

```kotlin
fun main() {
    val numbers = listOf(1, -5, 3, -2)
    
    // Explicit
    val positivesExplicit = numbers.filter { num -> num > 0 }
    
    // Implicit (Preferred in Kotlin)
    val positivesImplicit = numbers.filter { it > 0 }
    
    println(positivesImplicit) // [1, 3]
}
```

### Pattern 3: Function Reference Injection
**When to use:** You have a pre-existing, named function that matches the signature required by the HOF.

```kotlin
// Common in Android: Activity callbacks or Network handlers
fun main() {
    val inputs = listOf("cmd1", "cmd2")
    
    // Execute each string using a named function
    inputs.forEach(::executeCommand)
}

fun executeCommand(cmd: String) {
    println("Executing: $cmd")
}
```

### Pattern 4: Lazy Evaluation (Sequence)
**When to use:** Dealing with huge datasets or chained operations to save memory.

```kotlin
fun main() {
    val range = 1..1_000_000
    
    // Eager (Normal List) - Creates intermediate lists immediately
    val eager = range.toList()
        .filter { it % 2 == 0 }
        .map { it * 2 }
        .first() 

    // Lazy (Sequence) - Processes items one by one, stops at first match
    val lazy = range.asSequence()
        .filter { it % 2 == 0 }
        .map { it * 2 }
        .first() 
    
    println(lazy)
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Eager Filter Chain" on Large Data
**Danger:** Doing `hugeList.filter { }.map { }.filter { }` creates a new collection after *every* step.
**Why:** It can cause `OutOfMemoryError` or significant lag (GC thrashing).
**Fix:** Convert to `hugeList.asSequence().filter { }.map { }.toList()`.

### 2. Ignoring `it` Shadowing
**Danger:** Nesting lambdas without renaming `it`.
**Why:** `it` refers to the *immediate* enclosing lambda. In nested scopes, `it` becomes ambiguous and unreadable.

```kotlin
// BAD
listOf(1, 2).forEach { // 'it' is Int
    listOf("a", "b").forEach { 
        println(it) // ERROR: 'it' here is String? Or Int? Hard to tell.
    }
}

// GOOD (Explicit Naming)
listOf(1, 2).forEach { num ->
    listOf("a", "b").forEach { str ->
        println("$num : $str")
    }
}
```

### 3. Misusing `::` (Function References)
**Danger:** Passing `::myFunction` when `myFunction` relies on external state not passed via arguments.
**Why:** A function reference points to a specific function with a specific signature. If the HOF expects `(String) -> Unit`, you cannot pass `fun myFunc() { ... }` or a class method requiring `this`.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **HOF:** Function taking a function.
2.  **Syntax:** Put Lambda **inside** `{ }`.
3.  **Trailing Lambda:** If it's the last arg, move it **outside** `( )`.
4.  **One Param:** Use `it`. Don't write `{ x -> x }`.
5.  **Named Function:** Use `::` reference.
6.  **Filter:** Returns a NEW list containing items where {it} is `true`.
7.  **Iteration:** `forEach { }` iterates, `filter { }` selects.
8.  **Performance:** Use `.asSequence()` for large data chains.
9.  **Types:** Know `(Int) -> Unit` syntax.
10. **Clean Code:** Don't define a named function if you only use it once.

### Decision Logic (If-Else)
*   **IF** the logic is simple and used once -> **Lambda inline**.
*   **IF** the logic is complex or reused -> **Named Function + `::` reference**.
*   **IF** the list is huge (>10k items) -> **Use Sequence**.
*   **IF** the parameter is a lambda and last -> **Trailing syntax**.

<!-- CHUNK 41-46 -->

# DEVELOPER DECISION GUIDE: Lesson 2 Functions

## SECTION 1: CORE MENTAL MODEL

**Sequence (Chuỗi lười biếng)**: Dòng dữ liệu chỉ xử lý phần tử khi cần thiết. Thay vì tạo collection mới ngay lập tức, nó tạo ra một "kế hoạch" thực thi.
**Eager (Nhiệt tình)**: Xử lý ngay lập tức, tạo ra collection mới ở mỗi bước.

**Why is Sequence better?**
- Khi xử lý large datasets hoặc nhiều bước transform (filter -> map -> filter), Sequence tránh được việc tạo ra nhiều intermediate collections, tiết kiệm bộ nhớ và CPU.

```kotlin
// Eager: Tạo 2 list trung gian ([1,2,3] -> [2,4,6] -> [2,4])
val eager = listOf(1, 2, 3, 4, 5)
    .filter { it % 2 == 0 }      // List [2,4]
    .map { it * 2 }              // List [4,8]

// Sequence: Chạy từng phần tử qua hết các bước
val lazy = listOf(1, 2, 3, 4, 5)
    .asSequence()                // Chuyển sang chế độ lười
    .filter { it % 2 == 0 }      // Chưa làm gì cả
    .map { it * 2 }              // Chưa làm gì cả
    .toList()                    // Tại đây mới xử lý: 2 -> 4 -> 4 -> 8
```

## SECTION 2: DECISION TABLES

### Table 1: Collection Operations

| Tình huống sử dụng | Nên dùng gì | Tại sao - Lazy Evaluation (Đánh giá lười biếng) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Datasets nhỏ (< 1000 phần tử)** | Collection Operations (List/Set) | Overhead của Sequence creation > Performance gain. Nhanh hơn do không phải chuyển đổi state. | Dùng Sequence cho list 10 phần tử, gây chậm máy không cần thiết. |
| **Datasets lớn / Nhiều bước transform** | Sequence | Tránh tạo intermediate collections. Dừng processing ngay khi tìm thấy kết quả (terminal op). | Dùng Collection với `map` -> `filter` -> `map` lồng nhau, tạo rác bộ nhớ (GC pressure). |
| **Cần build UI (Android Adapter)** | Collection | UI render cần list rõ ràng. `asSequence().toList()` là rác. | Dùng Sequence trực tiếp trong `RecyclerView.Adapter` (nếu không convert về List). |

### Table 2: Transformations

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Nhân đôi giá trị (Element-wise)** | `map { it * 2 }` | Duyệt qua từng phần tử và apply transform. | Dùng `forEach` và thêm vào mutable list mới (lằng nhằng, dễ lỗi). |
| **Làm phẳng list con (Nested List)** | `flatten()` | Trả về một list duy nhất chứa mọi phần tử. | Dùng `flatMap` với logic trả về list rỗng thay vì `flatten()` cho cấu trúc đơn giản. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

```text
DATA FLOW: Eager vs Lazy Pipeline

[INPUT] -> [TYPE] -> [OP 1] -> [OP 2] -> [OUTPUT]

1. EAGER (Standard List)
   List(1, 2, 3)
      |
   Filter { it > 1 }
      |
   List(2, 3)  <-- [Tạo List mới ở đây]
      |
   Map { it * 2 }
      |
   List(4, 6)  <-- [Tạo List mới ở đây]
   KẾT QUẢ: List(4, 6)

2. LAZY (Sequence)
   List(1, 2, 3)
      |
   asSequence()
      |
   Sequence (Chưa xử lý)
      |
   Filter { it > 1 } (Chỉ lưu rule)
      |
   Map { it * 2 } (Chỉ lưu rule)
      |
   toList() / sum() / find()
      |
   Duyệt: 1 (bỏ) -> 2 (lọc -> nhân -> 4) -> 3 (lọc -> nhân -> 6)
   KẾT QUẢ: List(4, 6) hoặc Int (tùy terminal op)
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Lazy Filtering Chain
**Khi nào dùng**: Khi bạn có nhiều bước lọc/xử lý và chỉ cần kết quả cuối cùng.
**Tại sao đúng**: Giảm số lần tạo đối tượng trung gian, tối ưu CPU.

```kotlin
fun processHeavyData(items: List<String>): List<String> {
    return items.asSequence()
        .filter { it.startsWith("A") }    // Bước 1: Lọc
        .map { it.uppercase() }           // Bước 2: Chuyển đổi
        .filter { it.length > 3 }         // Bước 3: Lọc lại
        .take(10)                         // Bước 4: Giới hạn
        .toList()                         // Thực thi & Trả về List
}
```

### Pattern 2: Safe Data Transformation (Set -> List)
**Khi nào dùng**: Khi input là Set (không trùng lặp) nhưng output cần List hoặc xử lý thêm.
**Tại sao đúng**: `flatten()` xử lý cấu trúc nested dễ dàng, `map` thay đổi giá trị chuẩn xác.

```kotlin
val nestedSets = listOf(setOf(1, 2, 3), setOf(4, 5), setOf(1, 2))

// Mục đích: Lấy tất cả số, loại bỏ duplicate, nhân đôi
val result = nestedSets
    .flatten()                 // [1,2,3,4,5,1,2]
    .toSet()                   // Đảm bảo duy nhất: {1,2,3,4,5}
    .map { it * 2 }            // [2,4,6,8,10]
    .sorted()                  // Sắp xếp
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Mixing Collection & Sequence without `toList()`**
    *   **Danger**: Gây lỗi biên dịch hoặc logic không mong muốn. Sequence chỉ trả về `Sequence` object, không phải `List`.
    *   **Vietnamese**: Trả về `Sequence` cho Adapter hoặc API là sai quy chuẩn. Luôn kết thúc bằng `toList()` nếu cần collection thực.

2.  **Dùng `forEach` thay cho `map`**
    *   **Code Sai**:
        ```kotlin
        val bad = mutableListOf<Int>()
        list.forEach { bad.add(it * 2) } // Side effect, khó đọc
        ```
    *   **Why Bad**: Khó maintain, không khai báo biến mutable nếu không cần thiết. Dùng `map` để trả về giá trị mới trực tiếp.

3.  **Tạo Sequence cho List < 1000 phần tử**
    *   **Why Bad**: Chi phí tạo đối tượng `Sequence` và truy cập qua `Iterator` tốn kém hơn List index access trực tiếp.

## SECTION 6: MASTER CHEAT SHEET

**Top 5 Rules:**
1.  **Eager là mặc định**: List, Set xử lý ngay.
2.  **Lazy là Sequence**: Dùng `.asSequence()` ở đầu pipeline.
3.  **Terminal Operation**: Phải có `toList()`, `sum()`, `find()`, `count()` để kích hoạt Sequence.
4.  **`map`**: Transform 1-1.
5.  **`flatten()`**: Mở nested list.

**Logic Decision (If-Else):**
*   **IF** Dataset < 1000 items?
    *   **THEN** Use `list.filter { }.map { }` (Eager)
*   **IF** Dataset > 1000 items OR complex chain (filter > map > filter)?
    *   **THEN** Use `asSequence().filter { }.map { }.toList()` (Lazy)
*   **IF** Input is List of Lists?
    *   **THEN** Use `flatten()` hoặc `flatMap`