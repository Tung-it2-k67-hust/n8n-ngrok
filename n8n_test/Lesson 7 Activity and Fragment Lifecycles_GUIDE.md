# DEVELOPER DECISION GUIDE: Lesson 7 Activity and Fragment Lifecycles.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:30:08



<!-- CHUNK 1-10 -->

# Developer Decision Guide: Activity & Fragment Lifecycles

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Lifecycle (Chu kỳ sống - Android)**: Represents the state an activity/fragment is in at any specific time. Android manages this automatically, triggering callbacks (events) when the state changes. Your job is to respond to these callbacks to manage resources and user experience.

**Lifecycle-Aware Component (Thành phần nhận thức chu kỳ sống)**: A class that automatically adjusts its behavior based on the current lifecycle state of another component (like an Activity). Example: `ViewModel`.

**Activity State (Trạng thái Activity)**: A snapshot of where the activity is in its lifecycle.
1.  **RESUMED (Đã khôi phục)**: Visible and interactive.
2.  **STARTED (Đã bắt đầu)**: Visible but not in focus (behind a dialog).
3.  **CREATED (Đã tạo)**: Created but not visible.
4.  **DESTROYED (Đã hủy)**: Cleaned up.

### Key Mental Model: The "Visible vs. Interactive" Axis
Think of the lifecycle in two dimensions:
1.  **Visibility**: Does the user see the screen? (`onStart` to `onStop`).
2.  **Interaction**: Can the user touch the screen? (`onResume` to `onPause`).

*   **Visual but not interactive**: A dialog pops up. Activity goes `onResume` -> `onPause`.
*   **Not visual**: User presses Home. Activity goes `onPause` -> `onStop`.

### Why This Approach is Better
Instead of manually tracking `isVisible` or `hasFocus` booleans, Android provides a standard event stream (`onCreate`, `onResume`, etc.). This ensures:
1.  **Predictability**: The system guarantees the order of events (e.g., `onResume` is always called after `onStart`).
2.  **Safety**: You have strict points to clean up resources (camera, listeners) to prevent memory leaks.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **App just starts / Screen rotates** | `onCreate()` | **Initialization (Khởi tạo)**: Best place to inflate UI (`setContentView`) and setup static data. Called only once per lifecycle. | Doing heavy work (network calls) here. It blocks the UI thread, causing "App Not Responding" (ANR). |
| **User returns to app from recent apps** | `onRestart()` -> `onStart()` | **Restoration (Khôi phục)**: Used if you specifically need to distinguish between a fresh start and a restart. Usually `onStart` is enough. | Overusing `onRestart`. Usually, logic should go in `onStart` for both cases. |
| **User scrolls/listens to audio in background** | `onPause()` | **Pause Logic (Tạm dừng)**: Commit unsaved data. Pause animations or audio. The activity is still fully visible. | Starting CPU-intensive work here. `onPause` must execute quickly, or the next app will lag. |
| **App is minimized (Home button)** | `onStop()` | **Stop Logic (Dừng)**: Release heavy resources (Camera, Bitmaps). The UI is no longer visible. | Registering/unregistering listeners here. If a configuration change happens, `onStop` might not be called before `onDestroy`. |
| **Screen rotation / Low memory** | `onSaveInstanceState()` | **State Preservation (Bảo tồn trạng thái)**: Save dynamic UI state (scroll position, text input) into a Bundle. | Saving large data objects here. The Bundle has a transaction limit (approx 1MB). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Activity Lifecycle Flow
The lifecycle is a loop. Configuration changes (rotation) trigger a specific path.

```text
[ App Start ]
      |
   onCreate()  ---+
      |            |
   onStart()       |
      |            | (Configuration Change)
   onResume()      | (Rotation / Language Change)
      |            |
 [ User Interaction ] <-------------------+
      |                                 |
   onPause()                             |
      |                                 |
   onStop()                              |
      |                                 |
   onDestroy() <-------------------------+
      |
 [ App End ]
```

### Fragment vs. Activity Relationship
A Fragment's lifecycle is **directly tied** to its host Activity, but it has an extra concept: the **View**.

**Hierarchy:**
Activity `(Host)` -> Fragment `(Manager)` -> View `(UI Element)`

**Key Difference:**
*   **Activity**: `onCreate` sets the layout.
*   **Fragment**: `onCreateView` sets the layout. You can destroy the View (but keep the Fragment instance alive) during rotation.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Resource Cleanup
**Khi nào dùng:** When using listeners, sensors, or camera that must be stopped to save battery/prevent crashes.

**Tại sao đúng:** You must release resources in the reverse order they were acquired. `onDestroy` is the final cleanup station.

```kotlin
class MainActivity : AppCompatActivity() {

    private var sensorManager: SensorManager? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // Initialize heavy resources
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
    }

    override fun onDestroy() {
        super.onDestroy()
        // CRITICAL: Release resources to prevent memory leaks
        sensorManager?.unregisterListener(this)
        sensorManager = null
    }
}
```

### Pattern 2: Handling Rotation with ViewModel + SavedStateHandle
**Khi nào dùng:** When you need to preserve user input or UI state even if the app process is killed by the system.

**Tài sao đúng:** `onSaveInstanceState` is for small bundles. `ViewModel` holds data during rotation. `SavedStateHandle` allows `ViewModel` to survive process death.

```kotlin
// Dependency: lifecycle-viewmodel-savedstate
class UserViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {

    // Key for saving state
    private val KEY_INPUT = "user_input"

    // Save data immediately when user types
    fun saveInput(text: String) {
        savedStateHandle[KEY_INPUT] = text
    }

    // Retrieve data (survives rotation & process death)
    fun getInput(): String? {
        return savedStateHandle[KEY_INPUT]
    }
}
```

### Pattern 3: Fragment Transactions with `commitNow`
**Khi nào dùng:** When replacing a Fragment inside an Activity.

**Tại sao đúng:** `commit()` is asynchronous (scheduled for next frame). `commitNow()` executes immediately, ensuring the Fragment's lifecycle methods (`onCreateView`, etc.) run synchronously. Better for testing and immediate UI updates.

```kotlin
class ContainerActivity : AppCompatActivity() {
    fun loadFragment() {
        val transaction = supportFragmentManager.beginTransaction()
        val newFragment = MyFragment()

        // Use commitNow for immediate lifecycle execution
        transaction.replace(R.id.fragment_container, newFragment)
        transaction.commitNow() 
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Heavy Operations in `onCreate()`**
*   **Danger:** Blocks the app from launching. The user sees a frozen screen.
*   **Fix:** Use coroutines or background threads for network calls.

**2. Updating UI in `onStop()` or `onDestroy()`**
*   **Danger:** Pointless and risky. The user can't see it. If the app crashes here, it interrupts the user leaving the app.
*   **Fix:** Update UI in `onPause()` or `onStop()` only to hide sensitive data (for security), not to show loading bars.

**3. Storing Data Only in `onSaveInstanceState()`**
*   **Danger:** The Bundle is limited in size (IPC buffer limit). Trying to save a large Bitmap or list will crash the app (`TransactionTooLargeException`).
*   **Fix:** Save only IDs or small primitives in the Bundle. Save heavy data to disk (Database/File) or keep in a ViewModel.

**4. Using Background Threads in Fragments**
*   **Danger:** If the Fragment is destroyed (rotation), the background thread might try to update a non-existent UI, causing a crash.
*   **Fix:** Use `viewLifecycleOwner.lifecycleScope.launch` inside `onViewCreated`. This automatically cancels the job when the Fragment's View is destroyed.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Initialization:** `onCreate`
2.  **Visible:** `onStart`
3.  **Interactive:** `onResume`
4.  **User leaving (UI hidden):** `onPause` -> `onStop`
5.  **App killed:** `onDestroy`

### Top 10 Things to Remember
1.  **Guaranteed Order:** `Create` -> `Start` -> `Resume`. Reverse for shutdown.
2.  **Always Call Super:** `super.onCreate()`, `super.onResume()`.
3.  **Pause = Stop Visuals:** Animation, Video, GPS -> Pause here.
4.  **Stop = Release Heavy:** Camera, Bitmaps -> Release here.
5.  **Configuration Change:** `onDestroy` -> `onCreate` (Activity recreated).
6.  **Fragment View:** Distinct from Fragment instance. View is destroyed on rotation.
7.  **ViewModel:** Survives rotation. Does not survive Process Death.
8.  **SavedStateHandle:** Survives Process Death.
9.  **Commit:** Use `commitNow` if you need the fragment immediately active.
10. **Memory Leak:** Keeping references to Context/View after `onDestroy` causes leaks.

### If-Else Decision Logic
*   **IF** you need to setup UI or ViewModels -> **Use** `onCreate`.
*   **ELSE IF** the user is leaving the app (Home/Power) -> **Pause** in `onPause`, **Release** in `onStop`.
*   **ELSE IF** the screen rotates -> **Save** in ViewModel/SavedStateHandle, **Restored** automatically in `onCreate`.
*   **ELSE IF** the app is swiped away or killed -> **Clean up** in `onDestroy`.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Activity & Fragment Lifecycles

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Activity Lifecycle (Chu kỳ đời hoạt động)**: The sequence of states an Activity goes through from creation to destruction, managed by the Android system.

**Fragment Lifecycle (Chu kỳ đời Fragment)**: The sequence of states a Fragment goes through, which is tied to its host Activity's lifecycle but adds specific states for UI integration.

**State Restoration (Khôi phục trạng thái)**: The mechanism to preserve UI data across configuration changes or process death using `Bundle`.

### Key Mental Model

Think of an Activity/Fragment as a living organism with 3 fundamental survival phases:
1. **Born** (`onCreate`, `onStart`): Setup visual structure and prepare data.
2. **Active** (`onResume`): Fully visible, interactive, consumes resources.
3. **Death** (`onPause`, `onStop`, `onDestroy`): Pause interactions, release heavy resources, save state.

### Why This Approach is Better

**Event-driven vs. Manual Management**: Android manages lifecycle automatically, preventing memory leaks and ensuring the system can kill apps safely without corrupting user data.

**Lifecycle Awareness**: Components react to system constraints (low memory, configuration changes) intelligently rather than crashing or losing data.

---

## SECTION 2: DECISION TABLES

### Table 1: Activity Lifecycle Callback - When to Use

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Initialize UI components | `onCreate()` | Called once when Activity is created. Safe to call `setContentView()` and `findViewById()` here. | Doing heavy operations (network calls) here, blocking UI startup. |
| Start user-visible operations | `onStart()` | Activity becomes visible. Start animations, update UI that user sees. | Forgetting to stop matching operations in `onStop()`, causing leaks. |
| Resume UI interactions | `onResume()` | Activity has focus. Resume camera, GPS, keyboard, animations. | Starting long-running operations here that should be in background threads. |
| Pause UI interactions | `onPause()` | Activity loses focus. Commit fragment transactions, pause animations, release input focus. | Doing heavy work here - slows down transition to next Activity. |
| Release non-UI resources | `onStop()` | Activity invisible. Release memory-heavy resources (Bitmaps, listeners). | Releasing UI resources here (causes null pointers if accessed in `onPause`). |
| Final cleanup | `onDestroy()` | Activity destroyed. Release static references, unregister callbacks. | Saving user data here (system may kill process before it executes). |

### Table 2: State Saving - When to Use

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Save temporary UI state | `onSaveInstanceState()` | System calls this before destruction. Save to `Bundle`. | Saving large data or non-serializable objects to Bundle. |
| Restore UI state | `onCreate(Bundle)` | Bundle is passed here when Activity is recreated. Check for null. | Assuming Bundle is never null (crashes on normal startup). |
| Save permanent data | `onPause()` or `onStop()` | Commit to database or file. User expects data loss prevention. | Waiting until `onDestroy()` - may not execute if process killed. |

### Table 3: Fragment vs Activity Lifecycle

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Fragment setup with Activity | `onAttach()` | Fragment attached to Activity. Safe to access Activity context. | Accessing Activity views here (not created yet). |
| Fragment UI setup | `onCreateView()` | Inflate Fragment's layout. Return root view. | Forgetting to return the view (Fragment shows nothing). |
| Post-view initialization | `onViewCreated()` | View is created. Setup click listeners, adapters here. | Doing view setup in `onCreate()` (view not ready). |
| Fragment ready | `onActivityCreated()` | Activity's `onCreate()` finished. Safe to access Activity. | Deprecated - use `onViewCreated()` or `onStart()`. |
| Fragment visibility | `onStart()` or `onResume()` | Match Activity's behavior for user-visible operations. | Not handling Fragment-specific visibility in nested Fragments. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Activity State Flow

```
[onCreate()] -> [onStart()] -> [onResume()] --> Activity Running
      |               |              |
      v               v              v
  [User Interaction]  |              |
      |               |              |
      v               v              v
  [onPause()] -> [onStop()] -> [onDestroy()]
      ^               ^              ^
      |               |              |
  [User Returns]  [Activity Hidden] [System Kills]
```

### Fragment State Flow

```
[onAttach() -> onCreate()] -> [onCreateView()] -> [onViewCreated()] -> [onStart()] -> [onResume()]
      |                              |                    |               |              |
      v                              v                    v               v              v
  [onPause()] -> [onStop()] -> [onDestroyView()] -> [onDestroy()] -> [onDetach()]
```

### Lifecycle Hierarchy

```
Activity
├── onCreate() -------------------------------------+
│                                                   |
├── onStart() -------------------------------------+| 
│                                                   ||
├── onResume() ------------------------------------+||--> Running State
│                                                   |||
├── onPause() --------------------------------------+||--> Lose Focus
│                                                   |||
├── onStop() ---------------------------------------+||--> Invisible
│                                                   |||
└── onDestroy() ------------------------------------+|--> Destroyed

Fragment (Attached to Activity)
├── onAttach() ------------------------------------+
│                                                   |
├── onCreate() -------------------------------------+
│                                                   |
├── onCreateView() --------------------------------+|
│                                                   |
├── onViewCreated() -------------------------------+|
│                                                   |
├── onStart() -------------------------------------+|--> Sync with Activity
│                                                   |
├── onResume() ------------------------------------+|
│                                                   |
├── onPause() --------------------------------------+
│                                                   |
├── onStop() ---------------------------------------+
│                                                   |
├── onDestroyView() -------------------------------+|
│                                                   |
├── onDestroy() -----------------------------------+
│                                                   |
└── onDetach() ------------------------------------+
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe State Restoration

**Khi nào dùng**: When your Activity can be destroyed and recreated (rotation, low memory).

**Tại sao đúng**: Separates initialization logic. Handles both cold start and state restoration safely.

```kotlin
class MainActivity : AppCompatActivity() {
    private var userInput: String = ""
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Restore state if available
        savedInstanceState?.let {
            userInput = it.getString("KEY_USER_INPUT", "")
        }
        
        // Always initialize UI
        setupUI()
    }
    
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // Save before potential destruction
        outState.putString("KEY_USER_INPUT", userInput)
    }
    
    private fun setupUI() {
        val editText = findViewById<EditText>(R.id.editText)
        editText.setText(userInput)
        editText.addTextChangedListener { userInput = it.toString() }
    }
}
```

### Pattern 2: Resource Management

**Khi nào dùng**: When using heavy resources (camera, sensors, listeners) that must be released.

**Tại sao đúng**: Prevents memory leaks and battery drain. Pairs acquisition with release.

```kotlin
class CameraActivity : AppCompatActivity() {
    private var camera: Camera? = null
    
    override fun onResume() {
        super.onResume()
        // Start resources
        camera = Camera.open()
    }
    
    override fun onPause() {
        super.onPause()
        // Release immediately
        camera?.release()
        camera = null
    }
}
```

### Pattern 3: Fragment View Setup

**Khi nào dùng**: Every Fragment with a UI that needs initialization.

**Tại sao đúng**: Ensures View exists before accessing it. Follows proper separation of concerns.

```kotlin
class UserFragment : Fragment() {
    private lateinit var adapter: UserAdapter
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        // Inflate layout
        return inflater.inflate(R.layout.fragment_user, container, false)
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // View is guaranteed to exist here
        val recyclerView = view.findViewById<RecyclerView>(R.id.recyclerView)
        
        adapter = UserAdapter()
        recyclerView.adapter = adapter
        
        // Restore state
        savedInstanceState?.let {
            val users = it.getParcelableArrayList<User>("KEY_USERS")
            adapter.submitList(users)
        }
    }
    
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putParcelableArrayList("KEY_USERS", ArrayList(adapter.currentList))
    }
}
```

### Pattern 4: Background Work Coordination

**Khi nào dùng**: When performing tasks that should survive config changes.

**Tài sao đúng**: Uses ViewModel to separate data from UI lifecycle. Activities/Fragments only observe.

```kotlin
class TaskViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data
    
    fun loadData() {
        viewModelScope.launch {
            // Simulate network call
            delay(2000)
            _data.postValue("Loaded Data")
        }
    }
}

class TaskFragment : Fragment() {
    private val viewModel: TaskViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // Load once, survives rotation
        if (viewModel.data.value == null) {
            viewModel.loadData()
        }
        
        viewModel.data.observe(viewLifecycleOwner) { result ->
            findViewById<TextView>(R.id.resultText)?.text = result
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern 1: Heavy Work in `onPause()`

**Code**:
```kotlin
override fun onPause() {
    super.onPause()
    // BAD: Database operation
    database.saveAllData() // Blocks next Activity
}
```

**Why dangerous**: `onPause()` blocks the next Activity from starting. User sees frozen screen.

**Correct approach**: Move heavy work to `onStop()` or background thread.

### Anti-Pattern 2: Saving Data in `onDestroy()`

**Code**:
```kotlin
override fun onDestroy() {
    super.onDestroy()
    // BAD: May never execute
    saveUserData()
}
```

**Why dangerous**: System may kill process before `onDestroy()` runs. Data is lost.

**Correct approach**: Use `onPause()` or `onStop()` for permanent data.

### Anti-Pattern 3: Accessing Views in `onCreate()` of Fragment

**Code**:
```kotlin
class BadFragment : Fragment() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // CRASH: View not created yet
        view.findViewById<TextView>(R.id.text).text = "Hello"
    }
}
```

**Why dangerous**: `onCreate()` is called before `onCreateView()`. View is null.

**Correct approach**: Access views in `onViewCreated()` or later.

### Anti-Pattern 4: Not Calling Super Methods

**Code**:
```kotlin
override fun onPause() {
    // BAD: Missing super
    releaseResources()
}
```

**Why dangerous**: System expects super to be called for proper lifecycle management. Can cause crashes or undefined behavior.

**Correct approach**: Always call super first or last unless documented otherwise.

### Anti-Pattern 5: Holding Context in Long-lived Objects

**Code**:
```kotlin
object BadSingleton {
    lateinit var context: Context // Stores Activity context
    
    fun init(context: Context) {
        this.context = context // Memory leak!
    }
}
```

**Why dangerous**: Prevents Activity from being garbage collected after destruction.

**Correct approach**: Use Application context for singletons, or use weak references.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

**Activity Lifecycle Order**:
```
Create → Start → Resume ↔ Pause ↔ Stop → Destroy
```

**Fragment Lifecycle Order**:
```
Attach → Create → CreateView → ViewCreated → Start → Resume ↔ Pause ↔ Stop → DestroyView → Destroy → Detach
```

**State Saving Flow**:
```
onSaveInstanceState() → Bundle → onCreate(Bundle) → Restore
```

**Resource Management**:
- **Start in**: `onResume()` or `onStart()`
- **Stop in**: `onPause()` or `onStop()` (opposite of start)

### Decision Logic (If-Else Style)

**What lifecycle method to use?**

```
IF you need to initialize UI or data once → onCreate()
ELSE IF you need to start something user sees → onStart()
ELSE IF you need to take user input focus → onResume()
ELSE IF you lose focus but visible → onPause()
ELSE IF you become invisible → onStop()
ELSE IF final cleanup needed → onDestroy()
```

**When to save state?**

```
IF data needed after rotation → onSaveInstanceState()
ELSE IF user data should never be lost → onPause() or onStop()
ELSE IF temporary UI state → onSaveInstanceState()
```

**Fragment View Access**

```
IF accessing views in Fragment → Use onViewCreated()
IF accessing Activity in Fragment → Use onAttach() or onActivityCreated()
IF showing/hiding UI → Use onStart() or onResume()
```

### Top 10 Things to Remember

1. **Always call super** lifecycle methods first.
2. **Never save data in onDestroy()** - use onPause() or onStop().
3. **View access only after onCreateView()** - preferably in onViewCreated().
4. **Release resources in opposite order** of acquisition.
5. **onPause() is for fast operations** - don't block UI thread.
6. **onStop() is for heavy cleanup** - Activity is invisible.
7. **Save state in onSaveInstanceState()** - restored in onCreate() via Bundle.
8. **Fragment lifecycle = Activity lifecycle + UI-specific callbacks**.
9. **Check Bundle != null** before reading - null on first creation.
10. **Test config changes** (rotation) and process death to verify lifecycle handling.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Fragment Lifecycles (Lesson 7)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **LifecycleOwner (Chủ sở hữu vòng đời):** Interface chỉ định rằng class này có vòng đời (Activity/Fragment). Nó cung cấp phương thức `getLifecycle()` để các component khác có thể lắng nghe.
*   **Lifecycle (Vòng đời):** Class trong `androidx.lifecycle` lưu trữ trạng thái hiện tại của Activity/Fragment và dispatch các sự kiện vòng đời khi trạng thái thay đổi.
*   **Lifecycle-Aware Component (Component nhận thức vòng đời):** Component điều chỉnh hành vi dựa trên vòng đời của `LifecycleOwner` (ví dụ: `LiveData` chỉ cập nhật UI khi Fragment đang `RESUMED`).

### Key Mental Model
Fragment không chỉ là một Class, nó là một **State Machine (Máy trạng thái)** chuyển đổi giữa Created, Started, Resumed, và Destroyed. View của Fragment tách biệt với vòng đời của Fragment chính nó. `onCreateView` có thể được gọi nhiều lần (khi xoay màn hình), nhưng `onCreate` chỉ gọi 1 lần trong vòng đời Fragment.

### Why This Approach
Sử dụng Lifecycle-Aware Components loại bỏ việc phải dọn dẹp thủ công (Memory Leaks) khi Activity/Fragment bị hủy. Framework tự quản lý việc đăng ký và hủy đăng ký (Attach/Detach) thay vì developer phải tự làm.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Khởi tạo View, inflate layout | **`onCreateView()`** | **`onCreateView` (Create View)**: Đây là nơi hệ thống yêu cầu Fragment trả về View. Trả về `null` nếu Fragment không có UI. | Không inflate layout trong `onCreate`. |
| Thiết lập listener, adapter sau khi View tạo | **`onViewCreated()`** | **`onViewCreated` (View Created)**: Được gọi *ngay sau* `onCreateView`. View đã tồn tại, an toàn để truy cập `findViewById`. | Logic phức tạp trong `onCreateView` làm code khó đọc. |
| Lưu state khi Fragment bị hủy (Process death) | **`onSaveInstanceState(outState: Bundle)`** | **`onSaveInstanceState` (Save State)**: Ghi đè dữ liệu cần giữ vào Bundle để khôi phục sau. | Lưu dữ liệu vào instance variable (biến thường) - dữ liệu sẽ mất khi process bị kill. |
| Khôi phục state đã lưu | **`onCreate()`, `onCreateView()`, `onViewCreated()`** | Nhận Bundle từ `onSaveInstanceState`. Nên khôi phục sớm trong `onCreate` hoặc `onViewCreated`. | Bỏ qua việc kiểm tra `savedInstanceState == null` để tránh ghi đè state khi quay lại từ `onStop`. |
| Vượt qua sự thay đổi cấu hình (Config Changes) | **ViewModel + `onViewCreated()`** | ViewModel không bị hủy khi xoay màn hình. Truy cập data từ ViewModel tại `onViewCreated`. | Lưu dữ liệu UI vào `onSaveInstanceState` quá nhiều (Bundle có giới hạn ~500KB). |
| Hoạt động nền (Background) | **`onPause()` -> `onStop()`** | Dừng các hoạt động ngốn pin, animations khi `onPause`. Tạm ẩn UI khi `onStop`. | Giữ Video/Animation chạy trong `onPause` (dễ gây crash hoặc pin tụt). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Fragment Lifecycle Hierarchy
Fragment lifecycle phụ thuộc vào Host Activity. Nếu Activity dừng, Fragment cũng dừng.

```text
[Activity Created] (or [Fragment attached via XML])
       ⬇
[Fragment.onAttach()]  <-- Fragment bắt đầu tồn tại trong memory
       ⬇
[Fragment.onCreate()]
       ⬇
[Fragment.onCreateView()]  <-- Tạo View Hierarchy
       ⬇
[Fragment.onViewCreated()]  <-- View đã sẵn sàng
       ⬇
[Fragment.onStart()]  <-- Fragment visible
       ⬇
[Fragment.onResume()]  <-- Fragment đang tương tác (Active)
       ⬇ (User navigates away OR Config Change)
[Fragment.onPause()]   <-- Mất tiêu điểm
       ⬇
[Fragment.onStop()]    <-- Không visible
       ⬇ (Config Change happens here -> Keep Fragment instance)
       ⬇ (OR User presses Back -> Destroy path)
[Fragment.onDestroyView()] <-- Xóa View (truy cập View sau bước này sẽ Crash)
       ⬇
[Fragment.onDestroy()]  <-- Clean up logic
       ⬇
[Fragment.onDetach()]   <-- Tách hoàn toàn khỏi Activity
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: State Restoration (Khôi phục trạng thái)
**Khi nào dùng:** Khi Fragment có thể bị hệ thống hủy (Process Death) và cần giữ lại dữ liệu nhập liệu (ví dụ: Text trong EditText).

**Tại sao đúng:** `onSaveInstanceState` là callback an toàn duy nhất để lưu data trước khi Activity bị kill.

```kotlin
class UserFormFragment : Fragment() {
    private var currentUserId: Int = -1

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Khôi phục ID ngay khi onCreate
        currentUserId = savedInstanceState?.getInt("KEY_USER_ID") ?: -1
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // Lưu data vào Bundle
        outState.putInt("KEY_USER_ID", currentUserId)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // Khôi phục UI state nếu có (Ví dụ: Checkbox checked)
        val isChecked = savedInstanceState?.getBoolean("KEY_CHECKED", false) ?: false
        binding.checkBox.isChecked = isChecked
    }
}
```

### Pattern 2: Safe View Binding (Truy cập View an toàn)
**Khi nào dùng:** Luôn luôn dùng khi cần truy cập View trong Fragment.

**Tại sao đúng:** Tránh Null Pointer Exception. View bị h hủy trong `onDestroyView`. Biến binding phải được set về `null` để tránh rò rỉ bộ nhớ.

```kotlin
class DashboardFragment : Fragment() {
    // Khai báo nullable
    private var _binding: FragmentDashboardBinding? = null
    // Property computed (throw exception if accessed after onDestroyView)
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentDashboardBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // An toàn để dùng binding在这里
        binding.btnSubmit.setOnClickListener {
            // Handle click
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        // CRITICAL: Prevent memory leak & crash
        _binding = null
    }
}
```

### Pattern 3: Lifecycle-Aware Logic (ViewModel)
**Khi nào dùng:** Khi cần fetch data từ network hoặc database và update UI.

**Tại sao đúng:** ViewModel sống sót qua xoay màn hình. Observer `LiveData` trong `onViewCreated` (hoặc `onStart`) để auto update UI.

```kotlin
class ProfileFragment : Fragment() {
    // Sử dụng by viewModels để có lifecycle scope chuẩn
    private val viewModel: ProfileViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Observe LiveData (An toàn, không lo leak)
        viewModel.userData.observe(viewLifecycleOwner) { user ->
            // Cập nhật UI chỉ khi Fragment visible
            binding.txtName.text = user.name
        }
        
        // Trigger load data
        viewModel.loadUser()
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Accessing View after `onDestroyView`
*   **Description:** Truy cập `binding` hoặc `view.findViewById` trong `onDestroy()`, `onDetach()` hoặc các background thread được khởi tạo từ `onViewCreated`.
*   **Tại sao nguy hiểm:** View đã bị xóa khỏi hierarchy. Dẫn đến **NullPointerException** hoặc **Memory Leak** (nếu View được giữ bởi thread đang chạy).
*   **Fix:** Dọn dẹp一切 trong `onDestroyView()` và hủy các Jobs/Coroutines liên quan đến UI.

### 2. Logic nặng trong `onCreateView`
*   **Description:** Đọc database, xử lý JSON, hoặc tính toán toán học phức tạp trong `onCreateView`.
*   **Tại sao nguy hiểm:** `onCreateView` cần trả về View nhanh để UI responsive. Nếu quá chậm, App sẽ bị "giật" (UI Freeze) khi navigate.
*   **Fix:** Dùng ViewModel để xử lý logic nặng. `onCreateView` chỉ nên inflate layout.

### 3. Dùng `getActivity()` trong Lambda/Callback
*   **Description:** `activity?.doSomething()` trong `onViewCreated` listener.
*   **Tại sao nguy hiểm:** `getActivity()` trả về `null` nếu Fragment đã bị detach. Nếu callback fire sau khi Fragment destroyed, app crash.
*   **Fix:** Sử dụng `viewLifecycleOwner.lifecycleScope.launch` hoặc kiểm tra `isAdded`.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules to Remember
1.  **`onViewCreated` là nơi set UI Listener.**
2.  **`onCreateView` là nơi Inflate Layout.**
3.  **`binding` phải set về `null` trong `onDestroyView`.**
4.  **`ViewModel` cho data logic (sống sót qua xoay màn hình).**
5.  **`onSaveInstanceState` cho UI state (sống sót qua Process Death).**
6.  **`viewLifecycleOwner` để Observe LiveData (An toàn hơn `this`).**
7.  **`onStop` là nơi dừng Animation/Video.**
8.  **`arguments` (Bundle) dùng để truyền data initialize (không dùng args cho data thay đổi).**
9.  **Fragment trong ViewPager2/FragmentContainerView cần `setMaxLifecycle` để tránh `onStop` vô tội vạ.**
10. **Truy cập Fragment qua ID Navigation phải xử lý Safe Args.**

### Decision Logic (If-Else)
*   **IF** Fragment starts and needs to inflate UI: **Use `onCreateView`**.
*   **IF** View is created and needs binding/listeners: **Use `onViewCreated`**.
*   **IF** App might get killed (Config Change/Background): **Use `ViewModel` + `onSaveInstanceState`**.
*   **IF** Fragment is hidden temporarily: **Use `onPause` -> `onStop`**.
*   **IF** Fragment is destroyed (not config change): **Use `onDestroyView` to clean View**.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Lifecycles, Observers & Back Stack
**Source: Lesson 7 Activity and Fragment Lifecycles**

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **LifecycleObserver (Người quan sát vòng đời):** An interface that allows a class to observe the lifecycle of a `LifecycleOwner`. It uses annotations like `@OnLifecycleEvent` to react to state changes.
*   **LifecycleOwner (Chủ thể vòng đời):** An object that has a lifecycle, such as an `Activity` or `Fragment`.
*   **Back Stack (Ngăn xếp hoạt động):** A stack structure that holds `Activity` or `Fragment` instances. The system manages this stack; the "Back" button pops the top element off.

### Mental Model: The Event Bus vs. The Stack
Think of **LifecycleObserver** as a subscriber on an event bus. You register it once, and it reacts to events (`ON_CREATE`, `ON_RESUME`) without the owner knowing the implementation details. This decouples logic (like location tracking) from the UI controller.

Think of the **Back Stack** as a stack of cards. You add a new card on top (`startActivity` or `navigate`). To go back, you remove the top card (`finish` or `popBackStack`). The card underneath is now visible.

### Why this approach is better
Using `LifecycleObserver` prevents memory leaks and keeps `Activity/Fragment` code clean ("Separation of Concerns"). Instead of writing lifecycle logic inside the controller, you encapsulate it in a reusable observer. Managing the Back Stack manually ensures predictable navigation flow, preventing users from getting stuck in infinite loops or losing their place.

---

## SECTION 2: DECISION TABLES

### Table 1: Lifecycle Management Strategy

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Need to perform an action based on another component's lifecycle (e.g., start/stop camera). | **LifecycleObserver** | **Decoupling (Giải ghép):** Keeps the logic separate from the UI controller. You can test the observer independently. | **Logic inside Activity:** Writing `onResume()` inside the Activity to manage a complex service, making the Activity bulky. |
| You are inside an Activity/Fragment and need to react to its own state changes. | **Direct Lifecycle methods** (`onCreate`, `onDestroy`) | **Simplicity (Đơn giản):** It is the native, expected place for UI-specific setup code. | **Over-engineering:** Creating a separate Observer class for simple UI logic that belongs right in the Activity. |

### Table 2: Navigation & Stack Management

| Use case (Tình huống sử dụng) | Nên dùng gì | Why (Tại sao) | Common mistake |
| :--- | :--- | :--- | :--- |
| User performs an action to go to a new screen (e.g., "Compose Email"). | **Add to Back Stack** (`addToBackStack`) | **Expectation (Kỳ vọng):** Users expect the Back button to return them to the previous state. | **Forgetting the flag:** Calling `startActivity` without planning for the return journey, leading to the app closing unexpectedly. |
| User presses "Back" to close the current screen. | **Pop from Back Stack** (System default) | **Lifecycle (Vòng đời):** Popping destroys the current view/fragment and resumes the previous one. | **Manual `finish()`:** Calling `finish()` in `onBackPressed()` manually, which might skip system cleanup or fragment transactions. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy: The Lifecycle Integration
The `Lifecycle` object acts as the bridge between the Android OS and your custom logic.

```text
[Android OS Event]
       |
       v
[LifecycleOwner (Activity/Fragment)]
       |
       v
[Lifecycle (State Machine)]
       |
       v
[LifecycleObserver (Custom Class)]
       |
       v
[Annotation (@OnLifecycleEvent)] -> [Method Execution]
```

### The Back Stack Flow
Visualizing the stack operations:

1.  **Initial State:**
    `Stack: [HomeActivity]`
2.  **Action:** User opens ComposeActivity (added to stack).
    `Stack: [HomeActivity, ComposeActivity]`
3.  **Action:** User opens AttachFileActivity (added to stack).
    `Stack: [HomeActivity, ComposeActivity, AttachFileActivity]`
4.  **Action:** User presses Back.
    `Stack: [HomeActivity, ComposeActivity]` (AttachFileActivity popped & destroyed).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Self-Managing Observer
**When to use:** When you have a component (like a LocationTracker or AnalyticsLogger) that needs to start/stop based on the Activity's lifecycle.

**Why this pattern is correct:** It encapsulates the "start/stop" logic. The Activity only cares about adding the observer, not managing the underlying threads or sensors.

**Code Demo:**
```kotlin
// 1. Define the Observer
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleObserver
import androidx.lifecycle.OnLifecycleEvent

class LocationObserver : LifecycleObserver {

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    fun startTracking() {
        println("DEBUG: Location tracking STARTED")
        // Logic to connect to GPS service
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    fun stopTracking() {
        println("DEBUG: Location tracking STOPPED")
        // Logic to disconnect from GPS service (Prevents Leaks!)
    }
}

// 2. Usage in Activity
class UserProfileActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Just add it. The observer handles the rest.
        lifecycle.addObserver(LocationObserver())
    }
}
```

### Pattern 2: Fragment Transaction with Back Stack
**When to use:** When replacing a Fragment and you want the "Back" button to bring the previous Fragment back, not close the Activity.

**Why this pattern is correct:** It explicitly tells the FragmentManager to save the transaction state, enabling "Undo" navigation.

**Code Demo:**
```kotlin
fun loadSecondFragment() {
    val transaction = supportFragmentManager.beginTransaction()
    
    // Replace current view with SecondFragment
    transaction.replace(R.id.fragment_container, SecondFragment())
    
    // CRITICAL: Add this transaction to the back stack
    // "name" is optional (tag for retrieval)
    transaction.addToBackStack(null) 
    
    transaction.commit()
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Memory Leaks via LifecycleObserver
**The Mistake:** Inside `ON_RESUME`, you start a long-running network request or a background thread, but you forget to cancel it in `ON_PAUSE` or `ON_DESTROY`.
**Why Dangerous:** Even if the Activity is destroyed, the Observer might still be alive or the thread keeps running, holding a reference to the dead Activity's Context. This crashes the app (Out of Memory).

### 2. Double-Initialization in Observers
**The Mistake:** Performing initialization logic (like `init {}` blocks or `ON_CREATE`) inside a `LifecycleObserver` that gets added multiple times.
**Why Dangerous:** If `lifecycle.addObserver(observer)` is called twice, your logic runs twice, potentially causing bugs or duplicate data.

### 3. Flat Back Stack
**The Mistake:** Using `Intent` flags like `FLAG_ACTIVITY_CLEAR_TASK` incorrectly, or never calling `addToBackStack` in Fragments.
**Why Dangerous:** If the Back Stack is empty, pressing the Back button exits the app immediately. Users lose their context and get frustrated.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules
1.  **Always Pair:** If you start it in `ON_RESUME`, stop it in `ON_PAUSE`.
2.  **Add to Stack:** If the user might want to go back to the previous screen, add the transaction to the Back Stack.
3.  **Observer Independence:** Your `LifecycleObserver` should not rely on the specific Activity class; rely only on the `Lifecycle` state.
4.  **Fragments are Managed:** Fragments don't exist on their own; they live inside the Activity's Back Stack.
5.  **Leak Prevention:** Background tasks + `Lifecycle` = Use `Coroutine` cancellation or `ON_DESTROY` cleanup.

### Decision Logic (If-Else)
*   **IF** you are writing code that controls hardware (Camera, GPS) inside an Activity -> **EXTRACT** to a `LifecycleObserver`.
*   **IF** `onBackPressed()` is being overridden to do custom logic -> **CHECK** if you really need to manage the stack manually or if `addToBackStack` handles it.
*   **IF** you are using `addToBackStack(null)` -> **REMEMBER** that the previous Fragment is now in a "Stopped" state, not destroyed.

<!-- CHUNK 41-46 -->

# Developer Decision Guide: Activity & Fragment Lifecycles (Lesson 7)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Lifecycle (Chu kỳ vòng đời)**: Represents the sequence of states an object (Activity/Fragment) passes through from creation to destruction.
- **Back Stack (Ngăn xếp trở lại)**: A collection of fragments organized in a stack where the last added fragment is shown first.
- **Bundle (Gói dữ liệu)**: A mapping of string keys to Parcelable values used to save state across configuration changes.

### Key Mental Model
Think of an **Activity** as the *room* containing your app, and **Fragments** as *furniture* inside that room.
1.  **Activity** controls the overall lifecycle of the screen.
2.  **Fragments** are hosted *inside* the Activity but manage their own lifecycle sub-states.
3.  **Back Stack** behaves like a stack of plates: `push` (add) new plates (fragments) on top, and `pop` (remove) the top plate when the user presses "Back".

**Why this is better:** It decouples UI components. You can reuse a `QuestionFragment` in different Activities or compose complex UIs (like a master-detail flow) without rewriting navigation logic.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common Mistone (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Saving data across rotation** | **ViewModel + onSaveInstanceState** | **Survival (Sống sót)**: ViewModel survives config changes; Bundle survives process death. Use both for robustness. | Storing only in ViewModel (lost on process death) or only in Bundle (verbose code). |
| **Implementing a Wizard (Step-by-step)** | **FragmentTransaction & addToBackStack** | **Navigation Flow (Luồng điều hướng)**: Allows users to go back to previous steps (Question1 -> Question2 -> Result). | Using `replace()` without adding to back stack, making the "Back" button exit the app instead of going to the previous step. |
| **Handling the "Back" button press** | **OnBackPressedCallback** | **Control (Kiểm soát)**: Intercept the back press to perform logic (save data, show dialog) before popping the fragment. | Ignoring the back press, leading to invalid state or lost data. |
| **Performing one-time setup logic** | **onViewCreated()** | **Safety (An toàn)**: View is guaranteed to be inflated. Avoid `onCreateView()` for view binding/listeners. | Putting heavy logic or navigation in `onCreateView()`, causing view lifecycle issues. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Lifecycle Hierarchy
The Activity is the parent; Fragments are children attached to the Activity's view hierarchy.

```text
[ Android OS ]
      |
      v
[ Activity Lifecycle ]
(OnCreate -> OnStart -> OnResume ...)
      |
      +--- [ Fragment Lifecycle ] (Attached to Activity Window)
           (onAttach -> onCreate -> onViewCreated -> onStart -> onResume ...)
           |
           +--- [ Back Stack ]
                (LIFO: Last In, First Out)
                [ Top: ResultFragment ]
                [      Question3Fragment ]
                [      Question2Fragment ]
                [ Bottom: Question1Fragment ]
```

### Navigation Flow Logic
1.  **Transaction**: `beginTransaction().replace(R.id.container, newFragment).addToBackStack(null).commit()`
2.  **Back Press**: System triggers `OnBackPressed`.
3.  **Action**: FragmentManager `pops` the top entry from the Back Stack.
4.  **Result**: The previous Fragment is re-inflated (if destroyed) or made visible (if stopped).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Safe Configuration Change" (State Saving)
**When to use (Khi nào dùng):** When you need to preserve user input (like text in an EditText) if the user rotates the phone.

**Why this pattern is correct:** It separates volatile UI state from complex data logic using `ViewModel` and uses `Bundle` as a safety net for process death.

```kotlin
class QuestionFragment : Fragment() {
    // 1. Use ViewModel for logic
    private val viewModel: QuestionViewModel by viewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        // 2. Restore UI state from Bundle if available
        savedInstanceState?.getString("KEY_INPUT")?.let { savedText ->
            binding.editText.setText(savedText)
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // 3. Save critical UI state to Bundle
        outState.putString("KEY_INPUT", binding.editText.text.toString())
    }
}
```

### Pattern 2: Managing Custom Back Stack (The Wizard)
**When to use (Khi nào dùng):** Creating multi-step flows where the user must complete steps sequentially (e.g., Welcome -> Question1 -> Result).

**Why this pattern is correct:** `addToBackStack()` allows the FragmentManager to destroy the current fragment but keep the previous one in memory (or restore it), creating a seamless history.

```kotlin
fun navigateToNextFragment(currentFragment: Fragment, nextFragment: Fragment) {
    currentFragment.parentFragmentManager.beginTransaction().apply {
        // Replace current view with next fragment
        replace(R.id.fragment_container, nextFragment)
        // IMPORTANT: Add this transaction to the back stack
        addToBackStack(null) 
        commit()
    }
}
// Result: Pressing Back now returns to 'currentFragment' instead of closing Activity.
```

### Pattern 3: Intercepting Back Press
**When to use (Khi nào dùng):** When a fragment needs to stop the user from leaving immediately (e.g., "You have unsaved changes").

**Why this pattern is correct:** It integrates with the Activity's `OnBackPressedDispatcher` to handle events reactively.

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    // This callback runs when the back button is pressed
    val callback = requireActivity().onBackPressedDispatcher.addCallback(this) {
        // Logic to run before popping
        if (hasUnsavedChanges()) {
            showSaveDialog()
        } else {
            // Allows the default back behavior to happen (pop fragment)
            isEnabled = false 
            requireActivity().onBackPressed()
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Naked Transaction"
**Danger:** Calling `commit()` without `addToBackStack()`.
**Why dangerous:** The fragment replacement is permanent. The user cannot go back to the previous state. It acts like a "Forward" only button.
**Fix:** Always use `.addToBackStack(null)` if you expect the user to return to the previous step.

### 2. Logic in `onCreateView()`
**Danger:** Setting click listeners or modifying views directly in `onCreateView()`.
**Why dangerous:** This method may be called multiple times or when the view is not fully attached to the window, leading to `NullPointerException`.
**Fix:** Move all view logic to `onViewCreated()`.

### 3. Holding Context in Fragments
**Danger:** Storing a reference to the Activity (`var context: Context? = null`) in a variable.
**Why dangerous:** Causes memory leaks. The Fragment will outlive the Activity if not handled correctly.
**Fix:** Use `requireContext()` or `requireActivity()` inside methods when needed, or use the `viewLifecycleOwner` scope.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
```text
IF (User needs to go back to previous step) -> THEN use .addToBackStack()
ELSE IF (User needs to start fresh, no history) -> THEN skip .addToBackStack()
ELSE IF (Config change happens (rotate)) -> THEN use ViewModel
ELSE IF (Process death happens) -> THEN use onSaveInstanceState (Bundle)
```

### Quick Reference Rules
1.  **addToBackStack(null)** = Enables the "Back" button to return to the previous fragment.
2.  **replace()** = Removes old fragment, adds new one.
3.  **onViewCreated()** = Safe place to init UI listeners.
4.  **popBackStack()** = Programmatically remove the top fragment (simulate back press).

### Top 3 Things to Remember
1.  **Lifecycle is hierarchical:** Activity stops -> Fragments stop.
2.  **Back Stack is LIFO:** The last fragment added is the first one removed.
3.  **State requires two layers:** ViewModel (Rotation) + Bundle (Process Death).