# DEVELOPER DECISION GUIDE: Lesson 11 Connect to the internet .pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:13:50



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: LESSON 11 - CONNECT TO THE INTERNET

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Permission (Quyền truy cập)**: Rules defining what sensitive resources (camera, internet, storage) an app can access.
- **Normal Permission (Quyền thông thường)**: Low-risk permissions automatically granted at install time. No user prompt required.
- **Dangerous Permission (Quyền nguy hiểm)**: High-risk permissions (privacy/security related). Requires explicit user approval at runtime.
- **Manifest (Tệp kê khai)**: `AndroidManifest.xml` file where all permissions must be declared before use.

### The Reality of Networking
Unlike web browsers, Android apps are sandboxed. You cannot access the internet just by writing code; you must explicitly ask the system for permission. This is a two-step process:
1.  **Declare**: State your intent in the Manifest.
2.  **Request** (if dangerous): Ask the user politely during runtime.

### Why This Approach is Better
This "Ask First" model protects user privacy. It prevents malicious apps from silently harvesting data (contacts, location, photos) without the user knowing. It forces developers to be transparent.

---

## SECTION 2: DECISION TABLES

### Table 1: Permission Selection
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **App needs to load a webpage or API data** | `android.permission.INTERNET` | **Normal Permission**: Granted automatically. Safe. | Not adding it to Manifest, then wondering why `SocketException` occurs. |
| **App needs to check Wi-Fi status before downloading** | `android.permission.ACCESS_NETWORK_STATE` | **Normal Permission**: Checks if network is available without leaking privacy. | Assuming the internet is always available. Use this to check connectivity first. |
| **App needs to read user contacts** | `android.permission.READ_CONTACTS` | **Dangerous Permission**: Requires `requestPermissions` call at runtime. | Only declaring in Manifest but not handling the runtime user "Allow/Deny" logic. |

### Table 2: Runtime Handling
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **User denies permission** | Show a dialog explaining *why* it's needed, then exit gracefully. | **Fallback**: Don't crash. The app should still run if possible (e.g., show a "No Internet" icon). | Assuming permission is always granted. |
| **User checks "Don't ask again"** | Direct user to App Settings to manually enable it. | **System Limitation**: You cannot prompt again programmatically. | Spamming the user with permission requests that will be ignored. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Permission Lifecycle Flowchart
```text
[Developer Writes Code]
       |
       v
[AndroidManifest.xml] <--- (1. Declaration: Always required)
       |
       v
[App Installation] --------> [Normal Permission] ----> [GRANTED]
       |
       v
[User Launches Feature]
       |
       v
[Dangerous Permission?] ----> NO ---> [App Functions]
       |
       YES
       |
       v
[Runtime Request Popup] ---> [User Action]
                                  |
             +--------------------+--------------------+
             |                                        |
        [ALLOWED]                               [DENIED]
             |                                        |
             v                                        v
    [Feature Executes]                        [Graceful Fallback]
                                               (Show error/message)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Declaring Permissions (Manifest)
**When to use:** Always. This is the prerequisite for any network operation or hardware access.

**Why this pattern is correct:** The Android OS reads this file *before* your code runs. Without it, the OS kills the app for security violations.

```xml
<!-- File: app/src/main/AndroidManifest.xml -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.internetapp">

    <!-- Required for basic internet access -->
    <uses-permission android:name="android.permission.INTERNET" />

    <!-- Required to check connectivity state (Wi-Fi/Mobile) -->
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        ... >
        <!-- Activities go here -->
    </application>
</manifest>
```

### Pattern 2: Requesting Dangerous Permissions (Runtime)
**When to use:** When accessing Contacts, Camera, Location, Storage (API 23+).

**Why this pattern is correct:** It complies with Google Play policies and ensures the app doesn't crash on Android 6.0+.

```kotlin
// File: MainActivity.kt
class MainActivity : AppCompatActivity() {

    // 1. Define the permission you need
    private val REQUEST_CODE_CAMERA = 100

    fun onOpenCameraClicked() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) 
            == PackageManager.PERMISSION_GRANTED) {
            // Permission already granted, open camera
            startCamera()
        } else {
            // Permission not granted, request it
            ActivityCompat.requestPermissions(
                this,
                arrayOf(Manifest.permission.CAMERA),
                REQUEST_CODE_CAMERA
            )
        }
    }

    // 2. Handle the user's response
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        
        if (requestCode == REQUEST_CODE_CAMERA) {
            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // User said YES
                startCamera()
            } else {
                // User said NO (or "Don't ask again")
                Toast.makeText(this, "Camera permission required to take photos", Toast.LENGTH_SHORT).show()
            }
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern: "Just Hardcode It"
**Practice:** Assuming `Manifest.xml` is optional or that permissions are implied.
**Why Dangerous:** Your app will crash immediately with `SecurityException` or `SocketException`. The Play Store will reject it.

### Anti-Pattern: Ignoring "Don't Ask Again"
**Practice:** Calling `requestPermissions` repeatedly if the user denies.
**Why Dangerous:** It annoys the user. If they checked "Don't ask again", your request returns `PERMISSION_DENIED` immediately without showing a dialog. You must detect this and guide them to Settings.

### Anti-Pattern: Blocking UI Thread for Network
**Practice:** Making a network call (downloading image/data) directly on the main thread.
**Why Dangerous:** Android freezes the UI (App Not Responding) if network takes more than 5 seconds.
**Solution:** Use **Coroutines (Tiến trình rút gọn)** or **WorkManager (Quản lý công việc)** to run in background.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Manifest First:** Always check `AndroidManifest.xml` first.
2.  **Normal vs. Dangerous:** 
    *   Normal: Declare only.
    *   Dangerous: Declare + Runtime Code.
3.  **Check State:** Use `ACCESS_NETWORK_STATE` to verify connection before downloading.

### Decision Logic (If-Else)
```text
IF (Permission is Normal: e.g., INTERNET)
THEN
    Just add to AndroidManifest.xml
ELSE (Permission is Dangerous: e.g., CAMERA, READ_CONTACTS)
THEN
    1. Add to AndroidManifest.xml
    2. Check.checkSelfPermission() at runtime
    3. IF not granted -> requestPermissions()
    4. Handle onRequestPermissionsResult()
```

### Top 3 Things to Remember
1.  **INTERNET is Normal:** You don't need to ask the user to "allow internet", just declare it.
2.  **Manifest is not enough:** For dangerous permissions on API 23+, code is required.
3.  **Fail Gracefully:** If permission is denied, show a message, don't crash.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Connect to the Internet (Lesson 11)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Retrofit (Thư viện truy vấn API)**: Một thư viện mạng biến HTTP API thành một giao diện Kotlin/Java, tự động xử lý chuyển đổi request/response thành objects.
- **Moshi (Trình chuyển đổi JSON)**: Thư viện phân tích cú pháp JSON thành đối tượng Kotlin và ngược lại (JSON Parser/Converter).
- **Suspend Function (Hàm hoãn)**: Hàm có thể thực thi bất đồng bộ mà không blocking thread chính, bắt buộc khi gọi mạng trong Kotlin.
- **Converter Factory (Bộ chuyển đổi)**: Cơ chế ánh xạ dữ liệu thô (JSON/XML) từ network response thành các đối tượng trong app.

### Key Mental Model
Hệ thống hoạt động theo mô hình **Declarative Interface (Giao diện khai báo)**:
1. Bạn **khai báo** interface mô tả API (URL, method, parameters).
2. Retrofit **tự sinh ra** code thực thi network request.
3. Moshi Converter **tự động chuyển đổi** JSON ↔ Object.
4. Kết quả trả về là `suspend` function → dễ dàng integrate với Coroutine (Coroutines).

**Tại sao tốt hơn**: Thay vì tự viết `HttpURLConnection`, `OkHttp` client hay xử lý JSON thủ công (dễ sai, phức tạp), Retrofit cung cấp abstraction layer an toàn, type-safe và giảm boilerplate code đáng kể.

---

## SECTION 2: DECISION TABLES

### Table 1: Networking Library Choice

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term | Sai lầm thường gặp |
|---|---|---|---|
| **Simple API calls (Gọi API đơn giản)** | Retrofit + Moshi | **Type-Safety (An toàn kiểu dữ liệu)**: Tránh runtime error khi parse JSON. | Tự implement `JSONObject` thủ công → dễ crash khi API đổi format. |
| **High performance/Real-time** | OkHttp directly + WebSocket | **Low-level Control (Kiểm soát tầng thấp)**: Tối ưu connection pooling, cache manual. | Dùng Retrofit cho WebSocket → không hiệu quả, dư thừa abstraction. |
| **Testing network logic** | MockWebServer (cùng Retrofit) | **Isolation (Cô lập)**: Mô phỏng server response mà không cần mạng thật. | Gọi API thật trong unit test → chậm, không ổn định, dễ vượt quá quota. |
| **No external lib allowed** | `HttpClient` (Android 14+) / `HttpURLConnection` | **Built-in (Có sẵn)**: Tiết kiệm bộ nhớ, không cần thêm dependency. | Viết wrapper thủ công quá phức tạp → tái tạo lại Retrofit sai cách. |

### Table 2: HTTP Method Usage

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term | Sai lầm thường gặp |
|---|---|---|---|
| **Lấy dữ liệu (Read)** | `@GET` | **Idempotent (Bất biến)**: Request nhiều lần không thay đổi trạng thái server. | Dùng `@POST` để lấy dữ liệu → vi phạm RESTful principle, không cache được. |
| **Tạo mới (Create)** | `@POST` | **State Change (Thay đổi trạng thái)**: Tạo resource mới trên server. | Dùng `@GET` với body → server có thể bỏ qua body, không support. |
| **Cập nhật toàn bộ (Update All)** | `@PUT` | **Replace (Thay thế)**: Thay thế hoàn toàn resource cũ. | Lạm dụng `@PATCH` khi cần update toàn bộ → không rõ ràng. |
| **Xóa (Delete)** | `@DELETE` | **Removal (Xóa bỏ)**: Xóa resource khỏi server. | Quên truyền ID trong path → 404 Not Found. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy Flow
```text
[ App Logic (ViewModel/Repository) ]
         ↓ (Gọi suspend function)
[ Retrofit Service Interface ] 
         ↓ (Sinh request tự động)
[ Retrofit Builder Instance ]
         ↓ (Chuyển đổi data)
[ Converter Factory (Moshi) ]
         ↓ (Gửi/Nhận qua HTTP)
[ OkHttp Client (Underlying) ]
         ↓ (Xử lý kết nối)
[ Internet / Server API ]
```

### Component Relationships
- **Retrofit** là **Facade (Lớp vỏ bọc)** bao quanh **OkHttp**.
- **Service Interface** định nghĩa contract (hợp đồng) giữa App và Server.
- **Converter** là plug-in: `addConverterFactory()` kết nối Retrofit với Moshi.
- **baseUrl** phải kết thúc bằng `/` (vd: `https://api.example.com/`).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Setup & GET Request

**Khi nào dùng**: Khi cần gọi API RESTful để lấy danh sách dữ liệu (JSON).

**Tại sao đúng**: Sử dụng `suspend` function để không blocking UI thread, Moshi tự động map JSON key ↔ Kotlin property.

```kotlin
// 1. Define Data Model (Data Class)
data class Post(
    val id: Int,
    val title: String,
    val body: String
)

// 2. Define Service Interface
interface PostService {
    @GET("posts")
    suspend fun getPosts(): List<Post>
}

// 3. Setup Retrofit Instance (Singleton recommended)
val moshi = Moshi.Builder().add(KotlinJsonAdapterFactory()).build()

val retrofit = Retrofit.Builder()
    .baseUrl("https://jsonplaceholder.typicode.com/") // Phải có '/'
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .build()

// 4. Create Service & Call
val service = retrofit.create(PostService::class.java)

// Trong ViewModel hoặc CoroutineScope
scope.launch {
    try {
        val posts = service.getPosts()
        // Update UI with posts
    } catch (e: Exception) {
        // Handle network error
    }
}
```

### Pattern 2: Path Parameter & Query Parameter

**Khi nào dùng**: Khi cần lọc dữ liệu theo ID hoặc tìm kiếm (Search).

**Tại sao đúng**: Retrofit tự động insert giá trị vào URL `{placeholder}` hoặc append `?key=value`.

```kotlin
interface PostService {
    // Path: /posts/1 (ID thay đổi trực tiếp trong path)
    @GET("posts/{id}")
    suspend fun getPostById(@Path("id") postId: String): Post

    // Query: /posts/search?filter=android (Parameter append sau dấu ?)
    @GET("posts/search")
    suspend fun searchPosts(@Query("filter") query: String): List<Post>
    
    // Multiple Query: /posts?userId=1&_limit=5
    @GET("posts")
    suspend fun getPostsByUser(
        @Query("userId") userId: Int,
        @Query("_limit") limit: Int
    ): List<Post>
}
```

### Pattern 3: POST Request with Body

**Khi nào dùng**: Khi gửi dữ liệu mới lên server (Submit form, Register).

**Tại sao đúng**: Annotation `@Body`告诉Retrofit sử dụng Converter để serialize object thành JSON payload.

```kotlin
interface PostService {
    @POST("posts")
    suspend fun createPost(@Body post: Post): Post
}

// Usage
val newPost = Post(id = 0, title = "New Title", body = "Content")
scope.launch {
    try {
        // Retrofit tự động convert newPost thành JSON body
        val createdPost = service.createPost(newPost)
    } catch (e: Exception) {
        // Handle error
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Blocking Network on Main Thread
**Danger**: gọi suspend function mà không dùng `launch`/`async` hoặc dùng `Thread.sleep()` trong UI thread.
**Why**: Gây ra `NetworkOnMainThreadException` hoặc làm UI bị freeze (giật lag).
**Fix**: Luôn wrap network call trong `CoroutineScope` (IO dispatcher).

### 2. Wrong Base URL Format
**Danger**: `baseUrl("https://api.example.com")` (thiếu dấu `/` cuối).
**Why**: Retrofit ném `IllegalArgumentException` hoặc request sai endpoint (vd: `https://api.example.composts` thay vì `https://api.example.com/posts`).

### 3. Missing Moshi Annotation
**Danger**: Data class Kotlin có property `val name: String` nhưng JSON key là `user_name`.
**Why**: Parse null hoặc crash vì property mismatch.
**Fix**: Dùng `@Json(name = "user_name")` annotation.

```kotlin
import com.squareup.moshi.Json

data class User(
    @Json(name = "user_name") 
    val name: String
)
```

### 4. Forgetting Gradle Kapt/KSP
**Danger**: Sử dụng Moshi với `@Json` nhưng không enable code generator.
**Why**: Runtime error: "Moshi cannot reflect... requires code generation".
**Fix**: Add `kapt` hoặc chuyển sang KSP trong `build.gradle`.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Retrofit** = Builder + Interface + Converter.
2. **Moshi** = JSON ↔ Object (Dùng `KotlinJsonAdapterFactory`).
3. **Suspend** = Bắt buộc cho network calls trong Kotlin.
4. **BaseUrl** = Phải kết thúc bằng `/`.
5. **Annotations**:
   - `@GET("path")`: Lấy data.
   - `@POST("path")`: Gửi data mới.
   - `@Path("id")`: Thay thế `/path/{id}`.
   - `@Query("key")`: Append `?key=value`.
   - `@Body`: Gửi JSON object.

### Decision Logic (If-Else)
- **If** (API trả về JSON) → Dùng Retrofit + Moshi Converter.
- **If** (Cần upload file/large data) → Dùng `@Body` với `RequestBody` hoặc `Multipart`.
- **If** (Cần Retry/Cache logic thủ công) → Config OkHttp Client trước khi build Retrofit.
- **If** (API không có JSON body) → Vẫn dùng Retrofit nhưng Converter có thể không cần.

### Top 10 Things to Remember
1. Đừng bao giờ gọi API trực tiếp trên Main Thread.
2. Luôn xử lý Exception trong Coroutine (`try-catch`).
3. Interface Retrofit chỉ định nghĩa, không implement code.
4. `suspend` function trả về `List<T>` hoặc `T` (dữ liệu đã parse sẵn).
5. Postman/Insomnia dùng để test API trước khi code.
6. Dùng `@QueryMap` nếu có quá nhiều query parameters.
7. API Key nên gửi qua Header (`@Header`), không hardcode trong URL.
8. Network request chạy trên IO Dispatcher (background thread).
9. Debug network traffic bằng **OkHttp Interceptor**.
10. Kiểm tra `build.gradle` đã add cả Retrofit, Converter, Moshi chưa.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Lesson 11 - Connect to the Internet

## SECTION 1: CORE MENTAL MODEL

**Mục tiêu chính:** Xây dựng cầu nối an toàn giữa UI (ViewModel) và Web API (Server) bằng cách chuyển đổi JSON thành Object (Data Class) và tải dữ liệu异步 (Asynchronous).

**Core Definitions:**
- **Retrofit (Framework API):** Library quản lý HTTP Request, tự động chuyển đổi Response thành Object qua Converter.
- **Moshi (JSON Parser):** Thư viện đọc/ghi JSON, biến chuỗi JSON thành Data Class.
- **Converter.Factory:** "Trình thông dịch" giữa định dạng mạng (JSON) và code Kotlin (Object).

**Real-world Mental Model:**
1. **UI (ViewModel)** yêu cầu "Lấy dữ liệu".
2. **Retrofit** gửi HTTP Request đến URL.
3. **Server** trả về chuỗi JSON thô.
4. **Moshi** nhận JSON, đọc annotation `@JsonClass`, tạo Object.
5. **ViewModel** nhận Object và cập nhật UI.

**Lý do tốt hơn:** So với việc tự xử lý `InputStream` hay `JSONObject` thủ công, Retrofit + Moshi giúp code gọn, an toàn (Type-safe), và xử lý lỗi/network tự động.

---

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **API trả về JSON** | `MoshiConverterFactory` | **Type-safe conversion**: Đảm bảo dữ liệu khớp với Data Class, tránh lỗi runtime. | Dùng `ScalarsConverterFactory` (trả về String) rồi tự parse JSON thủ công. |
| **Cần tải ảnh từ URL** | `Glide` | **Performance**: Xử lý cache, tải song song, giảm giật lag khi scroll. | Dùng `BitmapFactory.decodeStream` thủ công, không cache, gây lag & crash OutOfMemory. |
| **API trả về lỗi (404, 500)** | Retrofit + `try-catch` trong Coroutine | **Structured Concurrency**: Bắt lỗi rõ ràng, không crash app. | Bỏ qua xử lý lỗi, để UI treo vĩnh viễn. |
| **Data class có field nullable** | Dùng `?` trong Kotlin | **Null Safety**: Tránh crash khi JSON thiếu field. | Ép kiểu (`!!`)导致 `NullPointerException`. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Hierarchy Flow:**
```text
[ UI Layer (Fragment/Activity) ]
       |
       ↓ (Observe LiveData/StateFlow)
[ ViewModel (Business Logic) ]
       |
       ↓ (Call suspend function)
[ Retrofit Service (Network Layer) ]
       | (Request: HTTP GET/POST)
       ↓
[ Web API (Server) ]
       | (Response: JSON String)
       ↓
[ Moshi Converter ] <--- (Configured via Converter.Factory)
       | (Parse → Object)
       ↓
[ Data Class (Model) ]
```

**Component Relationships:**
- `Retrofit.Builder` là **Root**, chứa `BaseUrl` và `ConverterFactory`.
- `ConverterFactory` (Moshi) hoạt động như một **Decoder**.
- `ViewModel` phụ thuộc vào `Retrofit Service` (không phụ thuộc vào UI).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Cấu hình Retrofit & Moshi
**Khi nào dùng:** Khởi tạo app hoặc Singleton scope.
**Tại sao đúng:** Tái sử dụng Builder, đảm bảo thread-safe qua `lazy`.

```kotlin
// 1. Data Class với annotation Moshi
@JsonClass(generateAdapter = true)
data class Post(
    val title: String,
    val description: String,
    val url: String,
    val updated: String,
    val thumbnail: String,
    val closedCaptions: String? // Nullable field
)

// 2. Service Interface
interface SimpleService {
    @GET("posts")
    suspend fun searchPosts(@Query("q") query: String): List<Post>
}

// 3. Singleton setup
private val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory()) // Bắt buộc cho Kotlin
    .build()

private val retrofit = Retrofit.Builder()
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .baseUrl("https://api.example.com/") // Phải kết thúc bằng /
    .build()

object API {
    val retrofitService: SimpleService by lazy {
        retrofit.create(SimpleService::class.java)
    }
}
```

### Pattern 2: gọi API trong ViewModel
**Khi nào dùng:** Khi UI yêu cầu dữ liệu.
**Tại sao đúng:** Sử dụng `viewModelScope` để lifecycle-aware, tự động hủy khi UI hủy.

```kotlin
class PostViewModel : ViewModel() {
    // Giả sử có LiveData hoặc StateFlow cho UI
    private val _posts = MutableLiveData<List<Post>>()
    val posts: LiveData<List<Post>> = _posts

    fun fetchPosts(query: String) {
        viewModelScope.launch {
            try {
                // Gọi suspend function
                val result = API.retrofitService.searchPosts(query)
                _posts.value = result
            } catch (e: Exception) {
                // Xử lý lỗi network/parsing
                Log.e("ViewModel", "Error fetching data", e)
            }
        }
    }
}
```

### Pattern 3: Tải và hiển thị ảnh với Glide
**Khi nào dùng:** Khi cần load ảnh từ URL vào ImageView.
**Tại sao đúng:** Xử lý async, cache, và lifecycle tự động.

```kotlin
// build.gradle (Module)
implementation "com.github.bumptech.glide:glide:4.16.0"

// Trong Adapter hoặc Fragment
Glide.with(context) // Context hoặc View
    .load(post.thumbnail) // URL String
    .centerCrop() // Hiệu ứng crop
    .placeholder(R.drawable.loading_shape) // Ảnh Loading
    .error(R.drawable.error_shape) // Ảnh khi lỗi
    .into(imageView) // Target view
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Không sử dụng `KotlinJsonAdapterFactory`**
- **Nguy hiểm:** Moshi không thể đọc được Data Class của Kotlin, gây lỗi parsing hoặc crash.
- **Lỗi:** Dùng thư viện JSON khác mà không cấu hình đúng `Converter`.

**2. BaseURL không kết thúc bằng `/`**
- **Nguy hiểm:** Retrofit cắt phần path, dẫn đến URL sai (`https://api.comv1` thay vì `https://api.com/v1`).
- **Lỗi:** 404 Not Found không rõ nguyên nhân.

**3. Gọi API trực tiếp từ UI (Activity/Fragment)**
- **Nguy hiểm:** Gây blocking UI thread, ANR (App Not Responding).
- **Lỗi:** Quên dùng `CoroutineScope` (viewModelScope).

**4. Không xử lý `Exception` trong Coroutine**
- **Nguy hiểm:** Lỗi network (timeout, No Internet) sẽ crash app nếu không có `try-catch`.
- **Lỗi:** Dùng `launch` mà không có `CoroutineExceptionHandler`.

**5. Để field non-null nhưng JSON trả về null**
- **Nguy hiểm:** `JsonDataException` từ Moshi, crash app.
- **Lỗi:** Thiếu `?` trong Data Class hoặc annotation `@Json(ignore = true)`.

---

## SECTION 6: MASTER CHEAT SHEET

**Quick Reference Rules:**
1. **Moshi:** Luôn dùng `@JsonClass(generateAdapter = true)` và `KotlinJsonFactory`.
2. **Retrofit:** URL cuối phải có `/`.
3. **Network:** Luôn gọi trong `viewModelScope.launch`.
4. **Image:** Dùng Glide, không dùng Bitmap thủ công.

**Decision Logic (If-Else):**
- **IF** API trả về JSON -> **THEN** Dùng `Retrofit + Moshi`.
- **IF** Cần hiển thị ảnh từ URL -> **THEN** Dùng `Glide`.
- **IF** Field có thể null -> **THEN** Dùng `?` trong Data Class.
- **IF** Lỗi network -> **THEN** Bắt `Exception` trong `try-catch`.

**Top 5 Things to Remember:**
1. `viewModelScope` = Auto-cancel & Background thread.
2. `suspend` function = Await result without blocking.
3. `Converter` = JSON ↔ Object translator.
4. `Glide` = Image loader (cache + performance).
5. `BaseURL` = Must end with `/`.

<!-- CHUNK 31-37 -->

# DEVELOPER DECISION GUIDE: Connect to the Internet (Lesson 11)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Retrofit (Bộ chuyển đổi API)**: A type-safe HTTP client for Android and Java that turns API interfaces into callable objects.
- **Moshi (Bộ phân tích JSON)**: A modern JSON library for Kotlin and Java that converts JSON strings into Kotlin objects and vice versa.
- **Glide (Bộ tải ảnh)**: An image loading and caching library for Android that handles networking, decoding, and memory/disk caching for images.
- **RequestOptions (Tùy chọn yêu cầu)**: A configuration object for Glide to customize image loading behaviors like placeholders, error images, and transformations.

### Key Mental Models
- **Declarative Configuration**: Instead of writing imperative logic for every network request (e.g., manually handling error cases or loading states), you define a reusable configuration (`RequestOptions`) and apply it declaratively to multiple requests.
- **Separation of Concerns**: Network logic (Retrofit), Data parsing (Moshi), and UI loading (Glide) are distinct layers. You use Retrofit/Moshi to fetch data, then pass that data to Glide to display it, keeping your code modular.

### Why This Approach is Better
Using a dedicated client like **Retrofit** is superior to standard `HttpURLConnection` because it reduces boilerplate, enforces type safety (preventing runtime crashes from malformed data), and integrates seamlessly with **Moshi** for automatic JSON parsing. **Glide** is better than manually downloading images and caching them because it performs these operations asynchronously off the main thread and manages memory automatically to prevent `OutOfMemoryError`.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Fetching structured data (JSON) from an API | **Retrofit + Moshi** | **Type Safety (An toàn kiểu dữ liệu)**: Moshi maps JSON to Kotlin data classes automatically, catching parsing errors early. | Using string manipulation to parse JSON manually. This is error-prone and hard to maintain. |
| Displaying a remote image in an `ImageView` | **Glide** | **Performance & Caching (Hiệu suất & Bộ nhớ đệm)**: Glide handles background threading, memory management, and disk caching automatically. | Downloading images on the main thread using `URL.getInputStream()`. This freezes the UI (ANR). |
| Handling different states (Loading, Success, Error) for network requests | **RequestOptions in Glide** | **Consistency (Tính nhất quán)**: Centralizes placeholder/error logic so you don't repeat `if/else` statements for every image. | Adding visibility logic (GONE/VISIBLE) inside the Activity/Fragment for every single image load. |
| Requesting user permission for internet access | **AndroidManifest.xml** | **Requirement (Yêu cầu)**: Android requires explicit declaration of permissions. | Forgetting to add `<uses-permission android:name="android.permission.INTERNET" />`. The app will crash when trying to connect. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Data Flow: API to UI
This flow describes how data moves from the internet to the user's screen using the libraries discussed.

```text
[ Internet ]
     |
     v
[ Retrofit API Call ] <--- Defines Endpoints & Base URL
     |
     v
[ Raw JSON Response ]
     |
     v
[ Moshi Parser ] <--- Converts JSON -> Kotlin Data Class
     |
     v
[ ViewModel / Logic ] <--- Receives Data Class Object
     |
     v
[ Glide Image Loader ] <--- Applies Options (Placeholder/Error)
     |
     v
[ ImageView (UI) ] <--- Image Displayed
```

### Component Responsibilities
- **Retrofit**: "How do I talk to the server?"
- **Moshi**: "How do I understand the server's response?"
- **Glide**: "How do I show the data (images) efficiently on screen?"
- **Manifest**: "Does the app have permission to go online?"

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Universal Image Loading with State Handling
**When to use (Khi nào dùng):** When you need to load an image from a URL into an `ImageView` and handle loading/error states gracefully.
**Why this pattern is correct (Tại sao đúng):** It encapsulates the logic in a `BindingAdapter`, allowing you to reuse it across the entire app via XML layout attributes.

```kotlin
// 1. Define the Adapter
@BindingAdapter("imageUrl")
fun bindImage(imgView: ImageView, imgUrl: String?) {
    imgUrl?.let {
        // Convert string to URI and ensure HTTPS
        val imgUri = imgUrl.toUri().buildUpon().scheme("https").build()

        Glide.with(imgView.context)
            .load(imgUri)
            .apply(RequestOptions()
                .placeholder(R.drawable.loading_animation) // Show while loading
                .error(R.drawable.ic_broken_image))        // Show on failure
            .into(imgView)
    }
}

// 2. Usage in XML Layout
<!--
<ImageView
    app:imageUrl="@{viewModel.property.imgUrl}"
    ... />
-->
```

### Pattern 2: Retrofit API Interface Definition
**When to use (Khi nào dùng):** When defining the contract for your backend API.
**Why this pattern is correct (Tại sao đúng):** It uses Kotlin coroutines (suspend functions) to ensure network calls are non-blocking but written like synchronous code.

```kotlin
// 1. Define Data Class
data class MarsProperty(val id: String, val imgSrcUrl: String)

// 2. Define API Interface
interface MarsApiService {
    @GET("realestate")
    suspend fun getProperties(): List<MarsProperty>
}

// 3. Create Retrofit Instance (in a Factory/Singleton)
val retrofit = Retrofit.Builder()
    .baseUrl("https://android-kotlin-fun-mars-server.appspot.com/")
    .addConverterFactory(MoshiConverterFactory.create())
    .build()

val service = retrofit.create(MarsApiService::class.java)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Manual JSON Parsing
**Danger:** Using `JSONObject` or string splitting to parse API responses.
**Why:** It is brittle. If the API changes one field name, the app crashes at runtime. **Moshi** maps fields to data classes, causing compile-time errors or safe handling.

### 2. Blocking the Main Thread
**Danger:** Calling `Retrofit` or `Glide` operations synchronously (without coroutines or background threads).
**Why:** Android enforces a strict 5-second rule. If the network is slow, the UI freezes, and the system kills the app (ANR - App Not Responding).

### 3. Hardcoding Image Loading Logic in Activities
**Danger:** Writing `Glide.with(this).load(...).into(...)` inside `onCreate` for every screen.
**Why:** If you need to change the error icon or add a fade transition later, you must hunt down every file. Using `RequestOptions` in a shared `BindingAdapter` prevents this.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Internet Permission**: Always add `<uses-permission android:name="android.permission.INTERNET" />` in `AndroidManifest.xml`.
2.  **Networking Thread**: Always use **Coroutines** (via `suspend`) with Retrofit to stay off the Main Thread.
3.  **JSON Parsing**: Use **Moshi** with `@Json` annotations if field names differ from JSON keys.
4.  **Image Loading**: Use **Glide** for any image download. Never `BitmapFactory.decodeStream()` manually.
5.  **UI Updates**: Use `BindingAdapter` to link Glide logic to XML layouts.

### Decision Logic (If-Else)
*   **If** loading a network image: **Use Glide**.
*   **If** fetching JSON data: **Use Retrofit + Moshi**.
*   **If** the app needs to access the web: **Add Permission to Manifest**.
*   **If** you need the same placeholder for many images: **Use RequestOptions**.

### Top 3 Things to Remember
1.  **Manifest**: Add Internet Permission.
2.  **Background**: Suspend functions for API calls.
3.  **Images**: Glide + RequestOptions for safety and UI polish.