# DEVELOPER DECISION GUIDE: Lesson 9 App architecture (persistence).pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:35:23



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Persistence Architecture (Lesson 9)

## SECTION 1: CORE MENTAL MODEL

### Storage Options Overview
*   **App-specific storage (Lưu trữ ứng dụng):** Internal/External files. Use for unstructured data (images, logs).
*   **Shared storage (Lưu trữ chia sẻ):** MediaStore/Downloads. Use for files user should access outside app.
*   **Preferences (Tùy chọn):** `SharedPreferences`. Use for simple key-value pairs (settings, flags).
*   **Databases (Cơ sở dữ liệu):** Structured data. Use for complex, relational, or large datasets.

### Room Mental Model
**Room (Thư viện Room)** is an abstraction layer over **SQLite (Cơ sở dữ liệu SQL trên Android)**. It eliminates boilerplate and provides compile-time verification.
*   **Entity:** Represents a table.
*   **DAO (Data Access Object):** Interface to access data.
*   **Database:** The main holder of the database instance.

**Why Room?** Raw SQLite requires manual string queries (prone to runtime crashes). Room validates SQL at compile-time and maps data automatically.

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Simple flags/saved settings** | **SharedPreferences** | **Simplicity (Đơn giản):** Fastest for small data. | Storing large lists or blobs (Base64 images). |
| **Complex relational data** | **Room Database** | **Relational Integrity (Tính toàn vẹn):** Supports foreign keys, complex queries. | Using files/JSON to simulate a database. |
| **Large files (images/videos)** | **File System (Internal/External)** | **Performance (Hiệu suất):** Databases become slow with large blobs. | Saving file paths as strings in Room is fine, but storing the actual file bytes in a BLOB column. |
| **Data needed by other apps** | **Shared Storage (MediaStore)** | **Security (Bảo mật):** Controlled access to shared files. | Writing directly to SD card root without permission handling. |

| Async Method (Phương thức bất đồng bộ) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Standard DB Operations** | **Coroutines** | **Structured Concurrency (Tiến trình có cấu trúc):** Lightweight, lifecycle-aware, easy to cancel. | Blocking the **Main Thread (Luồng chính)** causing **ANR (Application Not Responding)**. |
| **Complex Data Transformation** | **Flow + Coroutines** | **Reactive (Phản ứng):** Emits updates automatically when DB changes. | Using `LiveData` inside DAO. Use `Flow` in DAO, convert to `LiveData` in ViewModel if needed. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Layered Architecture
```text
[ UI Layer (Activity/Fragment/ViewModel) ]
       ↓  observes      ↑
[ Repository Pattern ] ← Use Case (Business Logic)
       ↓  calls
[ Room: DAO ] (Interface)
       ↓  generates
[ Room: Database ] (SQLite Wrapper)
       ↓  stores
[ Device Storage ]
```

### Component Relationships
1.  **Entity:** Defines the Table Schema (SQL Columns).
2.  **DAO:** Defines the Queries (SQL Logic).
3.  **Database:** Connects them all and creates the instance.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Defining the Room Components

**When to use:** Whenever you need to store structured data locally.

**Why this pattern:** Encapsulates DB logic, separates concerns, and ensures compile-time safety.

```kotlin
// 1. Entity (The Table)
@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val name: String,
    val email: String
)

// 2. DAO (The Access Logic)
@Dao
interface UserDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(user: User) // Suspend for Coroutines

    @Query("SELECT * FROM users")
    fun getAllUsers(): Flow<List<User>> // Flow for reactive updates
}

// 3. Database (The Holder)
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

### Pattern 2: Repository with Coroutines

**When to use:** To fetch/insert data without freezing the UI.

**Why this pattern:** Moves heavy DB operations off the Main Thread.

```kotlin
class UserRepository(private val userDao: UserDao) {

    // Coroutine Scope ensures safety
    suspend fun addUser(name: String, email: String) {
        // Run on IO thread automatically
        withContext(Dispatchers.IO) {
            val newUser = User(name = name, email = email)
            userDao.insert(newUser)
        }
    }

    fun observeUsers(): Flow<List<User>> {
        return userDao.getAllUsers()
    }
}
```

### Pattern 3: ViewModel Integration

**When to use:** To expose data to the UI (Activity/Fragment).

**Why this pattern:** Survives configuration changes (screen rotation) and separates UI logic from data logic.

```kotlin
class UserViewModel(application: Application) : AndroidViewModel(application) {
    // Get DAO
    private val userDao = Room.databaseBuilder(
        application, AppDatabase::class.java, "db-name"
    ).build().userDao()

    private val repository = UserRepository(userDao)

    // Exposed data for UI
    val allUsers: StateFlow<List<User>> = repository.observeUsers()
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), emptyList())

    fun add(name: String) {
        viewModelScope.launch {
            repository.addUser(name, "test@test.com")
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Running DB Operations on Main Thread
**Why dangerous:** Causes **ANR (Application Not Responding)**. The UI freezes while waiting for disk I/O.
**Fix:** Always use `suspend` functions or `Dispatchers.IO`.

### 2. Raw SQL Strings
**Why dangerous:** No compile-time checks. If you rename a column in your code but forget to update the SQL string, the app crashes at runtime.
**Fix:** Use **Room Annotations** (@Insert, @Query).

### 3. Storing Large Blobs in Database
**Why dangerous:** Databases are designed for text and numbers. Reading/Writing binary data (images) causes massive memory usage and lag.
**Fix:** Save the file path in Room, store the image file in Internal Storage.

### 4. Memory Leaks in DAO
**Why dangerous:** Returning `LiveData` or `Flow` from DAO is fine, but if you don't cancel the **Coroutine Scope** in the ViewModel, the DB operation keeps running even after the user leaves the screen.
**Fix:** Use `viewModelScope` (cancels automatically).

---

## SECTION 6: MASTER CHEAT SHEET

### Top 8 Rules to Remember
1.  **Room = SQLite + Abstraction.**
2.  **Entity** = Table.
3.  **DAO** = Queries.
4.  **suspend** = Run on background thread.
5.  **Flow** = Listen for changes automatically.
6.  **Repository** = Single source of truth.
7.  **Main Thread** = Never touch DB here.
8.  **Boilerplate** = Room removes it.

### Decision Logic (If-Else)
*   **If** data is simple settings (`isDarkMode`): **Use SharedPreferences.**
*   **If** data is complex/list/relational: **Use Room.**
*   **If** operation takes time (> 5ms): **Use Coroutines (suspend).**
*   **If** UI needs to update when data changes: **Use Flow in DAO -> Collect in ViewModel.**

### Quick Setup Snippet
```kotlin
@Database(entities = [YourEntity::class], version = 1)
abstract class AppDB : RoomDatabase() { abstract fun dao(): YourDao }

@Dao interface YourDao { @Insert suspend fun insert(x: YourEntity) }

@Entity primary class YourEntity(@PrimaryKey val id: Int)
```

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Room Persistence (Lesson 9)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Room (Room Persistence Library)**
Một lớp trừu tượng trên SQLite giúp tương tác cơ sở dữ liệu dễ dàng hơn, an toàn hơn khi biên dịch.

**Entity (Entity)**
Lớp Kotlin đại diện cho một bảng trong cơ sở dữ liệu. Dùng annotation `@Entity` để map.

**DAO (Data Access Object - Đối tượng truy cập dữ liệu)**
Interface hoặc abstract class chứa phương thức truy cập dữ liệu. Room tự sinh mã thực thi.

**Primary Key (Khóa chính)**
Cột duy nhất xác định mỗi hàng trong bảng. Dùng `@PrimaryKey`.

### Why Room?

- **Compile-time verification**: Kiểm tra lỗi cú pháp SQL ngay khi biên dịch (không lỗi runtime).
- **Zero-boilerplate**: Tự sinh mã (auto-generated code) cho implementation.
- **Kotlin Coroutines support**: Hỗ trợ sẵn `suspend` functions.

---

## SECTION 2: DECISION TABLES

### When to use Room vs SQLite raw vs Shared Preferences

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Dữ liệu cấu trúc phức tạp, nhiều bảng (Product, Order) | **Room** | **Type-Safety & Compile-time checks**: Tránh lỗi SQL injection và lỗi cú pháp. | Dùng raw SQLite string, dễ dẫn đến lỗi cú pháp khó tìm. |
| Lưu trữ cài đặt app đơn giản (User settings) | **SharedPreferences** | **Đơn giản**: Key-Value, không cần truy vấn phức tạp. | Dùng Room cho chỉ 1-2 giá trị, gây thừa thãi. |
| Dữ liệu nhạy cảm (Token, Password) | **EncryptedSharedPreferences** | **Bảo mật**: Mã hóa dữ liệu ở mức lưu trữ. | Lưu plaintext vào SharedPreferences hoặc Database. |
| Dữ liệu read-only lớn (Asset database) | **SQLite + RawQuery** | **Tiết kiệm dung lượng**: Copy database từ assets. | Load全部 vào RAM, không dùng database hiệu quả. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy

```text
[APP LAYER]
   |  (Gọi từ ViewModel/Repository)
   v
[DAO INTERFACE] (@Dao)
   |  (Room sinh mã implementation)
   v
[ROOM DATABASE] (@Database)
   |  (Quản lý connection)
   v
[SQLITE FILE] (.db)
```

### Data Flow

1.  **Entity**: Định nghĩa schema (`data class`).
2.  **DAO**: Định nghĩa操作 (`insert`, `getAll`).
3.  **Database**: Nối các DAO lại (`entities = [Color::class]`).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Setup (Entity + DAO + Database)

**Khi nào dùng:** Bất kỳ app nào cần lưu giữ dữ liệu cấu trúc.

**Tại sao đúng:** Tách biệt rõ ràng Schema (Entity), Logic (DAO), Management (Database).

```kotlin
// 1. Entity (Schema)
@Entity(tableName = "colors")
data class Color(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    @ColumnInfo(name = "hex_color") val hex: String,
    val name: String
)

// 2. DAO (Logic)
@Dao
interface ColorDao {
    @Query("SELECT * FROM colors")
    suspend fun getAll(): List<Color>

    @Insert
    suspend fun insert(color: Color)
}

// 3. Database (Management)
@Database(entities = [Color::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun colorDao(): ColorDao
}
```

### Pattern 2: Relations (One-to-Many)

**Khi nào dùng:** Khi 1 entity chứa danh sách các entity khác (ví dụ: User có nhiều Task).

**Tại sao đúng:** Room tự động map object lồng nhau.

```kotlin
// Parent
@Entity
data class User(
    @PrimaryKey val uid: Int,
    val name: String
)

// Child
@Entity(
    foreignKeys = [ForeignKey(
        entity = User::class,
        parentColumns = ["uid"],
        childColumns = ["user_id"],
        onDelete = ForeignKey.CASCADE
    )]
)
data class Task(
    @PrimaryKey val tid: Int,
    val user_id: Int,
    val title: String
)

// Wrapper (Không phải Entity)
data class UserWithTasks(
    @Embedded val user: User,
    @Relation(
        parentColumn = "uid",
        entityColumn = "user_id"
    )
    val tasks: List<Task>
)

// DAO
@Dao
interface UserDao {
    @Transaction
    @Query("SELECT * FROM User")
    suspend fun getUsersWithTasks(): List<UserWithTasks>
}
```

### Pattern 3: Reactive Data Flow (LiveData/Flow)

**Khi nào dùng:** Khi UI cần tự động cập nhật khi database thay đổi.

**Tại sao đúng:** Không cần refresh manual, theo dõi thay đổi real-time.

```kotlin
@Dao
interface ColorDao {
    // Trả về LiveData/Flow, tự động emit giá trị mới khi DB thay đổi
    @Query("SELECT * FROM colors")
    fun observeAll(): Flow<List<Color>>

    @Insert
    suspend fun insert(color: Color)
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Database on Main Thread (Blocking UI)
**Nguy hiểm:** Truy vấn database trực tiếp trên UI Thread sẽ freeze app, gây ANR (App Not Responding).
**Fix:** Luôn dùng `suspend` functions hoặc `background thread`.

### 2. Raw String Queries without Compile Checks
**Nguy hiểm:** Lỗi cú pháp SQL chỉ hiện khi chạy app, rất khó debug.
**Fix:** Dùng `@Query("...")` để Room verify trước khi build.

### 3. No Singleton Pattern for Database
**Nguy hiểm:** Mở nhiều connection cùng lúc -> Dùng nhiều RAM, trôi đổi dữ liệu.
**Fix:** Dùng Singleton (object hay dependency injection).

```kotlin
// WRONG (Do not do this)
val db1 = Room.databaseBuilder(...).build()
val db2 = Room.databaseBuilder(...).build() // Duplicate instance

// CORRECT
@Volatile
private var INSTANCE: AppDatabase? = null

fun getDatabase(context: Context): AppDatabase {
    return INSTANCE ?: synchronized(this) {
        val instance = Room.databaseBuilder(
            context.applicationContext,
            AppDatabase::class.java,
            "app_database"
        ).build()
        INSTANCE = instance
        instance
    }
}
```

---

## SECTION 6: MASTER CHEAT SHEET

### Top 7 Rules to Remember
1.  **`@Entity`**: Map data class to table.
2.  **`@Dao`**: Define queries, Room implements it.
3.  **`@Database`**: Single source of truth.
4.  **`suspend`**: Always for DB operations.
5.  **`@Query`**: Compile-time check, use SQL.
6.  **`@Insert`**: Auto-handle conflict or upsert.
7.  **Migration**: Always define when schema changes.

### Decision Logic (If-Else)

*   **If** (Need persistent storage) → **Room**.
*   **If** (Need fast key-value only) → **SharedPreferences**.
*   **If** (Query fails at compile) → **Fix SQL syntax in `@Query`**.
*   **If** (UI not updating) → **Return `Flow` or `LiveData` in DAO**.
*   **If** (App lags on DB load) → **Move to `background thread` (Coroutines)**.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Lesson 9 - Persistence (Room)

## SECTION 1: CORE MENTAL MODEL

**Entity (Thực thể)**: Lớp Kotlin đại diện cho một bảng trong cơ sở dữ liệu (SQL table).
**DAO (Data Access Object - Đối tượng truy cập dữ liệu)**: Interface xác định các phương thức truy cập dữ liệu (CRUD).
**RoomDatabase (Cơ sở dữ liệu Room)**: Lớp trừu tượng kết nối Entity và DAO, quản lý kết nối SQLite.

**Mental Model:**
Room là lớp wrapper an toàn quanh SQLite. Nó dùng annotation để sinh ra code boilerplate. Bạn định nghĩa **sơ đồ** (Entity), **cách truy vấn** (DAO), và **cổng vào** (Database). ViewModel/Repository sẽ gọi Database để lấy DAO.

**Tại sao tốt hơn:**
- **An toàn tại thời điểm biên dịch (Compile-time safety)**: Lỗi truy vấn SQL sẽ bị bắt ngay khi build, không đợi runtime crash.
- **Ít code viết tay**: Không cần `ContentValues` hay trỏ cột thủ công.
- **Tích hợp sẵn với Architecture Components**: LiveData/Flow hoạt động tự động với lifecycle.

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Lưu dữ liệu cấu trúc đơn giản, Offline-first** | `Room Database` | **Persistence (Lưu trữ)**: Tối ưu cho SQLite, hỗ trợ tốt offline. | Dùng `SharedPreferences` cho danh sách dữ liệu lớn (dễ gây ANR). |
| **Lấy dữ liệu 1 lần, không cần lắng nghe thay đổi** | `@Query` với `Array<T>` | **Snapshot (Chụp nhanh)**: Trả về danh sách cố định tại thời điểm gọi. | Trả về `LiveData` khi không cần observer (lãng phí tài nguyên). |
| **Lấy dữ liệu và cần update UI khi DB thay đổi** | `@Query` với `LiveData<T>` hoặc `Flow<T>` | **Reactive (Phản ứng)**: Tự động push dữ liệu mới khi database update. | Không dùng LiveData/Flow mà polling thủ công (lặp lại code). |
| **Xử lý tác vụ dài (DB/Network)** | `Coroutines (Tiến trình rút gọn)` | **Asynchronous (Bất đồng bộ)**: Không blocked Main Thread (UI). | Chạy DB操作 trực tiếp trên Main Thread -> Crash/ANR. |

| Thao tác DB | Phương thức DAO | Lưu ý |
| :--- | :--- | :--- |
| **Insert (Chèn)** | `@Insert` | Hỗ trợ list hoặc vararg. Nếu trùng khóa chính, mặc định là `REPLACE`. |
| **Update (Cập nhật)** | `@Update` | Phải có đủ khóa chính để tìm bản ghi. |
| **Delete (Xóa)** | `@Delete` | Xóa theo object hoặc khóa chính. |
| **Custom Query (Tùy chỉnh)** | `@Query("SQL...")` | Kiểm tra cú pháp SQL ngay khi build. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Mối quan hệ phân cấp:**
1. **Entity**: Định nghĩa bảng (`Color`).
2. **DAO**: Định nghĩa hành động (`ColorDao`). Database sử dụng DAO này.
3. **Database**: Class kết nối Room (`ColorDatabase`). Chứa instance singleton.

**Luồng gọi (Flow):**
`ViewModel` / `Repository` -> `ColorDatabase.getInstance()` -> `colorDao()` -> `@Query/@Insert`

```text
[ UI Layer (Activity/Fragment/ViewModel) ]
       |
       v
[ Repository (Optional) ]
       |
       v
[ RoomDatabase ] <--- Singleton ( getInstance )
       |
       +---> [ DAO Interface (Abstract) ]
                 |
                 +---> [ Entity Class (Table) ]
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Singleton Database Instance (Thread-Safe)
*Khi nào dùng:* Khi cần đảm bảo chỉ có 1 instance Database在整个 App lifecycle.

*Tại sao đúng:* Tránh rò rỉ bộ nhớ và xung đột kết nối DB. `@Volatile` và `synchronized` bảo vệ đa luồng.

```kotlin
@Database(entities = [Color::class], version = 1)
abstract class ColorDatabase : RoomDatabase() {
    abstract fun colorDao(): ColorDao

    companion object {
        @Volatile
        private var INSTANCE: ColorDatabase? = null

        fun getInstance(context: Context): ColorDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: Room.databaseBuilder(
                    context.applicationContext,
                    ColorDatabase::class.java, "color_database"
                )
                .fallbackToDestructiveMigration() // Dùng cho dev, xử lý migration sau
                .build()
                .also { INSTANCE = it }
            }
        }
    }
}
```

### Pattern 2: Reactive Query (LiveData)
*Khi nào dùng:* Khi UI cần hiển thị danh sách và tự động cập nhật khi DB thay đổi.

*Tại sao đúng:* Room chạy truy vấn trên background thread. LiveData quan sát kết quả và đẩy update về UI thread an toàn.

```kotlin
@Dao
interface ColorDao {
    @Query("SELECT * FROM colors")
    fun getAll(): LiveData<List<Color>> // Hoặc Flow<List<Color>>

    @Insert
    suspend fun insert(vararg color: Color) // suspend để gọi từ Coroutines
}
```

### Pattern 3: Asynchronous Insert/Update
*Khi nào dùng:* Khi người dùng thao tác (nhập liệu, bấm nút lưu).

*Tại sao đúng:* Tránh freeze UI. `suspend` function được gọi từ CoroutineScope (như `viewModelScope`).

```kotlin
// Trong ViewModel hoặc Repository
fun saveColor(hex: String, name: String) {
    viewModelScope.launch(Dispatchers.IO) { // Chạy trên background thread
        val newColor = Color(hex = hex, name = name)
        ColorDatabase.getInstance(context).colorDao().insert(newColor)
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Chạy Query trực tiếp trên Main Thread:**
    *   *Nguy hiểm:* Gây treo giao diện (ANR - Application Not Responding). Room sẽ crash nếu phát hiện.
    *   *Fix:* Luôn dùng `suspend` function hoặc `LiveData`/`Flow`.

2.  **Quên `@Volatile` trong Singleton:**
    *   *Nguy hiểm:* Có thể tạo ra nhiều instance database khác nhau trên các thread khác nhau, dẫn đến lỗi dữ liệu không đồng nhất.

3.  **Dùng `fallbackToDestructiveMigration()` trong Production:**
    *   *Nguy hiểm:* Xóa toàn bộ dữ liệu người dùng khi app update (change schema).
    *   *Fix:* Implement `Migration` strategy chính thức.

4.  **ViewModel truy cập trực tiếp Database:**
    *   *Nguy hiểm:* Vi phạm Clean Architecture. Khó test unit.
    *   *Fix:* Nên có lớp `Repository` đứng giữa ViewModel và Database.

## SECTION 6: MASTER CHEAT SHEET

**Quick Rules:**
- `@Database` (Entities) -> `abstract class` -> `abstract fun dao()`
- `@Dao` (Query/Insert) -> `@Entity` (Columns)
- **Main Thread:** UI only.
- **Background:** DB ops (Network/File) must be in `suspend` or `Coroutines`.

**Decision Logic:**
1. **Cần lưu Offline?** → Dùng Room Database.
2. **Cần update UI tự động?** → DAO return `LiveData/Flow`.
3. **Có thao tác ghi/đọc nặng?** → Dùng `suspend` + `Coroutines`.
4. **Chỉ cần lưu 1-2 giá trị Setting?** → Dùng `SharedPreferences`.

**Top 3 Things to Remember:**
1.  **Singleton** luôn dùng `synchronized` và `@Volatile`.
2.  **DAO** là nơi khai báo truy vấn, Room sinh code tự động.
3.  **Context** khi build Database nhớ dùng `context.applicationContext`.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Async & Persistence
**Lesson 9 - App Architecture (Persistence)**

---

## SECTION 1: CORE MENTAL MODEL

### Core Concepts
**Coroutine (Tiến trình rút gọn)**
Một đơn vị công việc không bloque luồng chính (main thread). Nó lightweight hơn Thread và có thể pause/resume được.
*Reality:* Think of it as a light-weight thread that you can start, pause, and stop cheaply without freezing your app UI.

**Suspend Function (Hàm hoãn)**
Hàm có thể dừng thực thi để chờ kết quả rồi tiếp tục, không blocked thread.
*Reality:* Marked with `suspend`. Inside, it looks like synchronous code (sequential), but it yields execution back to the system while waiting.

**Dispatcher (Bộ định vị luồng)**
Nói với Coroutine nên chạy ở luồng nào.
*Reality:* You decide WHERE the work happens (Main, IO, CPU).

### Why Coroutines over Callbacks?
Callbacks create "Callback Hell" (nested chaos). Coroutines let you write asynchronous code that looks synchronous (line-by-line), making it readable and easier to debug.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Database Operations** (Insert/Update/Delete) | `suspend` functions in DAO + `Dispatchers.IO` | Database I/O is blocking; needs a background thread pool. | Calling DB on `Dispatchers.Main` causing UI freeze. |
| **Network Requests** (API calls) | `suspend` functions + `Dispatchers.IO` | Network operations are unpredictable and slow; offload from Main thread. | Forgetting to mark API call as `suspend` or using Callbacks inside Coroutines. |
| **Complex Calculations** (Sorting large lists) | `Dispatchers.Default` | CPU-intensive work needs a thread pool sized to CPU cores. | Running heavy math on `Main` (ANR) or `IO` (wasting threads). |
| **Updating UI** (LiveData, View updates) | `Dispatchers.Main` | UI frameworks (Android View system) are single-threaded. | Accessing Views from background threads causing crashes. |
| **Mixing Work** (Net -> DB -> UI) | `viewModelScope.launch` + `withContext` | Structured concurrency handles lifecycle automatically. | Using `GlobalScope` (leads to memory leaks). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow of Execution (Async Data Loading)

```text
[User Action] Triggers
       |
       v
[ViewModel] (Main Thread)
  |-> Launches Coroutine in viewModelScope
  |
  v
[withContext(Dispatchers.IO)] Switches to Background
  |
  +--> [Repository] Calls Suspend Functions
        |
        +--> [Room DAO] @Query @Insert @Update @Delete
        |       |
        |       +--> [SQLite DB] (Disk)
        |
        +--> [Retrofit Service] @GET @POST
                |
                +--> [Network] (Internet)

[Returned Result] --> [LiveData/StateFlow] (Main Thread) --> Updates UI
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Room DAO Suspend
**Khi nào dùng:** When defining database access methods.
**Tại sao đúng:** Room provides native Coroutine support. `suspend` allows direct calling without manual threads.

```kotlin
@Dao
interface ColorDao {
    // No need for 'Observable' if you just want raw data once
    @Query("SELECT * FROM colors")
    suspend fun getAll(): Array<Color> // Suspends until DB returns

    @Insert
    suspend fun insert(vararg color: Color) // Suspends until inserted

    @Update
    suspend fun update(color: Color)
    
    @Delete
    suspend fun delete(color: Color)
}
```

### Pattern 2: Repository with Context Switching
**Khi nào dùng:** The central source of truth for data.
**Tại sao đúng:** Repository decides data source (Network/DB), but always returns to the calling thread (usually Main) safely.

```kotlin
class ColorRepository(private val dao: ColorDao) {
    
    // This function can be called from Main, but execution moves to IO
    suspend fun refreshColors() {
        // Switch to IO thread for network/DB work
        withContext(Dispatchers.IO) {
            // Example network call
            val newColors = api.fetchColors()
            // Insert into DB (still on IO)
            dao.insert(*newColors.toTypedArray())
        }
        // Automatically returns to previous context (Main)
    }
}
```

### Pattern 3: ViewModel Integration
**Khi nào used:** Handling UI logic and user inputs.
**Tại sao đúng:** `viewModelScope` automatically cancels coroutines when the ViewModel is cleared, preventing leaks.

```kotlin
class MyViewModel(
    private val repository: ColorRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow<ColorState>(ColorState.Loading)
    val uiState: StateFlow<ColorState> = _uiState

    fun loadData() {
        // Launch in Main Thread context by default, but handles switching internally
        viewModelScope.launch {
            _uiState.value = ColorState.Loading
            try {
                // Perform heavy work (handled by repository)
                repository.refreshColors()
                // Update UI (Main thread confirmed)
                _uiState.value = ColorState.Success
            } catch (e: Exception) {
                _uiState.value = ColorState.Error(e.message)
            }
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Blocking the Main Thread
**Danger:** Calling a `suspend` function or heavy task directly on the UI thread without a dispatcher.
**Why:** Causes the app to freeze (ANR - App Not Responding) because the UI loop is stopped.
**Fix:** Always use `Dispatchers.IO` or `Dispatchers.Default` for heavy work.

### 2. Using `runBlocking`
**Danger:** Using `runBlocking` in production Android code (ViewModel, Activity).
**Why:** It blocks the calling thread until the coroutine finishes. If called on Main, it freezes the UI.
**Fix:** Use `viewModelScope.launch` or `lifecycleScope.launch` for asynchronous work.

### 3. Memory Leaks with `GlobalScope`
**Danger:** Launching coroutines using `GlobalScope.launch`.
**Why:** The coroutine lives as long as the app. If the screen rotates, the old Activity/View might still be referenced in memory, or network calls keep going after the user left the screen.
**Fix:** Use `viewModelScope`, `lifecycleScope`, or `CoroutineScope(Dispatchers.IO + Job())` managed by a DI framework.

### 4. Not Handling Exceptions
**Danger:** Failing to wrap `suspend` calls in `try/catch` inside the ViewModel.
**Why:** If a network call fails, the app crashes or gets stuck in a loading state.
**Fix:** Always wrap risky operations in `try/catch` blocks.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic: Which Dispatcher?
```text
Is it UI work? (Update View, Toast, SnackBar)
  YES -> Dispatchers.Main

Is it I/O? (Network, Database, File Read/Write)
  YES -> Dispatchers.IO

Is it CPU Math? (Filter lists, JSON Parsing, Heavy Calculation)
  YES -> Dispatchers.Default
```

### Top 5 Things To Remember
1.  **Suspend != Parallel:** `suspend` means non-blocking, not automatically multi-threaded. You must `launch` or `async` to run things concurrently.
2.  **Main-Safe:** Write your public functions to be "Main-Safe". This means they can be called from the Main thread without freezing (they handle switching internally or are fast).
3.  **Room is Suspend Friendly:** Room generates the background code for you. Just add `suspend`.
4.  **Structured Concurrency:** Use `viewModelScope`. Never use `GlobalScope` unless you have a very specific reason (and know how to kill it).
5.  **Exception Propagation:** If a coroutine fails inside a `launch`, it propagates up the job tree. Use `try/catch` or `CoroutineExceptionHandler`.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Persistence & Coroutines

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **CoroutineScope (Phạm vi Coroutine)**: Không gian sống của các Coroutine. Nó quản lý vòng đời (tạo, theo dõi, huỷ) của các công việc con. Ví dụ: `viewModelScope` sẽ tự huỷ khi `ViewModel` bị xóa.
- **Dispatchers (Bộ điều hướng)**: Xác định Thread nào Coroutine sẽ chạy.
  - `Dispatchers.Main`: Giao diện người dùng (UI).
  - `Dispatchers.IO`: Input/Output (Database, Network).
- **withContext (Chuyển ngữ cảnh)**: Công cụ để chuyển Coroutine từ Dispatcher này sang Dispatcher khác một cách an toàn và hiệu quả.

### Key Mental Model
Hãy tưởng tượng Coroutine là công nhân. **Dispatchers** là các nhà máy (Main, IO). **withContext** là xe tải chở công nhân từ nhà máy này sang nhà máy khác để làm việc chuyên môn. **CoroutineScope** là người quản lý các công nhân, đảm bảo nếu người quản lý nghỉ (Scope huỷ), mọi công nhân đều dừng theo.

### Why this approach is better
Chủ động quản lý Thread (Main vs IO) giúp ứng dụng không bị "giật lag" (ANR) vì làm việc nặng trên Main Thread, và không bị "cháy" tài nguyên vì làm việc IO trên Main Thread. So với `runBlocking` (cách cũ), `suspend` kết hợp `withContext` không bao giờ block Main Thread.

---

## SECTION 2: DECISION TABLES

### Table 1: Launch vs Async
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Fire-and-forget (Chạy & Quên): Ví dụ save data, update UI không cần kết quả trả về ngay. | `launch` | **Fire-and-forget**: Dễ dùng, không cần trả về giá trị, code gọn. | Dùng `async` cho việc không cần kết quả, gây code thừa `.await()` rườm rà. |
| Cần kết quả (Result): Ví dụ fetch API, tính toán phức tạp và cần giá trị trả về. | `async` | **Defer (Hoãn)**: Trả về `Deferred` (giống Promise), phải gọi `.await()` để lấy giá trị. | Quên `.await()`, dẫn đến lỗi logic hoặc nhận về `Deferred` thay vì giá trị mong muốn. |

### Table 2: CoroutineScope & Context
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Trong ViewModel (Logic nghiệp vụ, Room DB) | `viewModelScope.launch` | **Lifecycle-aware**: Tự động huỷ khi ViewModel bị destroy, tránh rò rỉ bộ nhớ (Memory Leak). | Dùng `GlobalScope`: Không bao giờ tự huỷ, gây rò rỉ nghiêm trọng và lỗi Activity đã huỷ nhưng vẫn chạy code. |
| Trong UI (Activity/Fragment) | `lifecycleScope.launch` | **Lifecycle-aware**: Tự động huỷ khi UI bị destroy, an toàn cho UI updates. | Chạy block code dài trên UI thread mà không switch qua `Dispatchers.IO`. |

### Table 3: Database Testing
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Kiểm tra logic Database Unit Test | `Room.inMemoryDatabaseBuilder` | **In-memory Database**: Chạy RAM, tốc độ cực nhanh, tự động dọn dẹp sau mỗi test, không cần file thực tế. | Test trên database thực tế: Chậm, dễ nhiễm dữ liệu bẩn giữa các test, khó cleanup. |
| Kiểm tra Unit Test thông thường | `@Before` (Setup) & `@After` (Teardown) | **Test Lifecycle**: Đảm bảo database được tạo mới trước test và đóng (close) sau test để giải phóng nguồn lực. | Để database open sau test: Dẫn đến lỗi `IllegalStateException: Database leaked` hoặc xung đột test sau. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy
```text
[ Application / UI Layer ]
       |
       v
[ ViewModel ]  <------- (Lifecycle Bound) ------> [ LifecycleScope ]
       |
       | (viewModelScope)
       v
[ Coroutines ]
       |
       +--> [ withContext(Dispatchers.IO) ] ----> [ Database / Network ]
       |       (Chuyển đổi ngữ cảnh sang IO)
       |
       +--> [ withContext(Dispatchers.Main) ] ---> [ Update UI ]
```

### Flow: Save Data từ UI -> Database
1. **User Action**: Click nút "Save" trên UI.
2. **ViewModel**: Kích hoạt `viewModelScope.launch`.
3. **Switch Context**: Gọi `withContext(Dispatchers.IO)` để chuyển sang luồng IO.
4. **Persistence**: Thực hiện `dao.insert(color)`.
5. **Return**: Tự động quay lại `Dispatchers.Main` (hoặc context cũ) để update UI.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Database Operation in ViewModel
*Khi nào dùng:* Khi cần lưu/truy vấn dữ liệu Room DB từ UI mà không freeze app.

*Tại sao đúng:* Tách biệt luồng xử lý (IO) khỏi luồng UI (Main) một cách tự động.

```kotlin
class ColorViewModel(
    private val dao: ColorDao,
    application: Application
) : AndroidViewModel(application) {

    // Hàm suspend cho phép gọi từ UI hoặc Coroutine khác
    suspend fun saveColor(color: Color) {
        // Switch sang IO để làm việc với Database, quay lại Main sau khi xong
        withContext(Dispatchers.IO) {
            dao.insert(color)
        }
    }

    // Fire-and-forget pattern
    fun saveOnClick(color: Color) {
        viewModelScope.launch {
            saveColor(color) // Gọi suspend function
        }
    }
}
```

### Pattern 2: In-Memory Database Testing
*Khi nào dùng:* Khi viết Unit Test cho DAO (Data Access Object).

*Tại sao đúng:* Tách biệt môi trường test khỏi database thực tế, đảm bảo sạch sẽ và nhanh chóng.

```kotlin
@RunWith(AndroidJUnit4::class)
class ColorDaoTest {

    private lateinit var db: ColorDatabase
    private lateinit var dao: ColorDao

    @Before
    fun createDb() {
        val context = ApplicationProvider.getApplicationContext<Context>()
        // Tạo DB trong RAM, không dùng file thực
        db = Room.inMemoryDatabaseBuilder(context, ColorDatabase::class.java)
            .allowMainThreadQueries() // Chỉ dùng cho test để đơn giản hóa
            .build()
        dao = db.colorDao()
    }

    @After
    @Throws(IOException::class)
    fun closeDb() {
        db.close() // Đóng DB giải phóng bộ nhớ
    }

    @Test
    fun insertAndGetColor() = runBlocking {
        val red = Color(hex = "#FF0000", name = "red")
        dao.insert(red)
        val loaded = dao.findColorByName("red")
        assert(loaded.hex == "#FF0000")
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Using `GlobalScope`
- **Lỗi:** `GlobalScope.launch { ... }`
-   **Lý do nguy hiểm:** `GlobalScope` không thuộc lifecycle nào cả. Nếu người dùng đóng App/Activity khi job đang chạy, nó vẫn tiếp tục ngầm消耗资源 (CPU/RAM) cho đến khi xong, dẫn đến rò rỉ bộ nhớ nghiêm trọng và crash do tương tác với UI đã bị huỷ.

### 2. Blocking IO on Main Thread
- **Lỗi:** Không dùng `withContext(Dispatchers.IO)` khi đọc/ghi file hoặc query Database trực tiếp trong hàm `onClick`.
-   **Lý do nguy hiểm:** Giao diện sẽ đơ (freeze) hoàn toàn trong khi chờ database. Android sẽ hiển thị hệ thống "Application Not Responding" (ANR) nếu quá 5 giây.

### 3. Leaking Database Connection
- **Lỗi:** Test database nhưng không gọi `db.close()` trong `@After`.
- **Lý do nguy hiểm:** File database bị khoá hoặc bộ nhớ bị rò rỉ giữa các lần chạy test, dẫn đến lỗi `Unable to open database connection` hoặc test thất bại không rõ lý do.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules to Remember
1.  **Main là để UI, IO là để Data:** Cứ thấy IO là `withContext(Dispatchers.IO)`.
2.  **ViewModel dùng `viewModelScope`:** Đảm bảo auto-cancel, tránh leak.
3.  **Test DB dùng `inMemory`:** Nhanh và sạch.
4.  **Async cần `await`:** Nếu cần trả về giá trị.
5.  **Test lifecycle:** `@Before` tạo, `@After` huỷ (close).

### Decision Logic (If-Else Style)
*   **If:** Working inside `ViewModel`.
    *   **Then:** Use `viewModelScope.launch`.
*   **If:** Need to do Database/Network operation.
    *   **Then:** Wrap inside `withContext(Dispatchers.IO)`.
*   **If:** Writing Unit Test for DAO.
    *   **Then:** Use `Room.inMemoryDatabaseBuilder`.
*   **If:** Function needs to return a value asynchronously.
    *   **Then:** Declare as `suspend` or return `Deferred` (use `async`).

<!-- CHUNK 51-55 -->

# DEVELOPER DECISION GUIDE: Persistence (Lesson 9)

## SECTION 1: CORE MENTAL MODEL

**Room Database (Room Database)**: Thư viện trừu tượng hóa SQLite, giúp thao tác cơ sở dữ liệu an toàn và dễ dàng hơn.

**Entity (Entity)**: Lớp dữ liệu đại diện cho một bảng trong cơ sở dữ liệu.

**DAO (Data Access Object - Đối tượng truy cập dữ liệu)**: Interface chứa các phương thức truy vấn dữ liệu.

**Coroutine (Tiến trình rút gọn)**: Cơ chế lập trình bất đồng bộ, giúp thực thi tác vụ nặng mà không chặn luồng chính (UI Thread).

**Khi nào dùng?**
Khi ứng dụng cần lưu trữ dữ liệu cục bộ, bảo toàn dữ liệu khi đóng app, và truy xuất dữ liệu nhanh chóng để hiển thị.

**Tại sao dùng Room?**
So với SQLite thuần, Room cung cấp:
1. Kiểm tra lỗi cú pháp truy vấn ngay khi biên dịch (Compile-time checking).
2. Tích hợp sẵn Coroutine để xử lý dữ liệu nền dễ dàng.
3. Giảm thiểu boilerplate code (mã lặp lại không cần thiết).

## SECTION 2: DECISION TABLES

### Table 1: Truy xuất Dữ liệu (Main Thread vs Background)

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Truy vấn dữ liệu lớn hoặc ghi dữ liệu (INSERT/UPDATE/DELETE) | **Sử dụng Coroutine (suspend function)** trong DAO. | **Background Execution**: Tránh đóng băng giao diện (ANR) bằng cách chạy tác vụ nặng trên nền. | Để hàm truy vấn chạy trực tiếp trên **Main Thread** (Luồng chính), gây treo app. |
| Hiển thị dữ liệu LiveData/Flow từ DB lên UI | **Kết hợp ViewModel với viewModelScope**. | **Lifecycle-aware**: Dữ liệu tự động cập nhật khi UI thay đổi và tự dọn rác khi lifecycle kết thúc. | Viết logic xử lý dữ liệu trực tiếp trong Activity/Fragment thay vì dùng ViewModel. |

### Table 2: Cấu trúc Database

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| App cần chạy Unit Test (Test logic trong code) | **In-memory Database (SQLite in-memory)**. | **Isolation**: Tạo DB trong RAM, tách biệt hoàn toàn với DB thật, tốc độ chạy test siêu nhanh. | Dùng DB thật cho Unit Test -> Chạy chậm, dính dữ liệu cũ từ test trước. |
| App cần lưu trữ lâu dài, nhiều bảng phức tạp | **Room Database với Entity & ForeignKey**. | **Data Integrity**: Đảm bảo quan hệ dữ liệu giữa các bảng được quản lý chặt chẽ. | Lưu dữ liệu vào **SharedPreferences** cho cấu trúc phức tạp -> Khó truy vấn, mất cấu trúc. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**Mô hình luồng dữ liệu trong Room:**

```text
[ UI (Activity/Fragment) ]
       ^
       | (Observes)
       v
[ ViewModel ] <-> [ Repository (Optional) ]
                       ^
                       | (Accesses via Interface)
                       v
               [ DAO (Data Access Object) ]
                       ^
                       | (Queries SQL/Cursor)
                       v
               [ Room Database ]
                       ^
                       | (Stores on Disk)
                       v
                  [ SQLite File ]
```

**Quy tắc tương tác:**
1. **Entity**: Định nghĩa `@Entity` -> Tạo Table.
2. **DAO**: Định nghĩa `@Dao` -> Hỏi/Bắt (Query/Insert) Entity đó.
3. **Database**: Định nghĩa `@Database` -> Kết nối Entity và DAO.

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Định nghĩa Entity & DAO cơ bản

**Khi nào dùng:** Khi cần tạo bảng dữ liệu và các phương thức truy cập chuẩn.

**Tại sao đúng:** Tách biệt rõ ràng cấu trúc dữ liệu và logic truy vấn.

```kotlin
// 1. Entity (Định nghĩa bảng)
@Entity(tableName = "colors")
data class Color(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val name: String,
    val hexCode: String
)

// 2. DAO (Định nghĩa thao tác)
@Dao
interface ColorDao {
    // suspend để dùng với Coroutine
    @Insert
    suspend fun insert(color: Color)

    @Query("SELECT * FROM colors")
    suspend fun getAll(): List<Color>
    
    @Query("DELETE FROM colors")
    suspend fun deleteAll()
}

// 3. Database (Điều khiển chính)
@Database(entities = [Color::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun colorDao(): ColorDao
}
```

### Pattern 2: Test Database (In-Memory)

**Khi nào dùng:** Khi viết Unit Test cho Room.

**Tài sao đúng:** Đảm bảo test nhanh, sạch và không ảnh hưởng đến dữ liệu thật.

```kotlin
class DatabaseTest {
    private lateinit var db: AppDatabase
    private lateinit var dao: ColorDao

    @Before
    fun createDb() {
        // Tạo DB trong RAM (không lưu file)
        db = Room.inMemoryDatabaseBuilder(
            ApplicationProvider.getApplicationContext(),
            AppDatabase::class.java
        ).build()
        dao = db.colorDao()
    }

    @After
    fun closeDb() {
        db.close()
    }

    @Test
    @Throws(Exception::class)
    fun insertAndRetrieve() {
        // Given
        val red = Color(name = "Red", hexCode = "#FF0000")
        val green = Color(name = "Green", hexCode = "#00FF00")
        val blue = Color(name = "Blue", hexCode = "#0000FF")

        // When
        dao.insert(red)
        dao.insert(green)
        dao.insert(blue)
        
        val colors = dao.getAll()

        // Then
        assert(colors.size == 3)
    }
}
```

### Pattern 3: Xử lý bất đồng bộ với ViewModel

**Khi nào dùng:** Khi App cần ghi dữ liệu từ UI vào DB mà không freeze màn hình.

**Tại sao đúng:** `viewModelScope` quản lý vòng đời, tự động hủy Coroutine khi Activity/Fragment bị huỷ.

```kotlin
class MyViewModel(private val dao: ColorDao) : ViewModel() {
    
    // Lưu data an toàn
    fun saveNewColor(name: String, hex: String) {
        viewModelScope.launch {
            // Chạy trên nền (Background)
            val newColor = Color(name = name, hexCode = hex)
            dao.insert(newColor)
        } // Tự động hoàn trả tài nguyên khi ViewModel bị huỷ
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Thực thi Database trên Main Thread:**
    *   **Lỗi:** Gọi hàm `suspend` của DAO hoặc truy vấn SQLite trực tiếp trong `onCreate`.
    *   **Nguy hiểm:** Gây treo giao diện nghiêm trọng (ANR - Application Not Responding), người dùng không thể thao tác.
    *   **Fix:** Luôn dùng `Coroutines` (launch/async) hoặc `LiveData`.

2.  **Chép logic Database vào Activity/Fragment:**
    *   **Lỗi:** Viết code Room прямо trong Class UI.
    *   **Nguy hiểm:** Code lộn xộn (Spaghetti code), khó unit test, vi phạm nguyên tắc Separation of Concerns.
    *   **Fix:** Đưa logic vào `ViewModel` hoặc `Repository`.

3.  **Dùng `Thread.sleep()` trong Test:**
    *   **Lỗi:** Chờ DB hoàn thành bằng cách tạm dừng luồng.
    *   **Nguy hiểm:** Test không ổn định, chậm, che giấu lỗi race condition.
    *   **Fix:** Dùng `suspend` function và Kotlin Coroutines Test hoặc CountDownLatch đúng cách.

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules (Quy tắc nhanh)
*   **DB chạy ở đâu?** Luôn trên **Background** (Coroutine).
*   **UI quan sát gì?** Quan sát **LiveData/Flow** từ DAO/ViewModel.
*   **Làm sao test?** Dùng **Room.inMemoryDatabaseBuilder**.

### Decision Logic (Logic Ra Quyết Định)
*   **Nếu** muốn lưu dữ liệu -> Dùng **Room + Entity**.
*   **Nếu** muốn query data và update UI real-time -> Dùng **@Query** trả về **LiveData/Flow**.
*   **Nếu** muốn chạy Insert/Delete -> Dùng **Suspend Function** + **ViewModelScope**.
*   **Nếu** thấy UI lag khi thao tác DB -> Kiểm tra lại luồng执行, đảm bảo không chạy trên **Main Thread**.

### Top 5 Things to Remember
1.  **@Database** kết nối Entity và DAO.
2.  **Suspend** trong DAO là bắt buộc cho Coroutine.
3.  **@Test** DB nên dùng `inMemory` (RAM).
4.  **Main Thread** cấm truy vấn DB (Room kiểm tra lỗi này ngay khi build).
5.  **Repo/ViewModel** là nơi xử lý logic, không phải Activity.