# DEVELOPER DECISION GUIDE: App Architecture (UI Layer)

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:32:31

---

## SECTION 1: CORE MENTAL MODEL (Mô hình tư duy)

### 1.1. Core Concepts (Định nghĩa cốt lõi)

- **Separation of Concerns (Tách biệt các mối quan tâm)**: Nguyên tắc cốt lõi của kiến trúc Android. Tách biệt code liên quan đến giao diện (UI), logic nghiệp vụ (business logic), và dữ liệu (data) thành các lớp riêng biệt để dễ bảo trì, dễ test, và tránh lỗi.
- **UI Controller (Activity/Fragment)**: Vai trò duy nhất là **hiển thị** dữ liệu lên màn hình và **lắng nghe** tương tác của người dùng (clicks, text input), sau đó chuyển các sự kiện này cho `ViewModel`.
- **`ViewModel`**: Một lớp được thiết kế để lưu trữ và quản lý dữ liệu liên quan đến UI. Nó sống sót qua các thay đổi cấu hình (như xoay màn hình), giúp tránh mất dữ liệu. **`ViewModel` không bao giờ được chứa tham chiếu đến `View` hoặc `Context`**.
- **`LiveData` / `StateFlow`**: Các "hộp chứa" dữ liệu có thể quan sát được. Khi dữ liệu bên trong thay đổi, chúng sẽ tự động thông báo cho UI để cập nhật, đảm bảo giao diện luôn đồng bộ với trạng thái dữ liệu.

### 1.2. Unidirectional Data Flow (Luồng dữ liệu một chiều)

Đây là luồng dữ liệu được khuyến nghị trong kiến trúc Android hiện đại:

```text
User Interaction → UI Controller (Activity/Fragment) → ViewModel → (Updates State) → LiveData/StateFlow → UI Controller (Observes & Updates UI)
```

1.  **Sự kiện**: Người dùng tương tác với UI.
2.  **Thông báo**: UI Controller gọi phương thức của `ViewModel`.
3.  **Cập nhật trạng thái**: `ViewModel` xử lý logic và cập nhật dữ liệu (State).
4.  **Hiển thị**: UI Controller (hoặc Data Binding) lắng nghe sự thay đổi của State và tự động vẽ lại giao diện.

---

## SECTION 2: `VIEWMODEL` & `LIVEDATA`

### 2.1. Tại sao cần `ViewModel`?

Khi một `Activity` hoặc `Fragment` bị tạo lại (ví dụ, khi xoay màn hình), mọi dữ liệu lưu trong các biến thành viên của nó sẽ bị mất. `ViewModel` được thiết kế để giải quyết vấn đề này. Nó được gắn với vòng đời của màn hình (scope), không phải của `Activity`/`Fragment` instance, nên nó vẫn tồn tại sau khi xoay màn hình.

### 2.2. `LiveData` vs. `MutableLiveData`

- **`LiveData`**: Bất biến (immutable), chỉ có thể được quan sát. Được sử dụng để "phơi" dữ liệu ra cho UI Controller.
- **`MutableLiveData`**: Khả biến (mutable), có thể thay đổi giá trị. Luôn được giữ ở chế độ `private` bên trong `ViewModel` để đảm bảo chỉ `ViewModel` mới có quyền thay đổi dữ liệu.

**Code Pattern: Encapsulation với LiveData**

```kotlin
class MyViewModel : ViewModel() {
    // PRIVATE: Chỉ có thể thay đổi bên trong ViewModel
    private val _score = MutableLiveData<Int>(0)

    // PUBLIC: Chỉ có thể đọc và quan sát từ bên ngoài
    val score: LiveData<Int>
        get() = _score

    fun incrementScore() {
        _score.value = (_score.value ?: 0) + 1
    }
}
```

---

## SECTION 3: DATA BINDING

**Data Binding** là một kỹ thuật cho phép bạn "ghim" dữ liệu từ `ViewModel` trực tiếp vào layout XML, giúp loại bỏ phần lớn code thao tác UI thủ công trong `Activity` hoặc `Fragment`.

### 3.1. Khi nào nên dùng Data Binding?

| Tình huống | Nên dùng | Tại sao |
| :--- | :--- | :--- |
| **Giao diện phức tạp**, nhiều view cần cập nhật | **Data Binding** | Giảm thiểu code boilerplate (`findViewById`, `setText`, `setOnClickListener`). |
| **Giao diện đơn giản**, ít thay đổi | **View Binding** | Nhanh hơn một chút, ít code cần sinh ra hơn. |

### 3.2. Code Pattern: Data Binding với ViewModel

1.  **Bật Data Binding** trong `build.gradle`: `buildFeatures { dataBinding true }`
2.  **Bọc layout trong thẻ `<layout>`** và khai báo biến `viewModel`:
    ```xml
    <layout xmlns:android="http://schemas.android.com/apk/res/android">
        <data>
            <variable name="viewModel" type="com.example.MyViewModel" />
        </data>
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@{viewModel.score.toString()}" />
        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:onClick="@{() -> viewModel.incrementScore()}" />
    </layout>
    ```
3.  **Sử dụng trong Activity**:
    ```kotlin
    class MainActivity : AppCompatActivity() {
        private val viewModel: MyViewModel by viewModels()

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)

            // Gán ViewModel và LifecycleOwner cho binding
            binding.viewModel = viewModel
            binding.lifecycleOwner = this // Quan trọng để LiveData tự cập nhật!
        }
    }
    ```

---

## SECTION 4: SHARED VIEWMODEL (Giao tiếp giữa các Fragment)

**Khi nào dùng**: Khi nhiều `Fragment` trong cùng một `Activity` cần chia sẻ dữ liệu hoặc giao tiếp với nhau.
**Tại sao đúng**: Cung cấp một "nguồn sự thật" chung mà không cần truyền dữ liệu qua lại bằng `Bundle` hay interface callback phức tạp.

**Code Pattern: `activityViewModels`**

```kotlin
// ViewModel được chia sẻ
class SharedViewModel : ViewModel() {
    val selectedItem = MutableLiveData<Item>()
}

// Fragment A (Sender)
class ListFragment : Fragment() {
    // Lấy ViewModel có scope là Activity
    private val sharedViewModel: SharedViewModel by activityViewModels()

    fun onItemSelected(item: Item) {
        sharedViewModel.selectedItem.value = item
    }
}

// Fragment B (Receiver)
class DetailFragment : Fragment() {
    private val sharedViewModel: SharedViewModel by activityViewModels()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        sharedViewModel.selectedItem.observe(viewLifecycleOwner) { item ->
            // Cập nhật UI với dữ liệu từ Fragment A
        }
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS (Lỗi thường gặp)

1.  **Chứa logic trong Activity/Fragment**: Đây là lỗi kiến trúc phổ biến nhất, làm cho code khó test, khó bảo trì, và dễ mất dữ liệu khi xoay màn hình.
2.  **Truyền `Context` hoặc `View` vào `ViewModel`**: Gây ra memory leak nghiêm trọng vì `ViewModel` sống lâu hơn `Activity`.
3.  **Sử dụng `MutableLiveData` public**: Cho phép UI Controller thay đổi dữ liệu trực tiếp, phá vỡ luồng dữ liệu một chiều.
4.  **Quên `binding.lifecycleOwner = this`**: Khiến Data Binding không thể lắng nghe `LiveData` và UI sẽ không tự động cập nhật.

---

## SECTION 6: MASTER CHEAT SHEET (Bảng tra cứu nhanh)

-   **Dữ liệu cần sống sót khi xoay màn hình?** -> Dùng `ViewModel`.
-   **Cần UI tự cập nhật khi dữ liệu thay đổi?** -> Dùng `LiveData` hoặc `StateFlow`.
-   **Muốn giảm code `findViewById` và `setText`?** -> Dùng Data Binding.
-   **Cần chia sẻ dữ liệu giữa các `Fragment`?** -> Dùng `sharedViewModel` (`by activityViewModels()`).
-   **Luôn nhớ**: `ViewModel` là nơi xử lý logic, `Activity`/`Fragment` là nơi hiển thị.
