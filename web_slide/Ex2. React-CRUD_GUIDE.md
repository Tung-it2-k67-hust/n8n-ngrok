# DEVELOPER DECISION GUIDE: Ex2. React-CRUD.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:37:52



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: React CRUD (Ex2)

## SECTION 1: CORE MENTAL MODEL

### 1.1. Core Definitions

*   **State Lifting (Nâng cấp State)**
    *   **VN:** Di chuyển state chung lên Component cha (Parent) và truyền dữ liệu đó xuống Component con (Child) qua `props`.
    *   **Real-world mindset:** Nếu 2 anh em cần chia sẻ đồ chơi, chúng phải问 mẹ (App) giữ đồ, không giữ riêng trong phòng mình.
*   **Controlled Component (Thành phần được kiểm soát)**
    *   **VN:** Input HTML được điều khiển hoàn toàn bởi `value` và `onChange` từ React State.
    *   **Real-world mindset:** Nút bấm trong game chỉ hoạt động khi Server cho phép, không tự bấm lung tung.
*   **Spread Operator (`...`)**
    *   **VN:** Toán tử sao chép đối tượng/mảng. Dùng để cập nhật state mà không mất dữ liệu cũ.
    *   **Real-world mindset:** Photo copy tờ giấy, viết thêm dòng mới vào bản photo, giữ nguyên bản gốc.
*   **Dependency Array (Mảng phụ thuộc)**
    *   **VN:** Mảng tham số thứ 2 của `useEffect`. Giúp React quyết định khi nào chạy lại effect.
    *   **Real-world mindset:** Chuông báo thức chỉ reng khi đồng hồ chỉ đúng giờ (giá trị trong mảng thay đổi).

### 1.2. Why this approach?

*   **Single Source of Truth (Một nguồn sự thật):** State nằm ở Component Cha (App) đảm bảo `Search`, `Add`, `Edit` đều làm việc với cùng một danh sách dữ liệu.
*   **Predictable Flow (Luồng dự đoán được):** Dữ liệu chỉ đi theo 1 chiều: **Cha → Con → (Xử lý) → (Cập nhật Cha)**.

---

## SECTION 2: DECISION TABLES

### Table 1: State Management (useState vs useEffect)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why)? | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Lưu dữ liệu người dùng nhập vào Form | `useState` | **State is local (State là nội bộ):** Form cần nhớ giá trị mới nhất mỗi lần gõ phím. | Gọi API ngay trong hàm `handleChange` (gây lag, spam server). |
| Tải dữ liệu từ API khi trang mở lên | `useEffect([])` | **Lifecycle (Vòng đời):** Chạy 1 lần duy nhất khi component được gắn vào DOM (Mount). | Đặt fetch data ngay trong body function component (gọi infinite loop). |
| Tự động cập nhật danh sách khi có người dùng mới | `useEffect([newUser])` | **Reactivity (Tính phản ứng):** Khi `newUser` thay đổi, effect chạy để update `users` list. | Quên Dependency Array hoặc viết sai logic update list. |

### Table 2: Handling Nested Data (Object)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why)? | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Cập nhật `street` trong `address` | `{...user, address: {...user.address, street: 'new'}}` | **Deep Copy (Sao chép sâu):** Phải copy đối tượng cha và đối tượng con để tránh ghi đè nhầm. | `user.address.street = 'new'` (Mutating state trực tiếp - React không detect được thay đổi). |
| Reset form sau khi Add | `setUser({ name: "", address: { street: "" } })` | **Clean Slate (Vẽ lại từ đầu):** Đảm bảo form rỗng hoàn toàn, bao gồm cả object lồng. | `setUser({ name: "" })` (Bỏ qua object lồng, giữ lại dữ liệu rác). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy

```text
[App] (State Container)
  │
  ├── [SearchForm] (Input only)
  │     │
  │     └── (Triggers) → setKeyword(kw) → App → Pass 'kw' Down
  │
  ├── [AddUser] (Form Input)
  │     │
  │     └── (Triggers) → onAdd(newUser) → App → Pass 'newUser' Down
  │
  └── [ResultTable] (Output & Action)
        │
        ├── Receives: keyword, user (new/edit), onAdded()
        ├── Logic: fetch API, Filter, Edit, Delete
        └── State Local: editing (đang sửa), loading
```

### Data Flow Diagram

```text
1. READ FLOW:
   API ──fetch──> ResultTable (State: users) ──render──> UI

2. CREATE FLOW:
   AddUser ──onAdd(user)──> App ──props──> ResultTable ──useEffect──> Update UI

3. SEARCH FLOW:
   SearchForm ──onChange──> App (setKeyword) ──props──> ResultTable ──filter──> UI
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Clean CRUD" Setup (App Component)

**Khi nào dùng:** Khởi tạo ứng dụng có nhiều component con cần chia sẻ state.

**Tại sao đúng:**集中管理 state (Quản lý tập trung) tại App, dễ debug và hiển thị dữ liệu đồng nhất.

```javascript
function App() {
  // 1. State Lifting: Giữ data chung tại Cha
  const [kw, setKeyword] = React.useState("");
  const [newUser, setNewUser] = React.useState(null);

  return (
    <div className="container">
      <h1>Quản lý người dùng</h1>
      
      {/* 2. Truyền hàm set state xuống con */}
      <SearchForm onChangeValue={setKeyword} />
      
      <AddUser onAdd={setNewUser} />
      
      {/* 3. Truyền data xuống con để render */}
      <ResultTable 
        keyword={kw} 
        user={newUser} 
        onAdded={() => setNewUser(null)} 
      />
    </div>
  );
}
```

### Pattern 2: Handle Nested Input (Add/Edit)

**Khi nào dùng:** Khi Form có data lồng (Address, Object, Array).

**Tại sao đúng:** Dùng Spread Operator (`...`) để giữ nguyên cấu trúc đối tượng, chỉ thay đổi giá trị mục tiêu.

```javascript
// Trong Component con (AddUser hoặc ResultTable)
const handleChange = (e) => {
  const { id, value } = e.target;

  if (["street", "suite", "city"].includes(id)) {
    // TRƯỜNG HỢP LỒNG: Cập nhật obj.address
    setUser((prev) => ({
      ...prev,
      address: { ...prev.address, [id]: value } // Copy obj address cũ, ghi đè field mới
    }));
  } else {
    // TRƯỜNG HỢP BẰNG: Cập nhật obj.level1
    setUser((prev) => ({ ...prev, [id]: value }));
  }
};
```

### Pattern 3: Local Edit State (Edit Feature)

**Khi nào dùng:** Khi cần form sửa ngay trong trang hoặc modal.

**Tại sao đúng:** Tách biệt "Dữ liệu đang sửa" (`editing`) với "Dữ liệu gốc" (`users`). Không làm乱 dữ liệu nếu người dùng bấm Hủy.

```javascript
function ResultTable() {
  const [users, setUsers] = React.useState([]);
  const [editing, setEditing] = React.useState(null); // Dữ liệu đang sửa

  // Bắt đầu sửa: Deep Copy sang state editing
  const handleEditClick = (user) => {
    setEditing({ ...user, address: { ...user.address } });
  };

  // Lưu lại: Map và thay thế
  const handleSave = () => {
    setUsers((prev) => prev.map((u) => (u.id === editing.id ? editing : u)));
    setEditing(null); // Đóng form
  };

  return (
    <>
      {/* Table hiển thị ở đây... */}
      {editing && (
        <div className="modal">
          {/* Form input bind value={editing.name}... */}
          <button onClick={handleSave}>Lưu</button>
          <button onClick={() => setEditing(null)}>Hủy</button>
        </div>
      )}
    </>
  );
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Mutating State Directly (Thay đổi State trực tiếp)
*   **Code sai:** `user.name = "New Name"; setUser(user);`
*   **Tại sao nguy hiểm:** React không biết data đã thay đổi vì cùng địa chỉ bộ nhớ (reference). UI không cập nhật (UI not updating). Luôn tạo object mới với Spread Operator.

### 2. Calling API inside Render (Gọi API trong render)
*   **Code sai:** `function Component() { fetch("..."); return ... }`
*   **Tại sao nguy hiểm:** Gây ra Vòng lặp vô hạn (Infinite Loop) và treo trình duyệt. API chỉ được gọi trong `useEffect`.

### 3. Key không unique trong List
*   **Code sai:** `users.map((u, index) => <tr key={index}>...)`
*   **Tại sao nguy hiểm:** Khi xóa hoặc sắp xếp thứ tự, React sẽ render sai phần tử, gây lỗi trạng thái giao diện (Ghost bugs). Phải dùng `key={u.id}` (ID thực).

### 4. Sync State với Props
*   **Code sai:**
    ```javascript
    useEffect(() => {
      setLocalState(props.value); // Có thể gây re-render loop
    }, [props.value]);
    ```
*   **Tại sao nguy hiểm:** Nếu Component cha render lại liên tục, Component con sẽ reset state không cần thiết. Chỉ dùng khiprops value thay đổi thực sự cần thiết cho logic trong con.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic Flow

1.  **Add:**
    `Form (Local State) -> onAdd(User) -> App State -> Pass Down -> ResultTable (useEffect Add)`
2.  **Edit:**
    `Click Edit -> Deep Copy to Editing State -> Form (Binding Editing) -> Save -> Map & Replace Main State`
3.  **Delete:**
    `Click Delete -> Filter ID != Target -> Set State`
4.  **Search:**
    `Input Change -> Set Keyword State -> Pass Down -> ResultTable Filter`

### Top 5 Rules to Remember

1.  **Lifting State:** Share data? Move State Up to Parent.
2.  **Immutable:** Never `state.x = 1`. Use `setState({ ...state, x: 1 })`.
3.  **Dependency:** `useEffect` needs array of dependencies to run.
4.  **Async:** Update list based on previous list? Use `setUsers(prev => [...prev, new])`.
5.  **Deep Copy:** Nested object? Copy every level: `{ ...parent, child: { ...child } }`.