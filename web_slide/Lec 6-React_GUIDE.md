# DEVELOPER DECISION GUIDE: Lec 6-React.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 18:01:07



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE - REACT (Lecture 6)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Single Page Application (SPA - Ứng dụng Trang Đơn):** Mô hình ứng dụng web tải một trang HTML duy nhất và cập nhật nội dung động thông qua JavaScript thay vì tải lại trang hoàn toàn.
**Virtual DOM (DOM Ảo):** Bản sao nhẹ của DOM thật được React giữ trong bộ nhớ, dùng để so sánh (diffing) và tính toán thay đổi trước khi bắn vào trình duyệt.
**JSX (JavaScript XML - XML JavaScript):** Cú pháp mở rộng cho phép viết code HTML trong JavaScript, được chuyển đổi (transpile) thành hàm `React.createElement()`.

### Why React Approach?
- **Imperative vs Declarative:**
  - *Imperative (Thủ tục):* "Làm thế nào" (VD: `document.getElementById...` -> manip DOM trực tiếp).
  - *Declarative (Khai báo):* "Cái gì" (VD: `<div>{data}</div>` -> React lo phần render).
  - **Lý do tốt hơn:** Ít bug hơn, dễ dự đoán state, tự động xử lý DOM updates.

### Code Demo: React vs Vanilla JS
```javascript
// Vanilla JS (Imperative - Rủi ro cao)
const container = document.getElementById('root');
const btn = document.createElement('button');
btn.innerText = 'Click me';
btn.onclick = () => container.innerHTML = 'Updated!';
container.appendChild(btn);

// React (Declarative - An toàn)
// 1. Define what UI looks like based on State
function App() {
  const [text, setText] = React.useState('Initial');
  return (
    <div>
      <button onClick={() => setText('Updated!')}>{text}</button>
    </div>
  );
}
// 2. React handles DOM updates automatically
```

---

## SECTION 2: DECISION TABLES

### Table 1: State Management (State vs Props)
| Tình huống sử dụng | Nên dùng gì | Tại sao (State Management) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Dữ liệu cần thay đổi theo thời gian (VD: input người dùng, toggle button) | **State (useState)** | State (Trạng thái) là private, thuộc về component. Khi state thay đổi, component re-render. | Lưu state ở component cha nhưng con không cần dùng -> "Prop Drilling". |
| Dữ liệu chỉ đọc, truyền từ cha xuống con | **Props (Thuộc tính)** | Props là read-only (chỉ đọc). Đảm bảo luồng dữ liệu một chiều (One-way data flow), dễ debug. | Modify props trực tiếp trong con (VD: `props.value = 1`) -> Error. |

### Table 2: SPA vs MPA
| Tình huống sử dụng | Nên dùng gì | Tại sao (Performance) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Ứng dụng tương tác cao, nhiều chuyển đổi giữa các view (VD: Admin Dashboard, Social Media) | **SPA (React)** | **Fast UX:** Không reload trang. **Low Server Load:** Chỉ tải data JSON sau initial load. | SEO Indexing: Search engine bots khó crawl JS-rendered content (cần SSR/Next.js để fix). |
| Nội dung tĩnh, cần SEO mạnh, ít tương tác (VD: Blog, Tin tức) | **MPA (Traditional)** | **SEO:** Mỗi trang có URL riêng, meta tags riêng. **Initial Load:** Nhanh hơn vì không cần tải bundle JS lớn. | Dùng SPA cho blog đơn giản -> Tốn bandwidth, load chậm do bundle React nặng. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy & Data Flow
```text
[ Root (App) ]
      |
      |-- (Props down) --> [ Parent Component ]
      |                      |
      |                      |-- (Props down) --> [ Child A (Dumb/Presentational) ]
      |                      |                      |-- Gọi callback từ cha
      |                      |
      |                      |-- (Props down) --> [ Child B (Smart/Stateful) ]
      |                                             |-- Sở hữu State local (useState)
      |                                             |-- Rerenders khi State thay đổi
      |
      |-- (Event Up) -- <Callback Function] (Không truyền state lên trực tiếp, truyền hàm)
```

**Luồng hoạt động:**
1. **Top-Down:** Cha truyền `props` (dữ liệu) xuống Con.
2. **Bottom-Up:** Con gọi `event handler` (hàm được truyền từ cha) để yêu cầu thay đổi dữ liệu.
3. **Re-render:** Cha cập nhật State -> Component con (nhận props mới) tự động render lại.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Controlled Component (Quản lý Input)
**Khi nào dùng:** Khi cần kiểm soát giá trị input realtime (validate, submit logic).
**Tại sao:** React là nguồn "truth duy nhất" cho UI state.

```javascript
import React, { useState } from 'react';

function LoginForm() {
  const [email, setEmail] = useState(''); // 1. State làm nguồn dữ liệu

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitting: ${email}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* 2. Giá trị input gắn liền với State */}
      {/* 3. Sự kiện onChange cập nhật State */}
      <input 
        type="email" 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
        placeholder="Enter email"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Pattern 2: Rendering Lists & Keys
**Khi nào dùng:** Hiển thị mảng dữ liệu động.
**Tại sao:** `key` giúp React xác định item nào đã thay đổi, thêm, hoặc xóa để tối ưu hóa re-render (Virtual DOM diffing).

```javascript
function TodoList({ items }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}> {/* Phải là unique ID, không phải index */}
          {item.text}
        </li>
      ))}
    </ul>
  );
}

// Usage
const todos = [
  { id: 1, text: 'Learn React' },
  { id: 2, text: 'Build Project' }
];
// Render: <TodoList items={todos} />
```

### Pattern 3: Conditional Rendering
**Khi nào dùng:** Hiển thị phần tử khi thỏa mãn điều kiện (VD: Loading, Auth).

```javascript
function UserProfile({ user, isLoading }) {
  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {user ? (
        <h1>Hello, {user.name}</h1>
      ) : (
        <button>Please Login</button>
      )}
    </div>
  );
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Mutating State Directly (Đặc biệt với Objects/Arrays)
- **Nguy hiểm:** React so sánh state bằng tham chiếu (reference). Nếu bạn mutate object (VD: `user.name = 'New'`), React không nhận thấy sự thay đổi -> UI không update.
- **Cách đúng:** Dùng spread operator hoặc immutable update patterns.
```javascript
// ❌ WRONG
const [user, setUser] = useState({ name: 'A', age: 20 });
user.name = 'B'; // Mutation!
setUser(user); // React không update vì reference không đổi

// ✅ CORRECT
setUser(prev => ({ ...prev, name: 'B' })); // Tạo object mới
```

### 2. Using Index as Key
- **Nguy hiểm:** Nếu danh sách thay đổi (xóa/thêm ở giữa), React sẽ nhầm lẫn các component dẫn đến trạng thái bị sai (VD: checkbox bị check sai ô).
- **Cách đúng:** Luôn dùng `id` duy nhất từ dữ liệu.

### 3. Calling Hooks inside Loops/Conditions
- **Nguy hiểm:** React dựa vào thứ tự gọi Hooks. Nếu gọi trong `if`, thứ tự thay đổi -> State bị mất.
- **Cách đúng:** Chỉ gọi Hooks ở level cao nhất (top level) của function component.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **State:** Dữ liệu thay đổi -> UI re-render. Dùng `useState`.
2. **Props:** Dữ liệu truyền xuống (read-only).
3. **Virtual DOM:** Để render nhanh, không cần lo lắng về performance.
4. **JSX:** Phải return 1 parent element hoặc Fragment `<>...</>`.
5. **Event:** Viết camelCase (onClick, onSubmit).

### Decision Logic (If-Else)
- **IF:** Dữ liệu cần sửa đổi bởi người dùng? -> **State**.
- **ELSE:** Dữ liệu chỉ để hiển thị? -> **Props**.
- **IF:** Logic có điều kiện hiển thị? -> **Conditional Rendering (Ternary/If)**.
- **IF:** Hiển thị list? -> **map() + key=id**.

### Top 10 Things to Remember
1. **SPA:** Tải 1 lần,update bằng JS.
2. **Re-render:** Xảy ra khi Props/State thay đổi.
3. **One-way Data Flow:** Dữ liệu đi theo 1 chiều (Cha -> Con).
4. **Event Handling:** Trả về hàm, không gọi ngay (`onClick={handleClick}`, không phải `onClick={handleClick()}`).
5. **Immutability:** Luôn tạo bản sao mới khi update State (Object/Array).
6. **JSX = JS:** Dùng curly braces `{}` để nhúng JS logic vào HTML.
7. **Key:** Bắt buộc khi render list, phải unique.
8. **Hook Rules:** Đặt ở top level, không dùng trong loop/condition.
9. **Build Tool:** Vite là lựa chọn hiện đại nhanh hơn CRA.
10. **SEO:** React SPA mặc định khó SEO, cần giải pháp SSR (Next.js) nếu cần.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE - React Core & Virtual DOM

## SECTION 1: CORE MENTAL MODEL

### Core Concepts (Term English - Vietnamese Explanation)
- **DOM (Document Object Model)**: Mô hình tài liệu, cấu trúc cây HTML thực tế được trình duyệt render và JavaScript thao tác trực tiếp.
- **Real DOM (Real DOM)**: DOM thực, bộ nhớ trình duyệt, thao tác chậm do browser phải tính toán lại layout và paint.
- **Virtual DOM (Virtual DOM)**: DOM ảo, đối tượng JavaScript trong RAM, dùng để so sánh và tính toán thay đổi trước khi bắn vào Real DOM.
- **Reconciliation (Reconciliation)**: Quá trình React so sánh Virtual DOM cũ và mới để tìm ra sự khác biệt (diff).
- **Diffing Algorithm (Diffing Algorithm)**: Thuật toán so sánh nhanh, áp dụng quy tắc 2 giả định (key assumptions) để tối ưu hóa việc so sánh.
- **Fiber (Fiber)**: Cấu trúc dữ liệu树 (tree) mới trong React 16+, cho phép Reconciliation chạy bất đồng bộ (asynchronous), có thể ngắt quãng và ưu tiên priority.

### Key Mental Model: The "Snapshot & Patch" Workflow
React không làm việc với DOM thực tế từng giây. Nó làm việc với một bản sao (snapshot) trong trí nhớ.
1. **Bước 1 (Snapshot)**: Khi state thay đổi, React tạo một snapshot Virtual DOM mới.
2. **Bước 2 (Diff)**: React so snapshot mới với snapshot cũ để tìm "vết" (patch).
3. **Bước 3 (Patch)**: React bắn đúng "vết" đó vào Real DOM.

**Tại sao tốt hơn?**
- **Real DOM**: Nếu bạn sửa 1 dòng text, browser repaint cả cái `div` cha (có thể lan ra cả trang).
- **Virtual DOM**: React tính toán ra được chỉ có node text đó thay đổi, bắn đúng 1 update. Giảm thiểu Layout Thrashing.

---

## SECTION 2: DECISION TABLES

### Table 1: Real DOM vs Virtual DOM Usage
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Static Website (Brochure)** | **Real DOM** (hoặc Vanilla JS) | Tối giản, không cần khung framework nặng. | Dùng React cho trang landing page 1 trang chỉ đọc text (Overkill). |
| **Dynamic, Interactive UI (Dashboard, App)** | **Virtual DOM** (React) | **Minimize DOM Ops**: Cập nhật phần tử cụ thể mà không reflow cả trang. | Cố gắng tối ưu DOM thủ công (e.g., `document.getElementById`) thay vì tin tưởng vào React render cycle. |
| **Frequent Data Updates (Live feed)** | **Virtual DOM** (React) | **Batch Updates**: React gom nhiều thay đổi nhỏ thành 1 lần bắn lên UI, tránh lag. | Gọi `setState` quá nhiều lần trong vòng lặp mà không debounce/throttle. |

### Table 2: Functional vs Class Components
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **New Projects (React 16.8+)** | **Functional Component** | **Hooks**: Logic reuse (custom hooks) dễ hơn HOC/Render Props. Code ngắn gọn, dễ test. | Viết Class Component vì "truyền thống" (bỏ qua ưu điểm của Hooks). |
| **Legacy Codebases** | **Class Component** | Giữ nguyên consistency, tránh migrate lớn nếu không cần thiết. | Mix `Class` và `Functional` tùy tiện không có quy chuẩn. |
| **Complex Lifecycle Logic** | **Functional Component** | `useEffect` tách bạch logic rõ ràng (cần dependency array). | Dùng `useEffect` không có dependency array gây infinite loop. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The React Update Hierarchy
```text
[User Interaction / State Change]
       ⬇
[React Component Function] (Triggers)
       ⬇
[Virtual DOM Render] (Creates New Tree in RAM)
       ⬇
[Reconciliation (Diffing)] (Compares Old vs New Fiber Tree)
       ⬇
[Commit Phase] (Patches to)
[Real DOM] (Browser Paints)
```

### Component Relationship Rules
- **Parent -> Child**: Passing data down via **Props** (Properties).
- **Child -> Parent**: Passing events up via **Callbacks** (Functions passed as props).
- **Siblings**: Must communicate via **Common Parent** or **Context/State Management**.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Virtual DOM Rendering (React 18+)
**Khi nào dùng**: Khi cần tạo UI và quản lý DOM thông qua React.
**Tại sao đúng**: Utilizes `createRoot` để tối ưu hóa việc batches các updates.

```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

// 1. Component (Logic + Template)
function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <h1>Virtual DOM Demo</h1>
      <p>Count: {count}</p>
      {/* Triggers a render, creates a new Virtual DOM tree */}
      <button onClick={() => setCount(count + 1)}>Increase</button>
    </div>
  );
}

// 2. Mounting (Connecting Virtual DOM to Real DOM)
const container = document.getElementById('root');
const root = createRoot(container);
root.render(<App />);
```

### Pattern 2: Diffing Optimization with Keys
**Khi nào dùng**: Khi render list elements (`map`).
**Tại sao đúng**: `key` helps React identify which items have changed, added, or removed, preventing full list re-renders.

```jsx
function TodoList({ items }) {
  return (
    <ul>
      {items.map((item) => (
        // ✅ CORRECT: Use stable ID
        <li key={item.id}>
          {item.text}
        </li>
        
        // ❌ WRONG: Using index causes issues if list reorders
        // <li key={index}> {item.text} </li>
      ))}
    </ul>
  );
}
```

### Pattern 3: Functional Component with Hooks
**Khi nào dùng**: Modern standard for all new logic.
**Tại sao đúng**: Isolates side effects and state from the render cycle.

```jsx
import React, { useState, useEffect } from 'react';

function UserProfile({ userId }) {
  // State: Triggers re-render when updated
  const [user, setUser] = useState(null);

  // Effect: Handles side effects (API calls) after render
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => setUser(data));
  }, [userId]); // Dependency: Re-run only if userId changes

  if (!user) return <div>Loading...</div>;

  return <div>Hello, {user.name}</div>;
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Direct DOM Manipulation
**Code**: `document.getElementById('myInput').value = '...'`
**Lý do nguy hiểm**: React không biết bạn đã sửa DOM. Lần render sau, React sẽ overwrite thay đổi của bạn hoặc xóa nó. Gây ra "Race condition" giữa React và Vanilla JS.

### 2. Using Index as Key
**Code**: `items.map((item, index) => <li key={index}>...</li>)`
**Lý do nguy hiểm**: Nếu `items` array thay đổi (sort, delete, filter), React sẽ confused về identity của items, dẫn đến update sai state của component con hoặc làm mất focus (input).

### 3. Mutating State Directly
**Code**: `state.count = 5; setState(state)`
**Lý do nguy hiểm**: React dùng shallow comparison (kiểm tra địa chỉ nhớ). Nếu object không thay đổi địa chỉ, React không trigger re-render. Luôn tạo object mới (Spread operator: `...state`).

### 4. Suspense without Fallback (Legacy)
**Code**: `<Suspense> <HeavyComponent /> </Suspense>`
**Lý do nguy hiểm**: Nếu không có prop `fallback`, UI sẽ bị trống rỗng (white screen) trong lúc load, gây trải nghiệm người dùng tệ.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Decision Logic
```text
IF (Project is new AND React 16.8+) THEN -> Use Functional Components + Hooks.
ELSE IF (Legacy Code) THEN -> Keep Class Components, migrate if needed.

IF (Rendering List) THEN -> ALWAYS use unique Key (ID from database).
IF (State Change) THEN -> React builds Virtual DOM -> Diff -> Patch Real DOM.
```

### Top 5 Things to Remember for Exams/Coding
1. **Virtual DOM is just a JS Object**: It's fast because it lives in memory (RAM), not on screen.
2. **Reconciliation = Diffing**: React 16+ uses **Fiber** to make this process interruptible.
3. **Props are Read-Only**: Props should be treated as immutable.
4. **Keys are for React, not for you**: They help the diffing algorithm, don't use random numbers.
5. **Batching**: React 18 batches multiple `setState` calls into a single render for performance.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE - React Component Tree & State Management

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Props (Thuộc tính)**: Dữ liệu được truyền từ component cha xuống component con. Props là **immutable (không thay đổi)** và chỉ đọc (read-only). Trong React, `props` đóng vai trò như tham số của hàm, cho phép cha cấu hình con.

**State (Trạng thái)**: Dữ liệu nội bộ của component được React quản lý. State là **mutable (có thể thay đổi)** nhưng chỉ thông qua hàm setter (vd: `setCount`). Khi state thay đổi, component tự động re-render.

**One-way Data Flow (Luồng dữ liệu một chiều)**: Dữ liệu chỉ đi theo một hướng: Parent → Child. Child không thể sửa trực tiếp dữ liệu của Parent.

```javascript
// Props (Cha → Con): Read-only
function Parent() {
  const userName = "Lam";
  return <UserCard name={userName} />; // Pass props
}

function UserCard(props) {
  // props.name = "Lam" - immutable, không được sửa
  return <div>{props.name}</div>;
}

// State (Nội bộ): Mutable qua setter
function Counter() {
  const [count, setCount] = useState(0); // [giá trị, hàm cập nhật]
  
  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}

// Callback (Con → Cha): Child gọi function của Parent
function Parent() {
  const handleData = (data) => console.log(data);
  return <Child onSubmit={handleData} />; // Pass function
}

function Child({ onSubmit }) {
  return <button onClick={() => onSubmit("data")}>Send</button>;
}
```

**Why it's better**: Kiến trúc này đảm bảo luồng dữ liệu rõ ràng, dễ debug và tránh side effects không mong muốn.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Props vs State

| Use case (Tình huống) | Nên dùng gì | Why (Lý do) | Common mistake (Sai lầm thường gặp) |
|------------------------|-------------|-------------|-------------------------------------|
| Dữ liệu từ Parent, không đổi | Props | Props là **read-only**, đảm bảo dữ liệu nguồn không bị sửa | Child sửa props trực tiếp → lỗi immutable |
| Dữ liệu nội bộ, thay đổi theo event | State | State là **mutable**, tự động re-render khi đổi | Đưa state không cần thiết lên Parent |
| Configure component | Props | Props cho phép cha cấu hình con linh hoạt | Hardcode giá trị trong con |
| Dữ liệu lifecycle theo user action | State | State dùng `setState()` để update và render lại | Không dùng state mà sửa DOM trực tiếp |

### Parent → Child vs Child → Parent

| Use case (Tình huống) | Nên dùng gì | Why (Lý do) | Common mistake (Sai lầm thường gặp) |
|------------------------|-------------|-------------|-------------------------------------|
| Hiển thị dữ liệu cha sang con | Props | **One-way data flow**, đảm bảo unidirectional | Con sửa dữ liệu cha → sai nguyên tắc |
| Con thông báo event cho cha | Callback function (props) | Cha truyền function cho con, con gọi lại | Con tự sửa state cha trực tiếp |
| Sibling communication | Through Parent hoặc Context API | Props drilling hoặc **Context** cho shared state | Truyền dữ liệu ngang qua props lung tung |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS

```
[App (Parent)] ──props─────▶ [UserCard (Child)]
    │                            │
    │                            ▼
    │                      Hiển thị name="Lam"
    │
    └─props─────▶ [Counter (Child)]
                      │
                      ▼
                State: count = 0
                └─onClick──▶ setCount(1) → Re-render

Component Tree Flow:
Parent → Child: Props (data down)
Child → Parent: Callback (event up)
Sibling ↔ Parent/Context
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Passing Props (Parent → Child)

**Khi nào dùng**: Khi cần truyền dữ liệu từ cha sang con để hiển thị hoặc cấu hình.

**Tại sao đúng**: Duy trì **one-way data flow**, đảm bảo cha làm chủ dữ liệu.

```javascript
// Parent Component
function App() {
  const user = { name: "Lam", role: "Admin" };
  return (
    <div>
      <UserCard name={user.name} role={user.role} />
      <Welcome message="Welcome back!" />
    </div>
  );
}

// Child Component 1
function UserCard({ name, role }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>Role: {role}</p>
    </div>
  );
}

// Child Component 2 with children prop
function Welcome({ message, children }) {
  return (
    <div>
      <p>{message}</p>
      {children} {/* Render whatever is inside <Welcome> */}
    </div>
  );
}

// Usage: <Welcome message="..."><button>OK</button></Welcome>
```

### Pattern 2: Callback Function (Child → Parent)

**Khi nào dùng**: Khi con cần gửi dữ liệu hoặc thông báo event lên cha.

**Tại sao đúng**: Cha vẫn làm chủ logic, con chỉ kích hoạt callback.

```javascript
// Parent Component
function Parent() {
  const [data, setData] = useState([]);
  
  const handleAddItem = (newItem) => {
    setData([...data, newItem]); // Update parent state
  };
  
  return (
    <div>
      <ItemList items={data} />
      <AddButton onAdd={handleAddItem} />
    </div>
  );
}

// Child Component
function AddButton({ onAdd }) {
  return (
    <button onClick={() => onAdd("New Item")}>
      Add Item
    </button>
  );
}
```

### Pattern 3: useState Hook

**Khi nào dùng**: Khi component cần lưu trữ và thay đổi dữ liệu nội bộ.

**Tại sao đúng**: State tự động trigger re-render, đảm bảo UI đồng bộ với dữ liệu.

```javascript
import { useState } from 'react';

function Counter() {
  // [current value, setter function]
  const [count, setCount] = useState(0);
  const [user, setUser] = useState({ name: "Lam" });
  
  const increment = () => {
    setCount(count + 1); // Cập nhật state → re-render
  };
  
  const updateName = (newName) => {
    setUser(prev => ({ ...prev, name: newName })); // Functional update
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
      
      <p>Name: {user.name}</p>
      <button onClick={() => updateName("Admin")}>Change Name</button>
    </div>
  );
}
```

### Pattern 4: Props.children (Composition)

**Khi nào dùng**: Khi component cần wrap nội dung linh hoạt.

**Tại sao đúng**: Tái sử dụng component, cho phép cha tùy ý compose con.

```javascript
// Layout Component
function Card({ children, title }) {
  return (
    <div style={{ border: '1px solid #ccc', padding: '10px' }}>
      <h2>{title}</h2>
      <div>{children}</div>
    </div>
  );
}

// Usage
function App() {
  return (
    <div>
      <Card title="User Info">
        <p>Name: Lam</p>
        <button>Edit</button>
      </Card>
      
      <Card title="Settings">
        <ul>
          <li>Option 1</li>
          <li>Option 2</li>
        </ul>
      </Card>
    </div>
  );
}
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

**❌ Mutating Props trong Child**
```javascript
// SAI
function Child({ name }) {
  name = "New Name"; // ERROR: Props là read-only
  return <div>{name}</div>;
}
```
**Why dangerous**: Vi phạm immutable原则 → bugs không dự đoán được, React không track được changes.

**❌ Sửa State trực tiếp**
```javascript
// SAI
function Counter() {
  let count = 0; // Not state
  count++; // Not trigger re-render
  return <button onClick={() => count++}>{count}</button>;
}
```
**Why dangerous**: UI không update → state không đồng bộ với view.

**❌ Passing too many props (Prop Drilling)**
```javascript
// SAI
function App() {
  return <GrandParent data="x" />;
}
function GrandParent(props) {
  return <Parent {...props} />; // Pass through all levels
}
function Parent(props) {
  return <Child {...props} />;
}
```
**Why dangerous**: Code khó maintain, refactor vất vả → Use **Context API** instead.

**❌ Using index as key**
```javascript
// SAI
{items.map((item, index) => (
  <li key={index}>{item.name}</li>
))}
```
**Why dangerous**: Khi list thay đổi (add/remove), React bị confuse về component identity → performance issues, bugs state.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Quick Reference Rules
- **Props**: Read-only, Parent → Child, dữ liệu external
- **State**: Mutable via setter, internal, trigger re-render
- **One-way flow**: Data down, Event up
- **props.children**: Wrap content, composition pattern

### Decision Logic (If-Else Style)
```
IF data comes from Parent AND never changes → Use Props
IF data changes inside component → Use State
IF Child needs to send data to Parent → Pass callback function
IF sibling needs to share data → Use Parent as中介 OR Context API
IF component wraps other components → Use props.children
IF try to mutate props → STOP, use State instead
```

### Top 10 Things to Remember
1. **Props are immutable** - Child cannot modify
2. **State triggers re-render** - Use setState() to update
3. **One-way data flow only** - Parent → Child
4. **Callback for child→parent communication**
5. **props.children for composition**
6. **Don't use index as key** in lists
7. **Don't mutate state directly** (use setState)
8. **Props drilling is bad** - Use Context API for deep nesting
9. **useState returns [value, setter]** - Destructure properly
10. **All updates must be immutable** - Spread operators for objects/arrays

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: React Hooks & State Management

---

## SECTION 1: CORE MENTAL MODEL

### Core Concepts

*   **Hook (Nút kết nối)**: Functions that let you “hook into” React features (state, lifecycle, context) from functional components. Replaces Class Components complexity (`this`, `binding`, `constructor`).
*   **useState (Trạng thái)**: Hook returns `[current state, setter function]` to manage local component data.
*   **State Setter Function (Hàm cập nhật)**: `setState` used to update state. **Does not update immediately**.
*   **Batching (Gom nhóm)**: React combines multiple `setState` calls into a single re-render for performance optimization.
*   **Virtual DOM & Reconciliation (DOM Ảo & Cân bằng)**: React compares new Virtual DOM with previous version to calculate minimal changes, then patches Real DOM.

### Lifecycle Mental Model
1.  **Initial Mount**: `Demo()` -> `useState(0)` -> Render UI.
2.  **Event**: `setCount(1)` -> Queue Update -> Schedule Re-render.
3.  **Re-render**: `Demo()` called again -> `useState()` returns `1` -> Diffing -> Real DOM Update.
4.  **Unmount**: Component removed.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống) | Should Use (Nên dùng) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Simple state (value, bool, string)** | `useState` | **State Variable (Biến trạng thái)**: Simple, readable, direct updates. | Naming variables without `const` in array destructuring. |
| **Heavy initial calculation** | `useState(() => compute())` | **Lazy Initial State**: Ensures expensive logic runs only once (initial render), not every re-render. | Passing the function result directly `useState(compute())`, causing execution on every render. |
| **Lifecycle side effects (API, Timer)** | `useEffect` | **Effect Hook**: Handles logic after render or on specific prop/state changes. | Running effects without dependencies, causing infinite loops or unnecessary runs. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### State Update Flow

```text
[User Interaction / Event]
       |
       v
[Call Setter Function] (e.g., setCount)
       |
       v
[React Queues Update] (Batching happens here)
       |
       v
[Re-render Scheduled] (React Scheduler)
       |
       v
[Component Function Called Again]
       |
       v
[useState Returns NEW State]
       |
       v
[Virtual DOM Diffing] (Compare old vs new)
       |
       v
[Real DOM Update] (Patches only changed nodes)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic State Management

**When to use (Khi nào dùng):** Managing simple values (numbers, strings, booleans) inside a component.

**Why this pattern is correct:** `useState` provides a strict contract: the variable holds the value, the setter triggers the render cycle.

```javascript
import React, { useState } from 'react';

function Counter() {
  // 1. Declaration: [Value, Updater]
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    // 2. Update: Triggers Re-render
    // React batches multiple calls if triggered by synthetic events
    setCount(prev => prev + 1); 
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
}
```

### Pattern 2: Lazy Initial State

**When to use (Khi nào dùng):** When the initial state requires an expensive calculation (e.g., parsing large JSON, heavy math).

**Why this pattern is correct:** Passing a function to `useState` ensures it is executed **only once** during the mount phase, preventing performance drag on re-renders.

```javascript
import React, { useState } from 'react';

function ExpensiveComponent() {
  // ⚠️ Correct: Function wrapper
  const [state] = useState(() => {
    console.log('Calculating...');
    // Imagine heavy calculation here
    return performHeavyCalculation(); 
  });

  // ❌ Wrong: Runs on EVERY render
  // const [state] = useState(performHeavyCalculation()); 

  return <div>{state}</div>;
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

*   **Mutating State Directly**
    *   **Danger:** `state.count = 5` (Mutating object/array in place).
    *   **Why:** React relies on reference equality (`===`). Mutations don't trigger re-renders because the object reference hasn't changed. Always use the setter function.

*   **Relying on Current State for Next Update**
    *   **Danger:** `setCount(count + 1); setCount(count + 1);` inside one function.
    *   **Why:** Due to **Batching**, `count` variable inside the function scope doesn't update between calls. Both updates see the *old* value, resulting in an increment of only 1.
    *   **Fix:** Use the functional update form: `setCount(prev => prev + 1)`.

*   **Using State for Everything**
    *   **Danger:** Storing derived data or values that can be calculated from existing props/state into state variables.
    *   **Why:** Creates **Source of Truth** duplication. If one updates and the other doesn't, the UI becomes inconsistent. Use variables or `useMemo` instead.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules

1.  **State vs Variable:**
    *   Data changes UI? → `useState`.
    *   Data doesn't change UI? → Regular variable (`const`).
2.  **Updating Logic:**
    *   `setCount(count + 1)` → If you don't care about the previous state.
    *   `setCount(prev => prev + 1)` → If next state depends on previous state (safest).
3.  **Batches:** Multiple `setState` in event handlers = 1 Re-render.
4.  **Initialization:** `useState(expensiveFn)` runs `expensiveFn` on *every* render. `useState(() => expensiveFn)` runs *once*.

### Top 3 Things to Remember
1.  **Never mutate state directly.** Use the setter.
2.  **Rules of Hooks:** Call Hooks at the top level, only in functional components.
3.  **Functional Updates:** Use `prev` argument in `setState` when calculating new state based on old state.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: React State & Effects

## SECTION 1: CORE MENTAL MODEL

### 1.1. State Update Logic (Critical)

**setState(prev => next)**
- **Là gì**: Functional Update (Cập nhật theo hàm). Truy cập giá trị state an toàn và chính xác nhất tại thời điểm update.
- **Tại sao hiệu quả**: `setState(value)` là **bất đồng bộ** (asynchronous) và được gom batch. React giữ giá trị cũ để tối ưu性能, dẫn đến `value + 1` có thể bị ghi đè nếu gọi nhiều lần trong một chu kỳ render.

**Code Demo:**
```javascript
// ❌ SAI: Có thể bị ghi đè (Race Condition)
const handleClick = () => {
  setCount(count + 1); // React nhớ giá trị 'count' cũ
  setCount(count + 1); // Vẫn dùng giá trị 'count' cũ, cộng 1 => Tăng 1
};

// ✅ ĐÚNG: Dù gọi bao nhiêu lần cũng đúng
const handleClick = () => {
  setCount(prev => prev + 1); // React truyền giá trị mới nhất (prev)
  setCount(prev => prev + 1); // Tiếp tục dùng prev => Tăng 2
};
```

### 1.2. Immutability (Tính bất biến)

**State as Object/Array**
- **Là gì**: Không modify state trực tiếp. Phải tạo bản sao mới trước khi update.
- **Tại sao hiệu quả**: React so sánh references (địa chỉ bộ nhớ). Nếu object giữ nguyên reference, React không detect sự thay đổi và không re-render.

**Code Demo:**
```javascript
const [user, setUser] = useState({ name: "A", age: 20 });

// ❌ SAI: React không detect thay đổi
user.age = 21; 
setUser(user); 

// ✅ ĐÚNG: Tạo bản sao mới (Spread Operator)
setUser({ ...user, age: 21 }); 

// ✅ ĐÚNG (Array): Map trả về mảng mới
setUserList(prev => prev.map(u => u.id === 1 ? { ...u, age: 21 } : u));
```

### 1.3. Side Effects & Dependency Array (Mảng phụ thuộc)

**useEffect(callback, [deps])**
- **Là gì**: Nơi thực hiện logic "bên ngoài" vòng lặp render (API, DOM, Timer).
- **Luật chạy**: React so sánh `deps` cũ vs mới. Nếu khác -> Chạy lại callback. Nếu rỗng `[]` -> Chạy 1 lần duy nhất khi mount.

---

## SECTION 2: DECISION TABLES

### Table 2.1: Cập nhật State (Update Strategy)

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| State phụ thuộc vào giá trị cũ (Counter, Toggle) | `setState(prev => prev + 1)` | **Functional Update**: Đảm bảo luôn lấy giá trị mới nhất, tránh **Race Condition** do Asynchronous batching. | Dùng `setState(count + 1)` khi gọi nhiều lần cùng lúc. |
| Update Object/Array | `setState({ ...old, new })` / `map/filter` | **Immutability**: React dùng cơ chế tham chiếu (Reference) để tối ưu. Sửa trực tiếp sẽ không kích hoạt Re-render. | Sửa trực tiếp Object/Array hiện tại (mutation). |
| Input Form (Two-way Binding) | `value={state}` + `onChange` | **Controlled Component**: Input được React quản lý hoàn toàn, đảm bảo UI và State đồng nhất. | Để Input tự do (Uncontrolled) mà không sync với State. |

### Table 2.2: useEffect Dependency Array

| Mục đích | Dependency Array | Khi nào chạy (When it runs) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Fetch API / Setup全局 data | `[]` (Empty) | **1 lần duy nhất** sau khi Component Mount (Lần đầu render). | Để trống trong khi cần phụ thuộc props/state để fetch lại. |
| Cập nhật Title / Listenner theo State | `[count]` | Mỗi khi `count` thay đổi (Re-run). | Thiếu dependency gây lỗi stale data hoặc infinite loop. |
| Debug / tracking render | Không có array | **Mỗi lần** component re-render. | Dùng trong production gây performance drop. |
| Cleanup (Xóa timer, subscription) | Function return | Chạy trước khi unmount HOẶC trước khi effect chạy lại. | Quên cleanup gây rò rỉ bộ nhớ (memory leak). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Lifecycle & Data Flow

```text
[Component Render]
       |
       v
[1. Calculate UI] --> [State: userInput]
       |                   ^
       v                   | (Two-way Binding)
[2. Run useEffect]         |
   (Side Effects)          |
       |                   |
       | (Cleanup)         |
       v                   |
[3. Update DOM] <----------+
       |
       v
[User Event] --> [Trigger State Change]
       |
       +---> [setState(prev => ...)] (Batching)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe State Increment
**Khi nào dùng**: Khi cần tăng/giảm số lượng dựa trên chính nó.
**Tại sao đúng**: Loại bỏ hoàn toàn lỗi race condition trong môi trường asynchronous.

```javascript
const [count, setCount] = useState(0);

const incrementTwice = () => {
  // Logic này an toàn tuyệt đối
  setCount(c => c + 1); 
  setCount(c => c + 1);
};
```

### Pattern 2: Immutable Object Update
**Khi nào dùng**: Khi state là Object và bạn muốn thay đổi 1 field bất kỳ.
**Tại sao đúng**: Giữ nguyên các field cũ, tạo Object mới để React detect thay đổi.

```javascript
const [formData, setFormData] = useState({ name: 'John', email: 'a@b.com' });

const updateEmail = (newEmail) => {
  setFormData(prev => ({
    ...prev,        // Giữ lại name
    email: newEmail // Ghi đè email
  }));
};
```

### Pattern 3: useEffect Lifecycle Control
**Khi nào dùng**: Khi cần fetch data hoặc setup listener chỉ 1 lần.
**Tại sao đúng**: Dependency `[]` báo cho React chỉ chạy logic này khi Component sinh ra.

```javascript
useEffect(() => {
  // Logic chạy 1 lần
  const timer = setTimeout(() => {
    console.log("Mounted");
  }, 1000);

  // Cleanup (Bắt buộc nếu có side effect vĩnh viễn)
  return () => clearTimeout(timer);
}, []);
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Sửa trực tiếp State (Direct Mutation)**
    *   **Mã**: `user.name = "New"; setUser(user);`
    *   **Lỗi**: React không thấy Object thay đổi (vẫn cùng reference), UI không update.
    *   **Cách tránh**: Luôn dùng Spread Operator `{...obj}` hoặc `map` tạo mảng mới.

2.  **Thiếu Dependency trong useEffect**
    *   **Mã**: `useEffect(() => { fetchData(id); }, [])` nhưng `id` là props.
    *   **Lỗi**: Lần đầu load đúng `id`. Khi `id` thay đổi (props đổi), effect không chạy -> Hiển thị sai dữ liệu (Stale Closure).
    *   **Cách tránh**: Luôn đưa biến dùng bên trong effect vào dependency array: `[id]`.

3.  **Dùng state không cần thiết để trigger render**
    *   **Mã**: `setCount(0);` ngay lập tức sau khi count đã là 0.
    *   **Lỗi**: Gây re-render vô ích, lãng phí tài nguyên.
    *   **Cách tránh**: Kiểm tra điều kiện trước khi set state (if prev !== next).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic Flow
1.  **Cần update state dựa trên giá trị cũ?**
    *   Dùng `setState(prev => ...)`.
2.  **State là Object/Array?**
    *   Luôn clone trước: `{...obj}` hoặc `[...arr]`.
3.  **Logic chạy khi nào?**
    *   1 lần: `[]`
    *   Mỗi khi render: (không có [])
    *   Khi giá trị thay đổi: `[val]`
4.  **Có timer/fetch/event listener?**
    *   Return `() => cleanup` trong useEffect.

### Top 3 Things to Remember
1.  **State là bất biến (Immutable)**: Đọc được, không sờ được.
2.  **Batching là cơ chế**: Đừng tin vào thứ tự gọi `setState` nếu không dùng functional update.
3.  **Dependency Array là chìa khóa**: Nói cho React khi nào cần chạy lại logic.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: React Router & Context API (Lec 6)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions (Term - Vietnamese Explanation)
*   **SPA (Single Page Application - Ứng dụng Trang Đơn):** Web app that loads a single HTML page and dynamically updates content via JavaScript without full page reloads.
*   **MPA (Multi-Page Application - Ứng dụng Đa Trang):** Traditional website where each click loads a new HTML page from the server.
*   **Client-Side Routing (Định tuyến phía Khách hàng):** The browser intercepts navigation requests and renders new UI locally without asking the server for a full page.
*   **BrowserRouter (Bộ định trình trình duyệt):** A wrapper component that syncs UI with the browser's address bar using the HTML5 History API.
*   **URL Parameters (Tham số URL):** Dynamic segments in a URL (e.g., `/users/:id`) that capture variable values to render specific data.
*   **Prop Drilling (Khoan xuyên Prop):** The process of passing data from a top component down to a deeply nested component through intermediate components that don't need the data.
*   **Context API:** React's built-in system to create global variables accessible by any component in the tree without passing props manually.

### Why React Router over MPA?
*   **Performance:** No full page reload means instant transitions and preserved application state (e.g., scroll position, form inputs).
*   **User Experience:** Feels like a native app (smooth, fast).
*   **Architecture:** Decouples the view layer from the data layer; the server only provides data (API), not HTML.

---

## SECTION 2: DECISION TABLES

### React Router: `<Link>` vs `<a>` & Client vs Server Routing
| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Navigating between pages inside the app | **`<Link to="...">`** | **Client-Side Navigation (Định tuyến phía KH):** Prevents full reload, keeps app state intact. | Using `<a href="...">`: Triggers a full page reload, resetting all state and losing performance benefits. |
| Linking to external sites (google.com) | **`<a href="...">`** | **External Navigation:** Requires a full request to an external server. | Using `<Link>`: Breaks external links or behaves incorrectly because React Router only handles internal paths. |
| Defining routes in the app structure | **`<Routes>` & `<Route>`** | **Route Matching (Khớp đường dẫn):** Conditionally renders components based on the current URL path. | Placing `<Route>` directly inside `App` without a `<Routes>` wrapper (v6+ syntax), or using `component` prop instead of `element`. |

### Data Sharing: Prop Drilling vs Context API
| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao - EN term + VI explanation) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Passing data from Parent to Direct Child | **Props** | **Direct Data Flow:** Standard, explicit, and easy to trace data lineage. | Creating a Context for a simple parent-child relationship; adds unnecessary boilerplate. |
| Passing data through 3+ layers of components | **Context API** | **Avoid Prop Drilling (Tránh khoan xuyên):** Reduces coupling and makes code easier to maintain. | Creating one giant Context for *all* app data (e.g., User, Theme, Cart in one). Causes unnecessary re-renders. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### React App Hierarchy (Routing & State)
```text
[ index.js ]
      |
      +-- <BrowserRouter> (Wrapper: Syncs with Browser History)
            |
            +-- <App> (Main Layout: Navbar, Footer)
                  |
                  +-- <Context.Provider> (Global State: Auth, Theme)
                  |     |
                  |     +-- <Routes> (Switcher logic)
                  |           |
                  |           +-- Route: "/home"     -> <Home />
                  |           +-- Route: "/about"    -> <About />
                  |           +-- Route: "/users/:id"-> <UserProfile />
                  |                 |
                  |                 +-- <UserDetails> (Uses useContext)
                  |
                  +-- <Link> (Triggers URL change in Browser)
```

### Data Flow
1.  **User clicks `<Link to="/users/1">`**.
2.  **BrowserRouter** detects URL change (no server request).
3.  **Routes** scans for a matching `<Route path="/users/:id">`.
4.  **useParams** extracts `id: 1`.
5.  **Component renders** `<UserProfile id={1} />`.
6.  **useContext** (if used) injects global data (e.g., Theme) directly into the component.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Routing with Parameters
**Khi nào dùng:** Khi cần chuyển hướng giữa các view và truy cập ID từ URL (ví dụ: Chi tiết sản phẩm).

```jsx
import React from 'react';
import { BrowserRouter, Routes, Route, Link, useParams } from 'react-router-dom';

// Component hiển thị chi tiết (nhận tham số URL)
const ProductDetail = () => {
  const { id } = useParams(); // Lấy :id từ URL
  return <div>Đang xem sản phẩm số: {id}</div>;
};

// Component chính
const App = () => {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Trang chủ</Link>
        <Link to="/products/123">Sản phẩm A</Link>
      </nav>
      
      <Routes>
        <Route path="/" element={<div>Trang chủ</div>} />
        {/* Dấu : để khai báo tham số động */}
        <Route path="/products/:id" element={<ProductDetail />} />
      </Routes>
    </BrowserRouter>
  );
};

export default App;
```

### Pattern 2: Context API (Avoiding Prop Drilling)
**Khi nào dùng:** Khi nhiều component ở tầng sâu cần truy cập dữ liệu chung (ví dụ: Dark Mode).

```jsx
import React, { createContext, useState, useContext } from 'react';

// 1. Tạo Container (Context)
const ThemeContext = createContext(null);

// 2. Provider bao bọc app
const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => setTheme(prev => prev === 'light' ? 'dark' : 'light');

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// 3. Component ở tầng sâu nhất (Không cần props)
const DeepChildComponent = () => {
  const { theme, toggleTheme } = useContext(ThemeContext);
  
  return (
    <div style={{ background: theme === 'dark' ? '#333' : '#fff' }}>
      <p>Current Theme: {theme}</p>
      <button onClick={toggleTheme}>Đổi Mode</button>
    </div>
  );
};

// 4. Usage
const App = () => {
  return (
    <ThemeProvider>
      <DeepChildComponent />
    </ThemeProvider>
  );
};
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Using `window.location.reload()` in SPA
*   **Lý do nguy hiểm:** Hủy hoại lợi ích chính của React (tốc độ và state preservation). Nó giống như biến một SPA thành MPA kém hiệu quả.

### 2.滥用 Context API for high-frequency updates
*   **Lý do nguy hiểm:** Khi state trong Context thay đổi, **mọi** componentConsuming context sẽ re-render, kể cả những component không dùng đến giá trị đó. Làm giảm performance nghiêm trọng.

### 3. Logic Rendering trong `BrowserRouter`
*   **Lý do nguy hiểm:** Đặt logic điều kiện (nếu chưa đăng nhập) hoặc tính toán dữ liệu trực tiếp trong `BrowserRouter`. Luôn để `<BrowserRouter>` là wrapper rỗng, bao bọc logic ở tầng dưới.

### 4. Prop Drilling "tội lỗi"
*   **Lý do nguy hiểm:** Truyền `user`, `setUser` qua `Header -> Sidebar -> ProfileMenu` chỉ để hiển thị tên. Dùng Context API để giải quyết.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Import:** Luôn dùng `react-router-dom` cho web.
2.  **Wrapper:** `App` phải được bao bởi `<BrowserRouter>`.
3.  **Switching:** Dùng `<Routes>` bao bọc các `<Route>`.
4.  **Rendering:** `<Route path="..." element={<Component />} />` (v6+ syntax).
5.  **Links:** Dùng `<Link to="...">` thay vì `<a>`.

### Decision Logic (If-Else)
*   **IF** (Navigating to external site) -> **Use `<a href>`**
*   **ELSE IF** (Navigating internal) -> **Use `<Link to>`**
*   **IF** (Data needed by 1 child) -> **Pass as Props**
*   **ELSE IF** (Data needed by many deep children) -> **Use Context API**

### Top 5 Things to Remember (Ôn tập nhanh)
1.  **Router:** `BrowserRouter` (Lưu history, không reload).
2.  **Dynamic URL:** Định nghĩa `/path/:param` → Lấy bằng `useParams()`.
3.  **Global State:** `createContext` → `Provider` → `useContext`.
4.  **Avoid:** `window.location.href` và Prop Drilling quá 2 level.
5.  **Performance:** Cập nhật Context quá nhiều sẽ làm lag UI (tách Context nếu cần).

<!-- CHUNK 61-61 -->

# DEVELOPER DECISION GUIDE - REACT (LECTURE 6)

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**State (Trạng thái)**
Dữ liệu thay đổi theo thời gian, quyết định giao diện hiển thị. React re-renders components khi state thay đổi.

**Props (Thuộc tính)**
Dữ liệu truyền từ cha xuống con (read-only). Là cách components giao tiếp một chiều.

**Virtual DOM (DOM Ảo)**
Bản sao của DOM thật trong bộ nhớ. React so sánh Virtual DOM cũ vs mới (Diffing) và cập nhật DOM thật tối thiểu.

**Hooks (Móc nối)**
Functions cho phép dùng state và lifecycle trong functional components (thay vì class components).

**Component (Thành phần)**
Đơn vị giao diện độc lập, có thể tái sử dụng. Có thể là **Functional Component** hoặc **Class Component**.

### Key Mental Models

1. **UI = f(state)**: Giao diện là hàm số của trạng thái. Khi state thay đổi → UI tự động cập nhật.
2. **Unidirectional Data Flow**: Dữ liệu chỉ đi theo 1 chiều (Cha → Con). Không có 2-way binding tự động.
3. **Declarative**: Mô tả "UI trông như thế nào" khi có state X, không cần chỉ dẫn từng bước thao tác DOM.
4. **Immutability**: Không bao giờ mutate state trực tiếp. Luôn tạo bản sao mới.

### Why React? (So với Vanilla JS/JQuery)

| Tiêu chí | React | Vanilla JS |
|----------|-------|------------|
| **Performance** | Tối ưu tự động (Virtual DOM) | Phải manually update DOM → dễ lag |
| **Maintainability** | Component structure → Dễ scale | Spaghetti code khi project lớn |
| **Developer Experience** | Declarative, reusable components | Imperative, manual DOM manipulation |

---

## SECTION 2: DECISION TABLES

### Table 1: Functional vs Class Components

| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|------------------------|------------------------|---------------|--------------------------------------|
| New project / Modern React | **Functional Component + Hooks** | Cleaner syntax, easier to test, better performance | Still using Class Components vì "quen tay" → overhead lifecycle methods không cần thiết |
| Legacy codebase | **Class Component** | Maintain consistency, không refactor cả project | Mix 2 style lung tung → khó debug, khó maintain |
| Component cần pure logic (không state) | **Functional Component** | Đơn giản, chỉ cần nhận props và return JSX | Wrapped trong `React.memo()` không cần thiết → overhead |

### Table 2: useState vs useReducer

| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|------------------------|------------------------|---------------|--------------------------------------|
| State đơn giản (boolean, number, string) | **useState** | Đơn giản, ít boilerplate | Dùng useReducer cho biến đếm → phức tạp hóa |
| State phức tạp (object/array nhiều thuộc tính) | **useReducer** | Centralized logic, dễ debug, dễ scale | Dùng nhiều useState riêng lẻ → state logic bị phân tán |
| Có transition logic phức tạp giữa các state | **useReducer** | Action creator + reducer pattern giúp logic rõ ràng | Mutating state trực tiếp trong useState → UI không cập nhật đúng |

### Table 3: useEffect dependency array

| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|------------------------|------------------------|---------------|--------------------------------------|
| Chạy 1 lần sau mount | **[]** (empty array) | Cleanup không cần thiết, chạy đúng 1 lần | Omitted dependency → chạy vô hạn vòng lặp |
| Sync với state/props cụ thể | **[dep1, dep2]** | Chỉ chạy khi dependency thay đổi | Dùng `useRef` để cheat → không reactive, dễ bug |
| Mỗi lần render | **No array** | React sẽ cảnh báo, phải có lý do chính đáng | Dùng infinite loop không kiểm soát → crash browser |

### Table 4: Context API vs Redux

| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|------------------------|------------------------|---------------|--------------------------------------|
| Global state nhỏ / Theme, Language | **Context API** | Built-in, không cần library external |滥用 Context cho高频更新 state → performance drop |
| Complex state logic / Async actions | **Redux (Toolkit)** | DevTools, middleware, time-travel debugging | Dùng Context + useState cho business logic phức tạp → không testable, không có middleware |
| Deep nesting props drilling | **Context API** | Tránh truyền props qua nhiều lớp | Create quá nhiều contexts → Provider hell |

### Table 5: JSX vs Normal JS Functions

| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|------------------------|------------------------|---------------|--------------------------------------|
| Dynamic UI with logic | **JSX** | Declarative, readable,React handles updates | Trying to manually manipulate DOM inside JSX → anti-pattern |
| Pure utility functions | **Normal JS** | Không liên quan đến DOM, reusable anywhere | Đóng gói logic DOM manipulation vào utility → không thể predict |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### React Component Hierarchy

```
[Root]
  │
  ├─ [App] (State Provider)
  │     │
  │     ├─ [Header] (Props: title)
  │     ├─ [Main] (State: userData)
  │     │     │
  │     │     ├─ [Sidebar] (Context: theme)
  │     │     └─ [Content] (State: posts)
  │     │           │
  │     │           └─ [PostList] (Props: posts)
  │     │                 │
  │     │                 └─ [PostItem] (Props: post)
  │     └─ [Footer] (Static)
  │
  └─ [Modal] (Portal to body) - Outside normal flow
```

### Data Flow Patterns

```
Parent → Props → Child (One-way)
Child → Callback → Parent (Event handling)
Context Provider → Consumer (Global state)
State → useEffect → Side effects (API calls)
```

### Component Lifecycle (Functional Equivalent)

```
Mount: useEffect(() => {}, [])
Update: useEffect(() => {}, [deps])
Unmount: useEffect(() => { return cleanup }, [])
Error: useEffect(() => {}, [error])
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Compound Components

**When to use (Khi nào dùng):**
Cần tạo reusable component complex (như Select, Dropdown) mà vẫn cho phép custom UI từ outside.

**Why this pattern is correct:**
Separation of concerns: Logic được encapsulate trong parent, nhưng presentation cho phép custom. Không prop drilling.

```jsx
// Parent: CompoundContext.jsx
import { createContext, useContext, useState } from 'react';

const CompoundContext = createContext();

export const CompoundProvider = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState(null);

  return (
    <CompoundContext.Provider value={{ isOpen, setIsOpen, selected, setSelected }}>
      {children}
    </CompoundContext.Provider>
  );
};

export const useCompound = () => {
  const context = useContext(CompoundContext);
  if (!context) throw new Error("Missing CompoundProvider");
  return context;
};

// Child components
export const Toggle = ({ children }) => {
  const { setIsOpen } = useCompound();
  return <button onClick={() => setIsOpen(prev => !prev)}>{children}</button>;
};

export const List = ({ children }) => {
  const { isOpen } = useCompound();
  return isOpen ? <ul>{children}</ul> : null;
};

export const Item = ({ value, children }) => {
  const { setSelected } = useCompound();
  return <li onClick={() => setSelected(value)}>{children}</li>;
};

// Usage
function App() {
  return (
    <CompoundProvider>
      <Toggle>Choose Item</Toggle>
      <List>
        <Item value="A">Option A</Item>
        <Item value="B">Option B</Item>
      </List>
    </CompoundProvider>
  );
}
```

### Pattern 2: Render Props

**When to use (Khi nào dùng):**
Cần chia sẻ logic giữa components mà không tạo HOC hoặc Context overhead.

**Why this pattern is correct:**
Flexible reuse. Component cha control UI nhưng con control logic.

```jsx
// Logic Component
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  return render(position);
}

// Usage
function App() {
  return (
    <div>
      <MouseTracker render={({ x, y }) => (
        <p>Mouse at: {x}, {y}</p>
      )} />
      
      <MouseTracker render={({ x, y }) => (
        <div style={{ position: 'absolute', left: x, top: y }}>📍</div>
      )} />
    </div>
  );
}
```

### Pattern 3: Custom Hook for Logic Extraction

**When to use (Khi nào dùng):**
Có logic stateful lặp lại ở nhiều components (validation, fetch data, form handling).

**Why this pattern is correct:**
DRY principle. Logic được test độc lập. Component chỉ còn UI.

```jsx
// Custom Hook: useFetch.js
import { useState, useEffect } from 'react';

export function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        setData(data);
        setError(null);
      })
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  }, [url]);

  return { data, loading, error, refetch: () => {/* re-run effect */} };
}

// Usage in Component
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
}
```

### Pattern 4: Optimizing with React.memo + useCallback

**When to use (Khi nào dùng):**
Component receives props but doesn't re-render needlessly. Performance issue identified by profiling.

**Why this pattern is correct:**
Prevents unnecessary re-renders down the tree. Only re-render when props actually change.

```jsx
// Expensive child component
const ExpensiveList = React.memo(({ items, onItemClick }) => {
  console.log('Rendering ExpensiveList');
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => onItemClick(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
});

// Parent
function App() {
  const [count, setCount] = useState(0);
  const [items] = useState([{ id: 1, name: 'Item 1' }, { id: 2, name: 'Item 2' }]);
  
  // useCallback prevents new function creation on every render
  const handleItemClick = useCallback((id) => {
    console.log('Clicked:', id);
  }, []);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Re-render Parent: {count}</button>
      {/* Only re-renders when items or handleItemClick changes */}
      <ExpensiveList items={items} onItemClick={handleItemClick} />
    </div>
  );
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Mutating State Directly
```jsx
// ❌ WRONG
const [user, setUser] = useState({ name: 'John', age: 20 });
user.age = 21; // Mutating object → React không detect change → UI không update
setUser(user); // Same reference

// ✅ CORRECT
setUser(prev => ({ ...prev, age: 21 }));
```
**Danger:** React uses shallow comparison. Mutated object has same reference → no re-render. Debug nightmare.

### 2. Missing Dependency in useEffect
```jsx
// ❌ WRONG
function App({ userId }) {
  useEffect(() => {
    fetchUser(userId); // Missing userId in dependency array
  }, []); // Runs once, even when userId changes

  // ✅ CORRECT
  useEffect(() => {
    fetchUser(userId);
  }, [userId]); // Re-run when userId changes
}
```
**Danger:** Stale closure. Component uses old data when props/state change. Leads to inconsistent UI.

### 3. Abusing Context for High-Frequency Updates
```jsx
// ❌ WRONG - Context with frequent updates
const ValueContext = createContext();
function Provider({ children }) {
  const [value, setValue] = useState(0);
  // Every setValue causes ALL consumers to re-render
  return <ValueContext.Provider value={{ value, setValue }}>{children}</ValueContext.Provider>;
}
```
**Danger:** Performance disaster. All consumers re-render on every update. Use Redux or split contexts.

### 4. Inline Functions in Render
```jsx
// ❌ WRONG
function Parent() {
  const handleClick = () => console.log('clicked');
  return <Child onClick={handleClick} />;
}

function Child({ onClick }) {
  // Child re-renders every time Parent re-renders
  // because handleClick is NEW every render
  return <button onClick={onClick}>Click</button>;
}
```
**Danger:** Child re-renders unnecessarily. Use `useCallback`.

### 5. useEffect with No Dependencies (Hidden Infinite Loop)
```jsx
// ❌ WRONG
function App() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    setCount(count + 1); // Updates state → Triggers re-render → useEffect runs again
  }); // No dependency array = runs after EVERY render
}
```
**Danger:** Infinite loop → browser crash. Always add dependency array or condition.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

```
IF (State is simple boolean/string/number) → use useState
ELSE IF (State is complex object/array with transitions) → use useReducer
ELSE IF (Global state needed) → Check complexity:
  - Low (theme, lang) → Context API
  - High (async, middleware) → Redux Toolkit

IF (Logic repeats in components) → Extract to Custom Hook
IF (Component re-renders too often) → Check props:
  - Static props → React.memo
  - Function props → useCallback
  - Object props → useMemo

IF (Need reusable complex component) → Compound Components
IF (Need logic sharing without HOC/Context) → Render Props

IF (useEffect missing dependency → STALE CLOSURE)
IF (useEffect infinite loop → ADD dependency array)
IF (Mutating state → STOP, use spread operator)
```

### Top 10 Things to Remember

1. **Virtual DOM != Real DOM** - React batches updates for performance.
2. **Props are READ-ONLY** - Never mutate props in child component.
3. **Immutability is mandatory** - Always create new objects/arrays for state.
4. **Dependency array is CRITICAL** - Missing deps = stale data; empty deps = mount only.
5. **Context is not for everything** - Split contexts or use Redux for complex state.
6. **Re-render ≠ Bad** - Only optimize when profiling shows actual problem.
7. **JSX ≠ HTML** - `className` not `class`, `onClick` not `onclick`, expressions in `{}`.
8. **Keys must be stable** - Never use index as key if list can change order.
9. **Hooks Rules** - Only call at top level, not in loops/conditions/nested functions.
10. **State belongs where it's used** - Lift state up only when multiple children need it.

### Quick Reference: useEffect Patterns

```jsx
// Mount only
useEffect(() => { /* init */ }, []);

// Update on specific change
useEffect(() => { /* fetch data */ }, [id]);

// Cleanup on unmount
useEffect(() => {
  const timer = setInterval(() => {}, 1000);
  return () => clearInterval(timer); // Cleanup
}, []);

// Async data fetching pattern
useEffect(() => {
  let isMounted = true;
  fetchData().then(data => {
    if (isMounted) setData(data);
  });
  return () => { isMounted = false; }; // Prevent memory leak
}, [dependency]);
```