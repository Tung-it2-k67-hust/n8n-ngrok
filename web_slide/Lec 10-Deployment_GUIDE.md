# DEVELOPER DECISION GUIDE: Lec 10-Deployment.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:42:51



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Web Deployment (Lec 10)

## SECTION 1: CORE MENTAL MODEL

### DevOps Mindset (Tư duy DevOps)
DevOps là sự kết hợp của **Văn hóa (Culture)**, **Tự động hóa (Automation)**, và **Phản hồi (Feedback)** để chuyển giao giá trị cho người dùng.
- **Văn hóa:** DevOps KHÔNG phải là title hay tool, mà là trách nhiệm chia sẻ. DevOps là "You build it, you run it" (Bạn xây dựng, bạn vận hành).
- **Tự động hóa:** Automate mọi thứ từ build, test, deploy đến infrastructure (CI/CD, Docker).
- **Phản hồi:** Production là môi trường học hỏi, không chỉ là điểm đến.

### Deployment Flow (Luồng triển khai)
Mục tiêu: Biến code thành dịch vụ chạy ổn định.
1. **Source Code:** Push to Git.
2. **CI (Continuous Integration):** Build & Test tự động.
3. **Artifact:** Tạo Docker Image.
4. **Registry:** Lưu trữ Image (GitHub Container Registry, Docker Hub).
5. **Deployment:** Cung cấp Image cho Production (PaaS/Docker/VPS).

**Why better?** Manual deployment (đẩy file thủ công) dễ gây lỗi "works on my machine" và downtime. Automated flow đảm bảo tính nhất quán (consistency).

---

## SECTION 2: DECISION TABLES

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Chạy app trên nhiều môi trường khác nhau** | **Docker** | **Tiêu chuẩn hóa môi trường (Environment Standardization)**. Code chạy giống nhau ở dev và prod. | Cài đặt thư viện trực tiếp trên server (Local Dependencies) gây lỗi version conflict. |
| **Muon deploy nhanh, quan tâm infrastructure thap** | **PaaS (Platform as a Service)** | **Tốc độ (Speed)**. Không cần quản lý server hay OS. Ideal cho MVP và app quy mô nhỏ. | Dùng PaaS cho app cần custom OS level (ví dụ: cài driver GPU hoặc config kernel phức tạp). |
| **Muon quan ly toan bo server, co cost constrant** | **VPS (Virtual Private Server)** | **Control & Cost**. Toàn quyền kiểm soát server và OS. Rẻ hơn PaaS nếu đã có team Ops. | Quên update security patch trên OS của VPS. |

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cần build và test code mỗi khi push Git** | **CI (GitHub Actions)** | **Quality Gate (Cổng chất lượng)**. Détect lỗi sớm (shift-left testing) trước khi deploy. | Push code trực tiếp lên server mà không qua test (Manual deploy). |
| **Cần load balance traffic cao** | **Nginx (Reverse Proxy)** | **Performance & Security**. Chia tải (load balancing), SSL termination, và serving static files hiệu quả. | Để app Node.js/Python serve static files trực tiếp (chậm và lãng phí tài nguyên). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Components Hierarchy
1. **Developer**: Code -> Push Git.
2. **GitHub Actions (CI)**: Trigger -> Build -> Test -> Build Docker Image -> Push Registry.
3. **Registry**: Lưu trữ version (Tag) của ứng dụng.
4. **Server / Cloud (CD)**:
   - **Reverse Proxy (Nginx)**: Lệnh request từ公网 -> Internal App.
   - **App Container**: Chạy Docker Image.
   - **Logging**: Ghi lại quá trình chạy.

### Flow Diagram
```text
[ Developer ]
     |
     | (git push)
     v
[ GitHub Actions ]  <--- (Môi trường build chuẩn)
     |
     | (1. Build & Test)
     | (2. docker build / push)
     v
[ Container Registry ] (Source of Truth)
     |
     | (docker pull)
     v
[ Production Server ]
     |
     +--> [ Nginx ] <--- (Client Request) <--- (DNS)
     |
     +--> [ App Container (Docker) ] --(Logs/Metrics)--> [ Monitoring ]
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Dockerfile (Environment Standardization)
**Khi nào dùng:** Khi cần đảm bảo app chạy giống nhau ở mọi nơi.
**Tại sao:** Tách biệt application runtime khỏi máy chủ host.

```dockerfile
# 1. Chọn base image nhỏ gọn (Alpine Linux)
FROM node:18-alpine

# 2. Set working directory
WORKDIR /app

# 3. Copy dependency file trước (để cache layer)
COPY package*.json ./

# 4. Install dependencies
RUN npm install

# 5. Copy source code
COPY . .

# 6. Expose port
EXPOSE 3000

# 7. Run command
CMD ["node", "server.js"]
```

### Pattern 2: GitHub Actions CI Pipeline
**Khi nào dùng:** Mỗi khi code push lên nhánh chính (main/master).
**Tại sao:** Kiểm tra chất lượng code tự động và tạo artifact (Docker Image).

```yaml
# .github/workflows/deploy.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker Image
        run: docker build -t my-app:${{ github.sha }} .

      - name: Run Test (Example)
        run: docker run --rm my-app:${{ github.sha }} npm test

      # (Logic push to registry omitted for brevity, usually involves login & push)
      - name: Push to Registry
        run: |
          echo "Pushing image my-app:${{ github.sha }}..."
          # docker login ...
          # docker push ...
```

### Pattern 3: Nginx Reverse Proxy Config
**Khi nào dùng:** Khi chạy nhiều container hoặc cần SSL/Static file.
**Tại sao:** App container nên tập trung vào logic nghiệp vụ, không phải lo lắng về HTTP request handling.

```nginx
# /etc/nginx/sites-available/my-app
server {
    listen 80;
    server_name mydomain.com;

    location / {
        # Forward request to App Container
        proxy_pass http://localhost:3000; 
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    location /static/ {
        # Serve static files directly via Nginx (high performance)
        alias /var/www/my-app/static/;
        expires 30d;
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **"Tôi build trên máy local rồi upload file lên server"**
    *   **Danger:** Gây ra lỗi "Works on my machine". Local có thể dùng Windows, server dùng Linux; path file, env variable khác nhau.
    *   **Fix:** Luôn build bằng Docker hoặc CI/CD.

2.  **`docker run ...` mà không có `restart policy`**
    *   **Danger:** Khi server reboot hoặc app crash, container sẽ không tự động chạy lại.
    *   **Fix:** Sử dụng `docker run --restart=always` hoặc `docker-compose` restart policy.

3.  **Để `latest` tag trong Production**
    *   **Danger:** Khi pull image `:latest`, bạn không bao giờ chắc chắn nội dung bên trong là gì. Khó rollback khi lỗi.
    *   **Fix:** Luôn dùng immutable tag (ví dụ: SHA commit hoặc version `v1.0.1`).

4.  **Quên Set Environment Variables trong Production**
    *   **Danger:** Leaks secret (API key, DB password) vào code hoặc để default config không an toàn.
    *   **Fix:** Inject config qua file `.env` hoặc secrets của hệ thống.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules
1.  **DevOps ≠ Docker/K8s**: Nó là cách team làm việc (Ownership).
2.  **Never deploy from local**: Luôn dùng Git + CI/CD.
3.  **Dockerize Everything**: Môi trường chuẩn là chìa khóa.
4.  **Nginx là Gateway**: Để bảo vệ app backend.

### Decision Logic (If-Else)
*   **IF** (Need speed, low ops overhead) -> **Use PaaS**.
*   **ELSE IF** (Need full control, cost sensitive) -> **Use VPS + Docker**.
*   **ELSE** (Enterprise scale) -> **Use Kubernetes (K8s)**.

### Top 10 Things to Remember
1.  **Culture > Tool**: DevOps là mindset.
2.  **Build artifact once**: Build image 1 lần, deploy đi nhiều nơi.
3.  **Immutable Infrastructure**: Không sửa server đã chạy, hãy thay thế bằng container mới.
4.  **Log là King**: Không có log, không có debug.
5.  **Health Check**: Luôn có endpoint `/health` để monitor app status.
6.  **Port Mapping**: Docker port `-p 80:3000` (Host:Container).
7.  **Git Ignore**: Đừng commit file `.env`, `node_modules`, `__pycache__`.
8.  **CI/CD**: Auto Test trước khi Auto Deploy.
9.  **Nginx**: Config `proxy_pass` để connect với app internal port.
10. **Rollback Plan**: Luôn có cách quay lại version cũ nếu update lỗi.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Deployment (Lec 10)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **Docker Image (Ảnh Docker):** A read-only template containing the application code, runtime, libraries, and environment variables required to run an application. It is the "blueprint" for your container.
*   **Docker Container (RContainer Docker):** A live, running instance of a Docker Image. It is an isolated process running on your host machine.
*   **Docker Registry (Kho lưu trữ Docker):** A centralized storage system for Docker images (e.g., Docker Hub, GitHub Container Registry). It allows teams to share and distribute images.
*   **CI/CD (Tích hợp và Triển khai liên tục):** The automated process of building, testing, and deploying code changes. In this context, it refers to the pipeline: `Git Push → CI → Docker Image → Deploy`.

### The "Works on My Machine" Mental Model

The core problem in deployment is **Environment Inconsistency**. Code behaves differently in Development vs. Production because of differences in OS, libraries, or configurations.

**The Solution:** Standardization via Docker.
Instead of moving code to different servers, we package the **entire environment** (Code + Runtime + Libraries) into a single immutable artifact (the Image). The server simply runs this artifact, eliminating environment drift.

### Why Containerization is Better than Virtual Machines

*   **Virtual Machines (VMs):** Virtualize *hardware*. They require a full Guest OS for every application. Heavyweight, slow startup.
*   **Containers:** Virtualize the *Operating System*. They share the Host OS kernel. Lightweight, instant startup.
*   **Verdict:** Use Containers for agility and density; use VMs only when you need strict OS-level isolation or legacy support.

---

## SECTION 2: DECISION TABLES

### Table: Docker vs. Virtual Machine (VM)

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Microservices / Web APIs** | **Docker Containers** | **Lightweight (Nhẹ nhàng):** Shares host kernel. Fast startup (seconds) and high density (run more apps on same hardware). | Forcing a full VM for a simple stateless API, wasting resources. |
| **Legacy Apps / Full OS** | **Virtual Machines** | **Full Isolation (Cô lập hoàn toàn):** Requires a specific, old OS version or kernel module that containers can't provide. | Trying to containerize a legacy app that expects direct hardware access or a specific kernel without refactoring. |
| **CI/CD Pipelines** | **Docker Containers** | **Ephemeral (Tạm thời):** Containers can be created and destroyed instantly for every build/test run. | Using persistent VMs for CI runners, leading to "state pollution" between builds. |

### Table: When to Use Docker Compose vs. Raw Docker Run

| Use Case | Should Use | Why | Common Mistake |
| :--- | :--- | :--- | :--- |
| **Single App (Dev)** | `docker run` | **Simplicity (Đơn giản):** Quick command for spinning up one service or utility. | Over-complicating a simple one-off command with a Compose file. |
| **Multi-Service App (Dev/Prod)** | **Docker Compose** | **Orchestration (Điều phối):** Defines networking, volumes, and dependencies between services (e.g., App + DB) in a single YAML file. | Manually running multiple `docker run` commands and struggling to connect them via IP addresses. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The End-to-End DevOps Flow

This is the linear lifecycle of a code change to a running production system.

```text
[Developer Laptop]       [CI/CD Server]        [Registry]        [Production Server]
        |                       |                    |                    |
        | 1. Git Push           |                    |                    |
        |---------------------->|                    |                    |
        |                       | 2. Build & Test    |                    |
        |                       |------------------->|                    |
        |                       |                    | 3. Push Image      |
        |                       |                    |------------------->|
        |                       |                    |                    | 4. Pull & Run
        |                       |                    |                    |--------+
        |                       |                    |                    |        |
        |                       |                    |                    | [Container]
        |                       |                    |                    |        |
        |                       |                    |                    | <------+ 5. Monitor & Feedback
        | <-------------------------------------------------------------------|
```

### Hierarchy of Artifacts

1.  **Source Code:** Your logic.
2.  **Dockerfile:** Instructions to build the blueprint.
3.  **Docker Image:** The immutable blueprint (stored in Registry).
4.  **Docker Container:** The running instance on the server.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Standard Dockerfile (Build Once, Run Anywhere)

**When to use (Khi nào dùng):** When you need to package a standard web application (Node.js, Python, Java) into a portable image.

**Why this pattern is correct:** It separates the build stage (compiling code) from the run stage (executing code) if applicable, ensuring the final image is clean and secure. It explicitly defines the OS and entry point.

**Code Example:**
```dockerfile
# Use a specific base image (Don't use 'latest' in prod)
FROM node:18-alpine

# Set working directory inside the container
WORKDIR /app

# Copy dependency definition first (optimizes caching)
COPY package*.json ./
RUN npm install

# Copy the rest of the application code
COPY . .

# Expose the port the app runs on
EXPOSE 3000

# Define the command to start the app
CMD ["node", "server.js"]
```

### Pattern 2: The .dockerignore (Optimization & Security)

**When to use (Khi nào dùng):** ALWAYS used alongside a Dockerfile.

**Why this pattern is correct:** It prevents sensitive data (`.env`, `.git`) and unnecessary files (`node_modules`, logs) from being copied into the image, reducing build time and attack surface.

**Code Example:**
```text
# .dockerignore

# Secrets
.env
.env.local

# Version Control
.git
.gitignore

# Dependencies (never copy local node_modules)
node_modules
npm-debug.log

# Build artifacts
dist
build

# IDE settings
.vscode
.idea
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Latest" Tag in Production
**The Practice:** Using `FROM python:latest` or deploying `myapp:latest`.
**Why it's dangerous:** The `latest` tag is mutable. It can be updated upstream, changing your environment without your knowledge. This breaks reproducibility.
**The Fix:** Always use immutable version tags (e.g., `python:3.9-slim`, `myapp:v1.2.0`).

### 2. The "Fat" Image
**The Practice:** Using a heavy base OS image (like full Ubuntu) and leaving build tools inside the final image.
**Why it's dangerous:** Increases security risks (more vulnerabilities) and storage/transfer costs. Slow deployment.
**The Fix:** Use Alpine Linux or "slim" variants. Remove build-only dependencies in the same Dockerfile step.

### 3. Running as Root
**The Practice:** The container process runs as the default root user.
**Why it's dangerous:** If an attacker compromises the app, they gain root access to the container, and potentially the host.
**The Fix:** Create a non-root user in the Dockerfile and switch to it before running the app.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  **Image = Blueprint.** Container = Running Instance.
2.  **Containers are ephemeral.** Save data using Volumes, not inside the container.
3.  **Never trust the network.** Always use health checks.
4.  **The "Works on my machine" fix is to Dockerize.**
5.  **Docker shares the Kernel.** Linux containers on Windows/Mac run inside a lightweight VM (LinuxKit/Moby).
6.  **Build once, run anywhere.**
7.  **Keep images small.** Use Alpine or Slim variants.
8.  **Use Semantic Versioning.** `v1.0.1` is better than `latest`.
9.  **Never commit secrets (.env) into the image.** Use runtime environment variables.
10. **CI/CD Pipeline:** `Code -> Image -> Container -> Monitoring`.

### Decision Logic (If-Else)

*   **IF** you have a modern web app or microservice -> **USE Docker**.
*   **IF** you need to run multiple services locally (App + DB + Cache) -> **USE Docker Compose**.
*   **IF** you need a full OS or legacy Windows app -> **USE Virtual Machine**.
*   **IF** deployment fails saying "command not found" -> **CHECK your `CMD` or `ENTRYPOINT` in Dockerfile**.
*   **IF** your image takes forever to build -> **CHECK your `.dockerignore` and layer caching**.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Deployment (Lec 10)

## SECTION 1: CORE MENTAL MODEL

### Dockerfile & Build Image
- **Dockerfile**: File định nghĩa quy trình tạo Docker Image (Hình ảnh Docker - Tệp chứa môi trường chạy ứng dụng). Nó chuẩn hóa cách ứng dụng được xây dựng và triển khai, đảm bảo chạy đồng nhất mọi nơi.
- **Base Image (Hình ảnh cơ sở)**: Điểm xuất phát của Docker Image, chứa hệ điều hành và runtime (ví dụ: `node:20-alpine`). Quyết định bảo mật và hiệu năng ban đầu.

### Docker Compose & Orchestration
- **Docker Compose**: Công cụ định nghĩa và chạy đa container ứng dụng thông qua file YAML. Quản lý phụ thuộc dịch vụ (backend kết nối db) bằng một lệnh duy nhất.
- **Network (Mạng ảo)**: Cho phép container giao tiếp. Tự động tạo hostname dựa trên tên service (ví dụ: `backend` gọi `db`).
- **Volume (Khối dữ liệu)**: Lưu trữ dữ liệu bền vững, không bị xóa khi container restart. Bắt buộc cho database.

### CI/CD Pipeline
- **Continuous Integration (CI)**: Hộp đen kiểm tra code. Merge code → Tự động build & test → Phát hiện lỗi sớm.
- **Continuous Delivery (CD)**: Tự động prepare deploy nhưng **nhấn nút manually** để release.
- **Continuous Deployment (CD)**: Tự động prepare deploy **và** release luôn không cần can thiệp.

---

## SECTION 2: DECISION TABLES

### Base Image Selection
| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Production App | `node:20-alpine` (Alpine Linux) | **Tiny size (Dung lượng nhỏ)**, reduced attack surface, fast pull. | Dùng `node:latest` -> Không reproducible, unexpected updates. |
| Legacy/Debugging | `node:20` (Debian-based) | **Compatibility (Tương thích)** thư viện system-level cần thiết. | Dùng Alpine nhưng code phụ thuộc `apt-get` -> Build fail. |
| Static Site | `nginx:alpine` | **Optimized (Tối ưu)** cho web server, lightweight. | Dùng full OS image -> Cồng kềnh, không cần thiết. |

### CI/CD Automation Level
| Use case (Tình huống) | Should use (Nên dùng) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Dev/Test Env | **Continuous Deployment** | Tự động update server ngay khi test xong. Speed. | Không có test suite -> Đưa code bug lên production. |
| Production Env | **Continuous Delivery** | Kiểm soát thời điểm release, có nút "ấn" để deploy. Safety. | Cố gắng auto deploy mọi thứ -> Rủi ro downtime cao. |
| Hotfixes | **Manual Trigger** (Git Tag) | Kiểm soát chặt chẽ thay đổi khẩn cấp. Traceability. | Bỏ qua review流程 -> Dễ gây lỗi nghiêm trọng. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy: Multi-Stage Build & Stack
```text
[ Source Code ]
      |
      v
[ Dockerfile (Multi-Stage) ]
  ├─ Stage 1 (Builder): Install Deps → Build Code → Output artifact
  └─ Stage 2 (Runner): Copy Artifact → Clean Env → Run App
      |
      v
[ Docker Image ] (轻量, Secure)
      |
      v
[ Docker Compose ]
  ├─ Service: App (Restart: always, Healthcheck)
  ├─ Service: Database (Volume: data-persist)
  └─ Network: Internal Bridge (Isolated)
      |
      v
[ CI/CD Pipeline (GitHub Actions) ]
  ├─ Trigger: Push/PR
  ├─ Job: Build & Test
  └─ Job: Push to Registry / Deploy
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Optimized Dockerfile (Multi-Stage)
**Khi nào dùng:** Khi build Node.js app có nhiều phụ thuộc, cần tối ưu dung lượng image cuối.
**Tại sao đúng:** Tách biệt môi trường build (lớn, nhiều tool) và môi trường chạy (nhỏ, sạch).

```dockerfile
# Stage 1: Builder (Xây dựng)
FROM node:20-alpine AS builder
WORKDIR /app
# 1. Cache dependency layer (it doesn't change often)
COPY package*.json ./
RUN npm ci --only=production
# 2. Copy source & build
COPY . .
RUN npm run build

# Stage 2: Runner (Chạy)
FROM node:20-alpine
WORKDIR /app
# Copy only artifacts from builder, ignore source code
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
# Use non-root user for security
USER node
CMD ["node", "dist/index.js"]
```

### Pattern 2: Production Compose (Stack)
**Khi nào dùng:** Khi cần chạy backend + database đồng bộ, có auto-recovery.
**Tại sao đúng:** Định nghĩa infrastructure as code, tự động heal (khỏe lại) khi crash.

```yaml
services:
  api:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - db
    restart: unless-stopped # Tự động restart nếu crash
    healthcheck:
      test: ["CMD", "wget", "-qO-", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:15-alpine
    volumes:
      - db_data:/var/lib/postgresql/data # Persist data
    environment:
      POSTGRES_PASSWORD: example
    networks:
      - backend-net

volumes:
  db_data:

networks:
  backend-net:
```

### Pattern 3: Basic CI Pipeline (GitHub Actions)
**Khi nào dùng:** Đảm bảo code build được và test pass trước khi merge.
**Tại sao đúng:** Xác nhận tính ổn định của code trước khi vào nhánh chính.

```yaml
name: CI Pipeline
on: [push, pull_request]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        run: npm ci

      - name: Run Tests
        run: npm test

      - name: Build Docker Image
        run: docker build -t my-app:${{ github.sha }} .
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Using `latest` Tag
**Lý do nguy hiểm:** Không reproducible (không tái lập trình được). Nếu base image update (ví dụ: Node 20 -> Node 21), build tự động có thể break hoặc thay đổi hành vi đột xuất.
**Cách tránh:** Luôn chỉ định version rõ ràng (ví dụ: `node:20-alpine`).

### 2. Copy Code Before Install Dependency
**Lý do nguy hiểm:** Vi phạm Docker Layer Cache. Nếu code thay đổi nhưng dependency không đổi, Docker vẫn phải chạy lại `npm install` từ đầu làm chậm build.
**Cách tránh:** Luôn `COPY package*.json` trước, chạy `RUN npm install`, sau đó mới `COPY . .`.

### 3. Running Containers as Root
**Lý do nguy hiểm:** Nếu hacker chiếm được shell trong container, họ có quyền root trên host (trong một số cấu hình) hoặc phá hủy container nặng hơn.
**Cách tránh:** Dùng lệnh `USER node` (hoặc user ID 1000) trong Dockerfile trước khi chạy app.

### 4. Missing Healthcheck & Restart Policy
**Lý do nguy hiểm:** Ứng dụng crash vào 3h sáng sẽ không tự động dậy, gây downtime.
**Cách tránh:** Luôn cấu hình `restart: unless-stopped` và `healthcheck` cho service quan trọng.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules to Remember
1. **Alpine is King**: Dùng `-alpine` để giảm dung lượng image (~5x nhỏ hơn).
2. **No `latest`**: Luôn lock version để reproducible builds.
3. **Cache Order**: `COPY package.json` → `RUN install` → `COPY source`.
4. **Multi-Stage**: Bắt buộc cho app cần build (Java, Go, TS).
5. **Volume for DB**: Không bao giờ lưu data trong container nếu cần durability.
6. **Restart Policy**: Dùng `unless-stopped` cho production.
7. **Depends On**: Dùng `depends_on` cho startup order, nhưng dùng script.wait cho readiness.
8. **CI on PR**: Chạy test trên Pull Request, không merge nếu fail.
9. **Network Isolation**: Chỉ expose port cần thiết, dùng internal network cho service-to-service.
10. **Non-Root User**: Chạy app với user thường, không root.

### Decision Logic (If-Else)
- **Need build?** -> Use **Multi-Stage Dockerfile**.
- **Need DB?** -> Use **Docker Compose + Volume**.
- **Push code?** -> Trigger **CI Pipeline** (Test & Build).
- **Prod deploy?** -> Use **CD (Delivery)** -> Manual approval -> Deploy.
- **Container crash?** -> Check **Restart Policy** -> If `always`, auto restart.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: CI/CD & Deployment (Lec 10)

## SECTION 1: CORE MENTAL MODEL

### Core Concepts
- **CI/CD Pipeline (Quy trình Tích hợp & Triển khai Liên tục)**: Automates the journey from code commit to production deployment.
- **Workflow (Quy trình làm việc)**: A complete automation process defined in a YAML file. It is the "orchestrator".
- **Job (Công việc)**: A specific execution environment (runner) containing a sequence of steps. Jobs run in parallel by default.
- **Step (Bước)**: A single task, either a script command or an `action` (reusable code unit).
- **Runner (Máy thực thi)**: The server/container that executes the jobs. Can be GitHub-hosted or self-hosted.
- **Container Registry (Kho lưu trữ Container)**: A storage service for Docker images (e.g., GHCR, Docker Hub). Acts as the bridge between CI and CD.

### The CI/CD Mental Model
Think of CI/CD as a manufacturing assembly line:
1. **Event (Trigger)**: A raw material arrives (e.g., code push).
2. **CI (Factory Floor)**: The code is validated, built, and packaged into a standardized container (Docker Image).
3. **Registry (Warehouse)**: The packaged container is tagged and stored.
4. **CD (Delivery Truck)**: The container is pulled from the warehouse and run on the target server.

**Why this approach is better**: It eliminates "it works on my machine" by enforcing the exact same environment (the Docker container) from local development to production.

---

## SECTION 2: DECISION TABLES

### Table 1: CI Trigger Strategy
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Every code change** (Feature branches) | `push` | Ensures code integration works immediately. | Running heavy builds on every keystroke (use `paths` filter). |
| **Collaboration/Merging** (Pull Requests) | `pull_request` | Validates code before merging to `main`. Prevents breaking production. | Only testing locally, skipping PR validation. |
| **Production Release** (Tagging) | `push: tags: 'v*'` | Triggers a release only when a specific version is finalized. | Manually building release binaries. |
| **On-demand tasks** (Nightly builds) | `workflow_dispatch` | Allows manual execution for maintenance or rare tasks. | Hardcoding manual steps in code. |

### Table 2: Docker Tagging Strategy
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Daily Development** | `myapp:sha-<commit_hash>` | **Immutability**. Every commit has a unique ID. Perfect for rollbacks. | Using `latest`. If a deployment fails, you don't know which code caused it. |
| **Formal Release** | `myapp:1.2.0` | Semantic versioning. Easy for humans to understand. | Relying only on tags without git hashes for tracking. |
| **Environment Targeting** | `myapp:staging`, `myapp:prod` | Easy identification of which code is running where. | Using environment tags for the *build* step (use for deployment tags instead). |

### Table 3: CD Levels (Risk vs Automation)
| Level | Deploy Trigger | Risk | Recommendation |
| :--- | :--- | :--- | :--- |
| **Manual** | Human clicks "Deploy" | Lowest | Use for sensitive financial or database migrations. |
| **Continuous Delivery** | Auto-build, Manual approval | Medium | **Standard.** The pipeline builds and tests, a human approves the deploy. |
| **Continuous Deployment** | Fully Auto (Merge = Deploy) | High | Use only with 100% automated test coverage and high confidence. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy
```text
[GitHub Event: push/pr/tag]
       ⬇
[Workflow (.github/workflows/ci.yml)]
       ⬇
├── [Job: Build]
│   ├── Step: Checkout Code
│   ├── Step: Lint
│   └── Step: Build Docker Image
│       ⬇
└── [Job: Deploy] (Needs: Build Job)
    ├── Step: Login to Registry
    ├── Step: Pull Image
    └── Step: Run Container on Server
```

### The CI/CD Flow
**Code Commit** → **CI Job** (Build & Tag Image) → **Push to Registry** → **CD Job** (Pull Image) → **Server** (Run Container)

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Backend CI (Lint, Test, Build)
**Khi nào dùng**: Cho backend(Node.js, Python, Go...). Đảm bảo code đúng quy chuẩn và có thể build trước khi merge.

**Tại sao đúng**: Ngăn chặn code lỗi vào nhánh chính. Tách biệt quá trình build để tránh lỗi môi trường trên server.

```yaml
name: Backend CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run Linter
        run: npm run lint

      - name: Run Tests
        run: npm test
```

### Pattern 2: Docker Build & Push (Git SHA Tagging)
**Khi nào dùng**: Khi bạn muốn tạo một bản build Docker cho mỗi commit.

**Tại sao đúng**: `sha-${{ github.sha }}` tạo ra một bản ghi duy nhất, immutable (không thay đổi). Nếu lỗi, bạn rollback về hash cũ đơn giản.

```yaml
name: Docker Build

on:
  push:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          # Tag with Commit SHA (Unique) and 'latest' (Moving)
          tags: myapp:${{ github.sha }},myapp:latest
```

### Pattern 3: Manual Deployment (CD)
**Khi nào dùng**: Khi bạn cần kiểm soát thời điểm release (Continuous Delivery).

**Tại sao đúng**: Kết hợp tự động hóa với con người. Bấm nút để triển khai, giảm rủi ro "auto-deploy" khi chưa sẵn sàng.

```yaml
name: Manual Deploy to Prod

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Image tag to deploy (e.g., sha-3f9a1c2)'
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.PROD_SERVER_IP }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            docker pull myapp:${{ github.event.inputs.version }}
            docker stop myapp_container || true
            docker run -d --name myapp_container -p 80:3000 myapp:${{ github.event.inputs.version }}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

❌ **Hardcoding Secrets in YAML**
- **Lý do nguy hiểm**: Source code là public (hoặc accessible). Bất kỳ ai cũng có thể thấy password/API keys. Luôn dùng `secrets.NAME` và cấu hình trong Settings > Secrets.

❌ **Using `:latest` tag in Production**
- **Lý do nguy hiểm**: `:latest` là tag di chuyển (mutable). Nếu server pull lại image mà không rõ version, bạn có thể vô tình update production với code lỗi. Luôn dùng `sha-<hash>` hoặc version số.

❌ **Running heavy operations (npm install) trên mỗi Job**
- **Lý do nguy hiểm**: Làm tốn chi phí CI/CD và tăng thời gian chờ.
- **Cách sửa**: Sử dụng cache action (`actions/cache`) để lưu trữ dependencies giữa các run.

❌ **Undefined `needs` dependency**
- **Lý do nguy hiểm**: Job Deploy chạy đồng thời với Job Build. Khi Build chưa xong, Deploy sẽ pull image cũ hoặc fail.
- **Cách sửa**: Luôn định nghĩa `needs: [build-job-name]`.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
- **If** code is pushed to PR? → **Run** CI (Tests & Lint).
- **If** PR merged or tag created? → **Run** Build Docker Image (Tag with SHA).
- **If** Image built successfully? → **Push** to Registry.
- **If** manual approval needed? → **Wait** for `workflow_dispatch`.
- **If** deploying? → **Pull** specific SHA tag, **Stop** old container, **Start** new container.

### Top 10 Things to Remember
1. **Workflow** = Pipeline YAML.
2. **Job** = Virtual Machine execution.
3. **Step** = Single command/action.
4. **Runner** = Where the code runs (Linux/Windows).
5. **Secrets** = Use for passwords, never hardcode.
6. **Triggers**: `push`, `pull_request`, `workflow_dispatch`.
7. **Tagging**: Prefer `sha-<hash>` over `latest`.
8. **Registry**: Bridge between CI (Build) and CD (Deploy).
9. **Immutability**: Don't change a deployed container; replace it.
10. **Dependencies**: Use `needs` to control job order.

<!-- CHUNK 41-50 -->

# Lec 10-Deployment: Developer Decision Guide

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Reverse Proxy (Máy chủ chạy trước)**: A server that sits in front of backend applications, receiving client requests and forwarding them to the appropriate internal service. It handles internet traffic so the backend doesn't have to.
- **TLS Termination (Chấm dứt TLS)**: The process where the reverse proxy handles the encryption/decryption of HTTPS traffic. The traffic between the proxy and the backend can be unencrypted (HTTP), reducing CPU load on the backend.
- **IaaS (Infrastructure as a Service)**: Bạn thuê phần cứng (máy chủ, lưu trữ). Bạn quản lý hệ điều hành, runtime, và ứng dụng. (Ví dụ: AWS EC2, DigitalOcean Droplet).
- **PaaS (Platform as a Service)**: Bạn thuê môi trường chạy code. Nhà cung cấp quản lý OS và hardware. Bạn chỉ lo code và database. (Ví dụ: Render, Heroku, Vercel).
- **SaaS (Software as a Service)**: Bạn thuê phần mềm sử dụng ngay. Không cần lo gì về infrastructure. (Ví dụ: Gmail, Notion).

### Mental Model: The Gatekeeper Pattern
Imagine your Backend/Frontend as high-value assets inside a fortress. Exposing them directly to the outside world is like leaving the vault door open. **Nginx is the gatekeeper.**
1.  It speaks to the outside world (handles HTTPS, bad requests).
2.  It verifies credentials.
3.  It passes only valid requests to the assets inside.
This allows the assets (Apps) to focus purely on logic, not security or traffic management.

### Why Nginx Over Direct Exposure?
Direct exposure forces your Node/Python/Go app to handle low-level networking (port 80/443), SSL handshakes, and static file reading. This wastes CPU cycles and increases attack surface. Nginx is written in C and optimized for these tasks, serving 10,000x more concurrent connections efficiently than a typical application server.

---

## SECTION 2: DECISION TABLES

### Table 1: Nginx Configuration Strategy

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Single Page App (SPA)** (React, Vue) | `try_files $uri $uri/ /index.html;` | The browser handles routing. If user reloads `/dashboard`, server must return `index.html`, not 404. | Using `return 404` or `proxy_pass` for static routes, causing crashes on page refresh. |
| **Backend API** (REST/GraphQL) | `proxy_pass http://host:port/;` | Offloads SSL/TLS and static serving. App focuses on business logic. | Exposing the app port (e.g., 3000) directly to the internet. |
| **Container Recovery** (Crash loop) | `docker restart <container>` | Restarts the existing container instance instantly without rebuilding. | Running `docker build` and `docker run` immediately, wasting time rebuilding identical images. |

### Table 2: Deployment Levels (IaaS vs PaaS)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Full Control / Custom Kernel** | **IaaS** (AWS EC2, Azure) | You need to install specific OS versions, custom security rules, or non-standard software. | Using IaaS for a simple static site (high maintenance cost). |
| **Fast Web App Dev / CI/CD** | **PaaS** (Vercel, Render) | Git push = Deploy. Auto-scaling and SSL are handled automatically. | Trying to configure Nginx manually on PaaS (usually restricted or unnecessary). |
| **Internal Tools / MVP** | **SaaS** (Firebase, Supabase) | Don't reinvent the wheel. Auth and DB are hard; buy them ready-made. | Building your own database cluster for a simple MVP. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Traffic Flow: The "Bouncer" Architecture
```text
[ Internet ]
     |
     v
[ Nginx (Reverse Proxy / Bouncer) ]
     |                    |
     | (HTTPS)            | (HTTP - Internal Only)
     v                    v
[ Frontend (SPA) ]    [ Backend API ]
(Root Path /)         (Path /api/*)
```

### Dependency Hierarchy
1.  **Infrastructure Level**: IaaS (Hardware) OR PaaS (Platform).
2.  **Orchestration Level**: Docker (Containerization).
3.  **Traffic Level**: Nginx (Routing, SSL).
4.  **Application Level**: Frontend / Backend.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Universal Nginx Config (API + SPA)
**Khi nào dùng:** Khi bạn deploy một ứng dụng web đầy đủ (Frontend SPA + Backend API) trên cùng một máy chủ.
**Tại sao đúng:** Nó tách biệt流量 rõ ràng. Frontend load nhanh (static), Backend xử lý logic (proxy). Cấu hình `try_files`fix lỗi SPA.

```nginx
server {
    listen 80;
    server_name example.com;

    # --- FRONTEND (SPA) ---
    # Phục vụ file tĩnh và fix lỗi reload trang
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }

    # --- BACKEND API ---
    # Chuyển tiếp request sang container backend
    location /api/ {
        proxy_pass http://backend_service:3000/; # Tên service trong Docker Compose
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### Pattern 2: CI/CD Pipeline with Docker
**Khi nào dùng:** Khi muốn tự động hóa việc đẩy code lên server.
**Tại sao đúng:** Eliminates manual error. Secrets (mật khẩu) được quản lý an toàn.

```yaml
name: Simple CI/CD
on:
  push:
    branches: [ "main" ]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    # 1. Build & Push Image
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and Push
      run: |
        docker build -t ${{ secrets.DOCKER_USERNAME }}/myapp .
        docker push ${{ secrets.DOCKER_USERNAME }}/myapp

    # 2. Deploy to Server
    - name: Deploy
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SERVER_SSH_KEY }}
        script: |
          docker pull ${{ secrets.DOCKER_USERNAME }}/myapp
          docker rm -f myapp || true
          docker run -d --name myapp -p 80:3000 ${{ secrets.DOCKER_USERNAME }}/myapp
```

### Pattern 3: Container Recovery vs Update
**Khi nào dùng:** Monitoring và Maintenance.
**Tại sao đúng:** Phân biệt rõ giữa "sự cố tạm thời" và "cần thay đổi code".

```bash
# Case A: App crashed but logic didn't change (Fix: Restart)
# Fast, keeps data/volume, no rebuild.
docker restart backend

# Case B: New code/features deployed (Fix: Rebuild & Replace)
# Slow, ensures new image is used.
docker-compose build backend
docker-compose up -d backend
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Exposing Backend Port Directly**
    *   **Danger:** Rủi ro bảo mật cao. Lộ port 3000/8000 ra internet dễ bị quét và exploit. Backend phải xử lý SSL handshake, tốn CPU.
    *   **Fix:** Luôn để Nginx "che mặt" backend.

2.  **Using `latest` Tag in Production**
    *   **Danger:** Không kiểm soát được version. Khi update image, server có thể pull về bản lỗi mà không hay biết.
    *   **Fix:** Sử dụng `sha256` hoặc version tag cụ thể (v1.0.1).

3.  **Running Stateful Containers Without Volumes**
    *   **Danger:** Khi container bị xóa (do crash hoặc update), mọi dữ liệu trong database biến mất.
    *   **Fix:** Luôn mount volume cho dữ liệu quan trọng: `volumes: - db_data:/var/lib/postgresql/data`.

4.  **Ignoring SPA Routing in Nginx**
    *   **Danger:** Truy cập `/login` reload trang -> 404 Not Found.
    *   **Fix:** Cấu hình `try_files $uri $uri/ /index.html;` bắt buộc cho SPA.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  **Nginx là Gatekeeper**: Đứng trước app, xử lý SSL và Routing.
2.  **SPA = `try_files`**: Không có dòng này, SPA sẽ bị 404.
3.  **API = `proxy_pass`**: Forward sang `http://host:port/`.
4.  **IaaS**: Bạn làm everything (VPS).
5.  **PaaS**: Bạn làm Code (Render/Vercel).
6.  **Restart**: Dùng khi app crash, chưa sửa code.
7.  **Rebuild**: Dùng khi update code/image.
8.  **Secrets**: Không bao giờ hardcode. Dùng Env Var hoặc GitHub Secrets.
9.  **Internal Network**: Docker Compose cho phép container gọi nhau qua tên service (ví dụ: `backend`, `db`).
10. **Health Check**: Luôn check container status: `docker ps`.

### Decision Logic
*   **If** user accesses domain directly -> **Nginx handles it**.
*   **If** URL is `/api/...` -> **Nginx proxies to Backend**.
*   **If** URL is `/` (or sub-routes like `/user`) -> **Nginx serves `index.html`**.
*   **If** app crashes but code is same -> **`docker restart`**.
*   **If** code changed -> **`docker build` -> `docker run`**.

<!-- CHUNK 51-56 -->

# DEVELOPER DECISION GUIDE: DEPLOYMENT (PaaS & Monitoring)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **PaaS (Platform as a Service)**: Nền tảng dưới dạng dịch vụ. PaaS cung cấp môi trường chạy ứng dụng được quản lý hoàn toàn (máy chủ, OS, runtime). Developer chỉ cần đẩy code (Git push) và định cấu hình, không cần lo lắng về hạ tầng.
*   **Environment Variables**: Các biến môi trường. Là cách PaaS cấu hình ứng dụng (ví dụ: URL database, API key). Luôn tách biệt khỏi code.
*   **Secrets**: Bí mật. Là các thông tin nhạy cảm (API keys, DB passwords). PaaS lưu trữ an toàn và không bao giờ được commit vào Git.
*   **Monitoring**: Giám sát. Quá trình thu thập dữ liệu hệ thống và ứng dụng để phát hiện sự cố, đo lường hiệu năng và cảnh báo (Alert).
*   **Metrics**: Chỉ số. Dữ liệu định lượng (CPU, RAM, Error Rate, Latency) dùng để đánh giá sức khỏe hệ thống.

### PaaS Mental Model: "Black Box of Automation"
Hãy hình dung PaaS là một cỗ máy tự động hóa DevOps:
1.  **Input**: Bạn cung cấp Source Code và Environment Variables (Secrets).
2.  **Process**: PaaS tự động xử lý: Build container (như Docker), cài đặt OS, cấu hình Web Server (như Nginx), thiết lập CI/CD.
3.  **Output**: Ứng dụng chạy, scale tự động, và được giám sát.

**So sánh:**
*   **IaaS (VPS)**: Bạn nhận một cái hộp trống. Bạn phải tự cài OS, tự cài Web Server, tự vá lỗi.
*   **PaaS**: Bạn nhận một cái hộp đã cài sẵn tất cả. Bạn chỉ việc thả ứng dụng vào.

### Monitoring Mental Model: "EKG cho Ứng dụng"
Ứng dụng production là một cơ thể sống. Monitoring là máy theo dõi nhịp tim (EKG):
*   **Biểu đồ (Metrics)**: Nhịp tim tăng/giảm cho thấy vấn đề.
*   **Cảnh báo (Alerts)**: Chuông reo báo hiệu cơn đau tim sắp xảy ra.
*   **Nhật ký (Logs)**: Hồ sơ bệnh án ghi lại chi tiết tại sao bệnh nhân (ứng dụng) lại như vậy.

---

## SECTION 2: DECISION TABLES

### Table 1: PaaS vs IaaS (VPS)
*Khi nào chọn nền tảng nào?*

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Startup / MVP**<br>(Thời gian gấp, nguồn lực hạn chế) | **PaaS** | **Speed (Tốc độ)**: Ra mắt sản phẩm trong vài phút thay vì vài ngày. Tập trung vào tính năng. | Dùng VPS quá sớm, làm DevOps không cần thiết làm chậm tiến độ. |
| **App cần cấu hình đặc thù**<br>(Cài đặt phần mềm lạ, Kernel hack) | **IaaS (VPS)** | **Control (Kiểm soát)**: Quyền truy cập Root toàn quyền tùy chỉnh hệ thống. | Cố gắng "hack" PaaS để chạy phần mềm không hỗ trợ, gây ra sự cố không ổn định. |
| **Đội DevOps có sẵn / Lớn** | **IaaS (VPS)** | **Tối ưu chi phí & quyền lực**: Đội ngũ tự động hóa tốt có thể squeeze hiệu năng từ VPS rẻ hơn PaaS. | Dùng PaaS nhưng vẫn cố quản lý Infrastructure thủ công (lãng phí tiền và công sức). |
| **Ứng dụng có lượng truy cập không ổn định** | **PaaS** | **Automatic Scaling**: Tự động tăng/giảm tài nguyên khi người dùng tăng/giảm. | Dùng VPS nhưng không setup Auto-scaling, dẫn đến sập web khi có traffic spike. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy: Deployment & Monitoring Flow
Mối quan hệ giữa Code, PaaS và Monitoring trong vòng đời Production.

```text
[ Source Code + Secrets ]
          |
          v
[ PaaS Platform ] -------------------------> [ Monitoring & Alerts ]
          |                                      ^
          | (1. Git Push / Deploy)               | (3. Alert if bad)
          |                                      |
          v                                      |
[ Runtime Environment ]                  [ Metrics (CPU, Mem, Latency) ]
          |                                      |
          | (2. App Runs)                        |
          v                                      v
[ End Users ] ---------------------------> [ Logs (Errors, Crashes) ]
```

**Mô tả luồng:**
1.  **Code & Secrets**: Nguồn vào. Code được lưu trữ trong Git. Secrets được lưu trong cấu hình PaaS (không trong code).
2.  **PaaS Platform**: Nhà máy xử lý. Nhận code, tự động build và triển khai (Deploy).
3.  **Runtime**: Nơi ứng dụng chạy. Tự động mở rộng tài nguyên nếu cần.
4.  **Monitoring**: Đôi mắt của hệ thống. Thu thập Metrics và Logs.
5.  **Alerts**: Hệ thống cảnh báo. Nếu Metrics vượt ngưỡng hoặc Logs có lỗi, hệ thống sẽ gửi thông báo cho bạn.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Environment Configuration Loading
*Khi nào dùng:* Luôn luôn dùng khi truy cập API Key, Database URL hoặc bất kỳ cấu hình nào thay đổi giữa dev/prod.

*Tại sao đúng:* Tách biệt cấu hình khỏi logic ứng dụng. Đảm bảo Secrets không bị rò rỉ trong mã nguồn.

```javascript
// Ví dụ: Node.js / JavaScript
// TRÁNH: const DB_PASSWORD = "hardcoded_password_123"; (NGUY HIỂM)
// DÙNG:

require('dotenv').config(); // Tải biến môi trường từ file .env (chỉ ở dev)

function connectDatabase() {
  const dbHost = process.env.DB_HOST; // "localhost" ở dev, "prod-db.com" ở prod
  const dbPass = process.env.DB_PASSWORD; // Lấy từ biến môi trường hệ thống

  if (!dbHost || !dbPass) {
    throw new Error("Missing environment variables!");
  }

  console.log(`Connecting to database at ${dbHost}...`);
  // Logic kết nối...
}

connectDatabase();
```

### Pattern 2: Health Check Endpoint
*Khi nào dùng:* Khi deploy ứng dụng lên PaaS để platform kiểm tra ứng dụng có sống không trước khi routing traffic.

*Tại sao đúng:* Giúm PaaS tự động roll back nếu deploy hỏng (blue-green deployment).

```python
# Ví dụ: Python (Flask)
from flask import Flask, jsonify
import psutil # Thư viện kiểm tra tài nguyên system

app = Flask(__name__)

@app.route('/health')
def health_check():
    # Logic kiểm tra: Database có kết nối được không?
    # Nếu OK trả về 200, nếu lỗi trả về 500
    return jsonify({
        "status": "UP",
        "memory": psutil.virtual_memory().percent
    }), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

### Pattern 3: Structured Logging
*Khi nào dùng:* Khi cần debug lỗi trên Production.

*Tại sao đúng:* Log dạng text plain rất khó tìm kiếm. Log dạng JSON cho phép lọc và phân tích tự động.

```javascript
// Ví dụ: Javascript Logger
const log = (level, message, meta = {}) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    level: level, // INFO, ERROR, WARN
    message: message,
    ...meta, // Thêm metadata như UserID, RequestID
  };
  
  // In ra Console (PaaS sẽ thu thập và gửi về Central Logging)
  console.log(JSON.stringify(logEntry));
};

// Sử dụng:
try {
  processPayment();
} catch (error) {
  // Sai lầm: console.log("Lỗi rồi: " + error); -> Khó tìm
  // Đúng:
  log("ERROR", "Payment failed", { 
    userId: 123, 
    error: error.message 
  });
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern | Mô tả | Tại sao NGUY HIỂM (Lý do cấm) |
| :--- | :--- | :--- |
| **Commit Secrets to Git** | Lưu API Key, Password trực tiếp vào file code (`.env` file không được loại trừ). | Bất kỳ ai clone repo đều có quyền truy cập vào hệ thống của bạn. Xóa file history cũng không an toàn 100%. |
| **"Works on My Machine"** | Deploy code mà không cấu hình môi trường giống hệt Production (thay vì dùng Env Vars). | Lỗi chạy được trên máy local nhưng sập trên Production do sai port, sai database, sai thư viện. |
| **Ignoring Monitoring** | Chỉ cài đặt Monitoring nhưng không thiết lập Alert. | Chỉ biết hệ thống chết khi người dùng phản ánh. Mất uy tín và doanh thu. |
| **Log Everything (Blind Logging)** | In ra log toàn bộ thông tin nhạy cảm (Request body, User info) hoặc log quá nhiều. | Che khuất lỗi thật, tốn dung lượng lưu trữ, và rò rỉ thông tin bí mật nếu log bị lộ. |
| **Full Control Obsession** | Dùng VPS (IaaS) cho mọi thứ chỉ vì muốn "toàn quyền", dù ứng dụng chỉ là web simple. | Tốn hàng chục giờ setup Patch, Security, Load Balancer thay vì tập trung vào code. Lãng phí tài nguyên. |

---

## SECTION 6: MASTER CHEAT SHEET

### Quy tắc Vàng
1.  **Code là Vua, Secrets là Hoàng hậu**: Không bao giờ để Hoàng hậu (Secrets) lộ liễu trong cung điện (Code).
2.  **PaaS để chạy, IaaS để build**: Dùng PaaS khi muốn chạy app ngay. Dùng IaaS khi muốn build nền tảng riêng.
3.  **Không Monitoring = Blind Flight**: Bay máy bay mà không có kính nhìn窗外.

### Decision Logic (If-Else)

*   **Nếu** bạn cần ra mắt nhanh, team nhỏ, app web standard -> **Chọn PaaS**.
*   **Nếu** bạn cần cài đặt Custom Kernel, cấu hình mạng phức tạp -> **Chọn IaaS (VPS)**.
*   **Nếu** bạn không biết tại sao app chậm -> **Kiểm tra CPU/Mem Metrics**.
*   **Nếu** app bị lỗi 500 liên tục -> **Đọc Logs (Errors)** ngay lập tức.

### Top 5 Things to Remember for Exam
1.  **PaaS** tự động hóa: Server, OS, Scaling.
2.  **Environment Variables** là nơi để cấu hình thay đổi giữa các môi trường.
3.  **Git Push** là cách deploy đơn giản nhất trên PaaS.
4.  **Metrics** = Số (CPU, RAM), **Logs** = Văn bản (Lỗi, Crash).
5.  **Alerts** phải được cấu hình để thông báo cho bạn khi Metrics vượt ngưỡng.