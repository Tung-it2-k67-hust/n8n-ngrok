# DEVELOPER DECISION GUIDE: Lec 5-JS Advanced.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:57:38



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Advanced JavaScript (Lec 5)

## SECTION 1: CORE MENTAL MODEL

### 1.1. Asynchronous Execution (Thực thi không đồng bộ)
JavaScript là đơn luồng (Single-threaded), nghĩa là nó chỉ có thể làm một việc tại một thời điểm. Để xử lý các tác vụ chậm (như gọi API, đọc file) mà không làm đứng giao diện, chúng ta sử dụng cơ chế không đồng bộ.

**Mental Model:**想象 một người bán hàng (Main Thread). Thay vì đứng đợi một khách hàng mua xong mới phục vụ khách tiếp theo, anh ta nhận đơn hàng (Callback/Promise), làm việc khác, và quay lại khi đơn hàng sẵn sàng.

### 1.2. The Event Loop (Vòng lặp sự kiện)
Là cơ chế cho phép JavaScript xử lý bất đồng bộ.

*   **Call Stack:** Nơi code chạy.
*   **Web APIs:** Nơi các tác vụ chậm (setTimeout, fetch) diễn ra.
*   **Callback Queue:** Hàng đợi các tác vụ đã xong.
*   **Event Loop:** Luôn kiểm tra Call Stack có rỗng không, nếu rỗng thì đẩy tác vụ từ Callback Queue vào Call Stack.

### 1.3. DOM Manipulation (Xử lý DOM)
Là cách JavaScript tương tác với HTML.

*   **Selectors:** `querySelector`, `getElementById`.
*   **Events:** Lắng nghe hành động (`click`, `submit`).
*   **Form Handling:** Đọc dữ liệu từ các input complex (Select, Radio, Checkbox).

---

## SECTION 2: DECISION TABLES

### Table 1: Callback vs Promise vs Async/Await

| Tình huống sử dụng | Nên dùng gì | Tại sao (Term + Giải thích) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Simple API, Old Codebase** | **Callback** | **Legacy (Kế thừa):** Phù hợp với thư viện cũ hoặc logic đơn giản. Hàm nhận một hàm khác làm tham số. | **Callback Hell (Địa ngục Callback):** Lồng quá nhiều hàm làm code khó đọc ( Pyramid of Doom ). |
| **Complex Async Flow, Chaining** | **Promise** | **Chaining (Chuỗi):** Cho phép nối các bước xử lý `.then().catch()`. Dễ dàng bắt lỗi tập trung. | **忘记 return:** Trong `.then()`, nếu không return kết quả, bước tiếp theo sẽ nhận `undefined`. |
| **Modern Logic, Readability** | **Async/Await** | **Synchronous Style (Phong cách đồng bộ):** Code trông như đang chạy đồng bộ nhưng thực chất là bất đồng bộ. Dễ debug. | **Không try/catch:** Bỏ qua xử lý lỗi khi `await` ném ra ngoại lệ, làm chương trình crash. |

### Table 2: DOM Event Handling Approaches

| Tình huống sử dụng | Nên dùng gì | Tại sao (Term + Giải thích) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Dynamic Elements (List, Table)** | **Event Delegation (Giao quyền sự kiện)** | **Performance (Hiệu năng):** Chỉ gắn 1 sự kiện lên cha, dùng `e.target` để xử lý con. Con có sinh ra sau cũng tự động có chức năng. | **Bubbling Chaos (Hỗn loạn):** Dừng propagations (`stopPropagation`) bừa bãi gây lỗi các event listener khác. |
| **Static Elements (Header, Footer)** | **Direct Binding (Gắn trực tiếp)** | **Simplicity (Đơn giản):** Dễ hiểu, dễ debug. | **Memory Leak (Rò rỉ bộ nhớ):** Xóa phần tử mà không gỡ event listener (nếu không dùng delegation). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Async Flow Hierarchy

```text
[User Action]  ->  [Event Listener]  ->  [Trigger Async Op]
                                             |
                                             v
                                    [Web API / Browser]
                                    (Handling Request)
                                             |
                                             v
[Main Thread: UI Updates]  <-  [Event Loop]  <-  [Callback Queue]
                                             ^
                                             |
                                  [Promise / Async Function]
```

### DOM Interaction Flow

```text
[HTML Elements] <--> [DOM API] <--> [JavaScript Logic]
                                  |
                          (Event Listeners)
                                  |
                          [Form Data Object]
                                  |
                          (Process Data)
                                  |
                          [Update DOM / Send Request]
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Async/Await with Error Handling

**Khi nào dùng:** Khi bạn cần gọi API và muốn code dễ đọc như đồng bộ.

**Tại sao đúng:** Tránh được "Callback Hell" và cho phép bắt lỗi ở một nơi duy nhất.

```javascript
// Pattern: Async/Await + Try/Catch
async function fetchUserData(userId) {
    try {
        // 1. Wait for promise to resolve
        const response = await fetch(`https://api.example.com/users/${userId}`);
        
        // 2. Check response status
        if (!response.ok) {
            throw new Error(`HTTP Error: ${response.status}`);
        }

        // 3. Parse JSON
        const data = await response.json();
        
        // 4. Update UI
        console.log("User Data:", data);
        return data;

    } catch (error) {
        // Handle all errors (network, server, parsing)
        console.error("Failed to fetch:", error.message);
        // Perform fallback logic here (e.g., show cached data)
    }
}

// Usage
fetchUserData(123);
```

### Pattern 2: Event Delegation on Forms

**Khi nào dùng:** Khi xử lý form có nhiều input, hoặc input sinh động (dynamic).

**Tại sao đúng:** Tiết kiệm bộ nhớ và đảm bảo event hoạt động với phần tử sinh ra sau này.

```javascript
// HTML Structure
// <form id="myForm">
//   <input type="text" name="username">
//   <select name="role" multiple>
//     <option value="admin">Admin</option>
//     <option value="user">User</option>
//   </select>
//   <button type="submit">Submit</button>
// </form>

document.getElementById('myForm').addEventListener('submit', function(e) {
    e.preventDefault(); // 1. Prevent reload

    // 2. Accessing Standard Fields
    const username = this.elements['username'].value;

    // 3. Accessing Radio (Specific Logic)
    // document.querySelector('input[name="gender"]:checked')
    
    // 4. Accessing Multiple Select (Specific Logic)
    const roleSelect = this.elements['role'];
    // Array.from converts HTMLCollection to Array
    const roles = Array.from(roleSelect.selectedOptions).map(option => option.value);

    // 5. Result
    const formData = {
        username: username,
        roles: roles
    };

    console.log("Submitted Data:", formData);
});
```

### Pattern 3: Promise Chaining

**Khi nào dùng:** Khi bạn có các phụ thuộc giữa các bước异步 (A xong mới làm B, B xong mới làm C).

**Tại sao đúng:** Dễ dàng passing data từ bước này sang bước khác.

```javascript
function processOrder(orderId) {
    // Step 1: Check order
    return checkOrderStatus(orderId)
        .then(status => {
            if (status !== 'paid') throw new Error('Not paid');
            // Pass data to next step
            return { orderId, status }; 
        })
        // Step 2: Ship product
        .then(data => shipProduct(data.orderId))
        // Step 3: Notify user
        .then(() => sendEmail(orderId))
        // Step 4: Handle any error from any step
        .catch(error => {
            console.error("Order processing failed:", error);
        });
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Nested Callbacks (Callback Hell)
```javascript
// NO!
getData(function(a) {
    getMoreData(a, function(b) {
        getEvenMoreData(b, function(c) {
            // Deep nesting...
        });
    });
});
```
**Danger (Nguy hiểm):** Code coiled vertically làm difícil để đọc, debug và xử lý lỗi.

### 2. Forgetting `e.preventDefault()`
```javascript
// NO!
<form onsubmit="handleSubmit()">...</form>

function handleSubmit() {
    // Logic...
    // Forgot preventDefault -> Page reloads -> Data loss!
}
```
**Danger (Nguy hiểm):** Trình duyệt sẽ reload trang mặc định, làm mất trạng thái hiện tại và dữ liệu nhập liệu.

### 3. "Magic" Strings in Selectors
```javascript
// NO!
document.getElementById('submit-btn-123').addEventListener(...);
```
**Danger (Nguy hiểm):** Nếu thay đổi ID trong HTML, JS sẽ break mà không báo lỗi. Khó bảo trì.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

*   **IF** you see `function(data, callback)` -> Use **Callback** (but be careful of nesting).
*   **IF** you need to run async steps in sequence -> Use **Promise Chaining** (`.then()`).
*   **IF** you want code to look synchronous and easy to read -> Use **Async/Await**.
*   **IF** you need to handle a click on 100 list items -> Use **Event Delegation** (`parent.addEventListener`).
*   **IF** you are getting data from a `<select multiple>` -> Use `Array.from(el.selectedOptions).map(...)`.

### Top 5 Things To Remember

1.  **Async/Await** is just syntactic sugar for **Promises**.
2.  Always wrap **Async/Await** in **Try/Catch**.
3.  **Event Listeners** block the Main Thread. Keep them fast!
4.  `Array.from()` is your friend for converting HTML Collections (Select options, Nodelist).
5.  `e.preventDefault()` is mandatory for Forms.

<!-- CHUNK 11-20 -->

# Lec 5-JS Advanced: Developer Decision Guide

## SECTION 1: CORE MENTAL MODEL

### Form Submission Control (Xử lý sự kiện gửi biểu mẫu)
Browser default behavior: Tự động reload page hoặc navigate URL khi submit form -> Mất quyền kiểm soát dữ liệu.
**Solution**: Luôn luôn chặn hành vi mặc định.

```javascript
// Pattern: Handle Submit Event
const form = document.querySelector('#myForm');
form.addEventListener('submit', (event) => {
    event.preventDefault(); // Chặn reload page
    
    // Logic xử lý dữ liệu ở đây
    const formData = new FormData(event.target);
    const data = Object.fromEntries(formData);
    console.log(data);
});
```

### Real-time Validation (Xác thực thời gian thực)
Kiểm tra dữ liệu ngay khi người dùng nhập liệu, không đợi submit.
**Event Logic**:
- `input`: Fires immediately (type, delete, paste) - Dùng cho UX realtime
- `change`: Fires khi input blur (focus ra ngoài) - Dùng cho validate nhẹ

```javascript
// Real-time pattern
inputField.addEventListener('input', (e) => {
    const isValid = e.target.value.length >= 8;
    errorMsg.style.display = isValid ? 'none' : 'block';
});
```

### DOM Class Manipulation (Chỉnh sửa class DOM)
Thay thế việc dùng `className` (ghi đè toàn bộ) bằng `classList` (thao tác c cụ thể).
**Why**: Tránh mất các class đang có, code rõ ràng hơn.

```javascript
// Bad: Ghi đè toàn bộ
element.className = "btn active"; // Mất class cũ

// Good: Thao tác c cụ thể
element.classList.add("active");
element.classList.remove("hidden");
element.classList.toggle("dark-mode");
const hasError = element.classList.contains("error");
```

## SECTION 2: DECISION TABLES

### Table 1: Submit Event Handling

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|--------------------|-------------|---------|-------------------|
| Form cần xử lý dữ liệu JS (API call, validate) | `event.preventDefault()` + JS logic | Prevent Default: Chặn reload browser, giữ control dữ liệu | Quên `preventDefault()` -> page reload, mất dữ liệu |
| Form chỉ cần gửi data đến server cơ bản | HTML native submit (`action`, `method`) | Browser tự handle, không cần JS rườm rà | Dùng JS khi không cần thiết -> phức tạp hóa |

### Table 2: Validation Triggers

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|--------------------|-------------|---------|-------------------|
| Live feedback (password strength, length) | `input` event | Immediate: Cập nhật ngay khi gõ, UX tốt | Dùng `change` -> user phải blur mới thấy lỗi |
| Xác thực khi rời khỏi field | `change` event | Delayed: Đợi user nhập xong mới check | Dùng `input` -> spam validation quá nhiều |
| Validate trước khi gửi | `submit` event + `checkValidity()` | Final Gate: Đảm bảo data sạch trước khi gửi | Chỉ validate realtime -> lỗ hổng khi không sửa lỗi |

### Table 3: Data Storage Strategy

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|--------------------|-------------|---------|-------------------|
| Lưu metadata/config cho element (id, type) | `data-*` attributes + `dataset` | Data Attributes: Tách biệt logic HTML-JS, không污染 DOM | Lưu data trong `id` hoặc `class` -> hard to parse |
| Lưu dữ liệu lớn/nhạy cảm | JavaScript Variable (state) | Security: Tránh expose data ra HTML | Lưu secret key trong `data-*` -> insecure |

### Table 4: Event Targeting

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|--------------------|-------------|---------|-------------------|
| 1 element, 1 action | Direct Listener (`element.onclick`) | Explicit: Rõ ràng, dễ debug | Dùng Event Delegation cho 1 element -> overhead |
| Many dynamic elements (list, table) | Event Delegation (Parent + `event.target`) | Performance: 1 listener cho nhiều element, xử lý element tạo sau | Attach listener cho từng element -> performance drop, leak memory |

## SECTION 3: ARCHITARCHURE & RELATIONSHIPS

### Form Handling Architecture

```text
[User Action]
      |
      v
[Event Listener] (Submit/Input/Change)
      |
      v
[Event Object] (e.target, e.value)
      |
      +---> [Validation Logic] (RegEx, Check)
      |          |
      |          v
      |      [Visual Feedback] (classList.toggle, text)
      |
      +---> [Data Processing] (FormData, Object)
                 |
                 v
             [API/Send]
```

### Data Flow: Real-time Validation

```text
Input Field (input event)
    |
    v
Extract Value (e.target.value)
    |
    v
Match RegEx / Logic
    |
    +---> True? -> classList.remove("error")
    |
    +---> False? -> classList.add("error") + Show Msg
```

## SECTION 4: CODE PATTERNS

### Pattern 1: Complete Form Handler with Validation

**Khi nào dùng**: Khi cần xử lý form đăng nhập/đăng ký có validate realtime và submit.

**Tại sao đúng**: Combine HTML5 constraint + JS RegEx + Event Delegation -> Robust & UX.

```javascript
const form = document.querySelector('#registerForm');
const inputs = form.querySelectorAll('input[required]');

// Validate Function
const validateField = (input, regex, msg) => {
    const isValid = regex.test(input.value);
    input.classList.toggle('error', !isValid);
    
    // Error message logic
    const errorSpan = input.parentElement.querySelector('.error-msg');
    if (errorSpan) errorSpan.style.display = isValid ? 'none' : 'block';
    
    return isValid;
};

// Real-time (Input Event)
inputs.forEach(input => {
    input.addEventListener('input', () => {
        if (input.type === 'email') {
            validateField(input, /^[^\s@]+@[^\s@]+\.[^\s@]+$/, 'Email invalid');
        }
        if (input.name === 'phone') {
            validateField(input, /^\d{10}$/, 'Phone must be 10 digits');
        }
    });
});

// Final Check (Submit Event)
form.addEventListener('submit', (e) => {
    e.preventDefault(); // Bắt buộc
    
    let allValid = true;
    inputs.forEach(input => {
        // Trigger validation logic manually if needed
        if (!input.value) allValid = false;
    });

    if (allValid) {
        const data = Object.fromEntries(new FormData(form));
        console.log('Sending:', data);
        // fetch('/api/register', ...)
    }
});
```

### Pattern 2: Event Delegation for Dynamic Lists

**Khi nào dùng**: Khi list items được thêm/xóa bằng JS (todo list, table rows).

**Tại sao đúng**: Không cần re-attach listeners cho item mới -> Performance.

```javascript
// Parent container
const list = document.querySelector('#taskList');

// Single listener on parent
list.addEventListener('click', (e) => {
    // Detect clicked child
    if (e.target.matches('.delete-btn')) {
        const taskId = e.target.dataset.id; // Access data-*
        const li = e.target.closest('li');   // Find parent
        
        // Action
        li.remove();
        console.log(`Deleted task: ${taskId}`);
    }
});

// Add new item dynamically (no need to attach listener to new btn)
const addBtn = document.querySelector('#addTask');
addBtn.addEventListener('click', () => {
    const newLi = document.createElement('li');
    newLi.innerHTML = `
        <span>New Task</span>
        <button class="delete-btn" data-id="${Date.now()}">Delete</button>
    `;
    list.appendChild(newLi);
});
```

### Pattern 3: State Management via `data-*`

**Khi nào dùng**: Khi cần pass small config/data from HTML to JS without cluttering variables.

**Tại sao đúng**: Keeps HTML semantic, JS accessible via `dataset`.

```javascript
// HTML
// <div id="product" data-id="101" data-category="electronics">Laptop</div>

const card = document.querySelector('#product');

// Access
console.log(card.dataset.id);          // "101"
console.log(card.dataset.category);    // "electronics"

// Update JS -> Updates DOM (Good for sync)
card.dataset.status = "sold";

// Visual Sync
card.classList.add('disabled');
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Untouched Submit (Cấm)
```javascript
// DANGEROUS
form.addEventListener('submit', () => {
    // Logic without preventDefault
});
```
**Why**: Browser reloads page. JS logic không kịp chạy. Mất data chưa send.

### 2. Over-Validating (Performance Killer)
```javascript
// DANGEROUS (Spamming server or CPU)
input.addEventListener('keypress', () => {
    // Heavy regex or API call here
});
```
**Why**: `keypress` fires too fast. Dùng `input` có debounce hoặc `change` để tiết kiệm tài nguyên.

### 3. className Overwriting (Debug Nightmare)
```javascript
// DANGEROUS
element.className = "active"; 
// Nếu có class "hidden" do CSS khác thêm, nó biến mất.
```
**Why**: Dễ mất state style. Dùng `classList` để giữ nguyên các class không liên quan.

### 4. Inline Style vs Class Toggle
```javascript
// DANGEROUS
element.style.display = 'none';
element.style.color = 'red';
// Code rối, không tái sử dụng được CSS
```
**Why**: Hardcode style trong JS -> Khó maintain. Nên toggle class (`.hidden`, `.error`) để CSS handle style.

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules
1. **Submit**: `event.preventDefault()` là bắt buộc nếu xử lý JS.
2. **Realtime**: Dùng `input` event cho feedback ngay, `change` cho validate nhẹ.
3. **List**: Dùng **Event Delegation** nếu có >1 item hoặc item thay đổi.
4. **Data**: Lưu config trong `data-*`, truy xuất qua `dataset`.
5. **Class**: Dùng `classList` (add/remove/toggle), tuyệt đối không `className = "..."`.

### Decision Logic (If-Else)
```text
IF (Form needs JS logic) -> 
   addEventListener('submit', (e) => e.preventDefault() + Logic)

IF (User types in Input) -> 
   addEventListener('input', Validate)

IF (Many dynamic buttons) -> 
   addEventListener('click', Parent) + if (e.target.matches('.btn'))

IF (Need store ID in HTML) -> 
   <div data-id="123"> -> const el.dataset.id
```

### Top 5 Memory Hooks
1. **Prevent Default**: `submit` event luôn cần chặn browser reload.
2. **Input vs Change**: Input = Realtime, Change = On blur.
3. **classList API**: `add()`, `remove()`, `toggle()`, `contains()`.
4. **Dataset**: `data-user-id` -> `dataset.userId` (camelCase).
5. **Event Target**: `event.target` để xác định nguồn sự kiện trong Delegation.

<!-- CHUNK 21-30 -->

# Developer Decision Guide: JS Advanced (Lec 5)

## SECTION 1: CORE MENTAL MODEL

### DOM Performance: The Batch Update Model
- **Reflow (Tính toán lại bố cục)**: Browser calculates element positions/sizes after DOM changes.
- **Repaint (Vẽ lại giao diện)**: Browser draws pixels to the screen after layout calculation.
- **Mental Model**: Treat DOM manipulation like a database transaction. Collect all changes in memory, commit them once.

```javascript
// SLOW: Triggers Reflow/Repaint on every append
const parent = document.getElementById('list');
for (let i = 0; i < 1000; i++) {
    let li = document.createElement('li');
    li.textContent = `Item ${i}`;
    parent.appendChild(li); // BAD: 1000 reflows
}

// FAST: Single Reflow/Repaint
const fragment = document.createDocumentFragment(); // Memory-only
for (let i = 0; i < 1000; i++) {
    let li = document.createElement('li');
    li.textContent = `Item ${i}`;
    fragment.appendChild(li); // OK: No DOM touch
}
parent.appendChild(fragment); // GOOD: 1 reflow
```

### Asynchronous: The Non-Blocking Loop
- **Synchronous (Đồng bộ)**: Blocks the main thread. One task finishes, next starts.
- **Asynchronous (Bất đồng bộ)**: Non-blocking. The browser handles tasks in the background (Network, Timers) and triggers callbacks when done.

### Timing Functions: The Event Loop Control
- **Event Loop (Vòng lặp sự kiện)**: JS executes code, collects events, then executes callbacks.
- **Timers**: You cannot run code *at an exact time*. You can only schedule it to be added to the queue *after* a minimum delay.

## SECTION 2: DECISION TABLES

### DOM Updates: DocumentFragment vs Direct DOM
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Adding > 1 element to DOM** (Ví dụ: render list 1000 items) | `DocumentFragment` | **Batching (Gộp lệnh)**: Cuts 1000 **Reflow/Repaint** operations down to 1. | Appending directly inside a loop causing browser layout trashing. |
| **Updating 1 single element** (Ví dụ: change text) | Direct DOM (`innerHTML`, `appendChild`) | Overhead: Creating a Fragment for 1 element is slower than direct manipulation. | Creating unnecessary Fragment objects for simple tasks. |
| **Manipulating elements before adding to page** | `DocumentFragment` | **Memory (Bộ nhớ)**: Fragments live in memory, invisible to the browser until committed. | Updating elements on the live DOM, causing visual flicker. |

### Timing Control: Debouncing vs Throttling
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **User typing in Search Input** (Wait for pause) | **Debouncing (Chống dội)** | **Wait for Idle**: Function runs *only after* user stops typing for Xms. Prevents spamming API. | Using Throttling here, which sends requests while user is still typing. |
| **Window Resize / Scroll events** (Continuous triggers) | **Throttling (Giới hạn tốc độ)** | **Rate Limiting**: Ensures code runs at most once every Xms, preventing UI freeze/lag. | Using Debouncing here; UI updates only stop after user finishes resizing, causing lag. |
| **Button Click (Double click prevention)** | **Debouncing (Leading edge)** | **Safety**: Prevents accidental double-execution of critical logic (e.g., payment). | Relying on HTML `disabled` attribute manually. |

### Asynchronous Flow: Callbacks vs Promises
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Simple, single async operation** | **Promises (`fetch`, `.then`)** | **Readability**: Flat structure. Easier to read than nested callbacks. | Nesting Promises unnecessarily (creating "Promise Hell"). |
| **Legacy APIs / Event Listeners** | **Callbacks** | **Compatibility**: Native to DOM events and older libraries. | Converting simple callbacks to Promises just for style, adding overhead. |
| **Complex flow (If/Else logic)** | **Async/Await (Syntactic Sugar for Promises)** | **Control Flow**: Looks like synchronous code. Easy to handle `try/catch`. | Forgetting `await` inside `async` functions. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The DOM Update Flow Hierarchy
This flow visualizes how `DocumentFragment` bypasses the expensive Reflow cycle.

```text
[START: Loop 1000 times]
       |
       v
Method A: Direct Append
  1. Create Element
  2. Append to Live DOM  ------> [Browser Layout Engine]
  3. Trigger Reflow (Calculate)
  4. Trigger Repaint (Draw)
  5. Repeat 1000 times (LAG!)

Method B: DocumentFragment
  1. Create Element
  2. Append to Fragment (Memory) ---x (No Browser Update)
  3. Repeat 1000 times
  4. Append Fragment to Live DOM
                                     ------> [Browser Layout Engine]
                                             1. Trigger Reflow (Calculate)
                                             2. Trigger Repaint (Draw)
                                             3. Done! (1 time only)
```

### The Event Loop & Timer Hierarchy
How timers interact with the Main Thread.

```text
[Main Thread] -> [Code Execution] -> [Callback Queue] -> [Event Loop]
      ^                  |
      |                  v
[Timers API]      (Async Logic: setTimeout, fetch)
      ^
      |
[Browser Web APIs] (Waits 'delay' ms, then pushes to Queue)
```

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The DocumentFragment Renderer
**Khi nào dùng**: When rendering a list of items from an array.
**Tại sao đúng**: Prevents the browser from freezing during layout calculations.

```javascript
function renderList(items) {
    const container = document.getElementById('container');
    const fragment = document.createDocumentFragment();

    items.forEach(item => {
        const div = document.createElement('div');
        div.textContent = item.name;
        // Modify style/attributes here safely
        fragment.appendChild(div);
    });

    // The "Commit" phase: Single DOM insertion
    container.appendChild(fragment);
}
```

### Pattern 2: The Debounce Wrapper
**Khi nào dùng**: For search inputs or form validation while typing.
**Tại sao đúng**: Ensures logic runs only when the user pauses interaction.

```javascript
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        // Clear previous timer if called again
        clearTimeout(timeoutId);
        // Set new timer
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// Usage
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce((e) => {
    console.log('Searching for:', e.target.value);
}, 500));
```

### Pattern 3: The Throttle Wrapper
**Khi nào dùng**: For scroll events, window resize, or mouse move tracking.
**Tại sao đúng**: Guarantees execution happens at fixed intervals, preventing performance drops.

```javascript
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args); // Run immediately
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit); // Reset flag after delay
        }
    }
}

// Usage
window.addEventListener('resize', throttle(() => {
    console.log('Window resized - Runs max once per 1s');
}, 1000));
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Layout Thrashing" Loop
**Dangerous Practice**: Mixing DOM reads and writes inside a loop.
**Why**: Reading `offsetHeight` forces the browser to calculate layout immediately (Reflow) before the loop finishes. Doing this repeatedly in a loop kills performance.
**Fix**: Use `DocumentFragment` or batch reads then batch writes.

### 2. The "SetInterval" Accumulation
**Dangerous Practice**: Using `setInterval` for async logic without checking if the previous operation finished.
**Why**: If the operation takes longer than the interval, multiple instances will run simultaneously, causing race conditions and memory leaks.
**Fix**: Use recursive `setTimeout` inside the function to ensure the next call only starts after the previous one finishes.

```javascript
// BAD
setInterval(() => {
    if (!isFinished) { // Race condition risk
        doWork(); 
    }
}, 1000);

// GOOD
function doWorkRecursive() {
    doWork().then(() => {
        setTimeout(doWorkRecursive, 1000);
    });
}
```

### 3. The "Async Void" Fire-and-Forget
**Dangerous Practice**: Calling an `async` function without `await` or `.catch()`.
**Why**: Errors inside the async function will be swallowed (unhandled promise rejection), making debugging impossible.
**Fix**: Always `await` or attach `.catch()`.

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **Reflow is Expensive**: Always batch DOM updates with `DocumentFragment`.
2.  **Debounce**: Use for user input (Typing).
3.  **Throttle**: Use for continuous events (Scroll/Resize).
4.  **Timers are Minimums**: `setTimeout(fn, 0)` just means "run as soon as possible," not "run immediately."
5.  **Async/Await**: Use for logic flow; Promises for data flow; Callbacks for events.
6.  **Never read layout props inside a loop**: Read (Get) -> Modify (Set) -> Write (Append).
7.  **Memory Leaks**: Always `clearTimeout` or `clearInterval` when components unmount.
8.  **Fragment is Invisible**: It does not exist in the DOM tree until appended.
9.  **Event Loop**: JS is single-threaded. Async doesn't mean multi-threaded; it means non-blocking.
10. **Error Handling**: Use `try/catch` with `async/await`. Don't ignore Promise rejections.

### If-Else Decision Logic
*   **If** updating DOM multiple times in a loop -> **Use** `DocumentFragment`.
*   **If** waiting for user to stop typing -> **Use** `Debounce`.
*   **If** tracking mouse movement -> **Use** `Throttle`.
*   **If** operation takes time but UI must stay responsive -> **Use** `Async/Await`.

<!-- CHUNK 31-40 -->

# Developer Decision Guide: JS Advanced (Lecture 5)

## SECTION 1: CORE MENTAL MODEL

### Event Loop & Concurrency
**Event Loop (Vòng lặp sự kiện)**: Cơ chế xử lý bất đồng bộ trong JavaScript đơn luồng. Theo dõi Call Stack và Callback Queue.

**Call Stack (Ngăn xếp gọi)**: Cấu trúc dữ liệu LIFO (Last In, First Out) lưu trữ các frames hàm đang thực thi. JavaScript thực thi code đồng bộ trên Call Stack.

**Callback Queue (Hàng đợi Callback)**: Lưu trữ các tác vụ bất đồng bộ đã hoàn thành (từ WebAPIs) và chờ được đẩy vào Call Stack.

**WebAPIs**: Cung cấp bởi Runtime (Browser/Node.js) để thực thi các tác vụ bất đồng bộ thực sự (Timer, Network request).

**How it works in reality**:
1. JavaScript Engine chạy code đồng bộ trên Call Stack.
2. Khi gặp tác vụ bất đồng bộ (setTimeout, fetch), WebAPIs xử lý nó.
3. WebAPIs đẩy callback vào Callback Queue khi tác vụ hoàn thành.
4. Event Loop kiểm tra: Nếu Call Stack rỗng, lấy callback từ Callback Queue và đẩy vào Call Stack để thực thi.

**Why this approach is better**: Cho phép JavaScript thực thi các tác vụ nặng (IO, Network) mà không block main thread, giữ cho UI responsive.

### Microtask vs Macrotask
**Microtask Queue (Hàng đợi tác vụ nhỏ)**: Hàng đợi ưu tiên cao, chứa các tác vụ từ Promise, async/await.

**Macrotask Queue (Hàng đợi tác vụ lớn)**: Hàng đợi ưu tiên thường, chứa các tác vụ từ setTimeout, setInterval, DOM events.

**Execution Priority**: 
1. Hoàn tất Call Stack hiện tại.
2. Xử lý HẾT Microtask Queue (bao gồm cả các microtask được tạo ra trong quá trình xử lý).
3. Xử lý 1 Macrotask từ Macrotask Queue.
4. Lặp lại.

**Why this matters**: Đảm bảo Promise được xử lý trước setTimeout, tránh race condition không mong muốn.

### Callback Pattern
**Callback (Hàm gọi lại)**: Hàm được truyền làm tham số để thực thi sau khi một tác vụ bất đồng bộ hoàn thành.

**Error-first Callback Pattern**: Quy ước trong Node.js, tham số đầu tiên của callback dành cho lỗi (null nếu thành công).

**Callback Hell (Pyramid of Doom)**: Tình trạng callback lồng nhau sâu, gây khó đọc, khó bảo trì, khó debug.

---

## SECTION 2: DECISION TABLES

### When to use Callback vs Promise/Async-Await
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| **Support Node.js < 10 hoặc API legacy** | **Callback (Error-first)** | **Callback (Compatibility)**: Phù hợp với codebase cũ, API không hỗ trợ Promise | Bỏ qua lỗi tham số đầu tiên, không xử lý lỗi |
| **Mặc định cho code mới** | **Promise/Async-Await** | **Promise (Readability)**: Code flat, dễ đọc, lỗi được reject rõ ràng, xử lý lỗi tập trung với try-catch | Mix callback và Promise, tạo Promise không cần thiết |
| **Xử lý nhiều tác vụ song song** | **Promise.all() với Async-Await** | **Parallel Execution**: Thực thi song song, đợi tất cả hoàn thành, hiệu năng tốt hơn sequence | Dùng await trong vòng lặp lồng nhau, biến song song thành sequence |
| **Cần cancel request** | **AbortController với fetch** | **Cancellation**: Native support để cancel fetch đang chạy | Không cleanup timeout/event listener |

### When to use Microtask vs Macrotask
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| **Cần thực thi ngay sau Call Stack rỗng** | **Microtask (Promise.then)** | **Priority**: Đảm bảo chạy trước bất kỳ macrotask nào, useful cho cache/update state | Dùng setTimeout(fn, 0) thay vì Promise.resolve().then() |
| **Delay UI render** | **Macrotask (setTimeout 0)** | **Rendering**: Cho phép browser render UI trước khi chạy code nặng | Dùng microtask, block UI update |
| **Thực thi theo chu kỳ định kỳ** | **Macrotask (setInterval)** | **Repetition**: Chạy lặp lại theo khoảng thời gian cố định | Dùng setTimeout lồng nhau không kiểm soát |
| **Handle user interaction** | **Macrotask (Event Listener)** | **Event-driven**: Phản hồi hành động người dùng | Xử lý logic nặng trực tiếp trong event handler |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Execution Hierarchy
```text
JavaScript Runtime Environment (Browser / Node.js)
│
├── JavaScript Engine (V8, SpiderMonkey)
│   ├── Call Stack (Thực thi đồng bộ)
│   └── Heap (Memory)
│
├── WebAPIs / Libuv (Async Operations)
│   ├── Timer (setTimeout/setInterval)
│   ├── Network (fetch)
│   ├── File System (Node.js)
│   └── DOM Events
│
├── Event Loop (Cơ chế điều phối)
│   ├── Microtask Queue (Ưu tiên cao: Promise, queueMicrotask)
│   └── Macrotask Queue (Ưu tiên thường: setTimeout, setInterval)
│
└── Developer Code (User Implementation)
    ├── Synchronous Code (Chạy trực tiếp trên Call Stack)
    └── Asynchronous Code (Callback/Promise/Async-Await)
```

### Execution Flow
```text
1. Run synchronous code on Call Stack
   ↓
2. Encounter async operation → Pass to WebAPIs
   ↓
3. WebAPIs executes async task
   ↓
4. Task completes → Push callback to Queue (Microtask or Macrotask)
   ↓
5. Event Loop checks: Call Stack empty?
   ↓
6. YES: Process ALL Microtasks first
   ↓
7. Process ONE Macrotask
   ↓
8. Repeat from step 5
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Error-First Callback (Node.js Style)
**Khi nào dùng**: Khi làm việc với API legacy hoặc module Node.js cũ.

**Tại sao đúng**: Centralized error handling, easy to compose.

```javascript
// Định nghĩa hàm với callback error-first
function readFileAsync(filePath, callback) {
  setTimeout(() => {
    // Simulation: 20% chance of error
    const isError = Math.random() < 0.2;
    
    if (isError) {
      // First argument: Error (null if success)
      callback(new Error('File not found'), null);
    } else {
      // Second argument: Data
      callback(null, 'File content here');
    }
  }, 100);
}

// Sử dụng
readFileAsync('data.txt', (err, data) => {
  if (err) {
    console.error('Error:', err.message);
    return;
  }
  console.log('Data:', data);
});
```

### Pattern 2: Promise Chain (Avoid Callback Hell)
**Khi nào dùng**: Khi cần thực thi nhiều tác vụ bất đồng bộ theo trình tự.

**Tại sao đúng**: Code flat, lỗi được catch集中, dễ debug.

```javascript
// Simulate async tasks
function taskA() {
  return new Promise(resolve => setTimeout(() => resolve('Result A'), 100));
}

function taskB(prevResult) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (prevResult === 'Result A') resolve('Result B');
      else reject(new Error('Invalid previous result'));
    }, 100);
  });
}

// Execution
taskA()
  .then(resultA => taskB(resultA))
  .then(resultB => console.log('Final:', resultB))
  .catch(err => console.error('Chain failed:', err.message));
```

### Pattern 3: Async-Await with Try-Catch
**Khi nào dùng**: Khi cần code đồng bộ-looking nhưng thực thi bất đồng bộ. **Mặc định cho code mới.**

**Tại sao đúng**: Dễ đọc nhất, lỗi được xử lý như code đồng bộ.

```javascript
// Simulate API calls
function getUser(id) {
  return new Promise(resolve => 
    setTimeout(() => resolve({ id, name: 'User ' + id }), 100)
  );
}

function getPosts(userId) {
  return new Promise(resolve => 
    setTimeout(() => resolve(['Post 1', 'Post 2']), 100)
  );
}

// Async-Await pattern
async function fetchUserAndPosts(userId) {
  try {
    // await pauses execution until Promise resolves
    const user = await getUser(userId);
    const posts = await getPosts(user.id); // Sequential
    
    console.log('User:', user.name);
    console.log('Posts:', posts);
    return { user, posts };
  } catch (error) {
    console.error('Failed:', error.message);
    throw error; // Re-throw or return default
  }
}

// Calling
fetchUserAndPosts(1).then(result => console.log('Done'));
```

### Pattern 4: Parallel Execution with Promise.all
**Khi nào dùng**: Khi các tác vụ独立 không phụ thuộc nhau, cần tối ưu tốc độ.

**Tại sao đúng**: Song song hóa, giảm thời gian chờ đáng kể.

```javascript
function task1() {
  return new Promise(resolve => setTimeout(() => resolve('Task 1'), 300));
}

function task2() {
  return new Promise(resolve => setTimeout(() => resolve('Task 2'), 200));
}

function task3() {
  return new Promise(resolve => setTimeout(() => resolve('Task 3'), 100));
}

// Parallel execution
async function runParallel() {
  try {
    // Tất cả chạy song song, Promise.all đợi tất cả hoàn thành
    const results = await Promise.all([task1(), task2(), task3()]);
    console.log('All results:', results); // ['Task 1', 'Task 2', 'Task 3']
    
    // Total time: max(300, 200, 100) = 300ms (instead of 600ms)
  } catch (error) {
    console.error('One task failed:', error.message);
  }
}

// Alternative: Promise.allSettled (không throw lỗi)
async function runAllSettled() {
  const results = await Promise.allSettled([task1(), task2(), task3()]);
  console.log(results); // [{status: 'fulfilled', value: 'Task 1'}, ...]
}
```

### Pattern 5: Microtask vs Macrotask Timing
**Khi nào dùng**: Khi cần control execution order rõ ràng.

**Tại sao đúng**: Understanding priority để avoid race condition.

```javascript
console.log('1. Start'); // Synchronous

// Macrotask (low priority)
setTimeout(() => console.log('2. setTimeout'), 0);

// Microtask (high priority)
Promise.resolve().then(() => console.log('3. Promise.resolve'));

// Another Microtask
queueMicrotask(() => console.log('4. queueMicrotask'));

// Async-Await (also Microtask)
(async () => {
  console.log('5. Async start');
  await null; // Pause here, push rest to microtask
  console.log('7. Async after await');
})();

console.log('6. End'); // Synchronous

// Output Order:
// 1. Start
// 5. Async start
// 6. End
// 3. Promise.resolve
// 4. queueMicrotask
// 7. Async after await
// 2. setTimeout
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Pyramid of Doom (Callback Hell)
**Dangerous because**: Code lồng nhau quá sâu (3+ cấp) → khó đọc, khó sửa, khó maintain. Nếu có lỗi ở level 3, việc debug rất phức tạp.

```javascript
// ANTI-PATTERN: Đừng làm này
function getData(cb) {
  step1((err, res1) => {
    if (err) return cb(err);
    step2(res1, (err, res2) => {
      if (err) return cb(err);
      step3(res2, (err, res3) => {
        if (err) return cb(err);
        cb(null, res3);
      });
    });
  });
}
// ⇒ Use Promise chain or Async-Await
```

### 2. Ignoring Error in Error-First Callback
**Dangerous because**: Lỗi bị nuốt, application crash không rõ nguyên nhân hoặc state không mong muốn.

```javascript
// ANTI-PATTERN: Đừng làm này
function dangerous() {
  readFile('file.txt', (err, data) => {
    console.log(data); // Bỏ qua err!
  });
}
// ⇒ Luôn kiểm tra err trước
```

### 3. Blocking Event Loop with Synchronous Code
**Dangerous because**: JavaScript là single-threaded. Code đồng bộ nặng block cả thread → UI freeze, server không phản hồi.

```javascript
// ANTI-PATTERN: Đừng làm này trong server
app.get('/heavy', (req, res) => {
  // Giả lập compute nặng
  let sum = 0;
  for (let i = 0; i < 1e9; i++) sum += i; // Block ~1s
  res.send('Done'); // Request khác phải chờ
});
// ⇒ Dùng async/await hoặc chia nhỏ task
```

### 4. Mixing Callback and Promise (Callback Hell 2.0)
**Dangerous because**: Không nhất quán, khó Maintain, dễ quên xử lý lỗi.

```javascript
// ANTI-PATTERN: Đừng làm này
function mixed() {
  getUser(1, (err, user) => {
    if (err) return;
    // Mix Promise trong callback
    getPosts(user.id).then(posts => {
      // ...
    }).catch(err => console.log(err));
  });
}
// ⇒ Dùng Async-Await đồng nhất
```

### 5. Not Handling Promise Rejection
**Dangerous because**: Lỗi Promise không được catch → UnhandledPromiseRejection, process crash (Node.js) hoặc silent failure.

```javascript
// ANTI-PATTERN: Đừng làm này
function noCatch() {
  fetch('/api').then(res => res.json()); // Nếu lỗi, không catch
}
// ⇒ Luôn có .catch() hoặc try-catch với async/await
```

### 6. Creating Promise Anti-Pattern
**Dangerous because**: Không cần thiết, redundant code.

```javascript
// ANTI-PATTERN: Đừng làm này
function unnecessaryPromise(value) {
  return new Promise(resolve => {
    resolve(value);
  });
}

// ⇒ Use Promise.resolve()
function better(value) {
  return Promise.resolve(value);
}
```

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Call Stack rỗng?** → Process ALL Microtasks → Process 1 Macrotask → Repeat
2. **Promise/Async-Await = Microtask** → Chạy trước setTimeout
3. **Error-first callback** → Luôn check `err` ở tham số 1
4. **Callback Hell** → Chuyển sang Promise chain hoặc Async-Await
5. **Parallel tasks** → `Promise.all([task1(), task2()])`
6. **Sequential tasks** → `await task1(); await task2()`

### Decision Logic
```text
Cần xử lý async?
├── API legacy / Node.js cũ? → Error-first Callback
├── Code mới? → Async-Await
│   ├── Thực thi song song? → Promise.all()
│   ├── Thực thi tuần tự? → await từng cái
│   └── Lỗi cần xử lý? → try-catch
└── Control timing? → setTimeout (Macrotask) vs Promise (Microtask)
```

### Top 10 Things to Remember
1. **Event Loop** = Call Stack + WebAPIs + Callback Queue
2. **Microtask > Macrotask** → Promise trước setTimeout
3. **Single Thread** → Không block UI/server
4. **Error-first** → `err, data` parameters
5. **Callback Hell** → Pyramid shape = Bad
6. **Promise.resolve()** → Wrap value thành Promise
7. **Promise.all()** → Song song, nhanh hơn sequence
8. **Try-catch** → Duy nhất cách xử lý lỗi trong async/await
9. **queueMicrotask()** → Tạo microtask thủ công
10. **Unhandled Rejection** → Luôn catch Promise lỗi

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: JS Advanced (Lec 5)

## SECTION 1: CORE MENTAL MODEL

### Promise
- **Definition**: `Promise` (Đối tượng Promise) là một đối tượng tích hợp sẵn trong JavaScript đại diện cho sự hoàn thành (hoặc thất bại) của một thao tác bất đồng bộ và giá trị kết quả của nó.
- **Mental Model**: Xem Promise như một "phiếu biên nhận" cho một công việc đang chạy ở background. Nó không phải là kết quả ngay lập tức, mà là lời hứa sẽ trả về kết quả đó trong tương lai.
- **Why it's better**: So với Callback, Promise giúp bạn tránh được "Callback Hell" (trả về hàm lồng nhau) và quản lý lỗi tập trung hơn. Nó cho phép viết mã bất đồng bộ trông giống như đồng bộ.

### Promise States (Trạng thái)
| Trạng thái (State) | Mô tả (Description) | Chuyển tiếp (Transition) |
| :--- | :--- | :--- |
| **Pending** (Đang chờ) | Trạng thái ban đầu; thao tác chưa hoàn thành. | Chuyển sang **Fulfilled** hoặc **Rejected**. |
| **Fulfilled** (Đã hoàn thành) | Thao tác hoàn thành thành công. | Phương thức `.then()` được thực thi. |
| **Rejected** (Bị từ chối) | Thao tác thất bại. | Phương thức `.catch()` được thực thi. |

### So sánh: Callback vs Promise
- **Callback**: Hàm được truyền vào một hàm khác để thực thi sau. Dễ dẫn đến "Callback Hell" (mã bị lồng nhau quá sâu, khó đọc).
- **Promise**: Đối tượng đại diện kết quả. Cho phép nối chuỗi (chainable), đọc dễ hiểu hơn.

```javascript
// Callback Hell Example (Không nên)
getData(function(a) {
    getMoreData(a, function(b) {
        getMoreData(b, function(c) {
            // Lỗi xử lý khó khăn tại đây
        });
    });
});

// Promise Chain Example (Nên dùng)
getData()
    .then(a => getMoreData(a))
    .then(b => getMoreData(b))
    .catch(err => console.error("Lỗi:", err));
```

---

## SECTION 2: DECISION TABLES

### Khi nào dùng Promise.all() vs Promise Chaining

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Các tác vụ độc lập, chạy cùng lúc** (Vd: Gọi API để lấy User và Product song song). | `Promise.all([task1, task2])` | **Parallel Execution (Thực thi song song)**: Tiết kiệm thời gian bằng cách chạy tất cả cùng lúc và đợi kết quả cuối cùng. | Dùng nối chuỗi `.then()` lần lượt (Serial): Làm chậm chương trình một cách không cần thiết. |
| **Các tác vụ phụ thuộc nhau** (Vd: Phải có token mới gọi được API User). | `Promise Chaining (.then().then())` | **Sequential Execution (Thực thi tuần tự)**: Đảm bảo thứ tự xử lý và lấy kết quả của tác vụ trước cho tác vụ sau. | Dùng `Promise.all`: Sai logic vì tác vụ sau phụ thuộc vào kết quả của tác vụ trước chưa có. |

### Khi nào dùng .catch() vs .finally()

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Xử lý lỗi, log báo cáo, thông báo cho người dùng**. | `.catch()` | **Error Handling (Xử lý lỗi)**: Chỉ chạy khi có lỗi xảy ra trong chuỗi Promise. | Để xử lý lỗi lung tung trong từng `.then()`. |
| **Dọn dẹp tài nguyên (loading spinner, close connection)**. | `.finally()` | **Cleanup (Dọn dẹp)**: Chạy luôn cả khi thành công hay thất bại, không nhận tham số. | Dùng `.finally()` để xử lý logic kết quả (do không có access tới kết quả). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Luồng xử lý Promise (Lifecycle Flow)

```text
[ Bắt đầu ]
      |
      v
[ new Promise(executor) ] ------------------------+
      |                                           |
      v                                           |
[ Trạng thái: PENDING ]                           |
      |                                           |
   Thành công (Resolve)                           |
      +------------------> [ fulfilled ]          |
      |                            |              |
   Thất bại (Reject)               |              |
      +------------------> [ rejected ]           |
      |                            |              |
      v                            |              |
[ .then(successCallback) ]         |              |
      |                            |              |
[ .catch(errorCallback) ] <--------+              |
      |                                           |
      v                                           |
[ .finally(cleanupCallback) ]                     |
      |                                           |
      v                                           |
[ Kết thúc chuỗi ] <------------------------------+
```

### Mối quan hệ các phương thức
- **`.then()`**: Nhận kết quả từ `Resolve`. Trả về một Promise mới (có thể là Promise mới hoặc giữ nguyên chuỗi).
- **`.catch()`**: Bắt lỗi từ `Reject` ở bất kỳ bước nào trước đó.
- **`.finally()`**: Chèn vào cuối chuỗi để dọn dẹp, không ảnh hưưởng đến luồng dữ liệu.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Promise Chaining (Chuỗi Promise)
**Khi nào dùng**: Khi bạn cần thực hiện nhiều bước bất đồng bộ mà bước sau phụ thuộc vào kết quả của bước trước.

**Tại sao đúng**: Đảm bảo thứ tự thực thi và code dễ đọc hơn lồng callback.

```javascript
function getUser(userId) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (userId === 1) {
                resolve({ id: 1, name: "John Doe" });
            } else {
                reject("User not found");
            }
        }, 1000);
    });
}

// Pattern Implementation
getUser(1)
    .then(user => {
        console.log("Step 1: Got user", user.name);
        // Bước 2: Lấy thông tin chi tiết (mô phỏng)
        return getDetail(user.id); // Trả về Promise mới
    })
    .then(detail => {
        console.log("Step 2: Got detail", detail);
    })
    .catch(error => {
        console.error("Error occurred:", error);
    })
    .finally(() => {
        console.log("Cleanup: Operation finished.");
    });
```

### Pattern 2: Promise.all (Xử lý song song)
**Khi nào dùng**: Khi cần gọi nhiều API độc lập và cần tất cả dữ liệu trước khi xử lý tiếp.

**Tại sao đúng**: Tối ưu thời gian bằng cách chạy song song.

```javascript
const fetchUser = () => Promise.resolve({ name: "Alice" });
const fetchProducts = () => Promise.resolve(["Laptop", "Phone"]);
const fetchOrders = () => Promise.resolve(["Order#1"]);

// Pattern Implementation
Promise.all([fetchUser(), fetchProducts(), fetchOrders()])
    .then(([user, products, orders]) => {
        console.log(`User: ${user.name}`);
        console.log(`Products: ${products.length}`);
        console.log(`Orders: ${orders.length}`);
    })
    .catch(err => {
        // Nếu 1 trong 3 Promise bị reject, đoạn này chạy ngay lập tức
        console.error("One of the requests failed:", err);
    });
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Callback Hell (Pyramid of Doom)**
    *   **Lý do nguy hiểm**: Lồng các hàm callback quá sâu làm code khó đọc, khó debug, và xử lý lỗi trở nên cơn ác mộng.
    *   **Hướng giải quyết**: Dùng `Promise Chaining` hoặc `async/await`.

2.  **Bỏ qua `.catch()` (Unhandled Rejection)**
    *   **Lý do nguy hiểm**: Nếu Promise bị reject mà không có `.catch()`, lỗi sẽ bị "im lặng", chương trình có thể bị crash hoặc trạng thái application không rõ ràng.
    *   **Hướng giải quyết**: Luôn luôn có `.catch()` cuối chuỗi hoặc dùng `unhandledrejection` event ở level global.

3.  **Lồng `.then()` không cần thiết**
    *   **Lý do nguy hiểm**: Tạo ra "Promise Hell" tương tự như Callback Hell.
    *   **Ví dụ sai**:
        ```javascript
        getData().then(a => {
            getMoreData(a).then(b => {
                // Logic ở đây
            });
        });
        ```
    *   **Hướng giải quyết**: `return` Promise ở trong `.then()` để nối chuỗi phẳng.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules to Remember
1.  **Promise là_OBJ**: `new Promise()` trả về một đối tượng, không phải dữ liệu kết quả.
2.  **Bắt lỗi là bắt buộc**: Luôn có `.catch()` (hoặc `try/catch` nếu dùng async/await) để tránh Silent Failure.
3.  **Return trong `.then()`**: Nếu bạn muốn chuỗi tiếp tục, bạn phải `return` một giá trị hoặc một Promise mới.
4.  **`.finally()` là nơi dọn dẹp**: Đừng mong đợi nhận dữ liệu trả về từ `.finally()`.
5.  **Song song hóa khi có thể**: Dùng `Promise.all()` nếu các tác vụ không phụ thuộc nhau để tăng tốc độ.

### Decision Logic (Nếu... Thì...)
*   **Nếu** thực thi A xong mới tới B (A -> B) → **Thì** dùng **Promise Chaining** (`.then().then()`).
*   **Nếu** cần A, B, C cùng chạy một lúc để lấy dữ liệu → **Thì** dùng **`Promise.all([A, B, C])`**.
*   **Nếu** chỉ cần xử lý dọn dẹp sau khi hoàn thành (thành công hay thất bại) → **Thì** dùng **`.finally()`**.
*   **Nếu** cần xử lý lỗi cụ thể cho từng giai đoạn → **Thì** dùng **`.catch()`** ở cuối chuỗi hoặc từng đoạn.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: JS Advanced (Lec 5)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Async/Await (Xử lý bất đồng bộ thế hệ mới)**
Bộ từ khóa cho phép viết mã bất đồng bộ (Asynchronous) trông và hành xử như mã đồng bộ (Synchronous). Nó là "syntactic sugar" (đường ngữ pháp) cho Promises.

*   **`async` (Asynchronous Function)**: Khai báo một hàm luôn trả về một `Promise`, bất kể bạn trả về giá trị nào.
*   **`await` (Await Expression)**: Dừng (pause) việc thực thi hàm `async` tại đó cho đến khi `Promise` được giải quyết (settled - fulfilled hoặc rejected). Nó chỉ được dùng bên trong hàm `async`.

### Why this approach is better?

Nó loại bỏ sự phức tạp của "Callback Hell" (Hell tuần tự) và chuỗi `.then()` dài dòng của Promise, giúp mã nguồn dễ đọc, dễ bảo trì và xử lý lỗi tự nhiên hơn với `try...catch`.

---

## SECTION 2: DECISION TABLES

### Async/Await vs Promise Chaining

| Tiêu chí | Promise Chaining (`.then()`) | Async/Await (`async`/`await`) |
| :--- | :--- | :--- |
| **Tình huống sử dụng** | Xử lý một vài bước bất đồng bộ đơn giản hoặc pipeline dữ liệu đơn giản. | Các tác vụ phức tạp cần nhiều bước, phụ thuộc lẫn nhau hoặc logic phức tạp. |
| **Đọc mã (Readability)** | Kém. Dễ bị "Callback Hell" nếu nesting sâu. | Rất tốt. Trông giống như mã đồng bộ thông thường. |
| **Xử lý lỗi (Error Handling)** | Dùng `.catch()` ở cuối chuỗi hoặc `.then(null, handler)`. | Dùng `try...catch` blocks chuẩn (tương tự Java/C#). |
| **Tại sao dùng?** | Dễ implement cho Promise đơn giản. | Code sạch hơn, dễ debug hơn, logic rõ ràng hơn. |
| **Sai lầm thường gặp** | Quên `return` trong `.then()` dẫn đến chuỗi bị break hoặc giá trị `undefined`. | Quên từ khóa `await` trước Promise -> trả về Promise object thay vì giá trị resolve. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Execution Flow

Khi `await` được gọi, Event Loop sẽ tạm thời "gác" hàm đó lại và cho phép các tác vụ khác chạy cho đến khi Promise hoàn thành.

```text
[Async Function Call]
      |
      v
[Reach 'await' Keyword] -----> [Push Promise to Microtask Queue]
      |
      v
[Pause Execution] (Function sleeps, does NOT block main thread)
      |
      +---------------------------------> [Main Thread continues...]
                                                   |
[Microtask Queue: Promise Resolved] <-------------+
      |
      v
[Resume Execution] (Pick up where it left off)
      |
      v
[Assign Resolved Value] -----> [Continue next lines of code]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Sequential Async Logic
**Khi nào dùng:** Khi你需要 gọi nhiều API, và kết quả của API A cần dùng cho API B.

**Tại sao đúng:** Tránh "Promise Chain" rườm rà, giúp code chạy theo đúng logic tư duy.

```javascript
async function getUserData(userId) {
  try {
    // 1. Dừng ở đây cho đến khi có token
    const token = await authLogin('admin', '1234'); 
    
    // 2. Dừng ở đây cho đến khi có user info
    const user = await fetchUser(userId, token); 
    
    // 3. Dừng ở đây cho đến khi có posts
    const posts = await fetchUserPosts(user.id); 

    return { user, posts };
  } catch (error) {
    // Bắt lỗi của tất cả các await bên trên
    console.error('Failed to fetch data:', error);
  }
}
```

### Pattern 2: Parallel Execution
**Khi nào dùng:** Khi các tác vụ KHÔNG phụ thuộc vào nhau (ví dụ: gọi 3 API khác nhau cùng lúc).

**Tại sao đúng:** `Promise.all` chạy các tác vụ song song, giảm thời gian chờ tổng thể thay vì chạy tuần tự từng cái một.

```javascript
async function loadDashboard() {
  const [stats, notifications, ads] = await Promise.all([
    fetch('/api/stats'),    // Promise 1
    fetch('/api/messages'), // Promise 2
    fetch('/api/ads')       // Promise 3
  ]);
  
  // Tất cả đều resolved mới chạy tiếp đây
  renderDashboard(stats, notifications, ads);
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **The "Void Await" (Quên return kết quả)**
    *   **Code sai:** `async function sum(a, b) { await a + b; }`
    *   **Tại sao sai:** Hàm này trả về `Promise<undefined>` vì không có lệnh `return`.
    *   **Sửa:** `return await a + b;` hoặc `return a + b;`.

2.  **The "Floating Promise" (Promise bị bỏ lơ)**
    *   **Code sai:** Trong một hàm `async`, gọi `fetchData()` nhưng không có `await`.
    *   **Tại sao sai:** Lỗi có thể bị nuốt trôi, lỗi xảy ra không được bắt, biến chương trình vào trạng thái không xác định.
    *   **Sửa:** Luôn dùng `await` hoặc `return Promise` đó.

3.  **Blocking the Main Thread**
    *   **Code sai:** Dùng vòng lặp đồng bộ nặng bên trong `async`.
    *   **Tại sao sai:** `async` cho phép các tác vụ khác chạy khi chờ, nhưng nếu bạn làm việc nặng trong đó, UI vẫn bị treo.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules
1.  **Luôn dùng `try...catch`** bên trong hàm `async` để xử lý lỗi (thay vì `.catch()`).
2.  **Kiểm tra kỹ `await`**: Nếu bạn thấy `Promise { <pending> }` trong log, là bạn quên `await`.
3.  **Dùng `Promise.all`** khi các request độc lập để tối ưu tốc độ.
4.  **`async` funtion luôn trả về Promise**: Đừng cố `return` giá trị đồng bộ nếu không muốn wrap nó lại.
5.  **Top-level `await`**: Chỉ dùng được ở các file module (ES2022+), không dùng trong thường.

### Decision Logic (If-Else Style)

*   **Nếu** bạn chỉ cần xử lý 1 request và muốn đơn giản -> **Dùng `Promise.then()`**.
*   **Nếu** bạn cần xử lý nhiều request song song -> **Dùng `Promise.all([...])`**.
*   **Nếu** bạn cần xử lý nhiều request **từng bước một**, kết quả này là input của bước kia -> **Dùng `async/await`**.
*   **Nếu** bạn cần lặp qua một mảng và thực hiện bất đồng bộ cho từng phần tử -> **Dùng `Promise.all(array.map(...))`**.

<!-- CHUNK 61-66 -->

# DEVELOPER DECISION GUIDE: JS Advanced (Async & DOM)

## SECTION 1: CORE MENTAL MODEL

### 1.1 Asynchronous Mechanism
- **Async Function (Hàm bất đồng bộ)**: A function declared with the `async` keyword. It automatically wraps the return value in a `Promise`.
  - **Mental Model**: Think of it as a "wrapper" that guarantees the function will return a `Promise` object in the future. It does *not* make the code run in parallel (unless mixed with Workers); it just manages the execution flow non-blocking.
  - **Rule**: If you don't return explicitly, it returns `Promise.resolve(undefined)`.

- **Await Keyword (Từ khóa chờ)**: Pauses the execution of an `async` function until the `Promise` settles.
  - **Mental Model**: A "pause button" that only works inside `async` functions. It unwraps the result of the `Promise`, allowing you to assign the result directly to a variable without `.then()`.

- **Top-Level Await (Chờ ở cấp cao nhất)**: The ability to use `await` outside of an `async` function (available in ES Modules).
  - **Why it's better**: Allows initializing modules with asynchronous dependencies (e.g., fetching config) before the rest of the script executes, blocking the script load itself.

### Code Demo: The Async Lifecycle
```javascript
// 1. Async function always returns a Promise
async function getUser() {
  return { id: 1 }; // Automatically wrapped in Promise.resolve({ id: 1 })
}

// 2. Await unwraps the value
async function main() {
  console.log("Start");
  const user = await getUser(); // Pauses here until resolved
  console.log("User:", user);   // Prints { id: 1 }
  console.log("End");
}
main();
```

---

## SECTION 2: DECISION TABLES

### Table 1: Async Flow Control
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common Mistake) |
| :--- | :--- | :--- | :--- |
| **Dịch vụ cũ (Legacy API)** | **Callback** | Hợp với code cũ không hỗ trợ Promise. **Callback Pattern (Mẫu gọi lại)** là cơ bản nhất. | Dẫn đến "Callback Hell" (Hàm lồng hàm) khó đọc và xử lý lỗi. |
| **Xử lý chuỗi động (Dynamic Chaining)** | **Promise (.then())** | Dễ dàng nối chuỗi các bước phụ thuộc nhau. **Chaining (Nối chuỗi)** cho phép truyền kết quả giữa các bước. | Dùng `await` trong vòng lặp khi các bước không phụ thuộc để tối ưu tốc độ. |
| **Logic phức tạp, cần try/catch** | **Async/Await** | Code đọc như đồng bộ, dễ quản lý lỗi bằng **Try/Catch Block (Khối thử bắt lỗi)**. | Quên đặt `async` trước hàm hoặc `await` trước biến Promise. |

### Table 2: DOM Handling
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common Mistake) |
| :--- | :--- | :--- | :--- |
| **Lấy giá trị nhiều checkbox/select** | `HTMLSelectElement.selectedOptions` hoặc `querySelectorAll('input:checked')` | Trả về collection live hoặc array thực, dễ truy xuất `.value` trực tiếp. | Duyệt qua `options` và check manual `.selected` property, dễ sai với các giá trị đa chọn. |
| **Xác thực real-time** | `input` event + `RegExp` | Kích hoạt ngay khi người dùng gõ, mang lại trải phản hồi tức thì (**Real-time Validation**). | Dùng `submit` event (phải đợi bấm nút mới biết lỗi). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Async Stack
Execution moves linearly, but tasks are offloaded to the Browser/Web API or Microtask Queue.

```text
[Call Stack]
   ↓
[Async Function Call] → Returns Promise (Pending)
   ↓ (Pushes to Microtask Queue)
[Sync Code Continues] → Executes immediately
   ↓
[Event Loop Check] (When Call Stack is empty)
   ↓
[Microtask Queue] → Execute `resolve` / `await` handlers
   ↓
[Promise State] → Pending → Fulfilled / Rejected
```

### DOM Event Flow
```text
User Action (Type/Click)
   ↓
[Event Listener Attached] (`addEventListener`)
   ↓
[Event Triggered] -> Execute Callback Function
   ↓
[DOM Read/Write] -> Access `.value` -> Update `.textContent`
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Promise Chain (Linear Async)
**Khi nào dùng:** Khi bạn có nhiều bước phụ thuộc nhau, và mỗi bước là một Async task (ví dụ: Lấy User -> Lấy Posts -> Render).

**Tại sao đúng:** Tránh "Callback Hell" và giữ code ngang bằng, dễ đọc lỗi `.catch()` ở cuối chuỗi.

```javascript
// 1. Simulate fetching user
function fetchUser() {
  return new Promise(resolve => setTimeout(() => resolve({ id: 1, name: "Alice" }), 100));
}

// 2. Simulate fetching posts based on userId
function fetchPosts(userId) {
  return new Promise(resolve => setTimeout(() => resolve([{ id: 101, title: `Post for ${userId}` }]), 100));
}

// 3. Usage
fetchUser()
  .then(user => fetchPosts(user.id)) // Pass data to next step
  .then(posts => {
    console.log("Posts:", posts);
  })
  .catch(err => console.error("Error:", err)); // Handle error at one place
```

### Pattern 2: Async/Await with Try/Catch (Modern Standard)
**Khi nào dùng:** Khi logic cần đọc như câu lệnh thường, hoặc cần xử lý phức tạp giữa các bước await.

**Tại sao đúng:** Giúp bắt lỗi đồng bộ hóa một cách sạch sẽ, biến code bất đồng bộ thành đồng bộ trong mắt người đọc.

```javascript
async function processData() {
  try {
    // Step 1: Wait for user
    const user = await fetchUser(); 
    
    // Step 2: Wait for posts (logic logic in between works fine)
    if (!user) throw new Error("No user found");
    
    const posts = await fetchPosts(user.id);
    
    // Step 3: Render
    console.log("User:", user.name, "Posts:", posts.length);
  } catch (error) {
    // Catches both fetchUser and fetchPosts errors
    console.error("Operation Failed:", error.message);
  }
}
processData();
```

### Pattern 3: Real-Time Form Validation
**Khi nào dùng:** Đăng ký/Đăng nhập form.

**Tại sao đúng:** Kiểm tra input ngay lập tức giúp người dùng sửa lỗi nhanh.

```javascript
const emailInput = document.querySelector("#email");
const msgDiv = document.querySelector("#msg");
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

emailInput.addEventListener("input", (e) => {
  const val = e.target.value;
  if (!val) {
    msgDiv.textContent = "Email is empty";
    msgDiv.style.color = "red";
  } else if (!emailRegex.test(val)) {
    msgDiv.textContent = "Invalid format";
    msgDiv.style.color = "red";
  } else {
    msgDiv.textContent = "All good!";
    msgDiv.style.color = "green";
  }
});
```

### Pattern 4: Multiple Select Reader
**Khi nào dùng:** Form có nhiều checkbox hoặc select multiple.

**Tại sao đúng:** Truy cập `selectedOptions` hoặc filter input checked.

```javascript
// HTML: <select id="skills" multiple>...</select>
// HTML: <button id="btn">Show Selected</button>
const btn = document.getElementById("btn");
const select = document.getElementById("skills");

btn.addEventListener("click", () => {
  // Get all selected <option> elements
  const selectedOptions = Array.from(select.selectedOptions);
  
  // Extract values
  const values = selectedOptions.map(opt => opt.value);
  
  const display = document.getElementById("result");
  
  if (values.length === 0) {
    display.textContent = "No skill selected.";
  } else {
    display.textContent = values.join(", ");
  }
});
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Async Void" Trap
*Description:* Declaring an async function but not awaiting it or handling its promise.
```javascript
// DANGEROUS
function main() {
  someAsyncTask(); // Error inside here might be swallowed!
}
```
**Why it's dangerous:** If `someAsyncTask` throws an error, it creates an "Uncaught (in promise)" error that might crash the app silently or behave unpredictably.
**Fix:** Always `await` or `.catch()`.

### 2. Mixing Callbacks with Async/Await
*Description:* Using a callback style inside an async function unnecessarily.
```javascript
// CLUMSY
async function getData() {
  await fetchUser((err, user) => { ... }); // Bad practice
}
```
**Why it's dangerous:** It defeats the purpose of `await`. `await` expects a Promise, not a callback function taking `(err, data)`.
**Fix:** Wrap the callback in a Promise or use native Promise APIs.

### 3. Ignoring the `submit` Event Default
*Description:* Forgetting `e.preventDefault()` in form handling.
```javascript
form.addEventListener("submit", (e) => {
  // Logic only
  // Without e.preventDefault(), page reloads!
});
```
**Why it's dangerous:** The page will reload immediately after clicking submit, wiping out your JS state and stopping the validation logic from completing.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Syntax

| Concept | Syntax |
| :--- | :--- |
| **Define Async** | `async function name() {}` |
| **Pause Execution** | `const data = await promise` |
| **Return Promise** | `return value` (auto-wrapped) |
| **Handle Error** | `try { await ... } catch (e) { ... }` |
| **Simulate Delay** | `new Promise(r => setTimeout(r, ms))` |

### Decision Logic

```text
IF (Legacy system uses "error-first callbacks"):
  -> Use "util.promisify" or manual Promise wrapper.

ELSE IF (Sequence of dependent async steps):
  -> Use Async/Await inside Try/Catch.

ELSE IF (Multiple inputs need instant check):
  -> Use "input" event listener + Regex.

ELSE IF (Get values from <select multiple>):
  -> Use Array.from(element.selectedOptions).map(o => o.value).
```

### Top 5 Things to Remember
1.  **Async** always returns a `Promise`.
2.  **Await** only works inside `async` functions (except Top-Level).
3.  **Top-Level Await** blocks the module loading, not just execution.
4.  **DOM Access** needs Event Listeners (`addEventListener`).
5.  **Promise Chain** uses `.then()`, **Async/Await** uses `try/catch`.