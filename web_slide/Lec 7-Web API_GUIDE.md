# DEVELOPER DECISION GUIDE: Lec 7-Web API.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 18:04:13



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Web API (Lec 7)

## SECTION 1: CORE MENTAL MODEL

### API (Application Programming Interface)
* **Definition:** Giao diện lập trình ứng dụng - Một tập hợp quy tắc cho phép các phần mềm giao tiếp với nhau.
* **Mental Model:** Tưởng tượng như người phục vụ trong nhà hàng. Bạn (Client) gọi món qua người phục vụ (API), người phục vụ chuyển yêu cầu vào bếp (Server), và mang món ăn (Data) ra cho bạn.
* **Why use it?**
    * **Modularity (Tính mô-đun):** Phân chia hệ thống lớn thành các dịch vụ nhỏ, dễ bảo trì.
    * **Security (Bảo mật):** Kiểm soát quyền truy cập, che giấu dữ liệu nhạy cảm phía backend.
    * **Interoperability (Tính tương tác):** Các hệ thống khác nhau (Web, Mobile, Internal) có thể dùng chung data.

### REST (Representational State Transfer)
* **Definition:** Kiến trúc chuẩn cho Web API, sử dụng HTTP để định nghĩa tài nguyên (Resource) và thao tác (Method).
* **Key Principles:**
    * **Stateless:** Server không lưu trữ trạng thái request của Client (mỗi request đều tự chứa đủ thông tin).
    * **Resource-Based:** Mọi thứ đều là "Tài nguyên" được truy cập qua URL.
    * **Standard HTTP Methods:** GET, POST, PUT, DELETE.

### JSON (JavaScript Object Notation)
* **Definition:** Định dạng trao đổi dữ liệu nhẹ, đọc được bởi cả máy tính và người dùng.
* **Structure:** Dạng key-value, hỗ trợ mảng (Array) và đối tượng (Object).
* **Usage:** Dữ liệu gửi đi (Body) và nhận về (Response) trong Web API đều là JSON.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Thuần JavaScript, không cần tùy chỉnh nhiều** | **Fetch API** | **Native (Tích hợp sẵn):** Không cần cài thư viện, chạy được ngay trong trình duyệt hiện đại. | Quên xử lý lỗi `fetch` không tự ném lỗi cho HTTP 4xx/5xx, cần check `response.ok`. |
| **Dự án lớn, cần interceptor, timeout, retry** | **Axios** | **Features (Tính năng):** Hỗ trợ Interceptor (Xử lý giữa chừng), tự động parse JSON, timeout rõ ràng. | Viết lại logic intercept thủ công khi dùng Fetch, gây lặp code (redundancy). |
| **Xử lý nhiều request cùng lúc (Race condition)** | **Async/Await** | **Readability (Đọc được):** Code chạy tuần tự như đồng bộ, dễ debug hơn `.then()`. | Dùng `Promise.all` sai cách (không xử lý lỗi riêng lẻ) làm chết cả chuỗi request. |
| **Xử lý request một cách không đồng bộ (Background)** | **Promise (.then/.catch)** | **Control (Kiểm soát):** Phù hợp xử lý luồng phức tạp hoặc cần chèn logic giữa các bước. | Callback Hell (Nest quá nhiều `.then`), khó đọc và khó bảo trì. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Client-Server Flow (Text Diagram)
```
[Client / Browser] 
      ↓ (1. Gửi Request: URL + Method + Headers + Body)
[Network (Internet)]
      ↓ (2. API Gateway / Server xử lý logic)
[Server / Database]
      ↓ (3. Trả về Response: Status Code + Data JSON)
[Client / Browser] → Render UI
```

### Hierarchy of Libraries
```text
Browser Environment
├── Native APIs (Window, Document)
└── HTTP Client Layer
    ├── Fetch API (Native, Low-level)
    └── Axios Library (Wrapper, High-level)
        └── Awaits/Promises (Async Management)
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Fetch API with Error Handling (Native)
**Khi nào dùng:** Khi cần gọi API nhanh, nhẹ, không muốn cài thêm thư viện.
**Tại sao đúng:** `fetch` trả về một Promise chưa parse, cần check `response.ok` để bắt lỗi HTTP (404, 500).

```javascript
// Code Demo: Fetch chuẩn
async function getUserData(userId) {
  try {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    
    // QUAN TRỌNG: Fetch không tự ném lỗi cho HTTP 404/500
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }

    const data = await response.json(); // Parse JSON từ body
    console.log(data);
    return data;
  } catch (error) {
    console.error("Lỗi lấy dữ liệu:", error.message);
  }
}
```

### Pattern 2: Axios with Interceptors
**Khi nào dùng:** Khi cần xử lý lỗi tập trung (vd: 401 Unauthorized logout tự động) hoặc thêm Header (Token) tự động cho mọi request.
**Tại sao đúng:** Giúp code业务 logic (src/services) sạch sẽ, không lặp lại logic attach token.

```javascript
// Code Demo: Axios Interceptor
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
});

// Request Interceptor: Thêm Token tự động
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response Interceptor: Xử lý lỗi 401 tập trung
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      window.location.href = '/login'; // Redirect nếu hết hạn token
    }
    return Promise.reject(error);
  }
);

// Sử dụng
async function fetchOrders() {
  const res = await apiClient.get('/orders'); // Không cần viết lại logic token
  return res.data;
}
```

### Pattern 3: Async/Await Chaining
**Khi nào dùng:** Khi bạn cần dùng kết quả của Request A để làm Request B.
**Tại sao đúng:** Tránh "Callback Hell", code nhìn rõ trình tự thời gian.

```javascript
// Code Demo: Chain requests
async function processTransaction(productId, userId) {
  try {
    // Bước 1: Kiểm tra sản phẩm
    const product = await checkProductAvailability(productId); 
    if (!product.inStock) throw new Error("Hết hàng");

    // Bước 2: Lấy thông tin người dùng (dựa vào Bước 1)
    const user = await getUserProfile(userId); 
    
    // Bước 3: Thực hiện thanh toán
    const receipt = await paymentAPI.send(user.balance, product.price);
    
    return receipt;
  } catch (error) {
    console.error("Giao dịch thất bại:", error);
  }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1. **Không xử lý lỗi HTTP trong Fetch (Blind Fetching)**
   * **Tại sao nguy hiểm:** `fetch` chỉ reject khi lỗi mạng (Network Failure). Nếu Server trả về 404 hoặc 500, `fetch` vẫn thành công. Code sẽ chạy tiếp với dữ liệu lỗi, gây crash app.
   * **Cách tránh:** Luôn check `if (!response.ok)`.

2. **Quên CORS (Cross-Origin Resource Sharing)**
   * **Tại sao nguy hiểm:** Trình duyệt chặn request từ localhost:3000 sang api khác (do chính sách bảo mật Same-Origin). Dù code đúng vẫn bị lỗi.
   * **Cách tránh:** Phải dùng Proxy (nếu dev) hoặc đảm bảo Server response có header `Access-Control-Allow-Origin: *`.

3. **Dùng Promise.all() mà không có try-catch**
   * **Tại sao nguy hiểm:** Nếu 1 trong nhiều request thất bại, cả `Promise.all` sẽ bị reject ngay lập tức, dễ làm crash UI hoặc mất dữ liệu phần còn lại.
   * **Cách tránh:** Dùng `Promise.allSettled()` để đợi tất cả hoàn thành (dù thành công hay thất bại), sau đó lọc kết quả.

4. **Lấy dữ liệu nhưng không dùng Typing/Validation**
   * **Tại sao nguy hiểm:** API có thể thay đổi cấu trúc JSON mà không báo trước. Code sẽ crash khi truy cập vào property bị đổi tên hoặc undefined.
   * **Cách tránh:** Luôn validate data trước khi render (VD: `if (data && data.user)`).

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic
```text
IF (Project is small/simple) → Use Fetch API
ELSE IF (Project needs Auth/Timeout/Retry logic) → Use Axios
ELSE IF (Need to order requests strictly) → Use Async/Await
```

### Top 5 Rules to Remember
1. **JSON Everywhere:** Data trả về là String, dùng `.json()` (Fetch) hoặc tự động (Axios) để chuyển thành Object.
2. **HTTP Status Matters:** 200 là OK, 201 là Created, 400 là Bad Request (Client sai), 500 là Server Error.
3. **Async is Non-Blocking:** Đừng dùng `await` trong vòng lặp `forEach` nếu không cần thiết (dùng `Promise.all` hoặc `map`).
4. **Base URL:** Luôn đặt `baseURL` trong Axios hoặc biến môi trường trong Fetch để dễ đổi API Domain.
5. **Cleanup:** Trong React/Vue, hủy request cũ khi component unmount (dùng AbortController với Fetch, hay CancelToken với Axios) để tránh leak memory.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Web API (Lec 7)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **JSON (JavaScript Object Notation)**: Định dạng dữ liệu nhẹ, dùng để trao đổi dữ liệu giữa hệ thống. Cấu trúc dựa trên Object (key-value) và Array (danh sách có thứ tự). Không hỗ trợ kiểu dữ liệu Date, Function.
- **REST (Representational State Transfer)**: Tập hợp các nguyên tắc thiết kế Web API. API tuân thủ REST được gọi là RESTful.
- **Stateless (Không lưu trạng thái)**: Máy chủ không lưu trữ phiên làm việc của Client. Mỗi request phải chứa đủ thông tin định danh (ví dụ: JWT Token).
- **CRUD (Create, Read, Update, Delete)**: 4 thao tác cơ bản với dữ liệu, được ánh xạ trực tiếp vào các HTTP Method.

### Mental Model: Phân tách dữ liệu và giao diện
Hãy hình dung JSON là "ngôn ngữ chung" để hai hệ thống (Client và Server) trao đổi dữ liệu thô. REST là "quy tắc giao tiếp" để Client yêu cầu dữ liệu đó. Server chỉ làm nhiệm vụ cung cấp dữ liệu (Resource), Client tự quyết định cách hiển thị (UI).

---

## SECTION 2: DECISION TABLES

### Table 1: HTTP Method cho CRUD
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Tạo mới dữ liệu (không có ID sẵn) | **POST** | Dành cho tạo nguồn tài nguyên mới. Server tự sinh ID. | Dùng `GET` để tạo (vi phạm quy tắc an toàn của GET). |
| Đọc dữ liệu (chỉ lấy, không sửa) | **GET** | An toàn, có thể cache, không thay đổi dữ liệu server. | Dùng `POST` khi chỉ cần query dữ liệu. |
| Cập nhật **toàn bộ** resource | **PUT** | Thay thế hoàn toàn dữ liệu cũ bằng dữ liệu mới gửi lên. | Lạm dụng `PUT` cho update 1-2 field nhỏ. |
| Cập nhật **một phần** resource | **PATCH** | Chỉ sửa những trường gửi lên, giữ nguyên các trường khác. | Cập nhật thủ công từng field riêng lẻ không theo standard. |
| Xóa dữ liệu | **DELETE** | Xóa nguồn tài nguyên theo ID. | Dùng `GET` để xóa (dễ bị crawl công cụ tự động xóa dữ liệu). |

### Table 2: Xử lý JSON trong JavaScript
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Server gửi string JSON → JS Object | **`JSON.parse()`** | Để có thể truy cập thuộc tính (ví dụ: `data.user.name`). | Dùng trực tiếp chuỗi mà không parse. |
| JS Object → Gửi lên Server | **`JSON.stringify()`** | Chuẩn hóa dữ liệu thành định dạng JSON chuẩn để server hiểu. | Gửi object JS trực tiếp (có thể chứa function, undefined bị loại bỏ). |
| Xử lý dữ liệu rỗng/undefined | **Kiểm tra trước khi parse** | `JSON.stringify({x: undefined})` trả về `"{}"` (mất dữ liệu). | Truyền `undefined` vào stringify mà không kiểm tra. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Ánh xạ REST - Resource - Method
```text
[ Client ]发起请求 (Request)
      |
      v
[ REST API Layer ] (Quy tắc đặt tên + Method)
      |
      |--- Path (Resource): /users, /products/123
      |--- Method (Action): GET, POST, PUT, DELETE
      |
      v
[ Server ] xử lý logic & trả về (Response)
      |
      |--- Response Body: Dữ liệu JSON
      |--- Status Code: 200, 201, 404, 500
      |--- Headers: Content-Type: application/json
      v
[ Client ] nhận JSON → Parse → Hiển thị UI
```

### Cấu trúc JSON lồng nhau (Nested JSON)
JSON không phải là bảng phẳng, mà là cây.
```text
Object Root {
  "user": Object {
    "profile": Object {
      "city": "Hanoi" (Lấy: data.user.profile.city)
    },
    "orders": Array [
      0: Object { items: [ ... ] }
    ]
  }
}
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Chuẩn hóa API Resource Naming
**Khi nào dùng**: Luôn luôn khi thiết kế endpoint REST.
**Tại sao đúng**: Sử dụng danh từ (nouns) thay cho động từ (verbs) giúp API ngữ nghĩa rõ ràng, tuân thủ chuẩn REST.

```javascript
// BAD
GET /getUserById/123
POST /createUser
POST /login

// GOOD
GET /users/123          // Read
POST /users             // Create
GET /products?category=phone // Filter
DELETE /users/123       // Delete
```

### Pattern 2: Xử lý chu kỳ Request/Response JSON
**Khi nào dùng**: Khi gọi API từ Frontend (JS) về Backend (JSON).
**Tại sao đúng**: Luôn parse dữ liệu trước khi sử dụng và stringify trước khi gửi đi để đảm bảo dữ liệu nguyên dạng.

```javascript
// 1. Gửi dữ liệu lên (Client)
const userData = {
    name: "Alice",
    created: new Date() // JS Object
};

// Phải stringify để thành chuỗi JSON chuẩn
const payload = JSON.stringify(userData);

// Giả lập gọi API
fetch('/api/users', {
    method: 'POST',
    body: payload,
    headers: { 'Content-Type': 'application/json' }
});

// 2. Nhận dữ liệu từ Server (Client)
fetch('/api/users/1')
    .then(response => response.json()) // Parse JSON string thành Object
    .then(data => {
        // Đừng quên xử lý Date vì JSON gửi về dạng string
        data.created = new Date(data.created);
        console.log(data.name); // "Alice"
    });
```

### Pattern 3: Đọc dữ liệu lồng (Nested Access)
**Khi nào dùng**: Khi cấu trúc JSON phức tạp, nhiều cấp.
**Tại sao đúng**: Tránh lỗi "cannot read property of undefined" bằng cách kiểm tra rỗng hoặc dùng Optional Chaining (`?.`).

```javascript
const data = {
    orders: [
        { items: [{ price: 20 }, { price: 30 }] }
    ]
};

// BAD: Dễ bị lỗi nếu orders rỗng
// const price = data.orders[0].items[1].price;

// GOOD: An toàn (Optional Chaining)
const price = data.orders?.[0]?.items?.[1]?.price ?? 0;
console.log(price); // 30 hoặc 0 nếu không có dữ liệu
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Lồng Logic/Logic trong URL (Verb-based URLs)**
    *   **Ví dụ**: `/api/getAllUsers`, `/api/createOrder`.
    *   **Nguy hiểm**: Phá vỡ cấu trúc REST chuẩn, làm API khó maintain và không一致 (consistent).
2.  **Gửi `undefined` hoặc `Function` vào JSON**
    *   **Ví dụ**: `JSON.stringify({ a: undefined })`.
    *   **Nguy hiểm**: Dữ liệu bị mất lặng lẽ (`{}`), dẫn đến lỗi logic khó debug.
3.  **Dùng GET để xóa hoặc sửa dữ liệu**
    *   **Nguy hiểm**: Dễ bị tấn công CSRF hoặc bị các công cụ quét web (crawlers) tự động click xóa dữ liệu của người dùng.
4.  **Quên xử lý Date từ JSON**
    *   **Ví dụ**: `data.created` là string ISO, không phải Date Object.
    *   **Nguy hiểm**: Không thể dùng các hàm như `.getDate()`, `.getTime()` ngay lập tức.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **JSON là String khi truyền, Object khi dùng**: Luôn `parse()` và `stringify()` đúng chỗ.
2.  **Endpoint là danh từ**: `/users`, không phải `/getUsers`.
3.  **Method là hành động**: `GET` (xem), `POST` (tạo), `PUT/PATCH` (sửa), `DELETE` (xóa).
4.  **REST là Stateless**: Mỗi request tự đủ thông tin, server không nhớ trạng thái trước.
5.  **JSON không có Date**: Server gửi string, Client tự convert về Date.
6.  **JSON không có Comment**: Cần comment hãy dùng documentation khác.
7.  **Query Param để lọc**: `/users?role=admin`, không phải `/users/admin`.
8.  **Status Code**: 200 (OK), 201 (Created), 400 (Bad Request), 404 (Not Found), 500 (Server Error).
9.  **Hyphen trong URL**: Dùng `user-profiles` thay vì `userProfiles` hoặc `userprofiles`.
10. **Tránh Trailing Slash**: `https://api.com/users` (Tốt), `https://api.com/users/` (Tránh).

### If-Else Decision Logic
*   **If** (Bạn muốn lấy dữ liệu): **Use** `GET`.
*   **Else If** (Bạn muốn tạo dữ liệu mới): **Use** `POST`.
*   **Else If** (Bạn muốn thay đổi hoàn toàn dữ liệu cũ): **Use** `PUT`.
*   **Else If** (Bạn muốn thay đổi 1 phần dữ liệu): **Use** `PATCH`.
*   **Else If** (Bạn muốn xóa dữ liệu): **Use** `DELETE`.
*   **Else** (Trước khi gửi/nhận): **Use** `JSON.stringify()` / `JSON.parse()`.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE - Web API (Lecture 7)

## SECTION 1: CORE MENTAL MODEL

### 1.1. Resource Identification vs Filtering

**Path Parameter (Tham số đường dẫn)**
- Dùng để **định danh (identify)** một tài nguyên cụ thể.
- Ví dụ: `/users/10`, `/orders/A001/items/5`.
- **Quy tắc:** Thứ tự các segment trong URL là quan trọng.

**Query Parameter (Tham số truy vấn)**
- Dùng để **lọc (filter), sắp xếp (sort), phân trang (paginate)** dữ liệu.
- Ví dụ: `/products?category=phone`, `/posts?sort=desc&page=2`.
- **Quy tắc:** Thứ tự các tham số không quan trọng.

```javascript
// ✅ ĐÚNG: Path dùng để định danh
GET /api/v1/users/12345

// ✅ ĐÚNG: Query dùng để lọc/sắp xếp
GET /api/v1/users?role=admin&sort=created_at:desc

// ❌ SAI: Không dùng Path để filter
GET /api/v1/users/admin  // Confusing: admin là ID hay Role?
```

### 1.2. Gateway (Cổng thông tin)

**Gateway (Nginx, AWS API Gateway)**
- Lớp trung gian thông minh đứng trước Server.
- **Trách nhiệm:** Bảo vệ Backend, lọc request, định tuyến traffic, xử lý lỗi, load balancing.

### 1.3. CORS (Cross-Origin Resource Sharing)

**CORS (Chia sẻ nguồn gốc chéo)**
- Cơ chế bảo mật của trình duyệt ngăn việc gọi API giữa các nguồn (Origin) khác nhau.
- **Origin = Protocol + Domain + Port**.

**Phân loại Request:**

1.  **Simple Request (Đơn giản):** Trình duyệt gửi ngay.
    - Method: `GET`, `POST`, `HEAD`.
    - Header: Chỉ được dùng các header cơ bản (`Accept`, `Content-Type`...).
    - `Content-Type`: Chỉ `text/plain`, `multipart/form-data`, `application/x-www-form-urlencoded`.

2.  **Non-Simple Request (Phức tạp):** Trình duyệt gửi **Preflight (OPTIONS)** trước.
    - Method: `PUT`, `DELETE`, `PATCH`.
    - Header: Có custom header (ví dụ: `Authorization`).
    - `Content-Type`: `application/json`.

```javascript
// Flow CORS cho Non-Simple Request (DELETE)

// B1: Browser gửi OPTIONS (Preflight)
OPTIONS /api/users/123 HTTP/1.1
Origin: https://app.com
Access-Control-Request-Method: DELETE

// B2: Server trả lời cho phép (Phải cấu hình ở Gateway/Server)
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.com
Access-Control-Allow-Methods: GET, POST, DELETE, PUT
Access-Control-Allow-Headers: Content-Type, Authorization

// B3: Browser mới gửi Request thật
DELETE /api/users/123 HTTP/1.1
Origin: https://app.com
```

### 1.4. Fetch API

**Fetch API**
- Giao diện hiện đại để lấy tài nguyên (thay thế `XMLHttpRequest`).
- **Ưu điểm:** Dựa trên Promise, xử lý JSON tốt, giao diện rõ ràng.
- **Nhược điểm:** Không tự động xử lý lỗi HTTP (4xx, 5xx), không có cơ chế timeout sẵn, xử lý Cookie thủ công.

```javascript
// Fetch API - Xử lý lỗi thủ công
async function getUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);

    // ⚠️ Fetch KHÔNG ném lỗi cho HTTP 4xx/5xx
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Lỗi kết nối hoặc xử lý:", error);
  }
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Path Parameter vs Query Parameter

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Lấy thông tin 1 tài nguyên cụ thể**<br>Ví dụ: Láy thông tin user có ID=5 | **Path Parameter**<br>`/users/5` | **Identifier (Định danh):** URL mô tả chính xác tài nguyên đích. | Dùng Query: `/users?id=5` (Thừa thãi, không RESTful). |
| **Lọc danh sách dữ liệu**<br>Ví dụ: Lấy sản phẩm thuộc loại "Phone" | **Query Parameter**<br>`/products?category=phone` | **Filtering (Lọc):** Thay đổi tập kết quả, không định danh tài nguyên. | Dùng Path: `/products/category/phone` (Đây là một resource hierarchy, không phải filter). |
| **Phân trang & Sắp xếp**<br>Ví dụ: Lấy trang 2, giảm dần | **Query Parameter**<br>`/posts?page=2&sort=desc` | **Sorting/Pagination:** Đây là metadata đi kèm yêu cầu, không phải chính tài nguyên. | Dùng Path: `/posts/page/2/desc` (Cứng nhắc, khó mở rộng). |

### Table 2: HTTP Status Codes (Phân loại)

| Tình huống | Phân loại | Mã lỗi nên dùng |
| :--- | :--- | :--- |
| Yêu cầu thành công & có dữ liệu trả về | **2xx Success** | `200 OK` |
| Tạo mới tài nguyên thành công | **2xx Success** | `201 Created` |
| Xóa thành công (không có dữ liệu trả về) | **2xx Success** | `204 No Content` |
| Dữ liệu gửi lên sai định dạng (JSON lỗi, thiếu trường) | **4xx Client Error** | `400 Bad Request` |
| Chưa đăng nhập (Missing/Invalid Token) | **4xx Client Error** | `401 Unauthorized` |
| Đăng nhập rồi nhưng không có quyền truy cập resource | **4xx Client Error** | `403 Forbidden` |
| Yêu cầu đúng nhưng tài nguyên không tồn tại | **4xx Client Error** | `404 Not Found` |
| Lỗi code/backend (Exception, DB lỗi) | **5xx Server Error** | `500 Internal Server Error` |
| Server quá tải, không xử lý kịp | **5xx Server Error** | `503 Service Unavailable` |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow: Browser -> Gateway -> Server -> Database

```text
[Client Browser] 
      | (Gửi Request)
      v
[Gateway (Nginx/AWS)]
      | 1. Kiểm tra CORS
      | 2. Lọc tấn công
      | 3. Chặn IP bad
      | 4. Load Balance
      v
[Web Server (Node/Python/Java)]
      | 1. Parse Request (Path/Query/Header)
      | 2. Xác thực (Auth)
      | 3. Xử lý logic
      v
[Database]
      ^
      | (Trả dữ liệu)
      v
[Web Server]
      | (Format JSON)
      v
[Gateway]
      | (Gửi CORS headers nếu cần)
      v
[Client Browser]
```

### Quan hệ Fetch API & Promise

```text
Fetch API (Native Browser)
    |
    +--> Promise (Vowed to return data eventually)
        |
        +--> .then() : Xử lý Response thành công (HTTP 200-299)
        +--> .catch() : Xử lý lỗi kết nối mạng (Network Error)
        +--> response.ok : **PHẢI kiểm tra manually** để bắt lỗi HTTP 4xx/5xx
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Clean Fetch Wrapper (Production Ready)

**Khi nào dùng:** Khi cần gọi API trong dự án thật, thay vì dùng Fetch "đơn lẻ".
**Tại sao:** Handle统一 lỗi (HTTP + Network), xử lý JSON tự động, dễ maintain.

```javascript
// utils/api.js

async function apiClient(endpoint, options = {}) {
  const defaultHeaders = {
    'Content-Type': 'application/json',
    // Thêm token nếu cần: 'Authorization': `Bearer ${token}`
  };

  const config = {
    method: 'GET', // Mặc định
    headers: { ...defaultHeaders, ...options.headers },
    ...options,
  };

  try {
    const response = await fetch(endpoint, config);

    // 1. Xử lý lỗi HTTP (4xx, 5xx)
    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({ message: response.statusText }));
      throw new Error(`HTTP ${response.status}: ${errorBody.message || 'Unknown Error'}`);
    }

    // 2. Xử lý 204 No Content
    if (response.status === 204) return null;

    // 3. Parse JSON thành công
    return await response.json();
  } catch (error) {
    // 4. Catch lỗi mạng hoặc lỗi từ bước 1
    console.error('API Call Failed:', error.message);
    throw error; // Ném lỗi ra ngoài để Component xử lý UI
  }
}

// Sử dụng
async function loadUserData() {
  try {
    const user = await apiClient('/api/users/1', { method: 'GET' });
    console.log('User:', user);
  } catch (err) {
    // Hiển thị toast error cho user
  }
}
```

### Pattern 2: Preflight Handling (Non-Simple Request)

**Khi nào dùng:** Khi Frontend gọi `DELETE`, `PUT`, hoặc gửi Header `Authorization`.
**Tại sao:** Tránh lỗi CORS block trên trình duyệt. Logic nằm ở Server/Gateway.

```javascript
// Server-side config (Node.js Express example)

const cors = require('cors');

const corsOptions = {
  origin: 'https://my-frontend-app.com', // Chỉ cho phép domain này
  methods: ['GET', 'POST', 'PUT', 'DELETE'], // Các method được phép
  allowedHeaders: ['Content-Type', 'Authorization'], // Các header được phép
};

app.use(cors(corsOptions));

// Khi client gọi DELETE /api/users/123
// Server tự động trả lời OPTIONS với headers bên trên trước khi xử lý DELETE thật.
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Lạm dụng Path Parameter cho Filtering
- **Code sai:** `GET /products/category/electronics/brand/apple`
- **Tại sao sai:** Khó khăn cho việc kết hợp nhiều filters (ví dụ: điện thoại apple giá < 10tr). URL trở nên phức tạp.
- **Cách đúng:** `GET /products?category=electronics&brand=apple&price_lt=10000000`.

### 2. Quên kiểm tra `response.ok` trong Fetch
- **Code sai:** `fetch(...).then(res => res.json())`
- **Tại sao sai:** Fetch chỉ reject Promise khi lỗi mạng (DNS fail, Offline). Nếu Server trả về `404 Not Found` hoặc `500 Server Error`, Promise vẫn resolve (thành công).
- **Hậu quả:** Code sẽ cố gắng parse JSON từ trang lỗi, gây crash ứng dụng.
- **Cách đúng:** Luôn kiểm tra `if (!response.ok) throw new Error(...)`.

### 3. Trả về dữ liệu rác cho `204 No Content`
- **Code sai:** `res.status(204).json({ success: true })`
- **Tại sao sai:** Theo quy chuẩn HTTP, `204` là **No Content**. Trình duyệt hoặc Client library có thể treo hoặc报错 khi đợi body rỗng nhưng lại nhận JSON.
- **Cách đúng:** `res.status(204).end()` (hoặc trả về null/undefined).

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Quick Rules
1.  **Path:** Dùng để **Identify** (`/users/1`).
2.  **Query:** Dùng để **Filter/Sort/Paginate** (`/users?search=john`).
3.  **200:** OK & Có data.
4.  **201:** Created.
5.  **204:** Xóa thành công, không trả data.
6.  **400:** Client sai (Data invalid).
7.  **401:** Chưa login.
8.  **403:** Login rồi nhưng không đủ quyền.
9.  **404:** Resource không tồn tại.
10. **Fetch:** Luôn check `if (!response.ok)`.

### Decision Logic (If-Else)
- **If** resource ID is required -> **Use Path Param** (`/api/resource/{id}`).
- **If** refining a list -> **Use Query Param** (`/api/resource?type=A`).
- **If** response has data -> **Use 200 OK**.
- **If** created new -> **Use 201 Created**.
- **If** no content needed -> **Use 204**.
- **If** input is wrong -> **Use 400**.
- **If** not authorized -> **Use 401**.
- **If** forbidden -> **Use 403**.
- **If** resource gone -> **Use 404**.
- **If** server crash -> **Use 500**.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Web API (Lec 7)

## SECTION 1: CORE MENTAL MODEL

### Fetch API & Async/Await
**Fetch API**: Trình duyệt API thực hiện HTTP requests. Hoạt động bất đồng bộ (Asynchronous), trả về một Promise.

**Async/Await**: Syntax sugar cho Promise, cho phép viết code bất đồng bộ trông như đồng bộ.
- `async`: Khai báo hàm bất đồng bộ.
- `await`: Tạm dừng hàm直到 Promise hoàn thành (settled).

**Response Handling Workflow**:
1. `fetch()`: Trả về Promise Resolve thành `Response` object (dù HTTP lỗi 404 hay 500).
2. `response.json()`: Đọc body, parse JSON → Trả về Promise Resolve thành Object.

```javascript
// Workflow chuẩn: Hai bước bắt buộc
async function getData() {
  try {
    // Bước 1: Gọi API
    const response = await fetch('https://api.example.com/data');
    
    // Bước 2: Kiểm tra trạng thái (Bắt buộc vì fetch KHÔNG tự reject lỗi HTTP)
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}`);
    }

    // Bước 3: Parse dữ liệu
    const data = await response.json(); 
    console.log(data);
  } catch (error) {
    console.error("Lỗi kết nối hoặc parse:", error);
  }
}
```

---

## SECTION 2: DECISION TABLES

### Table 1: Fetch (Native) vs Axios
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **App nhỏ, không cần thư viện** | **Fetch API** | Native, không cần cài đặt. nhưng phải tự xử lý lỗi HTTP & parse JSON. | Quên kiểm tra `response.ok` → Lỗi bị nuốt khi server trả về 404/500. |
| **App lớn, cần xử lý lỗi tập trung** | **Axios** | **Automatic Error Handling**: Tự reject Promise nếu HTTP lỗi (4xx/5xx). Dễ config Timeout/Interceptor. | Dùng `try/catch` quá mức cần thiết cho lỗi HTTP khi dùng Axios (Axios đã xử lý giúp). |
| **Cần Cancel request** | **Cả 2** | Fetch dùng `AbortController`, Axios dùng `CancelToken` (hoặc signal). | Để request chạy hoài khi người dùng đóng component → Nghiêm trọng trên SPA. |

### Table 2: Xử lý dữ liệu Response
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Server trả về JSON** | `await response.json()` | Tự động parse string → Object. | Gọi `response.json()` 2 lần → Lỗi "Body already consumed". |
| **Server trả về Text/HTML** | `await response.text()` | Đọc nguyên chuỗi ký tự. | Cố parse text bằng `json()` → Crash. |
| **Server trả về File/Blob** | `await response.blob()` | Dùng cho file lớn, image download. | Lưu Blob vào state mà không revoke URL → Rò rỉ bộ nhớ. |

### Table 3: Timeout & Cancellation Logic
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cần hủy request cũ khi gọi mới** | **AbortController** (Native) | Tiết kiệm bandwidth, tránh race condition (data cũ về sau ghi đè data mới). | Không hủy request khi component unmount → Gọi API trên component đã bị xóa (memory leak). |
| **Cần xử lý Timeout đơn giản** | **Axios** (Config `timeout`) | Code ngắn gọn, không cần wrapper Promise. | Setting timeout quá ngắn (< 1s) → Gây lỗi fake cho người dùng mạng yếu. |
| **Native Fetch + Timeout** | `Promise.race()` | Bắt buộc dùng wrapper nếu không dùng thư viện. | Viết sai thứ tự Promise → Timeout không hoạt động. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow: Request Lifecycle
```text
[ Application Code ]
       |
       v
[ Async Function (async/await) ]
       |
       +---------------------------+
       |                           |
       v                           v
 [ Native Fetch (Promise) ]   [ Axios (Promise) ]
       |                           |
       v                           v
 [ Network Layer (Browser) ] [ Network Layer (Browser) ]
       |                           |
       v                           v
 [ Server Response ]           [ Server Response ]
       |                           |
       v                           v
 [ Check status.ok? ]          [ Auto Check (Reject if !2xx) ]
       |                           |
       v                           v
 [ Parse JSON (.json()) ]      [ Auto Parse (res.data) ]
       |                           |
       v                           v
 [ Try/Catch Block ]           [ Try/Catch Block ]
```

### Component Hierarchy
1. **Logic Layer**: Xác định URL, Params.
2. **Transport Layer**: `fetch()` hoặc `axios()`.
3. **Safety Layer**: `AbortController` (timeout/cancel) + `status check`.
4. **Data Layer**: Parse JSON.

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Native Fetch with Timeout (Promise.race)
**Khi nào dùng**: Khi bạn không muốn dùng thư viện ngoài (Axios) nhưng cần đảm bảo request không chạy vô định.

**Tại sao đúng**: Native `fetch` không có timeout, `Promise.race` sẽ hủy logic nếu fetch quá lâu.

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  // Tạo promise timeout
  const timeoutPromise = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Request Timeout')), timeout)
  );

  try {
    // Chạy đua giữa fetch và timeout
    const response = await Promise.race([
      fetch(url),
      timeoutPromise
    ]);

    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  } catch (error) {
    console.error("Failed:", error.message);
    // Xử lý lỗi ở đây
  }
}
```

### Pattern 2: Request Cancellation (AbortController)
**Khi nào dùng**: Khi người dùng search thực liên tục (typeahead) hoặc rời khỏi trang.

**Tại sao đúng**: Tránh race condition và tiết kiệm tài nguyên server.

```javascript
class ApiClient {
  constructor() {
    this.controller = null; // Lưu controller cũ
  }

  async get(endpoint) {
    // 1. Hủy request cũ nếu đang chạy
    if (this.controller) {
      this.controller.abort();
    }

    // 2. Tạo controller mới
    this.controller = new AbortController();

    try {
      const response = await fetch(endpoint, {
        signal: this.controller.signal // Gắn signal vào fetch
      });

      if (!response.ok) throw new Error('Failed');
      return await response.json();
    } catch (error) {
      // Bắt lỗi abort riêng (không phải lỗi hệ thống)
      if (error.name === 'AbortError') {
        console.log('Request canceled');
        return; // Không làm gì cả, request cũ bị hủy
      }
      throw error; // Vứt lỗi khác ra ngoài
    }
  }
}
```

### Pattern 3: Axios Standard Usage
**Khi nào dùng**: Khi cần code sạch, xử lý lỗi tự động, không cần write wrapper quá nhiều.

**Tại sao đúng**: Giảm boilerplate code xử lý JSON và status check.

```javascript
// Cài đặt trước: npm install axios
import axios from 'axios';

async function postData() {
  try {
    // Axios tự parse JSON, tự reject nếu status 400-599
    const response = await axios.post('https://api.example.com/posts', {
      title: 'Foo',
      body: 'Bar'
    }, {
      timeout: 5000 // Tự động hủy nếu quá 5s
    });

    console.log(response.data); // Dữ liệu đã parse sẵn
  } catch (error) {
    // Xử lý lỗi tập trung
    if (error.code === 'ECONNABORTED') {
      console.error('Quá thời gian kết nối');
    } else if (error.response) {
      // Lỗi từ server (4xx, 5xx)
      console.error(`Server Error: ${error.response.status}`);
    } else {
      // Lỗi mạng hoặc cấu hình
      console.error('Network Error:', error.message);
    }
  }
}
```

### Pattern 4: Custom Headers & Auth
**Khi nào dùng**: Khi cần đăng nhập, gửi token, hoặc thay đổi Content-Type.

**Tại sao đúng**: Phải cấu hình header trực tiếp trong object fetch/axios.

```javascript
async function fetchSecureData(token) {
  // Headers object
  const headers = new Headers({
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}` // Bearer Token Pattern
  });

  const response = await fetch('https://api.example.com/protected', {
    method: 'GET',
    headers: headers 
  });

  if (response.status === 401) {
    // Token hết hạn -> Redirect login
    window.location.href = '/login';
    return;
  }

  return await response.json();
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Fire and Forget" (Không xử lý lỗi)
**Hành vi**: Gọi `fetch()` nhưng không dùng `await`, không `.catch()`, không kiểm tra `response.ok`.
**Tại sao nguy hiểm**: Lỗi mạng hoặc lỗi server (404, 500) sẽ không được bắt, UI bị treo hoặc crash không báo trước.

### 2. Double Consume Response
**Hành vi**: Gọi `await response.json()` rồi sau đó gọi `response.text()` hoặc gọi `json()` 2 lần trên cùng 1 response.
**Tại sao nguy hiểm**: Response body là stream chỉ đọc được 1 lần. Lỗi "Failed to execute 'json' on 'Response': body stream already read".

### 3. Async Void (Hàm async không xử lý promise)
**Hành vi**: Khai báo `async function()` nhưng không `await` kết quả bên trong hoặc không return Promise.
**Tại sao nguy hiểm**: Lỗi bị nuốt (swallowed errors), trình duyệt không báo lỗi gì cả, debug cực khó.

### 4. Bỏ qua CORS & Preflight
**Hành vi**: Gửi request có custom header (như `Authorization`) nhưng server không cho phép CORS.
**Tại sao nguy hiểm**: Request bị chặn bởi trình duyệt ngay lập tức (Network Error), không thể gọi API được. Cần server config `Access-Control-Allow-Origin` và `Access-Control-Allow-Headers`.

### 5. Dùng Promise.race sai cách
**Hành vi**: Để Timeout Promise resolve trước, nhưng không hủy fetch request.
**Tại sao nguy hiểm**: Fetch request vẫn chạy nền (background) ăn băng thông và có thể update UI sau khi đã timeout (race condition).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules Logic (If-Else)

**1. Chọn Fetch hay Axios?**
- `IF` App nhỏ / Не có thư viện: **Fetch**.
- `ELSE` App lớn / Cần auto error handling: **Axios**.

**2. Xử lý lỗi Response:**
- `IF` Dùng Fetch: **LUÔN** check `if (!response.ok) throw ...`.
- `ELSE` Dùng Axios: **Không cần check**, dùng `.catch()`.

**3. Timeout:**
- `IF` Dùng Axios: Set `timeout: 5000`.
- `ELSE` Dùng Fetch: Wrap với `Promise.race` hoặc `AbortController`.

**4. Cancel Request:**
- `IF` Có thể hủy (tim搜索,离开 trang): **Dùng AbortController**.
- `IF` Bị lỗi timeout: **AbortController** (ném AbortError).

### Top 5 Things to Remember
1.  **Fetch response ok**: Luôn kiểm tra `response.ok` nếu dùng native fetch.
2.  **JSON Parse**: `response.json()` là Promise, cần `await`.
3.  **Header**: `Authorization: Bearer <token>` là chuẩn.
4.  **Abort**: Dùng `AbortController` để stop request cũ trước khi gọi mới.
5.  **Axios Error**: `error.response` chứa thông tin lỗi server (status, data).

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Web API (Axios & Fetch)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Axios (Thư viện HTTP Client)**: Thư viện JavaScript xây dựng trên XMLHttpRequest, hỗ trợ promise, cung cấp tính năng nâng cao như interceptors, timeout, và xử lý lỗi tự động.
- **Fetch API (Giao diện Lấy dữ liệu)**: API bản địa của trình duyệt để thực hiện các request mạng, sử dụng cơ chế Promise, yêu cầu xử lý lỗi thủ công.
- **Interceptors (Bộ chặn)**: Các hàm được tự động gọi trước khi request được gửi đi (request interceptor) hoặc trước khi response được xử lý (response interceptor).
- **AbortController (Bộ điều khiển hủy)**: Cơ chế để hủy các request mạng đang thực thi, giúp tránh race conditions và tiết kiệm tài nguyên.

### Mental Model: The Layer of Abstraction
- **Fetch**: Là "vùng đất hoang sơ". Bạn phải tự mình dựng lều (parse JSON), tự canh chừng thú dữ (check `res.ok`), và tự đun nước (thiết lập timeout). Phù hợp cho chuyến đi ngắn, hành trang nhẹ.
- **Axios**: Là "khách sạn 5 sao". Mọi thứ đã được chuẩn bị sẵn: đầu bếp (interceptors) xử lý nguyên liệu trước khi nấu, nhân viên tiếp tân (error handling) báo lỗi ngay lập tức khi có sự cố, và bạn không phải lo lắng về việc nước sôi (timeout). Phù hợp cho định cư lâu dài, quy mô lớn.

### Why Axios is Better for Complex Apps?
Axios giúp bạn viết code clean hơn bằng cách:
1. **Centralized Logic**: Xử lý lỗi và token xác thực tập trung tại một nơi (Interceptors) thay vì lặp lại trong mọi API call.
2. **Developer Experience**: Cú pháp đơn giản (`res.data`) và tự động chuyển đổi JSON.
3. **Reliability**: Xử lý lỗi chuẩn xác (coi 4xx/5xx là lỗi) thay vì Fetch coi mọi thứ là thành công trừ khi network fail.

---

## SECTION 2: DECISION TABLES

### Axios vs Fetch: Khi nào chọn?

| Tình huống sử dụng (Use case) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Ứng dụng quy mô lớn (SPAs, Enterprise)** | **Axios** | Cần **Interceptors** để xử lý JWT tokens tập trung và **Global Error Handling** (một nơi bắt lỗi 401, 500). | Dùng Fetch rồi copy-paste logic check token và bắt lỗi vào mọi component -> Dễ bỏ sót, khó bảo trì. |
| **Dự án nhỏ, không cần dependencies** | **Fetch** | Native API, không cần cài đặt (Zero dependencies), giảm kích thước bundle. | Cài đặt Axios cho việc gọi 1 API đơn giản -> Tăng dung lượng bundle không cần thiết. |
| **Cần xử lý lỗi chi tiết theo HTTP status** | **Axios** | Tự động ném lỗi khi nhận **Non-2xx** (400, 404, 500). Truy cập dễ qua `error.response.status`. | Dùng Fetch phải viết `if (!res.ok)` thủ công cho mọi request. Quên check là UI không báo lỗi. |
| **Cần chế độ Timeout (Hết giờ)** | **Axios** | Có sẵn thuộc tính `timeout` trong config. | Dùng Fetch phải dùng `AbortController` kết hợp `setTimeout` -> Code rườm rà. |
| **Chỉ gọi API đơn giản (GET)** | **Fetch** | Cú pháp gốc (`fetch().then().catch())`足够 mạnh và dễ hiểu. | Vòng vo unnecessarily引入 thư viện bên ngoài. |

### Kỹ thuật xử lý Request

| Tình huống | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cần hủy request đang chạy** | **AbortController** | Tiêu chuẩn mới (Works with both Fetch and Axios). Tránh race conditions (req cũ trả về sau req mới). | Để mặc request chạy ngầm, gây trôi data hoặc tốn tài nguyên CPU/Mạng. |
| **Inject Token (Bearer)** | **Axios Request Interceptor** | Xử lý ở layer thấp nhất, không cần can thiệp vào từng function gọi API. | Truyền header thủ công từng lần gọi API -> Rất dễ leak token hoặc quên truyền. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flowchart: So sánh luồng xử lý lỗi

```text
[START API CALL]
      |
      v
+-------------------+       +-----------------------+
|      AXIOS        |       |         FETCH         |
+-------------------+       +-----------------------+
|                   |       |                       |
| 1. Gửi Request    |       | 1. Gửi Request        |
|                   |       |                       |
| 2. Nhận Response  |       | 2. Nhận Response      |
|    (Dù status là) |       |    (Luôn thành công*) |
|    400, 404, 500  |       |    Trừ lỗi Network   |
|                   |       |                       |
| 3. TỰ ĐỘNG VÀO    |       | 3. PHẢI KIỂM TRA     |
|    .catch()       |       |    if (!res.ok)       |
|    (Error Object) |       |       throw Error    |
|                   |       |                       |
| 4. Parse JSON     |       | 4. Parse JSON (Manual)|
|    Tự động        |       |    res.json()         |
+-------------------+       +-----------------------+
```
*Note: `fetch` coi HTTP 404/500 là thành công ở bước 2, bạn phải kiểm tra thuộc tính `res.ok`.

### Cấu hình Instance (Reusable Logic)

```text
       [api.js] - Tạo Instance chung
            |
            | Axios Instance:
            | - baseURL: '/api/v1'
            | - timeout: 5000
            | - Headers: { Content-Type }
            |
            v
    [Request Interceptor]
            |
            | (Thêm token vào header)
            v
    [API Function]
            |
            v
[Response Interceptor]
            |
            | (Bắt lỗi 401, Refresh Token)
            v
   [Component UI]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Axios Instance + Interceptors (Global Auth & Error)
**Khi nào dùng:** Luôn dùng cho project có API xác thực (JWT) và cần xử lý lỗi tập trung (VD:跳出 Login khi 401).

**Tại sao đúng:** Code UI sạch sẽ, không cần try-catch lặp lại. Logic refresh token nằm ở một nơi.

```javascript
// api.js
import axios from 'axios';

// 1. Create Instance
const apiClient = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 5000,
  headers: { 'Content-Type': 'application/json' }
});

// 2. Request Interceptor (Inject Token)
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 3. Response Interceptor (Global Error Handling)
apiClient.interceptors.response.use(
  (response) => response, // Thành công thì trả về như bình thường
  (error) => {
    // Bắt lỗi 401 (Unauthorized)
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/login';
    }
    // Chuẩn hóa lỗi để component dễ xử lý
    return Promise.reject({
      message: error.response?.data?.message || 'Có lỗi xảy ra',
      status: error.response?.status
    });
  }
);

export default apiClient;
```

### Pattern 2: Fetch with AbortController
**Khi nào dùng:** Khi người dùng navigate sang trang khác hoặc nhập liệu nhanh (search debounce), cần hủy request cũ.

**Tại sao đúng:** Tránh race condition và tối ưu performance.

```javascript
// Component React hoặc JS thuần
const controller = new AbortController();

try {
  const response = await fetch('https://api.example.com/data', {
    signal: controller.signal // Gắn signal vào request
  });

  if (!response.ok) throw new Error('Network response was not ok');

  const data = await response.json();
  console.log(data);
} catch (err) {
  if (err.name === 'AbortError') {
    console.log('Request đã bị hủy');
  } else {
    console.error('Lỗi:', err);
  }
}

// Hàm hủy (gọi khi component unmount hoặc user nhập ký tự mới)
// controller.abort();
```

### Pattern 3: Axios với Timeout & Cancel
**Khi nào dùng:** Khi cần đảm bảo request không treo vĩnh viễn, hoặc người dùng muốn tự tay hủy request đang chạy.

**Tại sao đúng:** Axios có `CancelToken` (cũ) hoặc dùng chung `AbortController` (mới).

```javascript
import axios from 'axios';

const controller = new AbortController();

try {
  const response = await axios.get('https://api.example.com/slow-data', {
    timeout: 5000, // Tự động hủy nếu quá 5s
    signal: controller.signal // Hủy bởi người dùng
  });
  console.log(response.data);
} catch (err) {
  if (axios.isCancel(err)) {
    console.log('Request bị hủy bởi người dùng');
  } else if (err.code === 'ECONNABORTED') {
    console.log('Hết giờ (Timeout)');
  } else {
    console.log('Lỗi kết nối');
  }
}

// Hủy thủ công: controller.abort();
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Fetch: Quên kiểm tra `res.ok`
**Tại sao nguy hiểm:** `fetch` không reject Promise khi HTTP trả về 404 hoặc 500. Code của bạn sẽ chạy tiếp với dữ liệu rác hoặc crash khi parse JSON.
```javascript
// SAI
fetch('/api/data')
  .then(res => res.json()) // Nếu res là 404, res.json() sẽ fail schwer
  .then(data => console.log(data));

// ĐÚNG
fetch('/api/data')
  .then(res => {
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  });
```

### 2. Axios trong React: Gọi API trực tiếp trong Component
**Tại sao nguy hiểm:** Logic API lẫn lộn với UI. Khón tái sử dụng. Khó test.
**Giải pháp:** Tách riêng file `api.js` (Instance pattern ở trên).

### 3. Lạm dụng Interceptors quá mức
**Tại sao nguy hiểm:** Interceptors chạy "âm thầm". Nếu code trong interceptor sai, nó phá hỏng mọi request trong app mà bạn không biết lỗi ở đâu.
**Giải pháp:** Viết interceptor thật ngắn gọn, chỉ xử lý việc通用 nhất (Auth, Logger), không xử lý business logic.

### 4. Không xử lý Race Condition
**Tại sao nguy hiểm:** Khi user click nút "Save" 2 lần, nhận được 2 responses. Response nào về sau có thể ghi đè kết quả đúng.
**Giải pháp:** Luôn dùng `AbortController` hủy request cũ trước khi gửi request mới.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Mới bắt đầu / Dự án nhẹ**: Dùng **Fetch** (không cần cài đặt).
2. **App lớn / Cần Auth**: Dùng **Axios Instance** + **Interceptors**.
3. **Lỗi 404/500**: Axios tự bắt, Fetch phải check `res.ok`.
4. **Parse JSON**: Axios auto, Fetch phải gọi `res.json()`.
5. **Hủy Request**: Dùng `AbortController` (Tiêu chuẩn mới).

### Decision Logic (If-Else)
```text
IF (Project là Single Page App lớn) 
   -> USE: Axios Instance
ELSE IF (Cần validate Token tự động)
   -> USE: Axios Request Interceptor
ELSE IF (Cần xử lý lỗi 401/500 tập trung)
   -> USE: Axios Response Interceptor
ELSE IF (Dự án nhỏ, không muốn cài thêm thư viện)
   -> USE: Fetch API
ELSE IF (Cần hủy request khi navigate)
   -> USE: AbortController với Fetch/Axios
```

### Top 5 Things to Remember
1. **Axios** là wrapper của XMLHttpRequest, **Fetch** là native.
2. `axios.get(url, { data })` vs `fetch(url, { body })`.
3. **Error**: `err.response` (Axios) vs `if (!res.ok)` (Fetch).
4. **JSON**: `res.data` (Axios) vs `res.json()` (Fetch).
5. **Security**: Luôn validate dữ liệu trả về từ API (không tin tuyệt đối response dù dùng Axios hay Fetch).

<!-- CHUNK 51-57 -->

# DEVELOPER DECISION GUIDE: Web API & Asynchronous Patterns (Lec 7)

---

## SECTION 1: CORE MENTAL MODEL

### 1.1. Retry Pattern (Mẫu Thử Lại)
**Definition:** Mechanism tự động thử lại request khi gặp lỗi tạm thời.

**Mental Model:** Khi server báo "bận" (503) hoặc "chậm lại" (429), client không bỏ cuộc ngay mà đợi một khoảng thời gian rồi thử lại.

**Why it's better:** Prevents immediate failure, improves user experience, handles temporary server overload gracefully.

### 1.2. Async/Await (Đồng bộ hóa bất đồng bộ)
**Definition:** `async` biến hàm thành Promise, `await` dừng execution cho đến khi Promise hoàn thành.

**Mental Model:** Giống như việc đặt hàng và đợi shipper giao hàng. `await` là "đứng đợi" cho đến khi hàng về.

**Why it's better:** Code đọc như đồng bộ (sequential) nhưng thực thi bất đồng bộ (non-blocking), dễ debug hơn `.then()` chain.

### 1.3. Promise.all vs Promise.allSettled
**Promise.all:** "Tất cả hoặc không gì cả".
**Promise.allSettled:** "Làm hết sức, nhận kết quả từng cái".

**Why it's better:** `Promise.all` tiết kiệm thời gian khi cần thành công hết. `Promise.allSettled` an toàn khi một phần thất bại không ảnh hưởng phần còn lại.

---

## SECTION 2: DECISION TABLES

### Table 1: Retry Decision (When to Retry?)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Server trả về 503 (Service Unavailable) | **Retry Pattern** | Server đang overload/restart, request sau có thể thành công | Retry infinite loop không có limit |
| Server trả về 429 (Too Many Requests) | **Retry Pattern + Exponential Backoff** | Hit rate limit, cần chậm lại | Retry ngay lập tức làm server chết hoàn toàn |
| Server trả về 404 (Not Found) | **NO Retry** | Resource không tồn tại, retry vô ích | Mất thời gian và tài nguyên vô cớ |
| Request timeout | **Retry ( giới hạn 1-2 lần)** | Có thể do network lag tạm thời | Retry quá nhiều gây treo application |
| Lỗi 4xx (Bad Request, 401, 403) | **NO Retry** | Lỗi ở client, cần sửa code/data | Vô ích, server không thay đổi response |

### Table 2: Promise Handling

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Cần load 2 API độc lập để render UI | **Promise.all()** | Chạy song song, tiết kiệm thời gian (Total = slowest request) | Dùng await từng cái một, làm UI load chậm hơn cần thiết |
| Một API fail không được load phần còn lại | **Promise.all()** | Fail-fast: phát hiện lỗi sớm | Dùng Promise.allSettled sẽ che lỗi, không xử lý kịp |
| Cần load data từ nhiều sources, không quan trọng source nào fail | **Promise.allSettled()** | Đảm bảo không crash app vì 1 API fail | Dùng Promise.all sẽ crash cả app nếu 1 API lỗi |
| Kiểm tra quyền trước khi load data | **Sequential (await từng cái)** | Phải có kết quả A rồi mới gọi B | Dùng Promise.all sẽ không đảm bảo thứ tự logic |
| Xử lý 100 requests đồng thời | **Promise.allSettled()** | Xử lý partial failure, log lỗi từng cái | Dùng Promise.all sẽ fail cả batch nếu 1 cái lỗi |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Async Flow Hierarchy

```text
[User Event] (Click Button)
      ↓
[Async Function] (fetchData)
      ↓
[Promise] (Object representing future value)
      ↓
┌─────────────────────────────────────────┐
│   DECISION POINT: Error Handling        │
│   - Retry? (503, 429)                   │
│   - Fail immediately? (4xx, 5xx)        │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│   EXECUTION STRATEGY                    │
│   ┌──────────────┬──────────────────┐   │
│   │ Parallel     │ Sequential       │   │
│   │ Promise.all  │ await A, then B  │   │
│   │ Fast         │ Order Guaranteed │   │
│   └──────────────┴──────────────────┘   │
└─────────────────────────────────────────┘
      ↓
[UI Update] (Render Data or Show Error)
```

**Relationship Flow:**
1. **Event** triggers **Async Function**
2. **Async Function** returns **Promise**
3. **Promise** resolves/rejects based on **HTTP Status**
4. **Decision Layer** determines Retry or Continue
5. **Execution Layer** chooses Parallel vs Sequential
6. **Result** updates **UI**

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Retry with Exponential Backoff

**Khi nào dùng:** Gọi API external không ổn định (third-party), mạng yếu.

**Tại sao đúng:** Tránh đập server khi nó đang chết, tăng thời gian chờ sau mỗi lần retry.

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      
      // Retry on 503, 429
      if (response.status === 503 || response.status === 429) {
        throw new Error(`Retryable: ${response.status}`);
      }
      
      if (!response.ok) throw new Error(`Fatal: ${response.status}`);
      
      return await response.json();
      
    } catch (error) {
      const isLastAttempt = i === maxRetries - 1;
      
      if (error.message.includes('Retryable') && !isLastAttempt) {
        // Exponential backoff: 1s, 2s, 4s...
        const waitTime = Math.pow(2, i) * 1000;
        console.log(`Retrying in ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue; // Vòng lặp sẽ thử lại
      }
      
      if (isLastAttempt) throw error; // Ném lỗi cuối cùng
    }
  }
}

// Usage
fetchWithRetry('https://api.example.com/data')
  .then(data => console.log(data))
  .catch(err => console.error('Failed after retries:', err));
```

### Pattern 2: Promise.all - Parallel Performance

**Khi nào dùng:** Load dữ liệu độc lập cùng lúc để tăng speed.

**Tại sao đúng:** Không cần đợi A xong mới gọi B, giảm tổng thời gian chờ.

```javascript
async function loadDashboard() {
  try {
    // Chạy song song 3 API độc lập
    const [users, posts, comments] = await Promise.all([
      fetch('/api/users').then(r => r.json()),
      fetch('/api/posts').then(r => r.json()),
      fetch('/api/comments').then(r => r.json())
    ]);

    renderUI({ users, posts, comments });
    
  } catch (error) {
    // Nếu 1 trong 3 fail → CẢ BỘ ĐỀU HỦY
    console.error('One API failed, all stopped:', error);
    showError('Cannot load dashboard');
  }
}
```

### Pattern 3: Promise.allSettled - Safe Parallel

**Khi nào dùng:** Load nhiều data, không quan trọng một vài cái fail.

**Tại sao đúng:** Không crash app vì 1 source lỗi, xử lý partial success.

```javascript
async function loadMultipleSources() {
  const results = await Promise.allSettled([
    fetch('/api/users').then(r => r.json()),
    fetch('/api/missing').then(r => r.json()), // Sẽ fail
    fetch('/api/posts').then(r => r.json())
  ]);

  // Xử lý từng kết quả riêng lẻ
  const users = results[0].status === 'fulfilled' ? results[0].value : null;
  const posts = results[2].status === 'fulfilled' ? results[2].value : null;

  if (results[1].status === 'rejected') {
    console.warn('Posts API failed, but users loaded fine');
  }

  renderPartialUI({ users, posts });
}
```

### Pattern 4: CRUD with Manual UI Update (Exercise Style)

**Khi nào dùng:** Building raw CRUD apps without frameworks.

**Tại sao đúng:** Control UI state manually, clear data flow.

```javascript
// State Management
let users = [];
const API_URL = 'https://jsonplaceholder.typicode.com/users';

// READ
async function fetchUsers() {
  try {
    const response = await fetch(API_URL);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    users = await response.json();
    renderTable();
  } catch (error) {
    showError('Failed to load users');
  }
}

// CREATE
async function createUser(userData) {
  try {
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    
    const newUser = await response.json();
    
    // Manual UI Update: Thêm vào mảng và render lại
    users.unshift(newUser); // Thêm đầu mảng
    renderTable(); // Gọi lại hàm render
    
  } catch (error) {
    showError('Failed to create user');
  }
}

// UPDATE
async function updateUser(id, userData) {
  try {
    const response = await fetch(`${API_URL}/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    // Manual UI Update: Tìm và thay đổi trong mảng
    const updatedUser = await response.json();
    const index = users.findIndex(u => u.id === id);
    if (index !== -1) {
      users[index] = updatedUser;
      renderTable();
    }
  } catch (error) {
    showError('Failed to update user');
  }
}

// DELETE
async function deleteUser(id) {
  try {
    const response = await fetch(`${API_URL}/${id}`, {
      method: 'DELETE'
    });

    if (!response.ok) throw new Error(`HTTP ${response.status}`);

    // Manual UI Update: Filter mảng và render lại
    users = users.filter(u => u.id !== id);
    renderTable();
    
  } catch (error) {
    showError('Failed to delete user');
  }
}

// Search & Pagination (Client-side)
function filterUsers(searchTerm) {
  const filtered = users.filter(u => 
    u.name.toLowerCase().includes(searchTerm.toLowerCase())
  );
  renderTable(filtered); // Pass filtered data to render
}

function renderTable(data = users) {
  // Hiển thị dữ liệu ra DOM
  const tbody = document.querySelector('#user-table tbody');
  tbody.innerHTML = data.map(u => `
    <tr>
      <td>${u.name}</td>
      <td>${u.email}</td>
      <td>${u.phone}</td>
      <td>
        <button onclick="editUser(${u.id})">Edit</button>
        <button onclick="deleteUser(${u.id})">Delete</button>
      </td>
    </tr>
  `).join('');
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Ouroboros Retry (Infinite Retry Loop)
**What:** Retry request 503 không có giới hạn lần hoặc delay.
**Why dangerous:** Nếu server chết thật, client sẽ spam request, gây DDoS chính mình và sập browser tab.

### 2. Promise.all on Dependent Calls
**What:** Dùng `Promise.all` cho các API phụ thuộc nhau (A cần ID của B).
**Why dangerous:** Request B sẽ fail vì không có data từ A, hoặc chạy ngược thứ tự logic.

### 3. Ignoring 429 (Rate Limit)
**What:** Retry ngay lập tức khi gặp 429.
**Why dangerous:** Server đang bảo "dừng lại", client cứ Spam → Server block IP vĩnh viễn.

### 4. Silent Failures in Promise.allSettled
**What:** Dùng `Promise.allSettled` nhưng không kiểm tra `status`.
**Why dangerous:** UI hiển thị undefined hoặc crash khi truy cập property không tồn tại.

### 5. Blocking UI with Sequential await
**What:** Dùng `await` lần lượt cho 3 API độc lập.
**Why dangerous:** Tốn 3x thời gian thay vì 1x, user thấy loading quay lâu hơn cần thiết.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Decision Logic

**IF** response.status === 503 OR 429 **THEN** Retry (Max 3 times, Exponential Backoff)  
**ELSE IF** response.status >= 400 **THEN** Stop, Show Error  
**ELSE** Parse JSON, Update UI

**IF** APIs are independent **THEN** Use `Promise.all()`  
**IF** APIs are dependent **THEN** Use `Sequential await`  
**IF** Partial failure is OK **THEN** Use `Promise.allSettled()`

### Top 10 Things to Remember

1. **503/429 = Retry.** 4xx/5xx khác = Stop.
2. `await` stops execution, but doesn't block other tabs.
3. `Promise.all` = All or Nothing.
4. `Promise.allSettled` = Try everything, get all results.
5. **Exponential Backoff:** Đợi lâu dần sau mỗi lần retry (1s → 2s → 4s).
6. **Manual UI Update:** After POST/PUT/DELETE, update array, then call `render()`.
7. **Search:** Filter array locally before render, don't call API for search.
8. **Pagination:** Slice array locally for small data, call API with `page=` param for large data.
9. **Async Function:** Always returns a Promise, even if you don't write `return`.
10. **Error Handling:** Always wrap `await` in `try/catch` or use `.catch()` on Promise.