# DEVELOPER DECISION GUIDE: Lec 8-Backend.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 18:07:11



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: BACKEND fundamentals

---

## SECTION 1: CORE MENTAL MODEL

### Backend Core Concepts
- **Backend (Hệ thống phụ trợ)**: The server-side logic that processes requests, manages data, and enforces security. It acts as the bridge between the Frontend (Client) and the Database.
- **REST API (Giao diện lập trình ứng dụng kiểu REST)**: An architectural style using standard HTTP methods (GET, POST, PUT, DELETE) to interact with resources identified by URLs. The primary data exchange format is JSON.
- **NPM (Quản lý gói Node.js)**: The default package manager for Node.js. Used to install, share, and manage dependencies (libraries) for your project.

### The Request-Response Cycle (Chu kỳ yêu cầu - phản hồi)
1. **Client (Frontend)** sends an **HTTP Request** to a specific **Endpoint (API Route)**.
2. **Server (Backend)** receives the request, executes **Business Logic (Logic nghiệp vụ)**, and queries the **Database**.
3. **Server** sends back an **HTTP Response** containing a **JSON** payload or error status.

```javascript
// Mental Model: The Server is a traffic controller
// It receives traffic (Requests) and directs it to the right destination (Database/Logic)
// then sends back a receipt (Response).

// Example: A simple Node.js/Express Server entry point
const express = require('express');
const app = express();

// Middleware: Processes every request
app.use(express.json()); 

// Route: The destination for a specific request
app.get('/api/status', (req, res) => {
    // Logic happens here
    res.json({ status: 'Server is running', timestamp: new Date() });
});

app.listen(3000, () => {
    console.log('Backend listening on port 3000');
});
```

---

## SECTION 2: DECISION TABLES

### Table 1: Architecture Layer Decision (MVC vs Service Layer)

| Tình huống sử dụng (Use Case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common Mistake) |
| :--- | :--- | :--- | :--- |
| **Simple CRUD App** (App CRUD đơn giản) | **MVC (Model-View-Controller)** | **Speed (Tốc độ)**: Direct mapping of routes to logic. Easy to understand for small projects. | Putting all logic inside the Controller (Fat Controller), making it hard to test. |
| **Complex Business Logic** (Logic nghiệp vụ phức tạp) | **Service Layer Pattern** | **Separation of Concerns (Tách biệt trách nhiệm)**: Controllers handle HTTP only. Services handle logic. Reusable logic across different controllers. | Writing raw database queries inside the Controller instead of using a Service layer. |
| **Flexible Data Source** (Data thay đổi nguồn) | **Repository Pattern** | **Abstraction (Tính trừu tượng)**: Decouples the app from the database. You can swap MongoDB for SQL without rewriting business logic. | Importing Mongoose models directly into Controllers (tight coupling). |

### Table 2: Database Selection

| Tình huống sử dụng (Use Case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common Mistake) |
| :--- | :--- | :--- | :--- |
| **Structured Data** (Dữ liệu có cấu trúc) | **SQL (MySQL/PostgreSQL)** | **ACID Compliance**: Ensures data integrity, complex joins, and strict schema. | Using SQL for highly unstructured or rapidly changing data (schema changes are painful). |
| **Rapid Development / JSON** (Phát triển nhanh / JSON) | **MongoDB (NoSQL)** | **Flexibility (Tính linh hoạt)**: Schema-less (BSON), scales horizontally easily. Perfect for Node.js (JSON everywhere). | Treating MongoDB like SQL (trying to do complex joins across collections instead of embedding data). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy: The "Clean" Flow
This represents the **Service Layer** architecture (Best Practice).

```text
[HTTP Client]
      |
      v
[Controller Layer (Express Router)]
   • Parses Request (req.body)
   • Validates Input
   • Calls Service
      |
      v
[Service Layer (Business Logic)]
   • Performs calculations
   • Handles rules
   • Calls Repository/Model
      |
      v
[Data Access Layer (Mongoose / Model)]
   • Defines Schema
   • Interacts with DB
      |
      v
[MongoDB / SQL Database]
```

**Relationship Summary:**
- **Controller** knows nothing about the Database.
- **Service** knows nothing about HTTP (req/res).
- **Database** knows nothing about the Business Logic.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Express Route + Service Pattern
**Khi nào dùng:** Khi bạn cần tách biệt logic HTTP (đầu vào/đầu ra) khỏi logic nghiệp vụ (xử lý dữ liệu).

**Tại sao đúng:** Makes code testable. You can test the Service without mocking HTTP requests.

```javascript
// 1. User Model (Data Layer)
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  passwordHash: { type: String, required: true }
});

const User = mongoose.model('User', userSchema);

// 2. User Service (Business Logic Layer)
class UserService {
  // Logic không phụ thuộc Express "req/res"
  async registerUser(email, password) {
    // Logic nghiệp vụ: Kiểm tra tồn tại
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      throw new Error('User already exists'); // Business error
    }

    // Logic nghiệp vụ: Băm mật khẩu (giả lập)
    const hash = require('crypto').createHash('sha256').update(password).digest('hex');
    
    // Lưu dữ liệu
    const newUser = new User({ email, passwordHash: hash });
    return await newUser.save();
  }
}

// 3. Auth Controller (HTTP Layer)
const express = require('express');
const router = express.Router();
const userService = new UserService();

router.post('/register', async (req, res) => {
  try {
    // Chỉ xử lý HTTP: Lấy dữ liệu từ body
    const { email, password } = req.body;

    // Gọi Service
    const user = await userService.registerUser(email, password);

    // Chỉ xử lý HTTP: Trả về response
    res.status(201).json({ message: 'User created', userId: user._id });
  } catch (error) {
    // Exception handling
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;
```

### Pattern 2: MongoDB Connection Handling
**Khi nào dùng:** Khi khởi chạy một Node.js server cần kết nối cơ sở dữ liệu.

**Tại sao đúng:** Sử dụng `async/await` để đảm server không lắng nghe request nếu DB chưa kết nối.

```javascript
// server.js
const mongoose = require('mongoose');
const app = require('./app'); // Your express app

const PORT = process.env.PORT || 3000;
const MONGO_URI = 'mongodb://localhost:27017/my_database';

const startServer = async () => {
  try {
    console.log('Connecting to database...');
    await mongoose.connect(MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB Connected!');

    app.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (err) {
    console.error('Database connection failed:', err);
    process.exit(1); // Thoát ứng dụng nếu không kết nối được DB
  }
};

startServer();
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Fat Controllers (Controller "béo")
- **Lý do nguy hiểm:** Controller chứa quá nhiều logic (kiểm tra dữ liệu, tính toán, truy vấn DB). Khi logic thay đổi, bạn phải sửa lại Controller, dẫn đến code rủi ro và khó unit test.
- **Cách tránh:** Đưa logic vào **Service**. Controller chỉ là "người đưa thư".

### 2. Callback Hell (Địa ngục callback)
- **Lý do nguy hiểm:** Dùng quá nhiều hàm lồng nhau (nested callbacks) khiến code khó đọc, khó bảo trì ( Pyramid of Doom).
- **Cách tránh:** Sử dụng **Async/Await** (Modern JS) hoặc Promise chaining.

```javascript
// ❌ TRÁNH (Callback Hell)
getData(function(a) {
  getMoreData(a, function(b) {
    getMoreData(b, function(c) {
      // ...
    });
  });
});

// ✅ SỬ DỤNG (Async/Await)
async function processData() {
  const a = await getData();
  const b = await getMoreData(a);
  const c = await getMoreData(b);
}
```

### 3. Trusting Client Input (Tin tưởng dữ liệu từ Client)
- **Lý do nguy hiểm:** Người dùng có thể gửi dữ liệu rác, mã độc, hoặc thiếu trường dữ liệu. Gây lỗi hệ thống hoặc lỗi bảo mật (Injection).
- **Cách tránh:** Luôn validate dữ liệu đầu vào (Input Validation) ở Controller hoặc Middleware (dùng thư viện như `Joi` hoặc `express-validator`).

### 4. Blocking the Event Loop (Block Event Loop)
- **Lý do nguy hiểm:** Node.js là Single-threaded. Nếu bạn chạy một vòng lặp tính toán nặng (CPU-intensive task) trong主线程, toàn bộ server sẽ dừng hoạt động (không xử lý request nào được).
- **Cách tránh:** Đẩy tác vụ nặng ra Worker Threads hoặc xử lý bằng Message Queue (Redis, RabbitMQ).

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules to Remember
1. **JSON is King:** Frontend <-> Backend giao tiếp qua JSON.
2. **Single Responsibility:** 1 file = 1 mục đích (Controller, Service, Model).
3. **Never Block:** Tránh tính toán nặng trong主线程.
4. **Always Validate:** Validate input trước khi xử lý logic.
5. **Async Everywhere:** Dùng `await` cho mọi tác vụ bất đồng bộ (DB, File IO).
6. **Handle Errors:** Luôn dùng `try/catch` trong async functions.
7. **Status Codes:** 
   - `200`: OK
   - `201`: Created
   - `400`: Bad Request (Client sai)
   - `404`: Not Found
   - `500`: Server Error (Server sai)
8. **Separate Layers:** Controller gọi Service, Service gọi Model.
9. **Environment Variables:** Đừng hardcode secrets (API keys, DB passwords).
10. **NPM Scripts:** Biết cách dùng `npm start` và `npm run dev`.

### Quick Decision Logic (If-Else)
- **If** you need to store data with strict relationships (Users have Orders) -> **Use SQL**.
- **If** you need to store flexible documents (Product catalogs, Blogs) -> **Use MongoDB**.
- **If** your function calculates tax, finds users, or processes files -> **Put it in a Service**.
- **If** your function parses `req.body` or sends `res.json` -> **Put it in a Controller**.
- **If** you see `function(err, result)` inside another `function` -> **Rewrite with `async/await`**.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE - BACKEND LECTURE 8

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Node.js (Môi trường thực thi JavaScript)**
- JavaScript runtime built on V8 engine, allows JS to run outside browser
- Designed for fast, scalable network applications

**libuv (Thư viện async I/O)**
- Library enabling async operations off main thread
- Foundation of Node's Event Loop
- Handles OS-level I/O tasks

**Non-blocking I/O (Mô hình không bloque)**
- I/O operations delegated to libuv/OS, main thread continues execution
- Callbacks/Promises execute when I/O completes

### Key Mental Model: The Event Loop Flow

```javascript
// V8 Call Stack → libuv (I/O) → Event Queue → V8 (Callback)

// Example: Reading a file
const fs = require('fs');

// 1. V8: Call fs.readFile()
fs.readFile('data.txt', (err, data) => {
    // 4. V8: Callback executes here
    console.log(data);
});

// 2. libuv: Sends OS request, file read happens in background
// 3. Event Loop: Puts callback in queue when done
// 4. V8: Main thread executes callback

console.log('This runs first!'); // Non-blocking
```

**Why This Model Wins:**
- **Single thread** = No race conditions, no deadlocks
- **Non-blocking I/O** = One thread handles thousands of concurrent connections
- **Lightweight** vs Multi-threaded servers (Apache, Java)

---

## SECTION 2: DECISION TABLES

### When to Use Node.js vs Other Technologies

| Use Case | Should Use | Why | Common Mistake |
|----------|------------|-----|----------------|
| **Real-time apps** (chat, notifications) | Node.js | Event-driven architecture handles concurrent connections efficiently | Using blocking I/O operations |
| **CPU-intensive tasks** (video encoding, ML) | **NOT** Node.js | Single-threaded, blocks Event Loop | Running heavy calculations on main thread |
| **I/O-heavy services** (APIs, microservices) | Node.js | Non-blocking I/O excels at handling many simultaneous requests | Synchronous file/network operations |
| **Web scraping** | Node.js | Async HTTP requests + lightweight | Not using connection pooling |
| **CRUD apps** | Node.js + Express | Fast development, good performance | Over-engineering with too many threads |

### Module System Decision

| Scenario | Should Use | Why | Common Mistake |
|----------|------------|-----|----------------|
| **Modern projects** | ES Modules (ESM) | Official standard, static analysis, better optimization | Mixing require() and import |
| **Legacy projects** | CommonJS | Backward compatibility | Forcing ESM on old codebases |
| **Package creation** | ES Modules | Future-proof, tree-shaking support | Not specifying "type": "module" |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Node.js Runtime Architecture

```
┌─────────────────────────────────────────┐
│         JavaScript Code (V8)            │
│  ┌───────────────────────────────────┐  │
│  │  Call Stack (Synchronous)         │  │
│  │  - Functions execute immediately  │  │
│  │  - console.log(), math ops        │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────┐
│         Node.js Bindings (C++)          │
│  ┌───────────────────────────────────┐  │
│  │  Event Queue                      │  │
│  │  - Callbacks waiting to execute   │  │
│  │  - Timers (setTimeout)             │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────┐
│           libuv (Async I/O)             │
│  ┌───────────────────────────────────┐  │
│  │  Worker Threads Pool (4 default)  │  │
│  │  - File system ops                │  │
│  │  - DNS lookups                    │  │
│  │  OS Operations (Network, Process) │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
                   │
                   ▼
         Operating System Kernel
```

### Execution Flow: `fs.readFile()`

```
User Code → V8 Call Stack
              ↓
         fs.readFile()
              ↓
         Node Bindings (C++)
              ↓
         libuv → OS Thread Pool
              ↓
         File System (Background)
              ↓
         Event Queue (Callback ready)
              ↓
         V8 Call Stack → Callback executes
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Async File Operations

**Khi nào dùng:** Reading/writing files without blocking main thread

**Tại sao đúng:** Keeps Event Loop free for other requests

```javascript
const fs = require('fs').promises;

// ✅ CORRECT: Async/Await pattern
async function readConfig() {
    try {
        const data = await fs.readFile('./config.json', 'utf-8');
        return JSON.parse(data);
    } catch (error) {
        console.error('File read failed:', error);
        return null; // Graceful fallback
    }
}

// Usage
readConfig().then(config => {
    console.log('Config loaded:', config);
});

// ❌ WRONG: Blocking version
function readConfigSync() {
    const data = fs.readFileSync('./config.json', 'utf-8'); // Blocks everything
    return JSON.parse(data);
}
```

### Pattern 2: Event-Driven Architecture

**Khi nào dùng:** Building real-time features (chat, notifications)

**Tại sao đúng:** Decouples producers and consumers, scales horizontally

```javascript
const EventEmitter = require('events');

// ✅ CORRECT: Custom event emitter
class UserService extends EventEmitter {
    createUser(username) {
        // Business logic
        const user = { id: Date.now(), username };
        
        // Emit event, don't tie to notification logic
        this.emit('user:created', user);
        
        return user;
    }
}

// Separate concern: Notification handler
const userService = new UserService();

userService.on('user:created', (user) => {
    // Async notification (email, push, etc.)
    console.log(`Sending welcome email to ${user.username}`);
});

// Usage
const user = userService.createUser('john_doe');
// Output: Sending welcome email to john_doe
```

### Pattern 3: Global Environment Check

**Khi nào dùng:** Writing isomorphic code or environment-specific logic

**Tại sao đúng:** Prevents browser-specific API errors in Node.js

```javascript
// ✅ CORRECT: Environment detection
function getRuntimeInfo() {
    const isNode = typeof process !== 'undefined' && 
                   process.versions && 
                   process.versions.node;
    
    if (isNode) {
        return {
            env: 'node',
            globals: Object.keys(global),
            platform: process.platform
        };
    } else {
        return {
            env: 'browser',
            globals: Object.keys(window),
            userAgent: navigator.userAgent
        };
    }
}

// Usage
console.log(getRuntimeInfo());
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### Anti-Pattern 1: Blocking I/O in Single Thread

**Code:**
```javascript
// ❌ DANGEROUS: Blocks entire server
function heavyFileProcessing() {
    const data = fs.readFileSync('massive.txt', 'utf-8');
    // While reading... ALL other requests wait
    return data.toUpperCase();
}
```

**Why Dangerous:** 
- Node.js là **single-threaded**, một операция bloque sẽ giết chết cả server
- Không thể xử lý request khác trong khi đọc file

### Anti-Pattern 2: Mixing Sync and Async

**Code:**
```javascript
// ❌ DANGEROUS: Race condition, unpredictable behavior
const data = fs.readFileSync('config.json'); // Sync
fs.readFile('log.txt', (err, log) => {       // Async
    console.log(data, log);
});
```

**Why Dangerous:**
- Logic không đồng bộ, khó debug
- Promise/async-await nên nhất quán

### Anti-Pattern 3: Ignoring Error Handling in Async

**Code:**
```javascript
// ❌ DANGEROUS: Unhandled errors crash Node.js
async function fetchData() {
    const result = await fetch('/api/data');
    // No try-catch: process will crash on network error
}
```

**Why Dangerous:**
- Unhandled promise rejections =untime errors
- Node.js 15+ will terminate process on unhandled rejections

### Anti-Pattern 4: Not Using Global Objects Correctly

**Code:**
```javascript
// ❌ WRONG: window doesn't exist in Node.js
if (window) { /*...*/ } // ReferenceError

// ✅ CORRECT: Check for process
if (typeof process !== 'undefined') {
    // Node.js environment
}
```

**Why Dangerous:**
- Code crashes immediately
- Use `global` and `process`, not browser APIs

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

1. **Async > Sync** - Always use `fs.promises`, `async/await`
2. **Event-driven** - Use `EventEmitter` for decoupling
3. **Error handling** - Always `try/catch` around `await`
4. **Environment** - Check `process.versions.node` before using globals
5. **Module system** - Use ESM (`import/export`) for new projects

### Decision Logic (If-Else Style)

```
IF async operation needed:
  → Use fs.promises + async/await
ELSE IF sync operation:
  → REFACTOR to async, or use only in startup/config

IF building real-time features:
  → Use EventEmitter pattern
ELSE IF building REST API:
  → Use Express + async middleware

IF code runs in Node.js:
  → Use global, process, __dirname
ELSE IF code runs in browser:
  → Use window, navigator, document

IF "type": "module" in package.json:
  → Use import { x } from './file.js'
ELSE:
  → Use const x = require('./file.js')
```

### Top 10 Things to Remember

1. **Node.js ≠ Browser** - No DOM, no window, has global/process
2. **Single Thread** - One call stack, avoid blocking at all costs
3. **libuv handles I/O** - File, network, DB ops are backgrounded
4. **Event Loop** - Callbacks execute after async ops complete
5. **Promises > Callbacks** - Modern, cleaner error handling
6. **ES Modules** - Use for new code, static optimization
7. **Worker Threads** - For CPU-heavy tasks (not covered in basics)
8. **Error First** - Always handle errors in async code
9. **Environment Check** - `process.versions.node` is your friend
10. **Non-blocking mindset** - If it blocks, move it to libuv/OS

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Node.js Backend Essentials

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Node.js (Nền tảng thực thi JavaScript)**
- Runtime environment cho phép chạy JavaScript ở phía server.
- **Key Mental Model:** Xử lý I/O (database, file, network) một cách bất đồng bộ (non-blocking) để phục vụ nhiều request cùng lúc mà không cần nhiều thread.

**NPM (Node Package Manager)**
- Công cụ quản lý thư viện mặc định của Node.js.
- **Key Mental Model:** Kho lưu trữ (registry) và trình quản lý cài đặt. Nó đọc `package.json`, tải thư viện từ internet, và lưu vào `node_modules`.

**Express.js (Khung làm web)**
- Framework xây dựng trên Node.js để tạo web server và API.
- **Key Mental Model:** "Lớp phủ bù" (Abstraction). Nó che giấu sự phức tạp của việc xử lý HTTP request/response thủ công, cung cấp sẵn routing và middleware.
- *So với Node.js thuần:* Express giúp code sạch hơn, viết ít hơn, tập trung vào logic nghiệp vụ.

### Code Demos

**1. Đọc & Ghi File (Core Modules)**
*Khi nào dùng:* Cấu hình đơn giản, log file cục bộ, xử lý file không cần real-time.
*Lưu ý:* `readFileSync` blocking main thread, chỉ dùng cho file nhỏ hoặc startup.

```javascript
import { readFileSync, writeFileSync } from 'fs';
import path from 'path';

// Đọc file
const data = readFileSync('config.txt', 'utf-8');
console.log(data);

// Ghi file (ghi đè nếu có)
writeFileSync('log.txt', 'Log message');

// Xử lý đường dẫn đa nền tảng (Windows/Linux)
const fullPath = path.join(__dirname, 'uploads', 'image.jpg');
console.log(fullPath); // VD: C:\Project\uploads\image.jpg
```

**2. Khởi tạo Project & Biên dịch TypeScript**
*Khi nào dùng:* Bắt đầu dự án mới hoặc chuyển đổi JS sang TS.

```bash
# Khởi tạo package.json
npm init -y

# Cài đặt TypeScript (DevDependency)
npm install -D typescript

# Tạo file cấu hình tsconfig.json
npx tsc --init

# Biên dịch (JS -> TS)
npx tsc
# Chạy file JS đã biên dịch
node index.js
```

---

## SECTION 2: DECISION TABLES (QUAN TRỌNG)

### Table 1: Node.js Core Module vs External Package

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Đọc/Ghi file cơ bản, xử lý path | **Core Modules** (`fs`, `path`) | **Built-in:** Không cần cài đặt, ổn định, nhanh. | Cài thư viện第三方 (như `fs-extra`) cho việc đơn giản, làm phình to project. |
| Xây dựng Web Server, API复杂 | **Express.js** (External) | **Abstraction:** Cung cấp routing, middleware, xử lý request rườm rà sẵn. | Việc tự build server với `http` module làm code phức tạp, khó maintain. |

### Table 2: Dependencies vs DevDependencies

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Code chạy ở Production (API, DB, Auth) | **Dependencies** (`express`, `mongoose`) | **Production Runtime:** App bắt buộc phải có để chạy được. | Đặt thư viện test (Jest) vào đây, làm tăng thời gian deploy và rủi ro an ninh. |
| Chỉ dùng khi Dev (Lint, Test, Auto-restart) | **DevDependencies** (`nodemon`, `eslint`) | **Tối ưu:** Không cần thiết ở server production, giảm dung lượng cài đặt. | Đặt `nodemon` vào Dependencies, server production sẽ cài thừa thư viện dev. |

### Table 3: Lựa chọn Version Prefix (Semantic Versioning)

| Ký hiệu | Phạm vi cập nhật | Khi nào nên dùng | Cẩn thận |
| :--- | :--- | :--- | :--- |
| `^` (Caret) | `^1.2.3` → `1.x.x` (Cập nhật Minor, Patch) | Dự án ổn định, muốn nhận tính năng mới an toàn. | Minor update có thể thay đổi nhỏ behavior. |
| `~` (Tilde) | `~1.2.3` → `1.2.x` (Chỉ cập nhật Patch) | Dự án nhạy cảm, cần tối đa sự ổn định. | Bỏ lỡ tính năng mới ở Minor version. |
| `Exact` (`1.2.3`) | Chỉ đúng version đó | Lockdown môi trường, production critical. | Khó update security patch nếu dùng tay. |

### Table 4: JavaScript vs TypeScript

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Script nhỏ, prototype nhanh | **JavaScript** | Nhanh, không cần cấu hình, không biên dịch. | Viết project lớn (1000+ dòng) không có type, dễ bug runtime. |
| Team > 1 người, Project lớn, Enterprise | **TypeScript** | **Type Safety:** Phát hiện lỗi khi code, auto-complete tốt, dễ refactor. | Chỉ dùng `any` cho tất cả biến, vô hiệu hóa lợi ích của TS. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Workflow: Từ Code đến Chạy App

```text
[ Developer Code ]
      |
      v
[ package.json ] (Manifest: tên app, scripts, version, deps)
      |
      v
[ NPM Install ] (Tải dependencies)
      |
      +---> [ node_modules ] (Thư viện cài đặt)
      |
      v
[ TypeScript Code (.ts) ] (Nếu dùng TS)
      |
      v (Biên dịch tsc)
[ JavaScript Code (.js) ]
      |
      v (Chạy node)
[ Express Server ] (Xử lý Request/Response)
      |
      v
[ File System (fs) ] & [ Database ]
```

### Dependency Tree (Mô hình cây phụ thuộc)
- **Root:** `package.json` của bạn.
- **Level 1:** Direct Dependencies (Bạn cài thủ công).
- **Level 2, 3...:** Transitive Dependencies (Thư viện Level 1 cần).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Cấu hình Path An Toàn (Cross-Platform)
*Khi nào dùng:* Khi làm việc với file, load module relative path.
*Tại sao đúng:* `__dirname` không tồn tại trong ES Module. Dùng `import.meta.url` để tính toán path chuẩn, tránh lỗi `/` vs `\`.

```javascript
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Path an toàn tuyệt đối
const configPath = join(__dirname, 'config', 'app.json');
console.log(configPath);
```

### Pattern 2: Phân loại Dependency Đúng
*Khi nào dùng:* Cài đặt bất kỳ thư viện mới.
*Tại sao đúng:* Giữ Production environment gọn nhẹ và bảo mật.

```javascript
// Cài thư viện chạy app (Production)
npm install express mongoose axios

// Cài thư viện Dev (Development Only)
npm install -D nodemon eslint prettier typescript
```

### Pattern 3: Scripts trong package.json để tối ưu Workflow
*Khi nào dùng:* Luôn luôn dùng.
*Tại sao đúng:* Tiêu chuẩn hóa lệnh chạy, tránh gõ lệnh dài dòng.

```json
{
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "build": "tsc",
    "lint": "eslint . --fix"
  }
}
// Chạy bằng: npm run dev
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Đọc file lớn bằng `readFileSync` trong request handler.**
    *   **Tại sao nguy hiểm:** Block Event Loop. Server sẽ "đông cứng" (không phục vụ ai được) cho đến khi file được đọc xong. Dùng `fs.promises` hoặc Stream.

2.  **Bỏ qua `path.join()` khi nối đường dẫn.**
    *   **Tại sao nguy hiểm:** Code sẽ fail trên Windows (dùng `\`) nếu bạn hardcode dùng `/`. Luôn dùng `path.join()` hoặc `path.resolve()`.

3.  **Thả `nodemon` vào `dependencies`.**
    *   **Tại sao nguy hiểm:** Server production sẽ cài đặt cả thư viện chỉ để Auto-reload code. Vô ích và tăng thời gian deploy.

4.  **Không commit `node_modules` vào Git.**
    *   **Tại sao nguy hiểm:** Dung lượng repository c cực lớn, dễ conflict. Chỉ cần commit `package.json` và `package-lock.json`. (Đoạn này thuộc về best practice git nhưng là hậu quả của việc hiểu sai NPM).

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic: Khi gặp requirement mới
1.  **Cần thêm tính năng?** -> Vào `npmjs.com` tìm thư viện -> `npm install <name>` -> Check Dev vs Prod.
2.  **Cần đọc file?** -> Import `fs` -> Dùng `readFileSync` (nếu file nhỏ/startup) hoặc `fs.promises` (nếu file lớn/IO nặng).
3.  **Code bị lỗi path?** -> Import `path` -> Dùng `path.join(__dirname, ...)` (cần fix `__dirname` cho ES Module).
4.  **Chọn version?** -> Dùng `^` nếu muốn update auto, dùng `~` nếu muốn giữ nguyên minor.

### Top 5 Things to Remember
1.  **NPM** là quản lý gói, **Node.js** là runtime.
2.  **`package.json`** là bible của dự án.
3.  **`node_modules`** là folder chứa đồ, không commit lên Git.
4.  **`^1.2.3`** (Caret) là default tốt nhất cho phần lớn dự án.
5.  **TypeScript** biên dịch ra **JavaScript** mới chạy được trên Node.js.

<!-- CHUNK 31-40 -->

# Developer Decision Guide: Express.js Backend (Lec 8)

## SECTION 1: CORE MENTAL MODEL

### Core Concepts
- **Routing (Định tuyến)**: Mapping URLs to handler functions. It is the decision logic of which code runs when a user visits a specific URL.
- **Middleware (Phần mềm trung gian)**: Functions that execute in the **exact order** defined in the code. They act as gatekeepers or data transformers between the request and the final response.
- **Request & Response Objects**: The `req` object is the **input** (client data), and the `res` object is the **output** (server response).

### Why Express is Better
It abstracts raw Node.js `http` module complexities. It provides standardized methods for parsing data, handling errors, and structuring APIs, allowing you to focus on business logic rather than socket management.

---

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

### Table 1: Input Data Location
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Get ID from URL** (e.g., `/users/5`) | `req.params.id` | **Path Parameter (Tham số đường dẫn)**: Used to identify a specific resource by its unique ID. | Using query strings (`/users?id=5`) when the ID is a mandatory resource identifier. |
| **Filter or Search** (e.g., `/users?page=2&sort=asc`) | `req.query.page` | **Query String (Tham số truy vấn)**: Used for optional sorting, filtering, or pagination. | Trying to parse the URL string manually instead of using the built-in query parser. |
| **Create/Update Data** (JSON body) | `req.body.name` | **Request Body (Nội dung yêu cầu)**: Used to send data payload (create/update). Requires `express.json()` middleware. | Forgetting to use `app.use(express.json())`, resulting in `req.body` being `undefined`. |

### Table 2: HTTP Methods (REST)
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- |
| **Retrieve data** (Get list or item) | `GET` | Using `POST` to fetch data. |
| **Create new resource** (Register, New Post) | `POST` | Using `GET` with a body (generally discouraged/supported inconsistently). |
| **Update existing resource** (Overwrite all fields) | `PUT` | Using `PUT` for partial updates (use `PATCH` instead). |
| **Delete resource** | `DELETE` | Not returning a status code (like 204) indicating success. |

### Table 3: Response & Status Codes
| Nên dùng (Should use) | Mục đích (Purpose) | Trạng thái (Status) |
| :--- | :--- | :--- |
| `res.json(data)` | Send JSON data (API standard). | Usually 200 (OK) or 201 (Created). |
| `res.status(404).send('Not Found')` | Resource not found. | **404**. |
| `res.status(500).json({ error: ... })` | Server error (crash, DB fail). | **500**. |
| `res.status(201).json(data)` | Resource created successfully. | **201**. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### MVC Architecture Flow
This is the standard structure for scalable Express apps.

```text
[Client Request]
      ↓
[Route Handler] (app.get/post)
      ↓ (req)
[Middleware] (auth, logging, parsing)
      ↓
[Controller] (Business Logic)
      ↓
[Model] (Database Schema/Logic)
      ↓ (Query)
[Database]
      ↓
[Model] (Data Return)
      ↓
[Controller] (Format Response)
      ↓
[Response] (res.json / res.send)
      ↓
[Client]
```

### Component Relationship
- **`server.js`**: Entry point. Registers global middleware and mounts routers.
- **`routes/`**: Defines URL paths and maps them to specific Controllers.
- **`controllers/`**: Contains the logic that handles the request (calls Models, calculates data).
- **`models/`**: Defines data structure (Schema) and interacts with the database.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Server Setup
**Khi nào dùng**: Bắt đầu mọi dự án Express.
**Tại sao**: Thiết lập máy chủ cơ bản và xử lý JSON body chuẩn.

```javascript
import express from 'express';
const app = express();

// Middleware để đọc JSON body (Bắt buộc cho POST/PUT)
app.use(express.json());

// Route Hello World
app.get('/', (req, res) => {
    res.send('Hello World!');
});

// Lắng nghe cổng 3000
app.listen(3000, () => {
    console.log('Server running on http://localhost:3000');
});
```

### Pattern 2: API Route with Params & Query
**Khi nào dùng**: Khi cần tìm kiếm hoặc lấy thông tin chi tiết.
**Tại sao**: Phân biệt rõ ràng giữa tài nguyên (ID) và bộ lọc (Filter).

```javascript
// URL: /users/123?page=2
app.get('/users/:id', (req, res) => {
    const userId = req.params.id; // Lấy ID (string)
    const page = req.query.page || 1; // Lấy query parameter

    // Logic xử lý (tạm thời fake data)
    const user = { id: userId, name: 'Dev', page: page };

    res.status(200).json(user);
});
```

### Pattern 3: POST Request Handling
**Khi nào dùng**: Khi client gửi dữ liệu để tạo mới (Form, JSON).
**Tại sao**: Xác thực dữ liệu và trả về mã 201 (Created).

```javascript
// Middleware bắt buộc ở đầu file: app.use(express.json());

app.post('/users', (req, res) => {
    const { name, email } = req.body; // Lấy dữ liệu từ body

    // Validate đơn giản
    if (!name || !email) {
        return res.status(400).json({ error: 'Missing name or email' });
    }

    // Giả lập lưu database
    const newUser = { id: Date.now(), name, email };
    
    res.status(201).json(newUser); // 201 = Created
});
```

### Pattern 4: Middleware Chain
**Khi nào dùng**: Khi cần xử lý logic trước khi vào route chính (VD: Kiểm tra token).
**Tại sao**: Tránh lặp lại code (DRY - Don't Repeat Yourself).

```javascript
// Middleware 1: Log thời gian request
const logTime = (req, res, next) => {
    console.log('Time:', Date.now());
    next(); // Bắt buộc: chuyển quyền sang hàm tiếp theo
};

// Middleware 2: Kiểm tra API Key
const checkApiKey = (req, res, next) => {
    if (req.headers['x-api-key'] === 'SECRET_KEY') {
        next();
    } else {
        res.status(403).send('Forbidden');
    }
};

// Áp dụng cho route cụ thể
app.get('/secure-data', logTime, checkApiKey, (req, res) => {
    res.json({ data: 'Top Secret' });
});
```

### Pattern 5: Serving Static Files
**Khi nào dùng**: Khi cần hiển thị giao diện HTML hoặc trả về file ảnh, CSS.
**Tại sao**: Express tự xử lý file rủ rẽ, an toàn hơn readFile thủ công.

```javascript
// Đặt folder 'public' làm thư mục chứa file tĩnh
// Truy cập: http://localhost:3000/index.html hoặc http://localhost:3000/images/logo.png
app.use(express.static('public'));
```

### Pattern 6: Modular Routing
**Khi nào dùng**: Khi có nhiều route (Users, Products, Orders).
**Tại sao**: Dễ quản lý, không để tất cả trong một file.

**File `routes/userRoutes.js`:**
```javascript
import express from 'express';
const router = express.Router();

router.get('/', (req, res) => res.json({ msg: 'List users' }));
router.post('/', (req, res) => res.json({ msg: 'Create user' }));

export default router;
```

**File `server.js`:**
```javascript
import userRoutes from './routes/userRoutes.js';
app.use('/users', userRoutes); // prefix /users cho mọi route trong file đó
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Forgetting `express.json()`**
    *   **Tại sao nguy hiểm**: Khi dùng `POST`, `req.body` sẽ trả về `undefined`. Dữ liệu client gửi lên bị mất.
    *   **Cách tránh**: Luôn đặt `app.use(express.json())` ngay sau khi tạo `app`.

2.  **Quên `next()` trong Middleware**
    *   **Tại sao nguy hiểm**: Request sẽ bị treo (hang) vĩnh viễn. Client không bao giờ nhận được response.
    *   **Cách tránh**: Nếu không phải là endpoint cuối cùng, phải gọi `next()`.

3.  **Sử dụng GET để gửi Body**
    *   **Tại sao nguy hiểm**: Tiêu chuẩn HTTP không hỗ trợ Body trong GET. Các proxy/server có thể xóa body.
    *   **Cách tránh**: Dùng `POST` để gửi data hoặc `Query Params` để lọc.

4.  **Trả về Server Error chi tiết (500)**
    *   **Tại sao nguy hiểm**: `res.send(err.message)` làm lộ thông tin nhạy cảm (path DB, version stack).
    *   **Cách tránh**: Log lỗi ra console, nhưng gửi về client thông báo chung: "Có lỗi xảy ra".

---

## SECTION 6: MASTER CHEAT SHEET

### If-Else Decision Logic
*   **IF** client needs to find specific resource **AND** ID is in URL **THEN** use `req.params`.
*   **IF** client needs to filter/search **THEN** use `req.query`.
*   **IF** client sends data to create/update **THEN** use `req.body` (Remember `express.json()`).
*   **IF** operation succeeds **THEN** `res.status(200/201).json()`.
*   **IF** input is invalid **THEN** `res.status(400).json()`.
*   **IF** resource not found **THEN** `res.status(404).json()`.
*   **IF** server crashes **THEN** `res.status(500).json()`.

### Top 10 Things to Remember
1.  `npm install express`
2.  `app.use(express.json())` for POST.
3.  `req.params` (URL), `req.query` (Filter), `req.body` (Payload).
4.  `app.get/post/put/delete(path, handler)`.
5.  Middleware needs `next()`.
6.  `express.static('folder')` for HTML/Images.
7.  Split routes using `express.Router()`.
8.  Use `res.json()` for API responses.
9.  Follow RESTful conventions (GET/POST/PUT/DELETE).
10. MVC separates Logic (Controller) from Data (Model).

<!-- CHUNK 41-50 -->

# Lec 8 Backend: Developer Decision Guide

---

## SECTION 1: CORE MENTAL MODEL

### The 3-Layer Architecture (Mô hình 3 Lớp)
A request flows through specific layers to maintain separation of concerns.

1.  **Controller (Trình điều khiển):** The "Gatekeeper".
    *   **Definition:** Entry point for HTTP requests.
    *   **Role:** Parse input, validate format, call Service, format response.
    *   **Mental Model:** "I don't know how to do it, I just know who to ask."

2.  **Service (Dịch vụ):** The "Brain".
    *   **Definition:** Contains Business Logic & Data Processing.
    *   **Role:** Decides *what* happens (rules, calculations, orchestration).
    *   **Mental Model:** "I handle the rules and process the data."

3.  **Model / Repository (Kho lưu trữ):** The "Memory".
    *   **Definition:** Database schema and queries.
    *   **Role:** Interacts directly with the database (MongoDB).
    *   **Mental Model:** "I only store and retrieve data."

### Why this is better than "Fat Controller"
*   **Fat Controller:** Controller does DB queries + Logic + Response. **BAD** because it is hard to test, hard to reuse, and messy.
*   **Layered:** You can swap the database or the API framework without rewriting business rules.

---

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

### Table 1: Where to put Logic? (Controller vs Service)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Database Query** <br>(Tìm user, tạo order) | **Service Layer** | **Separation of Concerns (Tách biệt trách nhiệm):** Logic stays independent of HTTP. | Writing `User.find()` directly inside `app.post()`. |
| **Business Rules** <br>(Kiểm tra tuổi > 18, tính toán giá tiền) | **Service Layer** | **Reusability (Tính tái sử dụng):** Logic can be used by Cron jobs or other services, not just API. | Writing `if (age < 18)` inside the Controller. |
| **Input Parsing** <br>(Lấy `req.params`, `req.body`) | **Controller** | **Boundary (Ranh giới):** Controllers bridge HTTP and the App. | Sending raw `req` object to the Service layer. |
| **Return JSON Response** <br>(Gửi `res.status(200).json(...)`) | **Controller** | **Presentation (Trình bày):** Services shouldn't care about HTTP status codes. | Service returning `res` object. |

### Table 2: Error Handling Strategy

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Runtime Crash** <br>(Code lỗi, Database disconnect) | **Error Middleware** | **Stability (Ổn định):** Catches unhandled exceptions, prevents server crash. | Not having the `4-parameter` middleware. |
| **Input Validation** <br>(Missing fields, wrong types) | **Validation Layer** | **Early Fail (Thất bại sớm):** Stop request before it reaches Logic. | Doing `if (!req.body.name)` in Controller. |
| **Known Business Error** <br>(User không tồn tại, Sai mật khẩu) | **Service/Controller** | **User Feedback (Phản hồi):** Need specific status codes (404, 401). | Throwing generic errors instead of specific ones. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Folder Structure Hierarchy
```text
Project Root
├── .env                  (Cấu hình ẩn)
├── server.js             (Khởi chạy server)
├── app.js                (Khởi tạo Express)
└── src/
    ├── config/           (Cấu hình hệ thống)
    ├── constants/        (Giá trị cố định)
    ├── utils/            (Hàm helper chung)
    ├── models/           (Schema Database)
    ├── repositories/     (Xử lý truy vấn DB)
    ├── services/         (Business Logic)
    ├── controllers/      (Xử lý HTTP)
    ├── routes/           (Định nghĩa API endpoints)
    ├── validations/      (Kiểm tra input)
    └── middlewares/      (Xử lý trung gian)
```

### Request Lifecycle (Flow)
```text
[Client] 
   ↓ (HTTP Request)
[Route (URL)]
   ↓
[Controller] ← (Input Parsing/Validation)
   ↓ (Call Service)
[Service] ← (Business Logic)
   ↓ (Call Repository/Model)
[Model/DB] ← (Query Database)
   ↓ (Return Data)
[Service] ← (Process Result)
   ↓ (Return Data)
[Controller] ← (Format JSON Response)
   ↓ (HTTP Response)
[Middleware (Error)] → (If Error Occurs)
[Client]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Separation of Layers (MVC-Lite)

**Khi nào dùng:** Khi bắt đầu project hoặc khi Controller đang quá dài (> 50 dòng).
**Tại sao đúng:** Dễ test Logic (Service) mà không cần chạy Server.

**Code Demo:**

```javascript
// 1. Controller (Controller.js) - Chỉ xử lý HTTP
const UserService = require('./UserService');

exports.createUser = async (req, res, next) => {
  try {
    const { name, email } = req.body; // Parse Input
    
    // Call Service (Business Logic)
    const newUser = await UserService.register(name, email);
    
    // Format Response
    res.status(201).json({ success: true, data: newUser });
  } catch (error) {
    next(error); // Pass to Error Middleware
  }
};

// 2. Service (UserService.js) - Chỉ xử lý Logic
const User = require('../models/User'); // Database

exports.register = async (name, email) => {
  // Business Rule: Check if email exists
  const existing = await User.findOne({ email });
  if (existing) {
    throw new Error('Email already exists'); // Custom Error
  }
  
  // Logic: Create user
  return await User.create({ name, email });
};
```

### Pattern 2: Centralized Error Handling Middleware

**Khi nào dùng:** Luôn luôn. Để tránh lặp lại `try-catch` ở mọi Controller.
**Tại sao đúng:** Server không crash khi lỗi, log lỗi tập trung.

**Code Demo:**

```javascript
// middleware/errorMiddleware.js

// Phải có 4 tham số (err, req, res, next) để Express nhận diện
const errorHandler = (err, req, res, next) => {
  console.error(err.stack); // Log lỗi ra console

  // Lấy status code hoặc mặc định là 500
  const statusCode = err.statusCode || 500;

  res.status(statusCode).json({
    success: false,
    message: err.message || "Internal Server Error",
    stack: process.env.NODE_ENV === 'production' ? null : err.stack
  });
};

module.exports = errorHandler;

// Sử dụng trong app.js
const errorHandler = require('./middleware/errorMiddleware');
app.use(errorHandler);
```

### Pattern 3: Environment Variables (.env)

**Khi nào dùng:** Khi cần cấu hình Port, Database URI, API Keys.
**Tại sao đúng:** Bảo mật, không hardcode credentials.

**Code Demo:**

```javascript
// .env (File này không commit lên Git)
PORT=5000
NODE_ENV=development
DB_URI=mongodb://localhost:27017/my_db
SECRET_KEY=my_super_secret_key

// server.js
const express = require('express');
require('dotenv').config(); // Load .env variables

const app = express();
const PORT = process.env.PORT || 3000; // Lấy giá trị từ .env

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The "Fat Controller" (Controller "béo")
*   **What:** Controller chứa quá nhiều `if-else`, tính toán, và truy vấn DB (`User.find`, `User.create`).
*   **Why Dangerous (Nguy hiểm):** 
    *   **Không tái sử dụng được:** Nếu bạn muốn dùng logic đó cho Cron Job hoặc CLI, bạn phải copy-paste code.
    *   **Khó unit test:** Phải mock cả Request/Response object.

### 2. Database Connection in Controller
*   **What:** Viết `db.query(...)` hoặc `Model.find(...)` trực tiếp trong file Controller.
*   **Why Dangerous:** Làm Controller dính liền với Database. Nếu đổi DB (ví dụ MongoDB -> PostgreSQL), bạn phải sửa mọi file Controller.

### 3. No Error Middleware
*   **What:** Không có middleware 4 tham số `(err, req, res, next)`.
*   **Why Dangerous:** Khi có lỗi ngoại lệ (exception), Node.js server sẽ crash và dừng hoạt động hoàn toàn cho đến khi restart thủ công.

### 4. Hardcoded Configs
*   **What:** Đặt `const PORT = 3000` hoặc `const DB_URI = '...'` ngay trong file code.
*   **Why Dangerous:** Dễ leak secret keys, khó thay đổi cấu hình khi deploy (Prod vs Dev).

---

## SECTION 6: MASTER CHEAT SHEET

### Logic Flow (If-Else)
```text
IF request arrives:
  1. Validate Input? 
     NO -> Return 400 (Bad Request)
     YES -> Go to Controller
     
  2. Controller extracts data.
     IF parsing fails -> Return 400.
     
  3. Call Service Layer.
     IF Business Logic Fails (e.g. User exists) -> Throw Error (Caught by Middleware).
     IF Success -> Return Data.
     
  4. Controller formats JSON.
     Return 200 or 201.
```

### Top 5 Rules to Remember
1.  **Controller:** Only parse, validate, and call Service.
2.  **Service:** Contains all "If" statements (Business Logic).
3.  **Model:** Only queries the Database.
4.  **Error:** Always use `next(error)` inside `try-catch`.
5.  **Config:** Never commit `.env` to Git.

### HTTP Status Codes
*   `200`: OK (Everything good)
*   `201`: Created (User/Resource created successfully)
*   `400`: Bad Request (Client sent wrong data)
*   `404`: Not Found (Resource doesn't exist)
*   `500`: Internal Server Error (Server crashed or logic failed)

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: MongoDB & Mongoose

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **MongoDB Atlas (Dịch vụ Database đám mây)**: Managed cloud service for MongoDB. Handles scaling, backups, and security.
*   **Cluster (Tập hợp nút)**: A logical grouping of database servers in MongoDB Atlas. Represents your entire database environment.
*   **Mongoose (Thư viện ODM)**: Object Data Modeling library. Bridges MongoDB (NoSQL) and Node.js (OOP).
*   **Schema (Lược đồ)**: The strict blueprint for documents. Defines field types and validation rules.
*   **Model (Mô hình)**: A compiled constructor from a Schema. Represents a MongoDB collection. Used to perform CRUD operations.

### Key Mental Model: "Schema-on-Read" vs "Schema-on-Write"
*   **Raw MongoDB**: Flexible. You can dump *anything* into a collection (Schema-less). You validate data in your app code.
*   **Mongoose**: Strict. You define the **Schema** first. Data is validated **before** it touches the DB (Schema-on-Write).
*   **Why Mongoose?**: It brings discipline, data integrity, and reduces boilerplate validation code. It makes NoSQL feel like SQL (structurally).

---

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

### Table 1: Connection Method
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Production App** | `mongoose.connect(process.env.DB_URI)` | **Security (Bảo mật)**: Hides credentials. **Reconnect Logic (Tự động kết nối lại)**: Handles network blips. | Hardcoding credentials (`"mongodb://..."`) directly in code. |
| **Local Dev** | `.env` file + `mongoose.connect()` | **Environment Separation (Phân biệt môi trường)**: Keeps config separate from logic. | Using the production connection string locally. |

### Table 2: CRUD Operations
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Get List (Lấy danh sách)** | `Model.find({ query })` | Returns an **Array (Mảng)**. Can filter multiple docs. | Using `findOne()` inside a loop to get a list. |
| **Get One (Lấy 1)** | `Model.findById(id)` | Uses MongoDB's `_id`. Optimized for primary key lookup. | `Model.find({ _id: id })` (Returns array, needs `[0]`). |
| **Create (Tạo)** | `Model.create(data)` | Validates data **before** saving. Returns the created doc. | `new Model(data).save()` (More verbose). |
| **Update (Cập nhật)** | `Model.findByIdAndUpdate(id, data)` | Atomic. Updates by ID directly. | Fetching doc -> Modifying in memory -> Saving (Race conditions). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Data Flow Hierarchy
```text
[ Your Node.js App ]
       |
       v
[ Mongoose Library ]  <-- (ODM: Translates JS Objects to BSON)
       |
       v
[ MongoDB Atlas Cluster ]
       |
       v
[ Database ] -> [ Collection ] -> [ Document (JSON-like) ]
```

### Component Relationships
1.  **Schema**: Defines *what* is allowed (Type, Required, Min/Max).
2.  **Model**: Created from Schema. Acts as the *interface* to the database.
3.  **Document**: Created from Model. Represents a *single row* of data.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Definition & Connection
**Khi nào dùng**: Starting a new Node.js project with MongoDB.

```javascript
// 1. Import Mongoose
const mongoose = require('mongoose');
require('dotenv').config(); // Load .env

// 2. Define Schema (Blueprint)
const userSchema = new mongoose.Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  age: { type: Number, min: 0 },
  isActive: { type: Boolean, default: true },
  createdAt: { type: Date, default: Date.now }
});

// 3. Create Model (Collection Interface)
const User = mongoose.model('User', userSchema);

// 4. Connect to DB
async function connectDB() {
  try {
    await mongoose.connect(process.env.DB_URI);
    console.log('MongoDB Connected');
  } catch (err) {
    console.error('Connection Error:', err);
    process.exit(1);
  }
}

module.exports = { User, connectDB };
```

### Pattern 2: CRUD Implementation (Async/Await)
**Khi nào dùng**: Handling API requests (Express.js).

```javascript
// Assume 'User' model is imported from above

async function manageUser() {
  try {
    // CREATE
    // Validates schema before insert
    const newUser = await User.create({
      name: "Khoa",
      email: "khoa@example.com",
      age: 20
    });
    console.log("Created:", newUser._id);

    // READ
    // Find adults, exclude age field in result
    const adults = await User.find({ age: { $gte: 18 } }).select('-age');
    console.log("Adults:", adults);

    // UPDATE
    // { new: true } returns the updated doc, not the old one
    const updated = await User.findByIdAndUpdate(
      newUser._id, 
      { name: "Khoa Updated" }, 
      { new: true, runValidators: true }
    );
    console.log("Updated:", updated.name);

    // DELETE
    const deleted = await User.findByIdAndDelete(newUser._id);
    console.log("Deleted:", deleted ? "Success" : "Failed");

  } catch (err) {
    // Handles: Validation errors, Duplicate keys, Connection drops
    console.error("Operation Failed:", err.message);
  }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Skipping Schema Validation**
    *   **Danger**: If you use Mongoose, never use `insertOne()` or `insertMany()` directly from the driver. These bypass your Mongoose Schema validation.
    *   **Why**: Your database ends up with "dirty" data (wrong types, missing fields) that breaks your application logic later.

2.  **Ignoring Async/Await in CRUD**
    *   **Danger**: `User.find()` returns a **Query Object**, not data immediately.
    *   **Why**: If you don't `await` it, you get a Promise. Trying to log it results in `{ pending }`. You must `await` to get the actual array of documents.

3.  **Not Handling Connection Errors**
    *   **Danger**: App crashes if DB is restarting.
    *   **Why**: Always wrap connection logic in `try/catch` and handle `process.exit(1)` if DB is unreachable on startup.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic
1.  **Need to store data?** -> Create **Schema**.
2.  **Schema ready?** -> Create **Model** (`mongoose.model`).
3.  **Reading data?**
    *   Need one? -> `findById()`.
    *   Need many/filter? -> `find()`.
4.  **Writing data?**
    *   New record? -> `create()`.
    *   Existing record? -> `findByIdAndUpdate()`.
5.  **Removing data?** -> `findByIdAndDelete()`.

### Top 5 Things to Remember
1.  **Connection**: `mongoose.connect(process.env.DB_URI)`.
2.  **Validation**: Happens automatically on `create` and `save`.
3.  **IDs**: Use `findById` for primary key operations.
4.  **Async**: Always `await` Mongoose queries.
5.  **Return**: `create` returns a doc; `find` returns an array.

<!-- CHUNK 61-62 -->

# DEVELOPER DECISION GUIDE: Backend API Development (User Management)

## SECTION 1: CORE MENTAL MODEL

**REST API (Giao diện lập trình ứng dụng thư viện dạng lửa)**: A standardized way for clients to communicate with a server using HTTP methods to manipulate resources.

**CRUD (Tạo, Đọc, Cập nhật, Xóa)**: The four basic persistent storage functions. In a REST API, they map to specific HTTP methods:
- `GET`: Read (Đọc)
- `POST`: Create (Tạo)
- `PUT`/`PATCH`: Update (Cập nhật)
- `DELETE`: Delete (Xóa)

**Mental Model**: Think of your API as a library and your database (MongoDB) as the books. The API is the librarian. The client (Postman/Frontend) asks the librarian to perform actions on books. The librarian checks the request (validation), finds the book (database query), performs the action, and returns a receipt (JSON response).

**Why this approach is better**: REST is stateless and cacheable. It uses standard HTTP features, making it predictable and scalable. MongoDB's flexible schema fits well with the iterative nature of API development.

## SECTION 2: DECISION TABLES (VERY IMPORTANT)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Creating a new user resource. | **POST** /users | `POST` is used to submit an entity to the specified resource, often causing a change in state or side effects on the server. | Using `GET` to create data. `GET` requests should be safe and idempotent (không thay đổi trạng thái server). |
| Retrieving a list of users. | **GET** /users | `GET` requests a representation of the specified resource. Used only to retrieve data. | Returning sensitive data (passwords) in the response. |
| Retrieving a single user by ID. | **GET** /users/{id} | `GET` fetches a specific resource identified by its ID. | Not handling the case where the ID format is invalid (e.g., not a valid ObjectId) or the user doesn't exist (404). |
| Replacing an entire user record. | **PUT** /users/{id} | `PUT` replaces all current representations of the target resource with the request payload. | Using `PUT` for partial updates. Use `PATCH` instead if you only send a few fields. |
| Partially updating a user (e.g., just email). | **PATCH** /users/{id} | `PATCH` applies partial modifications to a resource. | Not validating which fields are allowed to be updated. |
| Removing a user permanently. | **DELETE** /users/{id} | `DELETE` deletes the specified resource. | Not returning a confirmation response (e.g., 204 No Content). |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### HTTP Request Flow (Backend Context)

```text
[Client: Postman/Frontend] 
      |
      v (HTTP Request: GET/POST/... + JSON Body)
[Backend API (Controller/Route)] 
      |
      v (Sanitize & Validate Input)
[Service Layer (Business Logic)]
      |
      v (Query Construction)
[Data Access Layer (Mongoose/MongoDB Driver)]
      |
      v (CRUD Operations)
[MongoDB Atlas (Database)]
      |
      v (Result Set)
[Backend API (Controller)]
      |
      v (JSON Response + Status Code)
[Client: Postman/Frontend]
```

### Error Handling Hierarchy
1. **Validation Layer**: Catch invalid input (e.g., missing email) -> Return `400 Bad Request`.
2. **Database Layer**: Catch connection errors or unique constraint violations -> Return `500 Internal Server Error` or `409 Conflict`.
3. **Logic Layer**: Catch "Not Found" errors -> Return `404 Not Found`.

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Express Route Handler (Basic CRUD Skeleton)
**Khi nào dùng**: Bắt đầu một API mới cần xử lý các phương thức HTTP cơ bản cho một resource (User).

**Tại sao đúng**: Separates routing definition from business logic. Uses `async/await` for cleaner asynchronous code.

```javascript
// server.js
const express = require('express');
const router = express.Router();
const User = require('./models/User'); // Mongoose Model

// 1. CREATE (POST)
router.post('/users', async (req, res) => {
  try {
    const userData = req.body;
    // Validation logic here
    if (!userData.email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    const newUser = new User(userData);
    const savedUser = await newUser.save();
    
    res.status(201).json(savedUser); // 201 Created
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 2. READ ALL (GET)
router.get('/users', async (req, res) => {
  try {
    const users = await User.find({});
    res.status(200).json(users);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 3. READ ONE (GET by ID)
router.get('/users/:id', async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    // Handle invalid ObjectId format
    res.status(400).json({ error: 'Invalid ID format' });
  }
});

// 4. UPDATE (PUT/PATCH)
router.put('/users/:id', async (req, res) => {
  try {
    const updatedUser = await User.findByIdAndUpdate(
      req.params.id, 
      req.body, 
      { new: true } // Return the updated document
    );
    if (!updatedUser) return res.status(404).json({ error: 'User not found' });
    res.status(200).json(updatedUser);
  } catch (error) {
    res.status(400).json({ error: 'Update failed' });
  }
});

// 5. DELETE (DELETE)
router.delete('/users/:id', async (req, res) => {
  try {
    const deletedUser = await User.findByIdAndDelete(req.params.id);
    if (!deletedUser) return res.status(404).json({ error: 'User not found' });
    res.status(204).send(); // No Content
  } catch (error) {
    res.status(500).json({ error: 'Deletion failed' });
  }
});

module.exports = router;
```

### Pattern 2: MongoDB Error Handling Wrapper
**Khi nào dùng**: Khi cần chuyển đổi lỗi hệ thống thành mã lỗi HTTP phù hợp.

**Tại sao đúng**: Prevents sensitive database stack traces from leaking to the client. Provides meaningful error messages.

```javascript
// utils/errorHandler.js
const handleErrors = (err) => {
  console.error(err.message);

  // Default error
  let status = 500;
  let message = 'Internal Server Error';

  // Duplicate key error (MongoDB Code 11000)
  if (err.code === 11000) {
    status = 409;
    message = 'Email already exists';
  }

  // Validation error
  if (err.name === 'ValidationError') {
    status = 400;
    message = Object.values(err.errors).map(val => val.message).join(', ');
  }

  return { status, message };
};

// Usage in route
router.post('/users', async (req, res) => {
  try {
    const user = await User.create(req.body);
    res.status(201).json(user);
  } catch (err) {
    const { status, message } = handleErrors(err);
    res.status(status).json({ error: message });
  }
});
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Trusting Client Input (Tin tưởng đầu vào của client)**
    *   **Danger**: Never assume `req.body` is valid. Always validate fields (type, length, required) using a library like Joi or manual checks before database operations.
    *   **Fix**: Use Mongoose Schemas or middleware validation.

2.  **Skipping Error Handling in Async Routes (Bỏ qua xử lý lỗi trong routes bất đồng bộ)**
    *   **Danger**: If an async function throws an error and you don't have a `try/catch` or `next(err)`, the Node.js process might hang or crash, leaving the client waiting indefinitely.
    *   **Fix**: Always wrap database calls in `try/catch`.

3.  **Returning 500 for Everything (Trả về 500 cho mọi lỗi)**
    *   **Danger**: `500 Internal Server Error` implies the server crashed. If the user sent a bad request (e.g., duplicate email), returning 500 hides the real problem and makes debugging hard.
    *   **Fix**: Distinguish between Client Errors (4xx) and Server Errors (5xx).

4.  **Leaking Stack Traces (Rò rỉ thông tin lỗi hệ thống)**
    *   **Danger**: Sending `err.stack` or raw error objects in the API response exposes internal implementation details, making it easier for attackers to find vulnerabilities.
    *   **Fix**: Log errors on the server; send generic, polite messages to the client.

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  **POST** = Create (201).
2.  **GET** = Read (200), 404 if not found.
3.  **PUT** = Replace whole resource.
4.  **PATCH** = Update part of resource.
5.  **DELETE** = Remove (204 No Content).
6.  **400 Bad Request** = Client sent invalid data.
7.  **404 Not Found** = Resource doesn't exist.
8.  **500 Internal Server Error** = Server failed (code bug or DB down).
9.  **Always Validate** `req.body`.
10. **Never** return raw database errors to the client.

### If-Else Decision Logic
```text
IF operation is "Create User":
  Use POST /users
  Check: Is data valid?
    YES -> Save to DB -> Return 201
    NO -> Return 400
  
ELSE IF operation is "Get User List":
  Use GET /users
  Fetch all -> Return 200

ELSE IF operation is "Get Single User":
  Use GET /users/:id
  Check: Is ID valid format?
    NO -> Return 400
    YES -> Check: Does user exist?
      NO -> Return 404
      YES -> Return 200

ELSE IF operation is "Update User":
  Use PUT /users/:id
  Check: Does user exist?
    NO -> Return 404
    YES -> Update -> Return 200

ELSE IF operation is "Delete User":
  Use DELETE /users/:id
  Check: Does user exist?
    NO -> Return 404
    YES -> Delete -> Return 204
```