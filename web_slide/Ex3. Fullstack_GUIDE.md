# DEVELOPER DECISION GUIDE: Ex3. Fullstack.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:38:22



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Ex3. Fullstack

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
*   **REST API (Representational State Transfer):** Giao thức giao tiếp tiêu chuẩn cho phép frontend và backend trao đổi dữ liệu thông qua các phương thức HTTP (GET, POST, PUT, DELETE).
*   **Pagination (Phân trang):** Kỹ thuật chia nhỏ danh sách dữ liệu thành các phần để hiển thị, giảm tải server và cải thiện trải nghiệm người dùng.
*   **CRUD (Create, Read, Update, Delete):** Bộ 4 thao tác cơ bản trên dữ liệu.
*   **Validation (Hợp lệ hóa):** Kiểm tra dữ liệu đầu vào có tuân thủ quy tắc định dạng trước khi lưu vào database.

### Mental Model (Mô hình tư duy)
Xây dựng Fullstack là quá trình kết nối hai thế giới:
1.  **Backend (Server):** Là "Bộ não". Nó nhận yêu cầu (Request), xử lý logic (Database Query), validate dữ liệu, và trả về kết quả (Response) dưới dạng JSON.
2.  **Frontend (Client):** Là "Giao diện". Nó gửi yêu cầu đến Backend, nhận JSON, sau đó render (hiển thị) dữ liệu HTML/CSS và quản lý trạng thái (State) của người dùng (loading, error, data).

### Why this approach?
Sử dụng **REST API tách biệt (Decoupled)** giúp bạn có thể thay đổi Frontend (ví dụ: từ Web sang Mobile) mà không cần sửa đổi Backend, và ngược lại.

---

## SECTION 2: DECISION TABLES

### When to use API Method & Validation Strategy

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Lấy danh sách dữ liệu** | **GET** + **Query Params** (`page`, `limit`, `search`) | Phân chia dữ liệu rõ ràng, giúp tìm kiếm và điều hướng dễ dàng. | Trả về toàn bộ dữ liệu database (không phân trang) gây treo trình duyệt. |
| **Tạo dữ liệu mới** | **POST** + **Body JSON** | Tránh expose dữ liệu nhạy cảm qua URL. | Dùng GET để tạo dữ liệu (vi phạm nguyên tắc REST). |
| **Cập nhật toàn bộ dữ liệu** | **PUT** + **ID trong URL** + **Body** | Cập nhật chính xác tài nguyên theo ID và thay thế toàn bộ bản ghi. | Dùng PATCH thay cho PUT nếu yêu cầu là thay thế hoàn toàn (hoặc ngược lại). |
| **Xóa dữ liệu** | **DELETE** + **ID trong URL** | Xóa chính xác tài nguyên, không cần gửi body. | Quên xác nhận trước khi xóa (Missing confirmation). |
| **Validate dữ liệu (Backend)** | **Mongoose Schema** (`required`, `match`, `min`) | Đảm bảo dữ liệu "sạch" trước khi vào DB, tránh lỗi vỡ nợ Database. | Chỉ validate ở Frontend (dễ bị hacker bypass). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### System Flow (Text Diagram)
```text
[Người dùng] <=> [Frontend (React)]
      |
      | (HTTP Request: GET /api/users?page=1&search=abc)
      v
[Node.js Server (Express)]
      |
      | (Mongoose Query)
      v
[MongoDB Database]
      |
      | (JSON Data)
      v
[Node.js Server] => (Response: { data: [...], totalPages: 5 })
      |
      v
[Frontend] => Render HTML Table
```

### Component Hierarchy (Frontend)
*   **App (Container):** Quản lý State chính (`users`, `page`, `search`), gọi API.
*   **SearchBar:** Nhập liệu và debounce tìm kiếm.
*   **UserTable:** Hiển thị danh sách (Header + Rows).
*   **Pagination:** Điều khiển chuyển trang.
*   **Modal (Form):** Nhập liệu tạo/sửa, xử lý Validation.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Backend Search & Pagination (Node.js)
**Khi nào dùng:** Khi danh sách dữ liệu quá lớn, cần lọc theo từ khóa.
**Tại sao đúng:** Sử dụng Regex không phân biệt hoa thường (`$options: "i"`) và kết hợp `$or` để tìm kiếm nhiều trường.

```javascript
// backend/server.js
app.get("/api/users", async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 5;
    const search = req.query.search || "";

    // 1. Build Filter
    const filter = search
      ? {
          $or: [
            { name: { $regex: search, $options: "i" } }, // 'i' = case insensitive
            { email: { $regex: search, $options: "i" } },
          ],
        }
      : {};

    // 2. Query with Skip/Limit
    const users = await User.find(filter)
      .skip((page - 1) * limit)
      .limit(limit);

    // 3. Count total for pagination logic
    const total = await User.countDocuments(filter);

    res.json({
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      data: users,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
```

### Pattern 2: Frontend Debounce Search (React)
**Khi nào dùng:** Khi người dùng nhập vào ô tìm kiếm, tránh gọi API quá nhiều lần.
**Tại sao đúng:** Giảm tải server và giúp UI mượt mà.

```javascript
// frontend/SearchBar.js
import { useState, useEffect } from "react";

const SearchBar = ({ onSearch }) => {
  const [input, setInput] = useState("");

  useEffect(() => {
    // Thiết lập bộ đếm (debounce)
    const handler = setTimeout(() => {
      onSearch(input);
    }, 500); // Chờ 500ms sau khi nhập mới gọi

    // Hủy bỏ bộ đếm cũ nếu người dùng tiếp tục nhập
    return () => clearTimeout(handler);
  }, [input]);

  return (
    <input
      type="text"
      placeholder="Tìm kiếm..."
      value={input}
      onChange={(e) => setInput(e.target.value)}
    />
  );
};
```

### Pattern 3: Frontend Render Table & Pagination
**Khi nào dùng:** Hiển thị dữ liệu và điều hướng trang.
**Tại sao đúng:** Phân tách logic hiển thị (UI) với logic lấy dữ liệu (Data).

```javascript
// frontend/App.js
const App = () => {
  const [users, setUsers] = useState([]);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  
  const fetchUsers = async () => {
    const res = await fetch(`http://localhost:3001/api/users?page=${page}`);
    const json = await res.json();
    setUsers(json.data);
    setTotalPages(json.totalPages);
  };

  useEffect(() => { fetchUsers(); }, [page]); // Gọi lại khi page thay đổi

  return (
    <div>
      <table>
        <thead>
          <tr><th>Name</th><th>Age</th><th>Action</th></tr>
        </thead>
        <tbody>
          {users.map((u) => (
            <tr key={u._id}>
              <td>{u.name}</td>
              <td>{u.age}</td>
              <td>
                <button onClick={() => handleDelete(u._id)}>Xóa</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
      
      <div className="pagination">
        <button disabled={page === 1} onClick={() => setPage(p => p - 1)}>Prev</button>
        <span> Trang {page} / {totalPages} </span>
        <button disabled={page === totalPages} onClick={() => setPage(p => p + 1)}>Next</button>
      </div>
    </div>
  );
};
```

### Pattern 4: Update with Validation (PUT)
**Khi nào dùng:** Sửa thông tin đối tượng.
**Tại sao đúng:** `runValidators: true` bắt Schema phải kiểm tra lại dữ liệu mới trước khi cập nhật.

```javascript
// backend/server.js
app.put("/api/users/:id", async (req, res) => {
  try {
    const { id } = req.params;
    // { new: true } trả về data mới sau update
    // { runValidators: true } chạy lại logic check Schema (min, max, pattern)
    const user = await User.findByIdAndUpdate(id, req.body, { 
      new: true, 
      runValidators: true 
    });
    
    if (!user) return res.status(404).json({ error: "Không tìm thấy" });
    res.json({ message: "Cập nhật thành công", data: user });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern (Mẫu xấu) | Why it's dangerous (Tại sao nguy hiểm) |
| :--- | :--- |
| **Dùng GET để xóa/modify** | **Bảo mật:** Dễ bị tool quét web tự động hoặc Google Indexing xóa hết dữ liệu. Chỉ dùng POST/PUT/DELETE. |
| **Quên `await` trong async** | **Logic:** Code sẽ chạy tiếp trước khi lấy dữ liệu từ DB, trả về kết quả rỗng hoặc Promise pending. |
| **Chỉ validate Frontend** | **Bảo mật:** Hacker có thể dùng Postman/Curl để gửi request trực tiếp vào API mà bỏ qua validate của bạn. **Luôn luôn validate ở Backend.** |
| **Không bắt lỗi (Try-Catch)** | **Stability:** Nếu có lỗi DB hoặc logic, server sẽ crash (treo) hoặc trả về trang HTML lỗi khó đọc thay vì JSON rõ ràng. |
| **CORS không cho phép** | **Kết nối:** Frontend (port 3000) sẽ bị chặn khi gọi Backend (port 3001) nếu không có `app.use(cors())`. |

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic Flow
1.  **User Action** (Click Search/Edit) -> **Frontend State Change** -> **API Call**.
2.  **Server** -> **Mongoose Query** -> **DB**.
3.  **DB** -> **Response JSON** -> **Frontend Render**.

### If-Else Decision Rules
*   **IF** Response Status == 400/500: **THEN** Show Error Alert.
*   **IF** Method == GET: **THEN** Use `req.query`.
*   **IF** Method == POST/PUT: **THEN** Use `req.body`.
*   **IF** Data List > Limit: **THEN** Enable Pagination (`skip/limit`).
*   **IF** User types in Search: **THEN** Debounce 500ms.

### Top 5 Things to Remember
1.  **CORS is mandatory** for 2 separate ports.
2.  **Regex `i` flag** is case-insensitive search.
3.  **Pagination math:** `(page - 1) * limit` is the `skip` value.
4.  **PUT requires ID** in URL.
5.  **Frontend Validation is for UX, Backend Validation is for Security.**

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: EX3 FULLSTACK

## SECTION 1: CORE MENTAL MODEL

### Key Concepts

**Pagination (Phân trang):**
Quản lý dữ liệu lớn bằng cách chia thành các phần nhỏ hơn, tải theo yêu cầu để tối ưu hiệu năng và UX.

**Optimistic UI Update (Cập nhật UI tối ưu):**
Logic: Cập nhật state UI ngay lập tức sau hành động user (nhấn nút), thay vì đợi confirm từ server. Nếu server trả về lỗi, rollback state lại.

```javascript
// Core Backend Logic: Phân trang & Tìm kiếm
async function getUsers(req, res) {
  try {
    // 1. Parse inputs
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 5;
    const search = req.query.search || "";
    
    // 2. Tính toán logic
    const skip = (page - 1) * limit; // Logic toán học
    
    // 3. Xây dựng filter
    const filter = search ? {
      $or: [
        { name: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } }
      ]
    } : {};

    // 4. Parallel Execution (Tối ưu tốc độ)
    const [users, total] = await Promise.all([
      User.find(filter).skip(skip).limit(limit),
      User.countDocuments(filter)
    ]);

    // 5. Trả về cấu trúc chuẩn
    return res.json({
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
      data: users
    });
  } catch (err) {
    return res.status(500).json({ error: err.message });
  }
}
```

**Why this approach is better:**
- **Tốc độ:** `Promise.all` chạy song song find và count, giảm thời gian response.
- **An toàn:** `skip` và `limit` của MongoDB đảm bảo phân chia dữ liệu chính xác.
- **Mở rộng:** Dễ dàng thêm filter mà không phá vỡ cấu trúc.

---

## SECTION 2: DECISION TABLES

### Table 1: CRUD HTTP Methods

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Tạo mới tài nguyên (User) | **POST** | Semantic method cho tạo dữ liệu. Trả về `201 Created`. | Dùng `GET` để tạo (vi phạm quy ước, không an toàn). |
| Cập nhật toàn bộ tài nguyên | **PUT** | Thay thế toàn bộ tài nguyên hiện có. Idempotent (gọi nhiều lần kết quả giống nhau). | Dùng `PUT` cho cập nhật một phần trường (nên dùng `PATCH`). |
| Xóa tài nguyên | **DELETE** | Xác định ý định xóa rõ ràng. | Dùng `GET` để xóa (dễ bị crawl công cụ tự động xóa dữ liệu). |

### Table 2: Data Validation Strategy

| Tình huống sử dụng | Nên dùng gì | Sai lầm thường gặp |
| :--- | :--- | :--- |
| Kiểm tra dữ liệu bắt buộc (Email, Age) | **Schema Validation (Mongoose)** | Để validator ở Frontend thôi. |
| Kiểm tra logic nghiệp vụ (Age > 0) | **Schema Validation (Mongoose)** | Kiểm tra bằng `if/else` lung tung trong Controller. |
| Kiểm tra ID hợp lệ trước khi xóa/sửa | **Check `if (!user)` return 404** | Cố gắng xóa/sửa ID sai, server crash hoặc trả về 500. |

### Table 3: Frontend Fetching Strategy

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| User gõ tìm kiếm | **Debounce (200ms)** | Tránh spam API call khi user gõ nhanh. | Gọi API mỗi lần `onChange` keystroke. |
| Logic thay đổi (Page, Search, Limit) | **useEffect với dependency array** | Tự động gọi lại API khi state thay đổi. | Gọi API thủ công ở nhiều nơi, khó bảo trì. |
| Cập nhật UI sau CRUD | **Fetch lại danh sách (Refetch)** | Đảm bảo dữ liệu hiển thị khớp với database. | Cập nhật mảng `users` ở state locally (dễ sai lệch). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Backend Controller Flow

```text
[Client Request] 
      ⬇
[Express Router] (/api/users)
      ⬇
[Middleware] (Parse Query: page, limit, search)
      ⬇
[Service Layer] (Logic: Tính skip, Build filter $or/$regex)
      ⬇
[Database] (Mongoose: find().skip().limit() + countDocuments)
      ⬇
[Response] (JSON: { data, pagination_info })
```

### Frontend Component Tree

```text
App (State Container)
├── SearchBar (Controlled Input)
├── Action Area (Add Button + Modal Trigger)
├── UserTable (Display Data)
│   └── UserRow (Edit/Delete Actions)
├── Pagination (Controls: Next/Prev + Limit)
└── UserModal (Form: Add/Edit)
    ├── Input Fields (Name, Age, Email, Address)
    └── Submit Handler (POST or PUT)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Backend Validated Update (PUT)

**Khi nào dùng:** Cập nhật thông tin user, chỉ update những trường được gửi lên, không ghi đè `null` vào trường trống.

**Tại sao đúng:** `runValidators: true` đảm bảo dữ liệu mới hợp lệ. `new: true` trả về document sau khi update (không cần fetch lại).

```javascript
// PUT /api/users/:id
app.put("/api/users/:id", async (req, res) => {
  try {
    const { id } = req.params;
    // Lọc các trường có giá trị thực tế để tránh ghi đè null
    const updateData = Object.keys(req.body).reduce((acc, key) => {
      if (req.body[key] !== "" && req.body[key] != null) {
        acc[key] = req.body[key];
      }
      return acc;
    }, {});

    const updatedUser = await User.findByIdAndUpdate(
      id,
      updateData, // Chỉ update data hợp lệ
      { new: true, runValidators: true } // Quan trọng
    );

    if (!updatedUser) {
      return res.status(404).json({ error: "Không tìm thấy người dùng" });
    }

    res.json({ message: "Cập nhật thành công", data: updatedUser });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});
```

### Pattern 2: Frontend Search Debounce

**Khi nào dùng:** Khi có ô Search nhập liệu, muốn giảm lượng request API.

**Tại sao đúng:** Tách biệt `input state` (nhập từng ký tự) với `filter state` (gọi API), dùng `setTimeout` để đợi user ngừng gõ.

```javascript
function SearchBar({ onChange }) {
  const [searchInput, setSearchInput] = React.useState("");

  React.useEffect(() => {
    const timer = setTimeout(() => {
      // Chỉ gọi callback sau 200ms
      onChange(searchInput);
    }, 200);

    return () => clearTimeout(timer); // Dọn dẹp khi unmount hoặc input thay đổi
  }, [searchInput]);

  return (
    <input
      type="text"
      placeholder="Tìm theo tên, email..."
      value={searchInput}
      onChange={(e) => setSearchInput(e.target.value)}
    />
  );
}
```

### Pattern 3: Safe Delete with Confirmation

**Khi nào dùng:** Khi xóa dữ liệu quan trọng.

**Tại sao đúng:** Sử dụng `window.confirm` để tránh xóa nhầm. Gọi API xong phải refresh lại list.

```javascript
// Component UserTable
const handleDelete = (id, name) => {
  // 1. Client-side guard
  if (!window.confirm(`Xóa ${name}?`)) return;

  // 2. API Call
  fetch(`http://localhost:3001/api/users/${id}`, {
    method: "DELETE"
  })
  .then(res => {
    if (!res.ok) throw new Error("Xóa thất bại");
    // 3. Optimistic Update hoặc Refetch
    // Ở đây nên Refetch để đảm bảo đồng bộ server
    window.location.reload(); // Hoặc gọi fetchUsers() từ App nếu dùng state lift-up
  })
  .catch(err => alert(err.message));
};
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Dùng `GET` để xóa dữ liệu:**
    *   **Lý do nguy hiểm:** Các công cụ tự động (crawlers), trình duyệt tự prefetch link có thể vô tình gọi URL và xóa mất dữ liệu người dùng.
    *   **Đúng:** Dùng `DELETE`.

2.  **Bỏ qua `runValidators: true` trong Update:**
    *   **Lý do nguy hiểm:** Mongoose mặc định không chạy validator khi update. Bạn có thể lưu dữ liệu sai quy định (VD: `age: -10`) vào database.
    *   **Đúng:** Luôn dùng `{ new: true, runValidators: true }`.

3.  **Update State Frontend trực tiếp sau CRUD:**
    *   **Lý do nguy hiểm:** Dữ liệu trong state React và Database dễ bị lệch nhau nếu logic phức tạp hoặc API fail.
    *   **Đúng:** Luôn gọi lại `fetchUsers()` (Refetch) sau mọi hành động Modify (POST/PUT/DELETE).

4.  **Lấy `page` và `limit` từ FE mà không kiểm soát:**
    *   **Lý do nguy hiểm:** FE có thể gửi `page: -999` hoặc `limit: 1000000`, gây lỗi database hoặc crash server.
    *   **Đúng:** Đặt giá trị mặc định (default) và giới hạn (max) ở Backend.

5.  **Trả về `password` hoặc sensitive data trong API Response:**
    *   **Lý do nguy hiểm:** Leakage bảo mật.
    *   **Đúng:** Sử dụng `.select('-password')` hoặc map dữ liệu trước khi trả về.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Logic Flow

1.  **Input:** `Page`, `Limit`, `Search` (Query String).
2.  **Math:** `Skip = (Page - 1) * Limit`.
3.  **Filter:** `Search ? { $or: [ { name: regex }, { email: regex } ] } : {}`.
4.  **Parallel:** `Promise.all([ Find, Count ])`.
5.  **Response:** `{ data, total, totalPages, page, limit }`.

### Top 5 Rules to Remember

1.  **Promise.all()** is your best friend for "Get List" (Find + Count).
2.  **{ new: true, runValidators: true }** is mandatory for Update.
3.  **DELETE** method only for removing data.
4.  **Debounce (200ms)** for Search inputs.
5.  **Refetch after CRUD** to keep UI in sync.

### Error Handling Matrix

| Error Type | HTTP Status | Action |
| :--- | :--- | :--- |
| Input Invalid (Schema/Type) | `400 Bad Request` | Return error message to FE. |
| Resource Not Found (ID not exist) | `404 Not Found` | Return specific error message. |
| Server Crash/DB Error | `500 Internal Server Error` | Log error, return generic message. |

<!-- CHUNK 21-28 -->

# DEVELOPER DECISION GUIDE: Fullstack.pdf

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **Pagination (Phân trang):** Quá trình chia nhỏ dữ liệu thành các phần (trang) riêng biệt để hiển thị, giúp tối ưu hiệu năng và trải nghiệm người dùng.
*   **CRUD Operations (Thao tác CRUD):** Bốn chức năng cơ bản của phần mềm: **C**reate (Tạo), **R**ead (Đọc), **U**pdate (Cập nhật), **D**elete (Xóa).
*   **Controlled Component (Component được kiểm soát):** Component React mà giá trị input (HTML) được điều khiển hoàn toàn bởi state của React (props/value).
*   **RESTful API:** Kiến trúc giao tiếp sử dụng HTTP request (GET, POST, PUT, DELETE) để tương tác với tài nguyên (resources) trên server.

### Mental Models

1.  **State-Driven UI (UI do State điều khiển):**
    *   **Reality:** UI chỉ là hình ảnh phản chiếu của state. Khi state (`page`, `limit`, `users`) thay đổi, UI tự động re-render.
    *   **Why:** Đảm bảo tính nhất quán. Dễ dàng Debug vì logic tập trung tại một nơi (state).

2.  **Single Source of Truth (Nguồn sự thật duy nhất):**
    *   **Reality:** Dữ liệu người dùng (User Data) chỉ nên được lưu trữ ở một nơi (mảng `users` trong `App`), không nên trùng lặp trong Modal hay Table.
    *   **Why:** Tránh lỗi đồng bộ dữ liệu (ví dụ: xóa trong Table nhưng Modal vẫn giữ dữ liệu cũ).

3.  **Request-Response Cycle (Chu kỳ Request-Response):**
    *   **Reality:** Frontend không tự sinh dữ liệu. Nó phải "hỏi" Backend qua `fetch`, xử lý kết quả (thành công hoặc lỗi), rồi cập nhật UI.
    *   **Why:** Phân tách trách nhiệm. Frontend lo giao diện, Backend lo dữ liệu.

---

## SECTION 2: DECISION TABLES

### Table 1: Form Handling Strategy

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Form đơn giản, ít input** | **Controlled Component** (State update `onChange`) | Dễ validate logic JS ngay lập tức, code nhất quán với React. | Để `value={state}` nhưng không có `onChange`. Gây lỗi "Read-only". |
| **Form phức tạp, nhiều field** | **Controlled Component + Dynamic State** | Tránh lặp code. Cấu trúc state là Object thay vì nhiều biến riêng biệt. | Tạo 1 state riêng cho từng input (`nameState`, `ageState`) → Khó quản lý. |
| **Xử lý dữ liệu trước khi gửi API** | **Data Sanitization (Chuẩn hóa)** | Dọn dẹp dữ liệu (trim whitespace) trước khi POST/PUT. | Gửi dữ liệu "bẩn" (dấu cách thừa) → Backend reject hoặc lưu sai. |

### Table 2: API Interaction Logic

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cập nhật UI sau CRUD** | **Gọi lại API (Refetch)** | `fetchUsers()` lại sau khi Create/Update/Delete để đảm bảo dữ liệu hiển thị khớp với Database. | Cập nhật state local (splice array) nhưng không sync với DB → Lạc hậu. |
| **Phân biệt Thêm vs Sửa** | **Kiểm tra `user` object** | Nếu `user` tồn tại (truthy) → Dùng phương thức `PUT`. Nếu không → Dùng `POST`. | Viết 2 component Modal hoàn toàn riêng biệt (AddModal, EditModal) → Lặp code. |
| **Reset Input khi đổi Limit** | **Set `page` về 1** | Khi hiển thị nhiều hơn/trên 1 trang, việc giữ nguyên số trang cũ có thể trống rỗng hoặc sai chỉ số. | Để nguyên `page` hiện tại khi `limit` thay đổi → Dữ liệu không khớp. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Component Hierarchy

```text
[ App (State Container) ]
       |
       +-- [ SearchBar ]
       |
       +-- [ UserTable ]
       |       |
       |       +-- (Render row từ state `users`)
       |       +-- [ Delete Button ] -> Call API DELETE
       |
       +-- [ Pagination ]
       |       |
       |       +-- (Control `page`, `limit`) -> Call `onPageChange`, `onLimitChange`
       |
       +-- [ UserModal ]
               |
               +-- (Local State: `formData`, `errors`)
               +-- Validate -> Call API POST/PUT -> `onSave()` (Refetch Parent)
```

### Data Flow Logic

1.  **App** fetches data (GET) -> Passes `users` to **UserTable**.
2.  **Pagination** changes -> Updates `App` state -> **App** refetches data.
3.  **UserTable** Edit click -> Opens **UserModal** with `user` prop.
4.  **UserModal** Save -> Calls API (PUT/POST) -> Calls `onSave` -> **App** refetches & closes modal.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Dynamic Input Handling & Validation (UserModal)

**Khi nào dùng:** Khi build form modal có nhiều input, cần validate trước khi gửi API.

**Tại sao đúng:** Sử dụng một hàm `handleChange` duy nhất xử lý tất cả các field, và một hàm `validate` để tách biệt logic kiểm tra dữ liệu khỏi UI.

```javascript
function UserModal({ user, onClose, onSave }) {
  // 1. Khởi tạo state động
  const [formData, setFormData] = React.useState(
    user || { name: "", age: "", email: "", address: "" }
  );
  const [errors, setErrors] = React.useState({});

  // 2. Handler động cho mọi input
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  // 3. Logic Validate (Sanitize data)
  const validate = () => {
    const newErrors = {};
    // Chuẩn hóa: trim whitespace
    const nameClean = formData.name?.trim();
    
    if (!nameClean || nameClean.length < 2) newErrors.name = "Tên ít nhất 2 ký tự";
    if (!formData.age || formData.age < 0) newErrors.age = "Tuổi >= 0";
    if (!formData.email?.includes("@") || !formData.email?.includes(".")) 
      newErrors.email = "Email không hợp lệ";

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // 4. Submit Logic (Phân loại POST/PUT)
  const handleSubmit = () => {
    if (!validate()) return;

    const method = user ? "PUT" : "POST";
    const url = user 
      ? `http://localhost:3001/api/users/${user._id}` 
      : `http://localhost:3001/api/users`;

    // Chuẩn hóa dữ liệu trước khi gửi
    const payload = { ...formData, name: formData.name.trim() };

    fetch(url, {
      method,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    })
    .then(res => res.json())
    .then(data => {
      if (data.error) throw new Error(data.error);
      alert(data.message);
      onSave(); // Trigger refetch ở component cha
    })
    .catch(err => alert("Lỗi: " + err.message));
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={e => e.stopPropagation()}>
        <h3>{user ? "Sửa người dùng" : "Thêm người dùng"}</h3>
        
        {/* Rendering Input với Error */}
        <label>Họ tên *</label>
        <input name="name" value={formData.name} onChange={handleChange} />
        {errors.name && <p className="error">{errors.name}</p>}

        <label>Email *</label>
        <input name="email" value={formData.email} onChange={handleChange} />
        {errors.email && <p className="error">{errors.email}</p>}

        <div className="modal-actions">
          <button onClick={handleSubmit}>Lưu</button>
          <button onClick={onClose}>Hủy</button>
        </div>
      </div>
    </div>
  );
}
```

### Pattern 2: Event Propagation in Modals (Overlay Click)

**Khi nào dùng:** Đóng Modal khi click ra ngoài (overlay), nhưng không đóng khi click vào nội dung bên trong.

**Tại sao đúng:** Sử dụng `e.stopPropagation()` để ngăn chặn sự kiện click "bong bóng" lên phần tử cha (overlay).

```javascript
// Trong component Modal
const ModalContent = ({ onClose }) => {
  return (
    // Click vào overlay gọi onClose
    <div className="modal-overlay" onClick={onClose}>
      
      {/* Click vào nội dung -> Stop -> Không gọi onClose */}
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <p>Nội dung modal...</p>
        <button onClick={onClose}>Đóng</button>
      </div>
      
    </div>
  );
};
```

### Pattern 3: Reset State on Dependency Change

**Khi nào dùng:** Khi `limit` (số dòng/trang) thay đổi, cần reset `page` về 1 để tránh lỗi hiển thị.

**Tại sao đúng:** `useEffect` bắt nguồn từ dependency `[limit]` giúp tự động hóa logic reset state.

```javascript
// Trong component App
const [page, setPage] = React.useState(1);
const [limit, setLimit] = React.useState(5);

// Khi limit thay đổi -> Reset page về 1
React.useEffect(() => {
  setPage(1); 
}, [limit]); 

const handleLimitChange = (newLimit) => {
  setLimit(newLimit); // Kích hoạt useEffect ở trên
};

// Logic tính số thứ tự tăng dần
// (page - 1) * limit + 1
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

| Anti-Pattern | Lý do nguy hiểm | Giải pháp đúng |
| :--- | :--- | :--- |
| **Lặp lại Logic Validate** | Viết lại quy tắc kiểm tra email/tuổi ở nhiều nơi (Modal, API) -> Rủi ro thay đổi không nhất quán. | Đặt logic validate vào một hàm chung (`validate()`) hoặc Util function. |
| **Thiếu `e.stopPropagation()`** | Click vào Modal (nội dung) sẽ đóng Modal ngay lập tức do bubble event lên Overlay. | Luôn thêm `onClick={(e) => e.stopPropagation()}` vào phần tử nội dung. |
| **Alert lỗi chung chung** | `alert("Lỗi hệ thống")` không giúp người dùng sửa lỗi (VD: Email trùng). | Kiểm tra code lỗi trả về (400, 409) và hiển thị chi tiết `data.error` hoặc `err.message`. |
| **Xóa dữ liệu không Refetch** | Xóa item trong Database nhưng List UI không cập nhật vì không gọi lại API GET. | Luôn gọi `fetchUsers()` sau thao tác POST/PUT/DELETE thành công. |
| **Bỏ qua `trim()`** | Cho phép tên " Admin " (có dấu cách) lưu vào DB, gây lỗi tìm kiếm/so sánh sau này. | Dùng `str.trim()` trước khi gửi dữ liệu lên Backend (`handleSubmit`). |

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules (Logic If-Else)

1.  **If** user clicks "Lưu" **Then** `validate()` -> **If** valid -> `fetch()` (POST/PUT).
2.  **If** `user` object được truyền vào Modal **Then** Mode "Sửa" (PUT) -> **Else** Mode "Thêm" (POST).
3.  **If** API trả về lỗi **Then** `alert(data.error)` -> **Else** `alert(data.message)` + `onSave()`.
4.  **If** `limit` thay đổi **Then** `setPage(1)`.
5.  **If** Click overlay **Then** `onClose()` -> **Else** (Click content) `stopPropagation()`.

### Top 5 Things to Remember

1.  **Sanitize Input:** Luôn `.trim()` string trước khi gửi API.
2.  **State Reset:** Đổi số dòng/trang -> Về trang 1.
3.  **Refetch:** Bất kỳ thao tác thay đổi dữ liệu (C/U/D) nào cũng phải gọi lại API Read.
4.  **Safe Modal:** `onClick={onClose}` trên overlay + `stopPropagation()` trên content.
5.  **Code Reuse:** Modal xử lý cả Thêm và Sửa chỉ bằng cách kiểm tra `props.user`.