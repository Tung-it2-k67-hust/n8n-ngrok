# DEVELOPER DECISION GUIDE: Lec 4-JavaScript.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:54:01



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: JavaScript Core

---

## SECTION 1: CORE MENTAL MODEL

### 1.1. Core Definitions
*   **Just-In-Time Compilation (JIT - Biên dịch tại thời điểm chạy)**: JavaScript code is compiled into machine code right before execution by the JS Engine (e.g., V8), not purely interpreted line-by-line.
*   **Single-Threaded (Đơn luồng)**: JavaScript executes code on one main thread. It handles concurrency via the Event Loop, not parallel execution.
*   **Prototype-Based (Dựa trên prototype)**: Objects inherit directly from other objects. There are no classes in the traditional sense; "classes" are syntactic sugar over prototypes.
*   **Dynamic & Weakly Typed (Động và弱 typing)**: Variable types are not fixed and are determined at runtime; type coercion happens automatically (often unexpectedly).

### 1.2. Mental Model: The Execution Environment
JavaScript does not live in a vacuum. It requires a **Host Environment** which provides the **Runtime**.
1.  **Browser (Client-side)**: Handles UI, Network, Storage. Main entry point is the `window` object.
2.  **Node.js (Server-side)**: Handles file system, HTTP, Processes. Main entry point is the `global` object.
3.  **Core Language (ECMAScript)**: The syntax, logic, and built-in objects (`Array`, `Object`, `Map`) that run identically in both environments.

### 1.3. Framework vs. Library
*   **Library (Thư viện)**: You are in control. You call the library functions when you need them.
*   **Framework (Khung ứng dụng)**: The framework is in control. It calls your code (Inversion of Control).

**Code Demo: Mental Model Application**
```javascript
// 1. Dynamic Typing (Duck Typing)
let data = "100"; // String
data = Number(data); // Now Number
console.log(typeof data); // "number"

// 2. Prototype Inheritance (Prototype-based)
const animal = { eats: true };
const rabbit = Object.create(animal); // rabbit inherits 'eats' from animal
console.log(rabbit.eats); // true

// 3. Environment Differences (Global Scope)
// Browser: window.alert('Hello')
// Node.js: global.console.log('Hello')
// Universal: alert('Hello') or console.log('Hello')
```

---

## SECTION 2: DECISION TABLES

### Table 1: Java vs. JavaScript
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Enterprise Backend System** | **Java** | **Static Typing (Kiểu tĩnh)** & **Multi-threading (Đa luồng)** ensures robustness for complex, CPU-heavy logic. | Assuming Node.js (JS) is suitable for heavy CPU calculation without Worker Threads. |
| **Web UI / Interactive Script** | **JavaScript** | **Single-Threaded + Event Loop** is optimized for non-blocking I/O (User clicks, Network). Lightweight. | Writing synchronous code that blocks the main thread (UI freezes). |
| **Cross-Platform Mobile** | **JavaScript** | **React Native / Ionic** allows code reuse across iOS/Android using web skills. | Expecting 100% native performance for heavy animations without native modules. |

### Table 2: Library vs. Framework
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Adding specific functionality (e.g., Charts)** | **Library** | **You call it**. Low intrusion. Easy to integrate into existing legacy projects. | Trying to force a library to manage the entire application state (reinventing a framework). |
| **Building a scalable SPA/PWA** | **Framework** | **It calls you**. Enforces structure (MVC/MVVM). Handles routing and lifecycle automatically. | Fighting the framework's architecture (e.g., bypassing Vue's reactivity or React's state flow). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The JavaScript Ecosystem Hierarchy
```text
[ HOST ENVIRONMENT ] <-------------------> [ CORE LANGUAGE (ECMAScript) ]
          |                                         |
    +-----------+                               +----------------+
    |  Browser  |                               | Syntax         |
    | (Window)  |--[ DOM / BOM APIs ]----------|| Types          |
    |           |                              | Logic          |
    +-----------+                              | Built-in Obj   |
                                               +----------------+
                                                       |
                                                [ RUNTIME ]
                                              (Call Stack, Heap)
```

### Event Loop Logic (The Relationship)
1.  **Call Stack (Đống gọi)**: Executes synchronous code (Top to bottom).
2.  **Web APIs / C++ APIs**: Handles async tasks (Timers, Fetch, Events).
3.  **Callback Queue (Task Queue)**: Stores callbacks ready to execute.
4.  **Event Loop**: Constantly checks "Is Call Stack empty?". If yes, moves first item from Callback Queue to Call Stack.

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Asynchronous Non-Blocking (The "Node Way")
**Khi nào dùng:** When fetching data or reading files without freezing the UI/Server.
**Tại sao đúng:** Utilizes the Event Loop to free the main thread while waiting for I/O.

```javascript
// Synchronous (Bad for server/web) - Blocks everything
// const fs = require('fs');
// const data = fs.readFileSync('file.txt'); 

// Asynchronous (Good) - Non-blocking
function fetchData(callback) {
    console.log("Start fetching...");
    
    // Simulate network delay (2 seconds)
    setTimeout(() => {
        const data = { id: 1, name: "JavaScript" };
        callback(null, data); // Execute callback when done
    }, 2000);

    console.log("Fetching in background... UI remains responsive");
}

fetchData((err, data) => {
    if (err) return console.error(err);
    console.log("Received:", data);
});
```

### Pattern 2: Object-Oriented vs. Functional
**Khi nào dùng:**
*   **OOP (Prototype/Class):** When managing stateful entities (User, Product, GameCharacter).
*   **Functional:** When processing data streams, transformations (Immutable).

```javascript
// OOP Pattern (Prototype/Class)
class User {
    constructor(name) {
        this.name = name;
    }
    greet() {
        return `Hello, I am ${this.name}`;
    }
}

// Functional Pattern (Pure Functions)
const formatName = (name) => name.toUpperCase();

const user = new User("Alice");
console.log(user.greet()); // OOP
console.log(formatName("Bob")); // Functional
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Using `==` (Loose Equality)
**Danger:** Triggers unexpected **Type Coercion (Chuyển đổi kiểu)**.
**Why:** JS attempts to convert types to match, leading to bugs like `0 == false` (true).
**Fix:** Always use `===` (Strict Equality).

```javascript
// Anti-Pattern
if (0 == false) { /* This runs, which is confusing */ }

// Safe
if (0 === false) { /* This does not run, as expected */ }
```

### 2. Blocking the Main Thread
**Danger:** Using `while` loops or heavy synchronous math inside the main thread.
**Why:** In Browser, the UI freezes. In Node.js, the server cannot handle other requests.
**Fix:** Use `setTimeout`, `setImmediate`, or Async/Await.

### 3. Ignoring `var` vs `let/const`
**Danger:** `var` has **Function Scope (Phạm vi hàm)** and **Hoisting (Nâng lên đầu)**.
**Why:** Variables declared inside blocks (loops/if) using `var` leak outside, causing data corruption.
**Fix:** Always use `const` (default), `let` (when reassigning).

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **JS is Single-Threaded:** Use Async for heavy tasks.
2.  **Always use `===`:** Avoid type coercion bugs.
3.  **Use `const` first:** Switch to `let` only if needed.
4.  **Modern JS (ES6+):** Use Arrow functions `=>`, Destructuring `const {x} = obj`.
5.  **DOM vs JS:** Separate your logic (JS) from your view (HTML/CSS).
6.  **Library is a Tool, Framework is a Blueprint:** Don't build a house with only a hammer; use a blueprint for large apps.
7.  **Browser != Node:** `window` exists in Browser, `require()` exists in Node.
8.  **Array Methods:** Master `.map()`, `.filter()`, `.reduce()` instead of `for` loops.
9.  **Error Handling:** Always catch promises with `.catch()` or `try/catch` in async/await.
10. **Event Loop:** Remember: Microtasks (Promises) run before Macrotasks (setTimeout).

### Decision Logic (If-Else)
```javascript
if (task.isHeavyCPU()) {
    // Use Web Workers (Browser) or Worker Threads (Node)
    // Do NOT run on main thread
} else if (task.isIOPerformanceCritical()) {
    // Use Node.js (Server)
} else if (task.isUIInteractivity()) {
    // Use JavaScript (Browser)
}
```

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Lec 4-JavaScript.pdf

## SECTION 1: CORE MENTAL MODEL

### Execution Model & Variables

**JavaScript Engine (Bộ máy JavaScript)**: Runs on a single thread (một luồng duy nhất), handling tasks concurrently (xử lý song song) via the Event Loop, not parallel execution.

**Variable Declaration**:
- **`var`**: Function scope/phạm vi hàm, **Hoisting (Nâng đỡ)** brings declaration to top with `undefined` value. Avoid.
- **`let`**: Block scope/phạm vi khối, **Temporal Dead Zone (TDZ - Vùng chết thời gian)** prevents access before declaration.
- **`const`**: Block scope, immutable reference (tham chiếu bất biến), but object content can change.

```javascript
// Code Demo: Scope & Hoisting Behavior
function scopeDemo() {
    // Hoisting: 'var' is undefined, 'let/const' in TDZ (cannot access)
    console.log(a); // undefined (var hoisted)
    // console.log(b); // ReferenceError (TDZ)
    
    var a = 10;
    let b = 20;
    const c = { val: 30 }; // Reference is constant, content is mutable
    c.val = 40; // Allowed
    
    if (true) {
        let blockVar = 50; // Only exists inside this block
    }
    // console.log(blockVar); // ReferenceError
}
```

### Data Types & Equality

**Mental Model**:
- **Primitives (Giá trị nguyên thủy)**: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`. Copied by **value (theo giá trị)**.
- **Reference Types (Tham chiếu)**: `Object`, `Array`. Stored as pointers; copied by **reference (theo tham chiếu)**.

**Equality Decision**:
- Use **`===` (Strict Equality - Đẳng thức nghiêm ngặt)**: Compares value AND type. No type coercion (ép loại).
- Avoid **`==` (Loose Equality)**: Allows type coercion, unpredictable.

```javascript
// Code Demo: Value vs Reference & Equality
// Value Copy
let x = 10;
let y = x;
y = 20; 
console.log(x); // 10 (x is unaffected)

// Reference Copy
let arr1 = [1, 2];
let arr2 = arr1;
arr2.push(3);
console.log(arr1); // [1, 2, 3] (arr1 is affected)

// Equality
console.log(5 == '5');  // true (Coercion)
console.log(5 === '5'); // false (Strict)
```

---

## SECTION 2: DECISION TABLES

### Variable Declaration Strategy

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Value needs to change** | `let` | **Block scope (phạm vi khối)** prevents leaks; **TDZ (Vùng chết thời gian)** ensures safety before init. | Using `var` because it's "easier", causing **Hoisting** bugs and global pollution. |
| **Value must NOT change** | `const` | Enforces **Immutability (Bất biến)** intent; prevents accidental reassignment. | Using `var` or `let` for constants, leading to logic errors if value is overwritten. |
| **Legacy / Pre-ES6 code** | `let` / `const` | Modern standards ensure **Predictability (Tính dự đoán)**. | Forgetting to refactor `var`, causing **Global Object Binding** (leaking to `window`). |

### Operators & Embedding

| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| **Comparing values in logic** | `===` | **Strict Equality (Đẳng thức nghiêm ngặt)**: No **Type Coercion (Ép loại)**. Prevents `0 == false` bugs. | Using `==` for convenience, causing hidden bugs when types differ. |
| **Loading scripts** | External `<script src="...">` | **Scalability (Mở rộng)**, **Caching (Bộ nhớ đệm)**, Separation of Concerns. | Using **Inline** or **Internal** scripts, making code hard to maintain and slowing page loads. |
| **Script execution timing** | Place `<script>` at end of `<body>` | Allows DOM to parse **before** JS runs, preventing "Element not found" errors. | Placing `<script>` in `<head>` without `defer`, blocking rendering. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The JavaScript Execution Hierarchy

```text
[ Browser Environment ]
       |
       v
[ JavaScript Engine ] (Single Threaded)
       |
       +-- [ Call Stack ] <-----------------------+
       |      | (LIFO: Last In, First Out)        |
       v      v                                   |
[ Execution Context ]                             |
       |      | (Created for function calls)      |
       |      v                                   |
       +--> [ Variable Environment ]              |
       |      +-- var: Hoisted (undefined)        |
       |      +-- let/const: TDZ (Temporal Dead Zone)
       |                                          |
       +--> [ Reference to Global Object ]        |
            +-- var: Binds to `window`            |
            +-- let/const: Does NOT bind          |
                                                ^
                                                |
[ Event Loop ] (Handling Concurrency) -----------+
       |
       +-- [ Web APIs ] (setTimeout, DOM, etc.)
```

**Relationship Summary**:
- **ASI (Automatic Semicolon Insertion)** acts as a parser safety net, but is unreliable.
- **Primitives** sit in the **Variable Environment** directly.
- **Reference Types** point to memory addresses outside the stack.

---

## SECTION 4: CODE PATTERNS

### Pattern 1: The "Block Scope" Guard
**Khi nào dùng**: When you need a temporary variable inside an `if` or `loop` that shouldn't leak to the outer scope.
**Tại sao đúng**: Using `let` or `const` respects block boundaries, preventing variable collision and pollution.

```javascript
function processData(items) {
    // 'result' is needed globally here
    let result = 0;
    
    // 'temp' is only needed inside the loop
    for (let i = 0; i < items.length; i++) {
        const temp = items[i] * 2; // 'const' ensures 'temp' doesn't change mid-iteration
        result += temp;
    }
    
    // 'temp' is inaccessible here, keeping scope clean
    return result;
}
```

### Pattern 2: Reference Handling (The Clone)
**Khi nào dùng**: When you need to modify an Object/Array without affecting the original source data.
**Tại sao đúng**: Breaks the reference chain (pointer copy), ensuring data integrity (tính toàn vẹn dữ liệu).

```javascript
function updateUser(user) {
    // Bad: Modifies original object
    // user.age = 30; 
    
    // Good: Create a clone to preserve original
    // Method 1: Spread Syntax (Modern)
    const updatedUser = { ...user, age: 30 };
    
    // Method 2: Object.assign (Legacy)
    // const updatedUser = Object.assign({}, user, { age: 30 });
    
    return updatedUser;
}

const originalUser = { name: "John", age: 25 };
const newVersion = updateUser(originalUser);

console.log(originalUser.age); // 25 (Unchanged)
console.log(newVersion.age);   // 30 (New value)
```

### Pattern 3: Safe Function Parameters
**Khi nào dùng**: When defining function arguments that might be optional or need default values.
**Tài sao đúng**: Uses **const** internally to prevent accidental reassignment of parameters (which are read-only in strict mode, but mutating objects is possible).

```javascript
// Using Default Parameters & Const
function createPoint(x = 0, y = 0) {
    // 'pos' is a new object, not a reference to input
    const pos = { x, y }; 
    return pos;
}

const p1 = createPoint(5); // { x: 5, y: 0 }
const p2 = createPoint();   // { x: 0, y: 0 }
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The `var` Keyword
**Why Dangerous**: It ignores block scope and relies on **Hoisting**.
```javascript
// Dangerous
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 0); 
}
// Output: 3, 3, 3 (Because 'var' is function scoped, 'i' is the global 3 by the time the timer fires)
```
**Solution**: Use `let` (block scoped) to capture the value per iteration.

### 2. Implicit Semicolon Insertion (ASI)
**Why Dangerous**: JS adds semicolons automatically where it thinks a statement ends. This breaks return statements and array definitions.
```javascript
// Dangerous
return 
{
    status: true
};
// Result: returns undefined. JS inserted a semicolon after 'return' automatically.

// Fix: Keep { on the same line
return {
    status: true
};
```

### 3. Global Object Pollution
**Why Dangerous**: Using `var` outside a function attaches it to the global `window` object. This leads to naming collisions and security risks.
```javascript
// Dangerous
var apiVersion = "1.0"; // Accessible as window.apiVersion

// Safe
const apiVersion = "1.0"; // Not attached to window
```

### 4. Using `==` (Loose Equality)
**Why Dangerous**: The engine converts types to match, leading to counter-intuitive results.
```javascript
if ("" == 0) { /* true! */ }
if (null == undefined) { /* true! */ }
```
**Rule**: Always use `===`.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **NEVER use `var`**.
2.  **ALWAYS use `===`** for comparison.
3.  **PREFER `const`**; use `let` only if reassignment is necessary.
4.  **PLACE scripts at the bottom** of `<body>`.
5.  **PRIMITIVES** copy by value. **OBJECTS** copy by reference.
6.  **ASI** is not magic; write your semicolons manually to be safe.
7.  **BLOCK SCOPE** is your friend (`if`, `for`, `{}`).
8.  **TEMPORAL DEAD ZONE (TDZ)** exists for `let`/`const`.
9.  **TYPE COERCION** is the enemy of predictability.
10. **EXTERNAL JS** is standard for production.

### Decision Logic (Cheat Code)

```text
IF (variable_value_changes_over_time) -> use 'let'
ELSE IF (variable_value_is_constant) -> use 'const'
ELSE -> use 'const' initially

IF (comparing_values) -> use '==='
ELSE -> refactor logic

IF (loading_script_in_HTML) -> use <script src="..."></script>
AND -> place at </body> closing tag
```

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE - JavaScript Foundations

## SECTION 1: CORE MENTAL MODEL

### Template Literals & Expression Interpolation
**Template Literals (Chuỗi khuôn mẫu)**: Chuỗi sử dụng dấu ngoặc kép ngược (`) cho multi-line strings và tích hợp biểu thức động `${}`.
**Expression Interpolation (Nội suy biểu thức)**: Chèn giá trị biến hoặc biểu thức trực tiếp vào chuỗi.

**Mental Model**: Xử lý chuỗi như một "form" động, thay vì nối chuỗi thủ công (string concatenation).

```javascript
// ❌ Cũ, khó đọc
const name = "Dev";
const age = 25;
const msg = "User: " + name + ", Age: " + age + ".\nStatus: " + (age > 18 ? "Adult" : "Minor");

// ✅ Mới, trực quan
const msg = `User: ${name}, Age: ${age}.
Status: ${age > 18 ? "Adult" : "Minor"}`;
console.log(msg);
```

### Dynamic Typing & Debugging
**Dynamic Typing (Kiểm tra kiểu động)**: Kiểu biến tự xác định khi chạy (runtime), không cần khai báo cứng.
**Mental Model**: Biến là "túi chứa" linh hoạt, nhưng cần kiểm tra kỹ trước khi dùng để tránh crash.

```javascript
// Biến thay đổi kiểu linh hoạt
let data = "100";      // String
data = 100;            // Number
data = [100];          // Array

// Debugging cơ bản
console.log("Giá trị:", data);
console.table([{ id: 1, val: 10 }, { id: 2, val: 20 }]); // Dạng bảng
console.dir({ id: 1, val: 10 }); // Dạng cây object

// Lỗi tiềm ẩn do Dynamic Typing
function sum(a, b) { return a + b; }
// sum("1", 2) -> "12" (string), không phải 3. 
// Cần dùng TypeScript để bắt lỗi biên dịch.
```

---

## SECTION 2: DECISION TABLES

### When to use Loops
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI giải thích | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Duyệt mảng để lấy **giá trị** | `for...of` | **Value Iteration**: Trực tiếp lấy phần tử, code ngắn gọn, dễ đọc. | Dùng `for (let i in arr)` sẽ lấy index (kiểu string), sai logic toán học. |
| Duyệt object để lấy **key** | `for...in` | **Property Enumeration**: Duyệt qua các key/tên thuộc tính của object. | Dùng `for...of` trên object thường lỗi (Object không iterable trừ khi custom). |
| Biết trước số lượng lặp | `for` (classic) | **Index Control**: Kiểm soát chính xác index, break/continue dễ. | Dùng `while` khi có sẵn biến đếm sẽ gây rối code. |
| Lặp khi chưa biết điều dừng | `while` | **Conditional Loop**: Chạy dựa trên điều kiện boolean thay đổi. | Quên cập nhật điều kiện → Infinite Loop. |

### When to use Logic Operators
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI giải thích | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Logic AND (Cả 2 đều đúng) | `&&` | **Short-circuit evaluation**: Tối ưu performance, dừng xét nếu mệnh đề đầu sai. | Viết dài dòng: `if (a) { if (b) { ... } }`. |
| Logic OR (Một trong 2 đúng) | `\|\|` | **Default value**: Chọn giá trị mặc định (ví dụ: `name \|\| "Guest"`). | Quên thứ tự ưu tiên, gây logic sai. |
| Kiểm tra giá trị chính xác (kiểu + giá trị) | `===` | **Strict Equality**: Tránh lỗi chuyển đổi kiểu ngầm định (type coercion). | Dùng `==` dễ gặp bug: `0 == ""` (true), `0 == "0"` (true). |
| Phủ định logic | `!` | **Inversion**: Đảo ngược điều kiện. | Dùng nhiều dấu `!!` để ép kiểu boolean (chỉ dùng khi cần thiết). |

### Ternary Operator (?:)
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI giải thích | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Gán giá trị dựa trên 1 điều kiện đơn giản | `cond ? A : B` | **Conditional Assignment**: Inline ngắn gọn thay vì `if-else` block. | Nesting ternary: `cond1 ? (cond2 ? A : B) : C` → Không thể đọc được. |
| Logic phức tạp hoặc nhiều dòng | `if-else` | **Block Statement**: Đọc được flow rõ ràng, dễ debug dòng. | Cố dùng ternary cho logic nhiều bước → Hard to maintain. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Logic Flow Hierarchy

```text
[Control Structures]
       |
       +--- [Conditionals]
       |      |
       |      +--- if / else if / else (Block logic)
       |      +--- switch (Multiple exact matches)
       |      +--- ?: (Ternary - Single assignment only)
       |
       +--- [Loops]
       |      |
       |      +--- for (Known range) -----> Use: Arrays, Counting
       |      +--- while (Unknown range) -> Use: Streams, Conditions
       |      +--- for...of (Values) -----> Use: Read-only iteration
       |      +--- for...in (Keys) -------> Use: Object properties
       |
       +--- [Data Types] <---- [Dynamic Typing] <---- [TypeScript (Fix)]
       |      |                                         |
       |      +--- Number, String, Boolean             |
       |      +--- Array, Object                       |
       |      +--- Undefined, Null                     |
       |
       +--- [Debugging]
              |
              +--- console.log (Generic)
              +--- console.table (Tabular Data)
              +--- console.dir (Object Tree)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Safe Default Value (Dynamic Typing)
**Khi nào dùng**: Khi xử lý dữ liệu đầu vào có thể null/undefined hoặc kiểu sai.
**Tại sao đúng**: Tránh lỗi runtime crash do "Cannot read property of undefined".

```javascript
function processUser(user) {
  // Pattern: Fallback logic
  const name = user.name || "Anonymous"; // Handle undefined/null/empty
  const age = user.age ? user.age : 0;   // Ternary fallback
  
  // Template Literal output
  return `Profile: ${name}, Age: ${age}`;
}

console.log(processUser({ name: "Alice" })); // Profile: Alice, Age: 0
```

### Pattern 2: Clean Loop Logic
**Khi nào dùng**: Khi cần xử lý từng phần tử mảng hoặc object.
**Tại sao đúng**: Sử dụng toán tử phù hợp cho phép skip/exit logic dễ dàng.

```javascript
const users = [
  { id: 1, role: "admin", active: true },
  { id: 2, role: "user", active: false },
  { id: 3, role: "user", active: true }
];

// Dùng for...of để xử lý logic phức tạp
for (const u of users) {
  if (!u.active) continue; // Bỏ qua nếu không active
  
  console.table(u); // In ra bảng xem thông tin
  
  if (u.role === "admin") {
    console.log("Admin detected");
    break; // Dừng hẳn vòng lặp khi tìm thấy admin
  }
}
```

### Pattern 3: Type Inference & Debug
**Khi nào dùng**: Khi cần kiểm tra kiểu dữ liệu runtime (nếu không dùng TypeScript).
**Tại sao đúng**: Dynamic typing yêu cầu validate rõ ràng.

```javascript
function handleInput(input) {
  // Validate type logic
  if (typeof input === "string") {
    return `Processing string: ${input.toUpperCase()}`;
  }
  
  if (Array.isArray(input)) {
    return `Array length: ${input.length}`;
  }

  // Debug: Log object tree nếu không rõ kiểu
  console.dir(input);
  return "Unknown type";
}

console.log(handleInput("hello")); // Processing string: HELLO
console.log(handleInput([1, 2]));  // Array length: 2
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Using `==` (Loose Equality)**
    *   **Lý do nguy hiểm**: Gây ra các lỗi chuyển đổi kiểu ngầm định (type coercion) khó lường. Ví dụ: `"" == 0` trả về `true`. Luôn dùng `===` (Strict Equality).

2.  **Nested Ternary Operators**
    *   **Lý do nguy hiểm**: "Code围棋" (trông như bàn cờ), cực kỳ khó đọc và sửa lỗi. Nếu cần nesting, hãy chuyển sang `if-else` hoặc `switch`.

3.  **Infinite Loops with `while`**
    *   **Lý do nguy hiểm**: Kiểm tra biến điều kiện không chính xác hoặc quên cập nhật giá trị bên trong loop. Luôn đảm bảo có điểm dừng (break) hoặc thay đổi điều kiện.

4.  **Confusing `for...in` with Arrays**
    *   **Lý do nguy hiểm**: Dùng `for...in` trên mảng có thể lấy ra các enumerable properties (nếu prototype bị sửa đổi) và trả về key là **string**, gây lỗi khi tính toán toán học. Luôn dùng `for...of` hoặc `.forEach()` cho mảng.

5.  **Over-reliance on Console.log**
    *   **Lý do nguy hiểm**: Chỉ in ra giá trị chứ không giúp hiểu cấu trúc object rõ ràng. Nên dùng `console.table()` cho mảng đối tượng và `console.dir()` cho DOM/Object.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
*   **String**: Backticks (`) + `${var}` cho mọi string động.
*   **Equality**: Gõ `===` (Trừ khi bạn biết chắc chắn muốn type coercion).
*   **Looping**:
    *   Mảng/Object logic: `for...of`
    *   Object keys: `for...in`
    *   Countdown/Range: `for (let i...)`
*   **Debug**: `table()` cho list, `dir()` cho object tree.

### Decision Logic (If-Else Style)

**Loops:**
```text
IF array needs values? 
   -> Use for...of
ELSE IF object needs keys?
   -> Use for...in
ELSE IF precise index control?
   -> Use standard for()
ELSE 
   -> Use while()
```

**Ternary:**
```text
IF (condition IS simple && expressions ARE short) 
   -> Use (condition ? A : B)
ELSE 
   -> Use if/else block
```

**Operators:**
```text
IF (check for both true) -> Use &&
IF (check for either true) -> Use ||
IF (strict type check) -> Use ===
```

### Top 5 Things to Remember
1.  **Backticks** are your friend for strings.
2.  **`===`** is safer than `==`.
3.  **`for...of`** for values, **`for...in`** for keys.
4.  **Dynamic Typing** means you must validate inputs (`typeof`, `Array.isArray`).
5.  **Debug**: Use `console.table` for data, `console.dir` for objects.

<!-- CHUNK 31-40 -->

# JavaScript Developer Decision Guide

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Function (Hàm):** Một khối mã tái sử dụng để thực hiện tác vụ cụ thể.
Mental Model: Trong JavaScript, hàm không chỉ là lệnh执行, mà là **First-class citizens (Công dân hạng nhất)** - tức là dữ liệu. Bạn có thể gán hàm vào biến, truyền làm đối số, và trả về từ hàm khác.

**Arrow Function (Hàm Mũi tên):** Cú pháp ngắn gọn viết hàm ẩn danh (anonymous).
Mental Model: Nó "bỏ qua" `this` của riêng nó, kế thừa `this` từ scope bao quanh. Lý tưởng cho callback nhưng **không** dùng làm method của object khi cần truy cập properties của object đó.

**Closure (Đóng kín):** Hàm ghi nhớ biến từ scope nơi nó được tạo, ngay cả khi scope đó đã kết thúc.
Mental Model: Think of it as "backpack" mà hàm mang theo các biến lân cận. Nó cho phép tạo state riêng tư (private) mà không cần class.

**Ưu điểm hơn các ngôn ngữ khác:**
- **So với Java/C#:** Linh động hơn (Dynamic typing), không cần khai báo loại biến strict.
- **So với Python:** Cho phép sửa đổi hàm runtime dễ dàng hơn (monkey patching), nhưng cần kỷ luật hơn để tránh lỗi runtime.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Function Declaration vs Expression
| Tình huống sử dụng | Nên dùng gì | Tại sao (Hoisting) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Gọi hàm trước khi định nghĩa (tổng quát) | **Function Declaration** | `function name(){}` được **Fully Hoisted** (nâng lên đầu file). Browser thấy ngay. | Viết Function Expression rồi gọi trước -> `TypeError: ... is not a function`. |
| Làm callback, passed as arguments | **Function Expression** | `const fn = function(){}` không hoisted. Tránh clutter scope global. | Dùng Declaration nếu chỉ dùng 1 lần ->污染 global namespace. |
| Điều kiện `if/else` định nghĩa hàm | **Function Expression** | Chỉ định nghĩa hàm khi điều kiện true. | Dùng Declaration trong `if` (behavior không đồng nhất giữa các browser cũ). |

### Table 2: Arrow Function vs Regular Function
| Tình huống sử dụng | Nên dùng gì | Tại sao (Context `this`) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Callback ngắn (Event, Array methods) | **Arrow Function `() => {}`** | `this` kế thừa từ outer scope. Trả về value ngắn gọn. | Viết `obj.method = () => { this.prop }` -> `this` là global/undefined, không phải obj. |
| Method trong Class/Object | **Regular Function `function(){}`** | `this` bind chính xác vào instance gọi method. | Dùng Arrow Function làm method -> không thể truy cập `this.name` của object. |
| Constructor function | **Regular Function `function(){}`** | Dùng `new` để tạo instance. | Dùng Arrow Function -> báo lỗi `Class constructor cannot be invoked without 'new'`. |

### Table 3: Array Iteration Methods
| Tình huống sử dụng | Nên dùng gì | Tại sao (Output & Purpose) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Chỉ muốn lặp qua để làm việc gì đó (side effect), không cần return | **`forEach()`** | Trả về `undefined`. Dùng để in log, update DOM. | Dùng `map()` cho side effect -> lãng phí performance (tạo mảng mới mà không dùng). |
| Muốn biến đổi mảng A thành mảng B (cùng độ dài) | **`map()`** | **Immutability**: Trả về mảng mới, không thay đổi mảng gốc. | Dùng `for` loop -> code dài dòng, dễ sai index. |
| Lọc dữ liệu theo điều kiện | **`filter()`** | Trả về mảng mới chứa phần tử thỏa condition (true). | Viết vòng lặp `for` với `push()` -> dễ quên `break` hoặc logic phức tạp. |
| Tính toán gộp thành 1 giá trị (sum, max, object) | **`reduce()`** | Giảm mảng thành 1 giá trị duy nhất. | Dùng `map` rồi `sum` riêng -> chạy 2 vòng lặp, kém hiệu quả. |

### Table 4: Flexibility (Dynamic Typing)
| Tình huống sử dụng | Nên dùng gì | Tại sao (Safety) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Dự án lớn, nhiều người | **TypeScript** | Validate lỗi tại compile time trước khi chạy. | Để Pure JS -> lỗi runtime khó debug (`undefined` vào chỗ mong number). |
| Dự án nhỏ, nhanh | **JS + Validate input** | Tốc độ development cao. | Tin tưởng input tuyệt đối -> crash khi dữ liệu người dùng sai format. |
| Kiểm tra kiểu dữ liệu | **`typeof` hoặc `===`** | Tránh Implicit Conversion (tự động đổi kiểu). | Dùng `==` -> `'5' == 5` là `true`, gây logic sai. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### Scope Chain & Closure Relationship
Scope là nơi biến sống. Closure kết nối Scope cha với Function con.

```text
[Global Scope]
   | (Truy cập được)
   V
[Outer Function Scope] <--- "Backpack" (Closure)
   | (Biến: count)        Function con ghi nhớ biến này
   | (Truy cập được)
   V
[Inner Function Scope] (Nơi closure được tạo)
```

### Data Flow in Array Methods
Input Array -> Iterator -> Output

```text
[Source Array] -----> [forEach] -----> (Side Effect) -----> void
                 |
                 +-----> [map] ------> [New Array] -----> Immutable Data
                 |
                 +-----> [filter] ---> [New Array] -----> Subset Data
                 |
                 +-----> [reduce] ---> (Single Value) ---> Aggregation
```

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Module Pattern (Using Closure)
**Khi nào dùng:** Khi cần biến private (biến không cho truy cập từ ngoài) và public API.
**Tại sao đúng:** Closure giữ biến bên trong, chỉ trả về object method để truy cập.

```javascript
const CounterModule = (function() {
  // Private variables (Không thể truy cập từ ngoài)
  let privateCount = 0;

  // Private method
  function log(action) {
    console.log(`Action: ${action} | Count: ${privateCount}`);
  }

  // Public API (Trả về object)
  return {
    increment: function() {
      privateCount++;
      log('increment');
    },
    getCount: function() {
      return privateCount;
    },
    reset: function() {
      privateCount = 0;
      log('reset');
    }
  };
})();

// Usage
CounterModule.increment(); // Action: increment | Count: 1
CounterModule.increment(); // Action: increment | Count: 2
console.log(CounterModule.getCount()); // 2
// console.log(CounterModule.privateCount); // undefined (Private)
```

### Pattern 2: Chaining Array Methods (Pipeline)
**Khi nào dùng:** Khi cần xử lý dữ liệu qua nhiều bước (Lọc -> Chuyển đổi -> Gộp).
**Tại sao đúng:** Code ngắn gọn, dễ đọc, không khai báo biến trung gian.

```javascript
const orders = [
  { id: 1, amount: 100, status: 'active' },
  { id: 2, amount: 200, status: 'completed' },
  { id: 3, amount: 50, status: 'active' },
  { id: 4, amount: 300, status: 'completed' }
];

// Logic: Lấy orders active -> Tăng amount 10% -> Tính tổng
const totalBonus = orders
  .filter(order => order.status === 'active') // Bước 1: Lọc
  .map(order => ({ ...order, amount: order.amount * 1.1 })) // Bước 2: Map (Immutability)
  .reduce((sum, order) => sum + order.amount, 0); // Bước 3: Reduce

console.log(totalBonus); // (100 + 50) * 1.1 = 165
```

### Pattern 3: Arrow Function in Callbacks
**Khi nào dùng:** Khi callback ngắn, không cần truy cập `this` của outer scope, hoặc chỉ cần argument.
**Tại sao đúng:** Giảm boilerplate code (`function` keyword).

```javascript
const users = ['Alice', 'Bob', 'Charlie'];

// Old way
users.forEach(function(user) {
  console.log(user);
});

// Modern Arrow Pattern (Implicit Return nếu chỉ 1 dòng)
users.forEach(user => console.log(user));

// Filter pattern
const shortNames = users.filter(name => name.length < 4); // ['Bob']
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

**1. Implicit Conversion (Coercion) Trap**
- **Code sai:** `if (userInput == 1)` hoặc `0 == false`.
- **Lý do nguy hiểm:** JS tự động đổi kiểu dữ liệu (`'1'` thành `1`). Dẫn đến logic điều kiện sai lầm mà không báo lỗi.
- **Fix:** Luôn dùng strict equality `===`.

**2. Arrow Function trong Object Literal**
- **Code sai:**
  ```javascript
  const obj = {
    value: 10,
    getValue: () => this.value // this.value là undefined
  };
  ```
- **Lý do nguy hiểm:** Arrow function không có `this` riêng. Nó kế thừa `this` từ global (window), không phải `obj`.
- **Fix:** Dùng regular function: `getValue: function() { return this.value; }`.

**3. forEach không đợi异步 (Async/Await)**
- **Code sai:**
  ```javascript
  [1, 2, 3].forEach(async (num) => {
    await fetchData(num); // Chạy song song, không đúng thứ tự
  });
  console.log('Done'); // Chạy ngay lập tức, không đợi forEach
  ```
- **Lý do nguy hiểm:** `forEach` bỏ qua return value của callback, không xử lý Promise. Nó chạy xong loop luôn.
- **Fix:** Dùng `for...of` nếu cần await tuần tự.

**4. Dùng map() nhưng không dùng kết quả (Side Effect)**
- **Code sai:** `numbers.map(n => console.log(n))`.
- **Lý do nguy hiểm:** `map` sinh ra để tạo mảng mới. Dùng nó cho side effect là sai Semantic, gây nhiễu logic debug.
- **Fix:** Dùng `forEach()`.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Quick Rules
1. **Function:** Trả về logic -> Declaration. Truyền callback -> Expression.
2. **Arrow:** Dùng cho ngắn gọn, giữ `this` outer. Tránh làm method object/class.
3. **Array:** Bỏ `for loop` nếu có thể. Map (đổi), Filter (lọc), Reduce (gộp).
4. **Safety:** Dùng `===`. Cân nhắc TypeScript cho dự án lớn.

### Decision Logic
- **Cần private variable?** -> Closure Pattern.
- **Cần sửa đổi mảng gốc?** -> `array.push()`, `splice()`.
- **Cần mảng mới?** -> `map()`, `filter()`.
- **Cần gọi hàm trước định nghĩa?** -> Function Declaration.
- **Code báo lỗi "this is undefined"?** -> Bạn đang dùng Arrow Function sai chỗ.

### Top 5 Things to Remember
1. **Functions are Data:** Gán `const fn = function...` thoải mái.
2. **Hoisting:** Declaration lên đầu, Expression thì không.
3. **Arrow `this`:** Kế thừa cha, không bind mới.
4. **Immutability:** `map`/`filter` không thay đổi mảng cũ.
5. **Runtime Errors:** JS freiendly nhưng không an toàn. Test kỹ input.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: JavaScript Objects & Classes

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
**Object (Đối tượng)**: Dữ liệu cấu trúc dạng "key:value", lưu trữ thuộc tính và hành vi.
**Class (Lớp)**: Bản thiết kế (template) để tạo ra nhiều Object đồng nhất.
**JSON (JavaScript Object Notation)**: Định dạng chuỗi chuẩn để trao đổi dữ liệu giữa các hệ thống.
**Garbage Collection (Thu gom rác)**: Tự động giải phóng bộ nhớ không còn được tham chiếu.
**Auto-Boxing (Ép tự động)**: Khi chuỗi thô (primitive) gọi phương thức, JS tự tạo wrapper object tạm thời.

### Key Mental Model
- **Objects là map dictionary**: Truy cập nhanh O(1) qua key.
- **Classes là factory**: Giúp tạo nhiều object giống nhau mà không lặp code.
- **Memory là runway**: Garbage Collection là máy bay dọn dẹp ghế trống sau khi bạn rời đi.

---

## SECTION 2: DECISION TABLES

| Use Case (Tình huống sử dụng) | Should Use (Nên dùng gì) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
|-------------------------------|--------------------------|---------------|-------------------------------------|
| Lưu trữ cấu trúc dữ liệu đơn lẻ | **Object Literal `{}`** | Nhanh, gọn, không cần định nghĩa lớp | Dùng class cho object 1 lần dùng |
| Tạo nhiều object cùng type | **Class + `new`** | Dễ bảo trì, tái sử dụng code (DRY) | Copy-paste object literal |
| Gửi dữ liệu qua API/Network | **JSON.stringify()** | Chuẩn hóa định dạng (Serialization) | Gửi object thuần JS → lỗi cấu trúc |
| Nhận dữ liệu từ API/Network | **JSON.parse()** | Chuyển chuỗi thành object sử dụng được | Dùng chuỗi trực tiếp không parse |
| Dọn dẹp bộ nhớ thủ công | **Không cần (Garbage Collection)** | JS tự xử lý tham chiếu | Gọi `delete` lung tung |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy Flow
```
[Class Definition] --new--> [Object Instance] --JSON.stringify--> [String/JSON] --API--> [Server]
       |                                                               |
       |                                                            JSON.parse
       |                                                               |
       v                                                               v
[Properties/Methods] <---------------------------------------- [Data Store/Response]
       |
       v
[Garbage Collection] (Xóa khi không còn tham chiếu)
```

### Relationship Map
- **Object** <-> **Class**: Instance vs Blueprint (Phiến bản vs Bản thiết kế)
- **Object** <-> **JSON**: Bidirectional conversion (Two-way street)
- **String** <-> **String Object**: Temporary wrapping (Temporary wrapper)

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Object Literal (Single Data Structure)
**Khi nào dùng**: Khi cần lưu trữ dữ liệu tạm thời, cấu trúc đơn giản.
**Tại sao đúng**: Trực quan, không overhead, truy cập nhanh.

```javascript
// Tạo object lưu trữ thông tin user
const user = {
  name: "Alice",
  age: 25,
  role: "Developer",
  isActive: true,
  
  // Method
  greet() {
    return `Xin chào, tôi là ${this.name}`;
  }
};

// Truy cập
console.log(user.name); // Alice
console.log(user.greet()); // Xin chào, tôi là Alice
```

### Pattern 2: Class (Object Factory)
**Khi nào dùng**: Khi cần tạo nhiều object cùng cấu trúc, có logic phức tạp.
**Tại sao đúng**: Dễ bảo trì, code reusable, chống lặp (DRY).

```javascript
// Bản thiết kế
class Student {
  constructor(name, age, score) {
    this.name = name;
    this.age = age;
    this.score = score;
  }

  // Method
  getStatus() {
    if (this.score >= 8) return "Giỏi";
    if (this.score >= 6) return "Khá";
    return "Trung bình";
  }
}

// Tạo instance
const student1 = new Student("Nam", 20, 8.5);
const student2 = new Student("Lan", 19, 7.2);

console.log(student1.getStatus()); // Giỏi
console.log(student2.getStatus()); // Khá
```

### Pattern 3: JSON Data Exchange
**Khi nào dùng**: Gửi/nhận dữ liệu qua API, lưu trữ dữ liệu.
**Tại sao đúng**: Chuẩn hóa, tương thích mọi ngôn ngữ lập trình.

```javascript
// Chuẩn bị dữ liệu
const data = {
  userId: 123,
  username: "nguyenvan",
  email: "nv@example.com",
  roles: ["admin", "editor"]
};

// Client gửi lên Server
const jsonString = JSON.stringify(data);
console.log(jsonString);
// Output: {"userId":123,"username":"nguyenvan","email":"nv@example.com","roles":["admin","editor"]}

// Server nhận từ Client
const receivedString = '{"userId":123,"username":"nguyenvan","email":"nv@example.com","roles":["admin","editor"]}';
const parsedData = JSON.parse(receivedString);
console.log(parsedData.username); // nguyenvan
```

### Pattern 4: String Auto-Boxing (Behavior Hack)
**Khi nào dùng**: Hiểu rõ cách primitive type có method được gọi.
**Tại sao đúng**: Tránh nhầm lẫn khi debug, hiểu cơ chế JS.

```javascript
const primitiveStr = "hello";

// JS tự động tạo wrapper object tạm thời
const result = primitiveStr.toUpperCase(); 
console.log(result); // HELLO

// Proof: primitive không có property nhưng có method
primitiveStr.customProp = "test"; // Không lỗi, nhưng không lưu được
console.log(primitiveStr.customProp); // undefined (mất khi wrapper biến mất)
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### ⚠️ Anti-Pattern 1:滥用 Object Literal for Complex Logic
**Nguy hiểm**: Code dễ rối, khó test, không có tính đóng gói.
**Tại sao nguy hiểm**: Không có class, bạn không thể tạo nhiều instance hay kế thừa.

```javascript
// SAI: Dùng object literal cho logic phức tạp
const calculator = {
  a: 0,
  b: 0,
  add() { this.a + this.b; },
  subtract() { this.a - this.b; }
};
// → Không tạo được calculator mới, dễ bị ghi đè state
```

### ⚠️ Anti-Pattern 2: Không Parse JSON Khi Nhận
**Nguy hiểm**: Dữ liệu thành string, không truy cập property được.
**Tại sao nguy hiểm**: Gây lỗi runtime "undefined is not a function".

```javascript
// SAI
const apiResponse = '{"name": "Alice"}';
console.log(apiResponse.name); // undefined (string không có property .name)

// ĐÚNG
const parsed = JSON.parse(apiResponse);
console.log(parsed.name); // Alice
```

### ⚠️ Anti-Pattern 3: Biến Object thành Global
**Nguy hiểm**: Khó quản lý, gây rò rỉ bộ nhớ (memory leak).
**Tại sao nguy hiểm**: Garbage Collection không thể dọn dẹp nếu vẫn còn tham chiếu global.

```javascript
// SAI
window.userData = { name: "Alice" }; // Không bao giờ bị dọn

// ĐÚNG
function processData() {
  const userData = { name: "Alice" }; // Tồn tại trong scope
  // làm việc với userData
} // userData tự động bị xóa sau khi function kết thúc
```

### ⚠️ Anti-Pattern 4: Lạm Dụng `delete`
**Nguy hiểm**: `delete` không xóa property, nó làm property thành `undefined`.
**Tại sao nguy hiểm**: Gây lỗi logic, làm object "bẩn".

```javascript
const obj = { a: 1, b: 2 };
delete obj.a;
console.log(obj); // { b: 2 } (good) but property 'a' is gone, not undefined
// WARNING: Dùng delete làm chậm performance, thay vì gán null/undefined
```

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1. **Object Literal**: Dùng cho data holder đơn lẻ, config, temp storage.
2. **Class**: Dùng khi cần >1 instance hoặc có method logic.
3. **JSON.stringify()**: Gửi data đi (API, LocalStorage).
4. **JSON.parse()**: Nhận data về (API, LocalStorage).
5. **Garbage Collection**: Đừng lo, chỉ cần không tham chiếu global là auto xóa.

### Decision Logic (If-Else)
```
IF (Cần 1 object dùng 1 lần, data đơn giản) → Object Literal {}
ELSE IF (Cần nhiều object cùng type) → Class + new
ELSE IF (Gửi/nhận data qua network) → JSON.stringify() / JSON.parse()
ELSE IF (Dọn dẹp memory) → Đừng dùng delete, hãy gán null hoặc để scope tự xử lý
```

### Top 10 Things to Remember
1. Object = Dictionary (Key:Value)
2. Class = Blueprint (Factory)
3. JSON là chuỗi, không phải object
4. `JSON.parse()` để dùng dữ liệu
5. `JSON.stringify()` để gửi dữ liệu
6. Auto-Boxing chỉ xảy ra khi gọi method trên primitive
7. Garbage Collection auto dọn object không còn tham chiếu
8. Tránh lưu object vào global scope
9. Dùng class để tránh lặp code
10. `delete` là anti-pattern, dùng `null` hoặc undefined thay thế

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: JavaScript DOM & Events

---

## SECTION 1: CORE MENTAL MODEL

### Core Concepts

*   **DOM (Document Object Model) (Mô hình đối tượng tài liệu):** Một cấu trúc cây (tree) đại diện cho tài liệu HTML. Nó là "cầu nối" cho phép JavaScript tương tác với nội dung, cấu trúc và style của trang web. Mỗi thẻ HTML là một node trong cây DOM.
*   **Node (Nút):** Đơn vị cơ bản của DOM. Bao gồm Element (thẻ HTML), Text (văn bản), Attribute (thuộc tính), và Comment (chú thích).
*   **Selector (Bộ chọn):** Phương pháp tìm kiếm các Node trong DOM tree. JavaScript cung cấp các API khác nhau từ cũ (tên thẻ, ID) đến hiện đại (CSS Selector).

### Reality Mental Model
Khi trình duyệt load trang web, nó đọc HTML và tạo ra một "bản đồ" các đối tượng trong bộ nhớ. JavaScript không tác động trực tiếp lên file HTML, mà nó tác động lên **bản đồ (DOM Tree)** này. Khi DOM thay đổi, giao diện người dùng (UI) sẽ tự động cập nhật.

---

## SECTION 2: DECISION TABLES

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Cần tìm 1 phần tử duy nhất có ID** | `document.getElementById('id')` | **Targeted Access (Truy cập mục tiêu):** Đây là cách nhanh nhất để lấy 1 phần tử duy nhất vì nó dùng index nội bộ của trình duyệt. | Dùng `querySelector('#id')` cho việc này (chậm hơn một chút và dư thừa). |
| **Cần tìm nhiều phần tử theo Class/Tag** | `parent.getElementsByClassName('cls')` hoặc `parent.getElementsByTagName('tag')` | **Collection Retrieval (Lấy bộ sưu tập):** Trả về `HTMLCollection` (tương tự mảng), tối ưu cho việc duyệt qua nhiều phần tử cùng loại. | Dùng `querySelectorAll` nếu không cần dùng CSS selector phức tạp, vì `getElementsBy*` nhanh hơn và nhẹ nhàng hơn. |
| **Cần tìm phức tạp (lồng ghép, attribute)** | `document.querySelectorAll('div.user > span.active')` | **CSS Power (Sức mạnh CSS):** Hỗ trợ toàn bộ cú pháp CSS selectors, rất linh hoạt. | Lặp lại `querySelector` nhiều lần để tìm đệ quy (VD: `div.querySelector('span')` rồi lại `div.querySelector('a')`). Nên dùng `querySelectorAll` một lần. |
| **Cần kiểm tra kiểu Node** | `elem.nodeType` | **Type Checking (Kiểm tra loại):** Trả về số nguyên (1, 3, 8...) để xác định chính xác loại node mà không phụ thuộc vào tên thẻ. | Dùng `typeof` hoặc `instanceof` (lỗi thời) để kiểm tra node. `nodeType` là chuẩn mực và rõ ràng nhất. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### DOM Hierarchy
DOM là một cấu trúc phân cấp cha-con (Parent-Child). Để thao tác hiệu quả, bạn phải hiểu cách di chuyển giữa các Node.

**Text Flow Diagram:**

```text
[Window]
    |
    v
[Document] (root, nodeType=9)
    |
    +-- [Element: <html>] (nodeType=1)
             |
             +-- [Element: <head>]
             |       |
             |       +-- [Element: <title>]
             |               |
             |               +-- [Text: "My Page"]
             |
             +-- [Element: <body>] (nodeType=1)
                     |
                     +-- [Element: <div id="main">] (nodeType=1)
                     |       |
                     |       +-- [Text: "Hello"] (nodeType=3)
                     |       |
                     |       +-- [Element: <span>] (nodeType=1)
                     |
                     +-- [Comment: " Footer "]
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Safe Selector" (Bộ chọn an toàn)
**Khi nào dùng:** Khi bạn不确定 (không chắc chắn) phần tử có tồn tại hay không trước khi thao tác.

**Tại sao đúng:** Tránh lỗi `Cannot read property of null`. Luôn kiểm tra kết quả truy vấn trước khi dùng.

```javascript
// Bước 1: Chọn phần tử
const btn = document.querySelector('#submit-btn');

// Bước 2: Kiểm tra t tồn tại (Kiểu guard clause)
if (btn) {
    btn.textContent = 'Submit Now';
    btn.classList.add('active');
    console.log('Button found and updated.');
} else {
    console.warn('Button #submit-btn not found in DOM.');
}
```

### Pattern 2: The "Collection Loop" (Vòng lặp bộ sưu tập)
**Khi nào dùng:** Khi cần áp dụng logic hoặc style cho nhiều phần tử cùng lúc (Vd: tất cả thẻ `<td>` trong bảng).

**Tại sao đúng:** `getElementsBy*` và `querySelectorAll` trả về một danh sách nhưng không phải mảng Array gốc. Cần chuyển đổi hoặc dùng phương thức Array.

```javascript
// Tìm tất cả các ô trong bảng
const cells = document.querySelectorAll('table.my-table td');

// Chuyển NodeList thành Array để dùng phương thức Array (Optional nhưng thường dùng)
Array.from(cells).forEach((cell, index) => {
    if (cell.textContent === 'Empty') {
        cell.style.backgroundColor = 'red';
    }
});

// Hoặc dùng for...of trực tiếp (nhẹ nhàng hơn)
for (const cell of cells) {
    console.log(cell.textContent);
}
```

### Pattern 3: "Attribute & Property Access" (Truy cập thuộc tính)
**Khi nào dùng:** Khi cần đọc hoặc ghi dữ liệu vào thẻ HTML (src, href, value, data-*, disabled).

**Tại sao đúng:** Phân biệt giữa thuộc tính HTML (Attribute) và thuộc tính DOM (Property) để tránh lỗi logic.

```javascript
const input = document.querySelector('input[type="text"]');

// ĐỌC/GHI Attribute (Trong HTML)
const id = input.getAttribute('id'); // "user-input"
input.setAttribute('placeholder', 'Enter text...');

// ĐỌC/GHI Property (Trong bộ nhớ JS)
const val = input.value; // Trạng thái hiện tại
input.value = 'New Value'; // Cập nhật giao diện ngay

// Xử lý Class (Dễ nhất)
input.classList.add('error'); // Thêm class
input.classList.remove('error'); // Bỏ class
input.classList.toggle('active'); // Bật/tắt class
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Dùng `innerHTML` khi không cần thiết
*   **Nguy hiểm:** Ghi đè toàn bộ nội dung con, xóa hết sự kiện (event) đã gắn, và dễ gây **XSS (Cross-Site Scripting)** nếu chèn dữ liệu người dùng chưa xử lý.
*   **Thay thế:** Dùng `textContent` nếu chỉ là văn bản thuần, hoặc `createElement` + `append` nếu cần chèn HTML phức tạp một cách an toàn.

### 2. Lặp lặp `querySelector` trong vòng lặp
*   **Nguy hiểm:** `document.querySelectorAll` là truy vấn trực tiếp vào cây DOM (nóng). Nếu bạn gọi nó trong vòng lặp `for` (Vd: mỗi lần click gọi một lần `querySelector`), nó làm chậm giao diện vì phải duyệt cây DOM liên tục.
*   **Thay thế:** Tìm nhanh một lần vào biến, rồi dùng biến đó trong vòng lặp hoặc logic.

### 3. Quên Guard Clause (Kiểm tra bảo vệ)
*   **Nguy hiểm:** `TypeError: Cannot read properties of null`. Website bị văng Javascript, người dùng thấy trang trắng hoặc giao diện bị đơ.
*   **Thay thế:** Luôn viết `if (element) { ... }` sau mọi thao tác `querySelector` hoặc `getElementById`.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

*   **Need an ID?** → `getElementById('id')` (Fastest).
*   **Need complex selection (descendant, attribute)?** → `querySelector('css')` or `querySelectorAll('css')`.
*   **Need collection by Class/Tag?** → `getElementsByClassName('cls')` (Fastest for collection).
*   **Is it a Text Node?** → `node.nodeType === 3`.
*   **Is it an Element (Tag)?** → `node.nodeType === 1`.

### Top 5 Rules to Remember

1.  **DOM is Tree:** Think branches and leaves, not just text.
2.  **Live vs Static:** `getElementsBy*` is **Live** (updates automatically), `querySelectorAll` is **Static** (snapshot).
3.  **Check Null:** Always verify the element exists before using it.
4.  **Use `textContent`:** For text, it's faster and safer than `innerHTML`.
5.  **Event Delegation:** Don't add 100 listeners to 100 buttons; add 1 listener to their parent. (Context from previous lectures).

<!-- CHUNK 61-70 -->

# DEVELOPER DECISION GUIDE: JavaScript DOM Manipulation

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**DOM (Document Object Model)**
Là giao diện lập trình ứng dụng (API) cho tài liệu HTML và XML. Nó mô hình hóa tài liệu như một cấu trúc cây (tree structure) nơi mỗi phần tử, thuộc tính và văn bản là một node (nút).

**Mental Model:**
Hãy coi HTML là "蓝图" (blueprint) ban đầu. DOM là "ngôi nhà sống" (living house) sau khi trình duyệt render. JavaScript không sửa file HTML gốc, nó sửa chính "ngôi nhà" đang được hiển thị đó. Mọi thay đổi là **real-time** và **live**.

**Why is this better?**
- **Direct Manipulation**: Thay đổi UI ngay lập tức mà không cần reload trang (so với việc submit form và reload server-side).
- **Granular Control**: Truy cập và sửa chính xác từng phần tử nhỏ nhất (element, text, attribute) thay vì làm việc với khối HTML lớt.

**Code Demo: The Living Tree Concept**
```javascript
// 1. HTML Blueprint (Static)
// <div id="container"><p>Hello</p> World</div>

// 2. Access the Living DOM
const container = document.getElementById('container');

// 3. It's live: Modify property (innerHTML)
container.innerHTML = '<span>New Content</span>'; 
// Result on screen: "New Content" instantly.

// 4. It's live: Modify attribute
container.style.color = 'red';
// Screen updates immediately without reloading.
```

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Reading Content (innerHTML vs textContent vs nodeValue)

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Need HTML structure**<br>(Lấy cấu trúc HTML) | **innerHTML**<br>(element) | **Why:** Returns full HTML string (including tags). Dùng để parse HTML string hoặc chèn HTML mới. <br>**Risk:** Dễ bị **XSS (Cross-Site Scripting)** nếu insert dữ liệu người dùng chưa kiểm duyệt. | Dùng `innerHTML` để lấy text thuần túy. Nó trả về chuỗi HTML rác (ví dụ: `<br>`) nếu có nhiều dòng. |
| **Need safe text**<br>(Lấy text thuần túy) | **textContent**<br>(element/text) | **Why:** Trả về text của tất cả descendants, **không bao gồm tags**. An toàn hơn `innerHTML`. Tốc độ render nhanh hơn khi insert text. | Dùng `innerText`. `innerText` là proprietary (của IE/Chrome), tốn kém vì nó tính toán layout (CSS) để ẩn phần tử. `textContent` thì "không care CSS", nhanh hơn. |
| **Need raw node text**<br>(Text node hay Comment node) | **nodeValue**<br>(text/comment) | **Why:** Truy cập trực tiếp dữ liệu thô của **Text Node** hoặc **Comment Node**. <br>**Constraint:** Chỉ hoạt động trên node type 3 (Text) hoặc 8 (Comment), không hoạt động trên Element. | Dùng `nodeValue` trên thẻ `<div>`. Kết quả trả về là `null` vì thẻ `<div>` là Element Node, không phải Text Node. |

### Table 2: Insertion & Replacement

| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Add to end**<br>(Thêm vào cuối) | **node.append(...)** | **Why:** **Modern (ES2018+)**. Hỗ trợ thêm nhiều nodes hoặc chuỗi string cùng lúc. Thay thế cho `appendChild` (chỉ nhận 1 node) và `insertAdjacentHTML`. | Dùng `appendChild` cho string. `appendChild` chỉ nhận Node, nếu passing string sẽ thành Text Node hoặc lỗi. |
| **Add to start**<br>(Thêm vào đầu) | **node.prepend(...)** | **Why:** **Modern**. Thêm vào trước `firstChild`. Rõ ràng về mặt ý nghĩa so với việc dùng `insertBefore` phức tạp. | Dùng `innerHTML = '...' + oldHTML`. Việc cộng chuỗi như vậy thường xóa đi các event listener đã attach trước đó (event detachment). |
| **Add before/after**<br>(Chèn ngoài lề) | **node.before(...)**<br>**node.after(...)** | **Why:** **Modern**. Cho phép chèn node lân cận mà không cần truy cập parent (không cần `parentNode.insertBefore`). | Cố gắng dùng `insertBefore` với logic phức tạp để chèn trước một phần tử trong khi `node.before()` giải quyết vấn đề chỉ với 1 dòng. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### DOM Hierarchy (Tree Traversal)
Mọi thứ bắt đầu từ `document`. Một Element chứa các Node con (có thể là Element khác hoặc Text).

```text
      [document]
          |
      [html element] (root element)
          |
    +-----+-----+
    |           |
[head]       [body] (Parent Node)
                |
          +-----+-----+-----+
          |     |     |     |
       [div] [text] [p] [text] (Children Nodes)
                  (Child Nodes)
```

### Node Type Relationship
*   **Element Node**: Represents tags (`<div>`, `<p>`). Has `children`, `attributes`.
*   **Text Node**: Represents text inside tags (even whitespace). Has `nodeValue`.
*   **Relationships**:
    *   **Parent → Child**: `parent.append(child)`
    *   **Sibling**: `node.before(otherNode)`, `node.after(otherNode)`

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Safe Text Update (Updating Labels)
**Khi nào dùng:** Khi cần hiển thị dữ liệu text (không có HTML) từ server hoặc người dùng.
**Tại sao đúng:** Sử dụng `textContent` tránh được **XSS Injection** và performance tốt hơn.

```javascript
// Setup
const statusEl = document.getElementById('status'); 
const userInput = "<img src=x onerror=alert(1)>"; // Malicious payload

// BAD (Vulnerable)
// statusEl.innerHTML = userInput; // Alert triggers!

// GOOD (Secure)
statusEl.textContent = userInput; 
// Result displayed on screen: "<img src=x onerror=alert(1)>"
// The HTML is treated as plain text, safely.
```

### Pattern 2: List Insertion (Batch Adding)
**Khi nào dùng:** Khi render danh sách dữ liệu (array) vào giao diện.
**Tại sao đúng:** Dùng `append()` hiện đại, linh hoạt giữa string và node. Tránh loop và reflow quá nhiều.

```javascript
const listContainer = document.getElementById('item-list');
const data = ['Apple', 'Banana', 'Orange'];

// Create a fragment (Optional performance boost)
const fragment = document.createDocumentFragment();

data.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
});

// Append once (or append inside loop if string)
// Modern way:
listContainer.append(...data.map(item => `<li>${item}</li>`)); 

// Or with nodes (safer for events)
listContainer.append(fragment);
```

### Pattern 3: Element Replacement (Update UI State)
**Khi nào dùng:** Khi muốn thay thế hoàn toàn một phần tử cũ bằng phần tử mới (ví dụ: nút "Loading" -> "Success").
**Tại sao đúng:** `replaceWith()` xử lý việc thay thế node cha mà không cần `parent` reference.

```javascript
const oldBtn = document.getElementById('btn-loading');

// Create new element
const newBtn = document.createElement('button');
newBtn.id = 'btn-success';
newBtn.textContent = 'Save Successfully';
newBtn.className = 'btn-green';

// Replace
oldBtn.replaceWith(newBtn);
// oldBtn biến mất, newBtn xuất hiện tại đúng vị trí đó.
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1.  **Dangerous `innerHTML` Injection**
    *   **Practice:** Gán `innerHTML` bằng dữ liệu nhập từ người dùng (URL params, form input) chưa xử lý.
    *   **Why Dangerous:** Gây ra **XSS (Cross-Site Scripting)**. Người dùng có thể chạy code tùy ý trên trình duyệt của nạn nhân, đánh cắp session/cookie.

2.  **Mixing `nodeValue` on Elements**
    *   **Practice:** `document.querySelector('div').nodeValue = 'text'`.
    *   **Why Dangerous:** Không có lỗi báo nhưng **không hoạt động**. `nodeValue` cho Element Node luôn là `null`. Phải dùng `textContent` hoặc `innerHTML`.

3.  **Overusing `innerHTML` for Text**
    *   **Practice:** `el.innerHTML = 'Hello World'`.
    *   **Why Dangerous:** Trình duyệt phải parse chuỗi đó thành DOM tree, sau đó xóa DOM cũ và insert mới. Hoàn toàn không cần thiết cho việc hiển thị text đơn thuần (`textContent` nhanh hơn).

4.  **Ignoring Whitespace Nodes**
    *   **Practice:** Duyệt `childNodes` và xử lý như thể mọi phần tử đều là thẻ HTML.
    *   **Why Dangerous:** `childNodes` bao gồm cả **Text Node** (khoảng trắng, dòng mới). Code sẽ gặp lỗi logic nếu không kiểm tra `nodeType === 1` (Element Node).

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Top 10 Rules**
1.  **Node vs Element:** `childNodes` (tất cả, kể cả text) vs `children` (chỉ Element).
2.  **Read Content:** `innerHTML` (có tag), `textContent` (không tag, an toàn).
3.  **Write Content:** `append()` (thêm cuối), `prepend()` (thêm đầu).
4.  **Modern Replace:** Dùng `replaceWith()` thay vì `parentNode.replaceChild()`.
5.  **Text Node:** Dùng `nodeValue` hoặc `data` (chỉ cho Text/Comment node).
6.  **Safety:** Luôn dùng `textContent` nếu dữ liệu từ người dùng.
7.  **Performance:** `document.createDocumentFragment()` để减少 Reflow khi append nhiều element.
8.  **Check Type:** `node.nodeType === 1` để filter Element (thẻ), loại bỏ Text node (dấu cách).
9.  **String vs Node:** `append()` nhận cả 2, `appendChild()` chỉ nhận Node.
10. **Attribute vs Property:** `getAttribute('id')` lấy giá trị HTML, `id` lấy giá trị property JS.

**Decision Logic**
```text
IF (Need to INSERT HTML string) -> Use .innerHTML (Check XSS!) OR .append() string.
ELSE IF (Need to INSERT Safe Text) -> Use .textContent = "...".
ELSE IF (Need to READ Text) -> Use .textContent.
ELSE IF (Need to READ HTML) -> Use .innerHTML.
ELSE IF (Working with Text Nodes) -> Use .nodeValue.
ELSE IF (Moving/Replacing Elements) -> Use .append(), .before(), .replaceWith().
```

<!-- CHUNK 71-80 -->

# Developer Decision Guide: JavaScript Events & DOM

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

**Event (Sự kiện)**: Là hành động hoặc sự cố xảy ra trong trình duyệt (ví dụ: người dùng click chuột, nhập liệu). JavaScript không chạy liên tục mà hoạt động theo cơ chế "chờ và phản ứng" (Event-Driven).

**DOM (Document Object Model - Mô hình đối tượng tài liệu)**: Cây cấu trúc HTML được biến thành các đối tượng mà JavaScript có thể tương tác. Không phải là HTML, mà là bản đồ trí nhớ của trang web.

**Event Flow (Luồng sự kiện)**: Sự kiện đi từ ngoài vào trong (Capturing) và từ trong ra ngoài (Bubbling).

**Mental Model**: Hãy tưởng tượng DOM là một công ty. Các phần tử (Node) là nhân viên. Event là công việc đến. `addEventListener` là cách bạn giao việc cho nhân viên. Nếu không giao, nhân viên sẽ không làm gì cả.

**Why this is better**: Cơ chế này giúp mã nguồn tách biệt logic (Separation of Concerns). HTML định nghĩa cấu trúc, JavaScript xử lý logic, không cần trộn lẫn như `onclick="..."`.

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Table 1: Attaching Event Handlers
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Modern Web Development** | `element.addEventListener('click', handler)` | **Preferred Method**: Hỗ trợ nhiều listener cho cùng một event và tách biệt HTML/JS. | Dùng **Inline HTML** (`onclick="..."`) làm bẩn HTML và khó bảo trì. |
| **Override/Quick Prototype** | `element.onclick = handler` | **DOM Property**: Ghi đè listener cũ, đơn giản nhưng linh hoạt thấp. | Ghi đè nhầm handler của thư viện thứ 3 hoặc của chính framework. |
| **Legacy/Security Restrictions** | `element.attachEvent('onclick', handler)` | **IE8 (Legacy)**: Chỉ dùng nếu phải hỗ trợ trình duyệt c cổ lỗ sĩ. | Dùng sai trình duyệt hiện đại (chức năng này đã bị loại bỏ). |

### Table 2: Event Object Usage
| Tình huống sử dụng | Nên dùng gì | Tại sao - EN term + VI explanation | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Get Mouse Position** | `event.clientX`, `event.clientY` | **Mouse Coordinates**: Lấy tọa độ chuột tương đối khung nhìn. | Dùng `pageX/pageY` khi cần tọa độ tương đối document (khác biệt nếu có scroll). |
| **Prevent Default** | `event.preventDefault()` | **Default Action**: Ngửng hành vi mặc định (ví dụ: submit form, mở link). | Quên gọi hàm này导致 form tự submit khi validate thất bại. |
| **Stop Propagation** | `event.stopPropagation()` | **Event Bubbling**: Dừng sự kiện lan truyền lên phần tử cha. | Dùng sai chỗ làm Event Listener của cha không bao giờ kích hoạt. |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

### Hierarchy: DOM & Event Flow
Mọi `Node` (phần tử) trong DOM đều có thể lắng nghe sự kiện thông qua `EventTarget`.

**Flow (Luồng sự kiện):**
1. **Capture Phase**: Sự kiện đi từ `Window` xuống tới `Target`.
2. **Target Phase**: Sự kiện tại phần tử mục tiêu.
3. **Bubble Phase**: Sự kiện đi từ `Target` ngược lên `Window`.

```text
[Window]
  ↓ (Capture) / ↑ (Bubble)
  [Document]
    ↓
    [HTML]
      ↓
      [Body]
        ↓
        [Button] <--- Event Target (Điểm kích hoạt)
```

### Relationship: DOM vs JavaScript
| Aspect | Document Object Model (DOM) | JavaScript (ECMAScript) |
| :--- | :--- | :--- |
| **Nature** | Tree model của HTML (Standard: W3C) | Ngôn ngữ lập trình (Standard: ECMA) |
| **Objects** | `document`, `window`, `Node`, `Event` | `String`, `Number`, `Array`, `Function` |
| **Role** | **Access & Modify**: `getElementById()`, `style` | **Control Logic**: `if/else`, `map()`, `reduce()` |
| **Interaction** | **"What"**: Tìm/thay đổi phần tử giao diện | **"How"**: Xử lý dữ liệu & gọi thao tác DOM |

**Formula**: `DOM + JavaScript = Dynamic UI`

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Event Delegation (Phân công sự kiện)
**Khi nào dùng**: Khi có nhiều phần tử con (danh sách, bảng) mà bạn không muốn gắn listener cho từng cái.
**Tại sao đúng**: Tiết kiệm bộ nhớ, tự động hoạt động cho phần tử con được thêm mới sau này (Dynamic elements).

```javascript
// HTML: <ul id="list"><li>A</li><li>B</li></ul>
const list = document.getElementById('list');

list.addEventListener('click', function(event) {
  // Kiểm tra xem click có phải vào LI không
  if (event.target && event.target.nodeName === 'LI') {
    console.log('Clicked on:', event.target.textContent);
  }
});
```

### Pattern 2: Form Handling & Default Control
**Khi nào dùng**: Khi xử lý Form, cần validate dữ liệu trước khi gửi đi.
**Tại sao đúng**: `preventDefault()` ngăn browser reload trang, cho phép xử lý logic bất đồng bộ (AJAX).

```javascript
const myForm = document.getElementById('signupForm');

myForm.addEventListener('submit', function(event) {
  const input = this.querySelector('input');
  
  if (input.value.length < 5) {
    // 1. Ngăn hành vi submit mặc định (reload trang)
    event.preventDefault();
    
    // 2. Hiện lỗi cho người dùng
    alert('Username must be at least 5 characters');
  }
  // Nếu không có lỗi, form sẽ submit bình thường
});
```

### Pattern 3: Dynamic Element Creation (Ex4 Logic)
**Khi nào dùng**: Khi người dùng nhập liệu và cần render giao diện mới ngay lập tức.
**Tại sao đúng**: Tương tác trực tiếp với DOM tree để cập nhật UI mà không cần reload.

```javascript
const input = document.getElementById('textInput');
const btn = document.getElementById('addBtn');
const ul = document.getElementById('targetList');

btn.addEventListener('click', function() {
  const text = input.value.trim();
  
  if (text) {
    // Bước 1: Tạo phần tử (không có trong DOM yet)
    const li = document.createElement('li');
    
    // Bước 2: Set nội dung/thuộc tính
    li.textContent = text;
    
    // Bước 3: Chèn vào DOM
    ul.appendChild(li);
    
    // Bước 4: Reset input
    input.value = '';
  }
});
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

**1. Inline Event Handlers (`onclick="doSomething()"`)**
- **Why**: Violates Separation of Concerns. Khó debug, không thể xóa event listener bằng JS thuần, vi phạm Content Security Policy (CSP).
- **Fix**: Dùng `addEventListener`.

**2. Memory Leaks with Handlers**
- **Why**: Gắn listener vào phần tử bị xóa khỏi DOM mà không dùng `removeEventListener` hoặc `removeChild` (trong các SPA). Lớp "Closure" vẫn giữ tham chiếu đến phần tử bị xóa.
- **Fix**: Luôn dọn dẹp trong `componentWillUnmount` (React) hoặc `disconnect` (Web Components).

**3. Overusing `stopPropagation()`**
- **Why**: Phá vỡ cơ chế Event Delegation và Bubbling. Khó khăn trong việc quản lý sự kiện toàn cục (Global Event Handlers).
- **Fix**: Chỉ dùng khi logic yêu cầu cô lập hoàn toàn.

**4. `alert()` trong Event Handler**
- **Why**: Blocking main thread. Làm giao diện "giật/lag" (UI freeze).
- **Fix**: Dùng `console.log` hoặc UI Modal không bloque (ví dụ: Toast notification).

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

### Top 10 Things to Remember
1. **Event Flow**: Capture -> Target -> Bubble.
2. **Add Listener**: `el.addEventListener(type, handler)`.
3. **Remove Listener**: `el.removeEventListener(type, handler)`.
4. **Prevent Default**: `e.preventDefault()` (Stop reload, stop link).
5. **Stop Bubble**: `e.stopPropagation()` (Stop reaching parent).
6. **Target Element**: Use `e.target` (where clicked) vs `this` (where listener attached).
7. **List Handling**: Use **Event Delegation** for lists.
8. **Form**: Always listen for `submit`, not `click` on button (handles Enter key).
9. **Hierarchy**: `EventTarget` is the root of Node, Text, Document.
10. **Scope**: DOM is Browser API, JS is Language logic.

### Decision Logic (If-Else)

```javascript
if (isFormSubmit) {
  // Check e.target
  if (validationFailed) e.preventDefault();
}

if (isDynamicList) {
  // Use Event Delegation (Attach listener to Parent)
  // Check e.target.matches('li')
}

if (isLegacyBrowser) {
  // Fallback to onlick = function
} else {
  // Use addEventListener
}
```

### JS & DOM Comparison Cheat
| Operation | JavaScript Code |
| :--- | :--- |
| **Get Element** | `document.getElementById('id')` |
| **Set Attribute** | `element.setAttribute('src', '...')` |
| **Get Attribute** | `element.getAttribute('id')` |
| **Change Style** | `element.style.color = 'red'` |
| **Add Class** | `element.classList.add('active')` |
| **Create Node** | `document.createElement('div')` |
| **Add to Page** | `parent.appendChild(newNode)` |