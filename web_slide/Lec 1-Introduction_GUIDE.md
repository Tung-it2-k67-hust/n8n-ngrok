# DEVELOPER DECISION GUIDE: Lec 1-Introduction.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:41:19



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Introduction to Web Development

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Internet (Mạng Internet)**
Một mạng lưới vật lý kết nối hàng triệu máy tính bằng các giao thức chung (TCP/IP) để truyền tải thông tin.
- **Bản chất**: Hệ thống cáp, router, server vật lý toàn cầu.

**World Wide Web - WWW (Mạng Web Toàn Cầu)**
Tập hợp các tài liệu đa phương tiện liên kết với nhau lưu trữ trên Internet và truy cập bằng giao thức chung (HTTP).
- **Bản chất**: Một lớp ứng dụng chạy trên Internet (như email, FTP cũng chạy trên Internet).

**Mental Model (Mô hình tư duy)**
Hãy tưởng tượng **Internet là con đường giao thông**, còn **Web là các cửa hàng/địa điểm** bạn muốn đến trên con đường đó. Bạn cần phương tiện (HTTP) và địa chỉ (URI/URL) để đến đúng nơi.

---

## SECTION 2: DECISION TABLES

### Web vs Internet Decision

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|-------------------|-------------|---------|-------------------|
| Thiết kế ứng dụng giao tiếp máy-tới-máy (email, file transfer) | **Internet** (TCP/IP, FTP, SMTP) | **TCP/IP** là bộ giao thức nền tảng cho mọi giao tiếp mạng, không phụ thuộc vào web browser | Nhầm lẫn Web là toàn bộ Internet, không tận dụng được các giao thức khác |
| Xây dựng giao diện người dùng qua browser | **World Wide Web** (HTTP, HTML, Browser) | **HTTP** là giao thức tối ưu cho nội dung đa phương tiện và giao diện đồ họa | Dùng Telnet/FTP để hiển thị UI (không khả thi) |
| Tối ưu tốc độ tải trang | **WWW** (caching, CDN, HTTP/2) | Web có các cơ chế tối ưu riêng cho nội dung tĩnh/động | Tối ưu ở mức TCP/IP khi chưa cần thiết (lãng phí) |

### Career Path Decision

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
|-------------------|-------------|---------|-------------------|
| Thích giao diện trực quan, UX/UI | **Frontend** (HTML/CSS/JS) | Trực tiếp nhìn thấy kết quả, khả năng sáng tạo cao, feedback nhanh | Học toàn bộ stack cùng lúc (dễ bị overload) |
| Thích logic dữ liệu, API, database | **Backend** (Node/Python/Java) | Xử lý business logic, bảo mật, scalability | Bỏ qua kiến thức HTTP/Network cơ bản |
| Muốn làm chủ toàn bộ dự án | **Fullstack** (FE + BE) | Hiểu sâu hệ thống, tự triển khai được | Chọn trước khi thử 2 mảng riêng (dễ sai định hướng) |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Web System Hierarchy (Text Diagram)

```text
[User Device] ← HTTP/HTTPS → [Browser]
       ↓
[DNS Server] → Maps Domain → IP Address
       ↓
[Web Server] ← TCP/IP → [Backend Application]
       ↓
[Database / Storage]
```

### Component Relationships

1. **DNS → Web Server**: Chuyển đổi tên miền (domain) thành địa chỉ IP vật lý
2. **Browser → Web Server**: Gửi yêu cầu HTTP, nhận HTML/CSS/JS về render
3. **Web Server → Backend**: Xử lý logic, truy vấn database nếu cần
4. **Internet**: "Đường cao tốc" kết nối tất cả các thành phần trên

**Khi nào cần hiểu rõ từng tầng?**
- **Lỗi DNS**: Không truy cập được website nhưng server vẫn chạy
- **Lỗi HTTP**: Server phản hồi nhưng giao diện bị sai
- **Lỗi TCP/IP**: Kết nối chập chờn, timeout

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Basic HTTP Request Handling (Backend)

**Khi nào dùng**: Khi cần xây dựng API cho frontend hoặc service khác gọi.

**Tại sao đúng**: HTTP là chuẩn giao tiếp web, tuân thủ RESTful giúp hệ thống dễ bảo trì.

**Code Example (Node.js/Express)**:

```javascript
const express = require('express');
const app = express();

// GET endpoint: Lấy dữ liệu
app.get('/api/users', (req, res) => {
    res.json([
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' }
    ]);
});

// POST endpoint: Nhận dữ liệu từ client
app.post('/api/users', (req, res) => {
    const userData = req.body;
    // Lưu vào database
    res.status(201).json({ message: 'User created', data: userData });
});

app.listen(3000, () => console.log('Server running on port 3000'));
```

### Pattern 2: DNS Resolution in Code

**Khi nào dùng**: Khi cần lấy IP thực tế từ tên miền (debug, load balancing).

**Tại sao đúng**: DNS là bước đầu tiên trước mọi kết nối mạng, hiểu nó giúp debug hiệu quả.

**Code Example (Node.js)**:

```javascript
const dns = require('dns');

// Chuyển tên miền thành IP
dns.lookup('google.com', (err, address, family) => {
    console.log(`IP: ${address}`); // Ví dụ: 142.250.190.46
    console.log(`IPv${family}`);
});
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Confusing Internet with Web

**Why dangerous**: Khi bạn không hiểu **Internet (TCP/IP)** vs **Web (HTTP)**, bạn sẽ không thể debug đúng:
- **Lỗi DNS**: "Website không mở" nhưng thực ra là DNS chết → Cần test bằng `ping IP` thay vì chỉ mở browser
- **Lỗi Network**: "API không hoạt động" nhưng server vẫn ping được → Cần kiểm tra port/HTTP, không phải chỉ network layer

### 2. Bỏ qua Web Developer Roadmap

**Why dangerous**: Học loạn xạ không có lộ trình → Mất 2 năm học công nghệ lỗi thời. Roadmap giúp:
- Nhận diện **Frontend** (giao diện) vs **Backend** (logic)
- Hiểu thứ tự học: HTML/CSS → JS → Framework → API → Database

### 3. Tưởng LLM/AI thay thế developer

**Why dangerous**: LLM là công cụ tăng tốc (nhúng trong IDE, generate code), không thay thế việc hiểu **cốt lõi** (HTTP, DNS, TCP/IP). Nếu không hiểu basics, bạn không thể sửa lỗi AI tạo ra.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules

1. **Web ≠ Internet**: Internet là đường, Web là nhà trên đường
2. **HTTP là ngôn ngữ**: Browser và Server nói chuyện bằng HTTP
3. **DNS là danh bạ**: Chuyển tên thành địa chỉ IP
4. **Frontend = UI**: Code chạy trên browser
5. **Backend = Logic**: Code chạy trên server

### Decision Logic (If-Else)

```text
IF (Làm giao diện, nút bấm, animation) → Frontend
ELSE IF (Xử lý data, API, login, database) → Backend
ELSE IF (Muốn làm full system) → Fullstack
ELSE → Học Web Basics trước đã (HTTP, DNS)
```

### Top 5 Things to Remember for Exam

1. **TCP/IP**: Giao thức mạng cơ bản (Internet)
2. **HTTP**: Giao thức web (World Wide Web)
3. **DNS**: Hệ thống phân giải tên miền → IP
4. **URI/URL**: Địa chỉ tài nguyên trên Web
5. **Browser**: Client software để truy cập Web

### API Call Flow Checklist

```text
1. Browser nhập URL → 2. DNS lookup IP → 3. TCP connection → 
4. HTTP request → 5. Server processing → 6. HTTP response → 
7. Browser render
```
**Lỗi ở bước nào?** Dùng tools:
- **Bước 1-2**: `ping`, `nslookup`
- **Bước 3-4**: `curl`, Postman, Browser DevTools (Network tab)
- **Bước 5-6**: Server logs, console.log

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: Internet & Web Fundamentals (Lec 1)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **ARPANET (Advanced Research Projects Agency Network)**: Mạng máy tính do Bộ Quốc phòng Hoa Kỳ phát triển vào năm 1969, là nền tảng kỹ thuật cho Internet hiện đại. Nó được thiết kế để chịu lỗi (fault-tolerance) và sống sót sau tấn công (survivability) bằng cách phân tán dữ liệu.
*   **HTTP (Hypertext Transfer Protocol)**: Giao thức ứng dụng dùng cho việc trao đổi dữ liệu trên World Wide Web. Nó hoạt động theo mô hình **Client-Server** (Máy khách - Máy chủ).
*   **DNS (Domain Name System)**: Hệ thống "danh bạ" của Internet, chuyển đổi tên miền dễ đọc (ví dụ: `google.com`) thành địa chỉ IP máy tính (ví dụ: `142.250.193.206`) để máy tính định vị nhau.
*   **Stateless (Không trạng thái)**: Đặc tính của HTTP, trong đó máy chủ **không lưu trữ** thông tin về phiên làm việc của người dùng giữa các yêu cầu (request) riêng lẻ. Mỗi yêu cầu đều độc lập như lần đầu tiên.

### Mental Model: The "Survivable Web"

Hãy tư duy về Internet như một hệ thống **phi tập trung (decentralized)**. Thay vì một trung tâm duy nhất (như tổng đài điện thoại cũ), Internet là một mạng lưới các nút (nodes) kết nối chằng chịt.

*   **Reality Check**: Khi bạn gõ `vnexpress.net`, DNS chuyển đổi tên thành IP. Trình duyệt (Client) gửi HTTP Request đến Server đó.
*   **Stateless Reality**: Server không nhớ bạn là ai trừ khi bạn gửi theo Token (Session/Cookie). Đây là lý do tại sao bạn phải đăng nhập lại nếu xóa Cache.

### Why this approach is better?

*   **Survivability**: Nếu một tuyến cáp bị cắt, dữ liệu tự động đi đường vòng (đây là bài học từ thiết kế "survivable" của Paul Baran).
*   **Scalability**: Máy chủ không phải quản lý trạng thái cho hàng triệu kết nối giúp hệ thống chạy nhanh hơn và ổn định hơn.

---

## SECTION 2: DECISION TABLES

### Table 1: Architecture & History

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Xây dựng hệ thống mạng quân sự hoặc tài chính yêu cầu độ chính xác cao | **Mạng phi tập trung (Decentralized Network)** | **Survivability (Sự sống sót)**: Hệ thống vẫn hoạt động ngay cả khi một phần bị tấn công hoặc lỗi. | Thiết kế tập trung quá mức (Single Point of Failure - SPOF), khiến cả hệ thống sụp đổ nếu server chính hỏng. |
| Chia sẻ dữ liệu giữa các máy tính khác hệ điều hành/hardware | **ARPANET model (TCP/IP)** | **Interoperability (Tương thích)**: Kết nối được máy tính Heterogeneous (khác biệt). | Cố gắng thiết kế giao thức proprietary (riêng) thay vì dùng chuẩn TCP/IP hiện có. |

### Table 2: Web Protocols & Concepts

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| Hiển thị trang web (cần giao diện đồ họa, media) | **HTTP + HTML + Modern Browser** | **Rendering & Interaction**: Hỗ trợ đa phương tiện và tương tác người dùng. | Dựa vào Text-based browser (như Mosaic đời đầu) cho ứng dụng hiện đại, dẫn đến UX nghèo nàn. |
| Chuyển đổi tên miền sang IP | **DNS (Domain Name System)** | **Human-readable to Machine-readable**: Giúp người dùng gõ tên thay vì số. | Hardcode (ghim cứng) địa chỉ IP vào code, gây lỗi khi server IP thay đổi. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Web Request Flow

```text
[User] ---(Gõ URL---> [Browser (Client)] ---(DNS Query---> [DNS Server]
                                                    |
                                                    V
                                              [IP Address]
                                                    |
                                                    V
[Browser] ---(HTTP Request (Stateless)---> [Web Server] ---(HTTP Response---> [Browser]
                                     (Xử lý logic, truy vấn DB)             (Render HTML)
```

### Component Hierarchy

1.  **Application Layer**: Web Browser (Chrome, Firefox, Edge).
    *   *Function*: Render HTML, Gửi HTTP Request.
2.  **Transport Layer**: HTTP/HTTPS.
    *   *Function*: Quy tắc trao đổi dữ liệu (Request/Response).
3.  **Addressing Layer**: DNS + URI.
    *   *Function*: Tìm địa chỉ và xác định tài nguyên.
4.  **Infrastructure Layer**: TCP/IP Network (ARPANET legacy).
    *   *Function*: Đảm bảo gói tin đến nơi an toàn (Survivability).

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Stateless Request Handling (Simulation)

**Khi nào dùng**: Khi thiết kế API hoặc Server logic. Luôn giả định Server không nhớ Client.

**Tại sao đúng**: Đảm bảo hệ thống có thể Scale horizontally (thêm server) mà không cần đồng bộ state.

```python
# Mô phỏng server-side xử lý request
class StatelessServer:
    def __init__(self):
        self.request_count = 0 # Không dùng để tracking user specific

    def handle_request(self, user_id, request_data):
        self.request_count += 1
        
        # MỖI REQUEST ĐỀU XỬ LÝ ĐỘC LẬP
        # KHÔNG có memory về request trước đó của user này
        if "session_token" not in request_data:
            return {"error": "Unauthorized", "code": 401}
        
        # Logic xử lý nghiệp vụ ở đây
        return {"status": "success", "data": request_data}

# Sử dụng
server = StatelessServer()
# Request 1
print(server.handle_request(1, {"session_token": "xyz", "action": "buy"})) 
# Request 2 (Server không tự động nhớ session, client phải gửi lại token)
print(server.handle_request(1, {"session_token": "xyz", "action": "sell"}))
```

### Pattern 2: URL to Object Mapping (URI)

**Khi nào dùng**: Khi cần định nghĩa tài nguyên (Resource) trên Web.

**Tại sao đúng**: URI (Uniform Resource Identifier) là chuẩn để xác định duy nhất một tài nguyên bất chấp vị trí vật lý của nó.

```python
# Python: Kiểm tra tính hợp lệ của URL (URI)
from urllib.parse import urlparse

def validate_resource_location(url):
    parsed = urlparse(url)
    
    if not parsed.scheme or not parsed.netloc:
        return False # Thiếu http/https hoặc domain
        
    # Chức năng: Ánh xạ URL -> Resource
    resource_map = {
        "/users": "Danh sách người dùng",
        "/posts": "Bài viết"
    }
    
    path = parsed.path
    return resource_map.get(path, "404 Not Found")

# Demo
print(validate_resource_location("http://example.com/users")) 
# Output: Danh sách người dùng
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Assuming State on Server (Giả định trạng thái trên Server)
*   **Dangerous Practice**: Lập trình viên cho rằng sau khi gửi request A, server sẽ "nhớ" để xử lý request B mà không cần xác thực lại.
*   **Why**: HTTP là **Stateless**. Nếu user refresh browser hoặc request bị timeout, mọi thông tin tạm thời sẽ mất.

### 2. Hardcoding IP Addresses (Ghim cứng địa chỉ IP)
*   **Dangerous Practice**: Trong code, kết nối trực tiếp đến `192.168.1.100`.
*   **Why**: IP có thể thay đổi. Dùng DNS (tên miền) cho phép thay đổi server phía sau mà không cần update code client.

### 3. Trusting Client-side History (Tin tưởng lịch sử Client)
*   **Dangerous Practice**: Dựa vào nút "Quay lại" (Back button) của browser để điều hướng logic nghiệp vụ phức tạp.
*   **Why**: Người dùng có thể bookmark hoặc gõ URL trực tiếp, bỏ qua các bước bạn nghĩ là "bắt buộc".

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things to Remember
1.  **1969**: ARPANET ra đời -> Cha đẻ của Internet.
2.  **1989**: Tim Berners-Lee phát minh Web (HTTP/HTML).
3.  **Decentralized**: Mạng không có trung tâm duy nhất (Survivable).
4.  **Stateless**: Server không nhớ Client giữa các request.
5.  **DNS**: Chuyển `tên.com` → `IP`.
6.  **URL/URI**: Địa chỉ duy nhất của tài nguyên.
7.  **Request-Response**: Client gửi yêu cầu, Server trả lời.
8.  **Browser**: Công cụ hiển thị (Render) và gửi request.
9.  **TCP/IP**: Giao thức nền tảng đảm bảo dữ liệu đi đúng đường.
10. **Modern Web**: Bắt đầu graphical từ Mosaic (1993) → Chrome/Firefox.

### Decision Logic
*   **Cần kết nối mạng?** → Dùng TCP/IP.
*   **Cần truy cập bằng tên dễ nhớ?** → Dùng DNS.
*   **Cần trao đổi dữ liệu Web?** → Dùng HTTP (Client-Server, Stateless).
*   **Cần hiển thị giao diện đẹp?** → Dùng Browser (Chrome/Edge/...) + HTML.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: HTTP Fundamentals (Lecture 1)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **HTTP (HyperText Transfer Protocol)**: Giao thức chuẩn để truyền dữ liệu trên Web, hoạt động dựa trên mô hình Client-Server.
- **TCP (Transmission Control Protocol)**: Giao thức vận chuyển tin cậy mà HTTP thường sử dụng (Port 80).
- **URI (Uniform Resource Identifier)**: Chuỗi định danh tài nguyên.
  - **URL (Uniform Resource Locator)**: Định vị tài nguyên (ví dụ: `https://example.com`) - **Dùng khi cần định vị VỊ TRÍ**.
  - **URN (Uniform Resource Name)**: Tên định danh tài nguyên (ví dụ: `urn:isbn:12345`) - **Dùng khi chỉ cần ĐỊNH DANH**.

### Key Mental Model: Request-Response Cycle
HTTP là giao thức **không trạng thái (Stateless)**. Mỗi request là một thực thể độc lập.
1. **Client** (Browser/App) thiết lập TCP Connection.
2. **Client** gửi **Request** (Đường dẫn + Phương thức + Header + Body).
3. **Server** xử lý và trả về **Response** (Mã trạng thái + Header + Body).
4. **Server** đóng kết nối (hoặc giữ lại nếu dùng Keep-Alive).

### Why this is Better
So với các giao thức tùy chỉnh (Custom Protocol), HTTP:
- **Hỗ trợ sẵn:** Có sẵn công cụ kiểm tra (Postman, Curl), cache proxy.
- **Tiêu chuẩn hóa:** Phù hợp mạng công khai (Internet).

---

## SECTION 2: DECISION TABLES

### Table 1: HTTP Method Selection
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| Lấy dữ liệu chỉ đọc (Read-only) | **GET** | **Idempotent (Bất biến)**: Không thay đổi trạng thái server, cache được. | Dùng GET để xóa dữ liệu (vi phạm quy tắc an toàn). |
| Tạo mới tài nguyên (Create) | **POST** | **Non-idempotent (Không bất biến)**: Mỗi lần gọi tạo bản ghi mới. | Dùng POST để cập nhật (nên dùng PUT/PATCH). |
| Cập nhật/Có thể tạo mới (Update/Upsert) | **PUT** | **Idempotent**: Gửi toàn bộ resource, gọi bao nhiêu lần kết quả giống nhau. | Dùng PUT để cập nhật 1 trường lẻ (nên dùng PATCH). |
| Cập nhật 1 phần (Partial Update) | **PATCH** | Chỉ gửi phần dữ liệu thay đổi, tiết kiệm bandwidth. | Cấu trúc payload không rõ ràng, khó rollback. |

### Table 2: HTTP Status Code Classes
| Tình huống sử dụng (Use case) | Nên dùng gì (Should use) | Tại sao (Why) | Sai lầm thường gặp (Common mistake) |
| :--- | :--- | :--- | :--- |
| Thành công có dữ liệu trả về | **2xx (200 OK, 201 Created)** | **Success**: Server đã xử lý đúng yêu cầu. | Trả về 200 ngay cả khi lỗi nghiệp vụ (nên dùng 400). |
| Cần chuyển hướng (Redirect) | **3xx (301 Moved Permanently, 302 Found)** | **Redirection**: Gợi ý client lấy URL mới. | Thiếu header `Location` trong response. |
| Lỗi do Client (Input sai, Không có quyền) | **4xx (400 Bad Request, 404 Not Found, 401 Unauthorized)** | **Client Error**: Server hiểu yêu cầu nhưng từ chối do client sai. | Trả về 500 Internal Server Error khi URL sai (404 mới đúng). |
| Lỗi do Server (Bug, Database down) | **5xx (500 Internal Server Error, 503 Service Unavailable)** | **Server Error**: Server không thực hiện được yêu cầu. | Trả về 404 khi database lỗi (500 mới đúng). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### HTTP Message Structure (Request & Response)
Cả Request và Response đều có cấu trúc 3 phần chính:
1. **Start Line**: Khai báo thông tin cơ bản.
2. **Headers**: Metadata (Kiểu dữ liệu, độ dài...).
3. **Body**: Dữ liệu thực tế (Optional).

### Text-Based Flowchart
```text
[ Client ] 
   |
   | (1. TCP Connection: Port 80)
   v
[ HTTP Request ]
   |-- Start Line: "GET /index.html HTTP/1.1"
   |-- Headers:    "Host: example.com"
   |-- Blank Line: (Đánh dấu kết thúc Header)
   |-- Body:       (Rỗng với GET)
   |
   v
[ Server ]
   |-- Xử lý Logic
   |
   v
[ HTTP Response ]
   |-- Start Line: "HTTP/1.1 200 OK"
   |-- Headers:    "Content-Type: text/html"
   |-- Blank Line:
   |-- Body:       "<html>...</html>"
   |
   v
[ Client Render ]
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Constructing a Raw HTTP Request
*Khi nào dùng:* Khi cần hiểu sâu hoặc debug giao thức ở mức thấp (Socket/Network).
*Tại sao đúng:* Giúp thấy rõ từng byte gửi đi, tránh lầm tưởng về "magic" của thư viện.

```python
import socket

def send_raw_http_request(host, path):
    # Tạo socket TCP
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, 80))
    
    # 1. Build Request Line
    # 2. Build Headers
    # 3. Blank Line quan trọng (\r\n\r\n)
    request = f"GET {path} HTTP/1.1\r\n"
    request += f"Host: {host}\r\n"
    request += "Connection: close\r\n" # Đóng kết nối sau khi nhận
    request += "\r\n" # Kết thúc Headers
    
    # Gửi bytes
    sock.sendall(request.encode('utf-8'))
    
    # Nhận response
    response = b""
    while True:
        data = sock.recv(1024)
        if not data: break
        response += data
    
    sock.close()
    return response.decode('utf-8')

# Sử dụng
print(send_raw_http_request("www.example.org", "/"))
```

### Pattern 2: Handling HTTP Status Codes Programmatically
*Khi nào dùng:* Luồng xử lý lỗi và UX trong application.
*Tại sao đúng:* Phân biệt rõ lỗi network, lỗi client, lỗi server để có hành động phù hợp (retry vs cảnh báo).

```python
import requests # Thư viện cao cấp

def fetch_data(url):
    try:
        resp = requests.get(url)
        
        # Phân tích Status Code
        if resp.status_code == 200:
            return resp.json()
            
        elif resp.status_code == 404:
            raise Exception("Tài nguyên không tồn tại - Kiểm tra lại URL.")
            
        elif resp.status_code >= 500:
            raise Exception("Lỗi Server - Thử lại sau.")
            
        else:
            return None
            
    except requests.exceptions.RequestException as e:
        # Lỗi mạng (DNS, Timeout)
        raise Exception("Không thể kết nối tới Server.")

# Sử dụng
try:
    data = fetch_data("https://api.example.com/data")
except Exception as e:
    print(f"Lỗi: {e}")
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1. **Dùng GET để thay đổi dữ liệu (Side-effect)**
   - **Nguy hiểm:** Các con bot, công cụ tìm kiếm (SEO) hoặc browser pre-fetching có thể gọi URL này tự động và làm hỏng dữ liệu của bạn.
   - **Cách tránh:** Chỉ dùng GET để lấy dữ liệu. Dùng POST/PUT cho thay đổi.

2. **Trả về 200 OK cho mọi thứ**
   - **Nguy hiểm:** Code client sẽ không bao giờ bắt được lỗi (ví dụ: `if (response.status != 200)` sẽ bỏ qua lỗi).
   - **Cách tránh:** Trả về 4xx (Client lỗi) hoặc 5xx (Server lỗi) entsprechend để client xử lý tự động.

3. **Bỏ qua HTTP Headers (Cache, Encoding)**
   - **Nguy hiểm:** Gây quá tải server vì không cho phép client cache. Gây lỗi hiển thị do sai mã hóa (UTF-8).
   - **Cách tránh:** Luôn set `Content-Type` và `Cache-Control`.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
```text
IF (Action is Read) THEN Use: GET
ELSE IF (Action is Create New) THEN Use: POST
ELSE IF (Action is Update Full) THEN Use: PUT
ELSE IF (Action is Update Partial) THEN Use: PATCH
ELSE IF (Action is Delete) THEN Use: DELETE

IF (Request Success with Body) THEN Status: 200 OK
IF (Request Success Created) THEN Status: 201 Created
IF (Client sends Bad Data) THEN Status: 400 Bad Request
IF (Client asks for Missing Data) THEN Status: 404 Not Found
IF (Server crashes) THEN Status: 500 Internal Server Error
```

### Top 5 Things to Remember
1. **Stateless:** Server không nhớ client giữa các request (phải xử lý session/token).
2. **Port 80:** Cổng mặc định của HTTP (Secure là 443).
3. **`\r\n\r\n`:** Dấu hiệu kết thúc Headers trong Request/Response.
4. **URI > URL:** URL là loại URI (định vị địa điểm), URN thì không (định danh tên).
5. **First Digit Matters:** Đọc mã trạng thái qua số đầu tiên (2xx=OK, 4xx=Lỗi Client, 5xx=Lỗi Server).

<!-- CHUNK 31-36 -->

# DEVELOPER DECISION GUIDE: Web Hosting & Servers (Lecture 1)

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

**Web Hosting (Dịch vụ lưu trữ web)**
Dịch vụ đám mây cung cấp không gian trên máy chủ (server) để lưu trữ tất cả file mã nguồn (HTML, CSS, JS, Code backend) và cho phép người dùng truy cập qua Internet.

**Web Server (Máy chủ web)**
Là phần mềm (hoặc phần cứng) xử lý các yêu cầu HTTP/HTTPS từ trình duyệt và trả về phản hồi (web page, dữ liệu).
*   **Ví dụ phần mềm:** Apache, Nginx, IIS.

### The Reality Check
*   **Web Hosting** là "mặt bằng" (địa điểm vật lý hoặc ảo).
*   **Web Server** là "người vận hành" ở trong mặt bằng đó (phần mềm xử lý request).
*   Một Web Hosting (VPS) có thể chạy nhiều Web Server khác nhau.

---

## SECTION 2: DECISION TABLES

### Table 1: Web Hosting Types Selection

| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Web tin tức đơn giản, traffic thấp, budget hạn chế** | **Shared Hosting** | Tiết kiệm chi phí (Cost-effective), không cần quản lý hệ thống phức tạp. | Dùng VPS cho web nhỏ gây tốn kém và quản lý rắc rối. |
| **Web cần tài nguyên riêng, chạy app tùy chỉnh, VPS là điểm bắt đầu tốt** | **Virtual Private Server (VPS)** | Tách biệt tài nguyên (Dedicated resources), root access tùy biến cao. Balance cost vs control. | Chọn Shared Hosting khi app cần RAM/CPU cao -> Web bị treo do chung tài nguyên với site khác. |
| **Web lớn, traffic cực cao, cần uptime 99.99%** | **Cloud Hosting** | Khả năng mở rộng linh hoạt (Scalable), thanh toán theo lượng dùng. | Dùng Dedicated Server (đơn lẻ) -> Server bị lỗi thì site chết cả ngày. |
| **Siêu thị điện tử lớn, bảo mật dữ liệu nghiêm ngặt** | **Dedicated Hosting** | Toàn quyền kiểm soát phần cứng, bảo mật tối đa (không ai chung server với bạn). | Dùng Shared Hosting -> Dễ bị lỗ hổng "cross-site" từ site khác tấn c. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Hierarchy & Data Flow

```text
[ Người dùng (Browser) ]
       |
       v
[ Internet ]
       |
       v
[ DNS System ] -> Tên miền trỏ đến IP Hosting
       |
       v
[ Web Hosting (Máy chủ vật lý/tưưởng) ] <--- (Resources: CPU/RAM/Disk)
       |
       +-- [ Web Server Software (Apache/Nginx) ]
             |
             +-- Nhận Request (GET /index.html)
             +-- Đọc file -> Xử lý (PHP/Node)
             +-- Trả về Response (HTML/Data)
```

### Mối quan hệ
1.  **Client** yêu cầu `domain.com`.
2.  **DNS** tìm IP của **Web Hosting**.
3.  **Web Hosting** (bộ nhớ) chuyển yêu cầu cho **Web Server Software** (bộ não).
4.  **Web Server** trả kết quả về Client.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Basic Nginx Config (Cấu hình Web Server)
**Khi nào dùng:** Cài đặt Web Server trên VPS/Cloud Hosting để phục vụ file tĩnh.

**Tại sao đúng:** Tách biệt cấu hình Port, Root folder và tối ưu xử lý request.

```nginx
# File: /etc/nginx/sites-available/default
server {
    listen 80; # Lắng nghe port 80 (HTTP)
    server_name example.com www.example.com; # Tên miền

    root /var/www/html; # Thư mục chứa source code
    index index.html index.htm; # File mặc định

    location / {
        try_files $uri $uri/ =404;
    }
}
```

### Pattern 2: Git Deployment (Triển khai code lên Hosting)
**Khi nào dùng:** Khi bạn dùng VPS/Cloud và muốn update code nhanh, an toàn.

**Tại sao đúng:** Tránh upload file thủ công (dễ lỗi), lưu trữ history thay đổi rõ ràng.

```bash
# 1. Clone repository lên server
git clone https://github.com/username/project.git /var/www/my-app

# 2. Vào thư mục
cd /var/www/my-app

# 3. (Tùy chọn) Cấu hình Web Server trỏ vào thư mục này
# sudo nano /etc/nginx/sites-available/my-app

# 4. Khi update code, chỉ cần pull
git pull origin main
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Dùng Shared Hosting cho Database lớn:**
    *   **Nguy hiểm:** Shared Hosting thường giới hạn số lượng kết nối (connection limits) và CPU. Database sẽ chạy chậm hoặc crash khi có nhiều người truy cập.
    *   **Solution:** Chuyển Database sang VPS hoặc Cloud Database riêng.

2.  **Không cấu hình Web Server (Nginx/Apache) đúng cách:**
    *   **Nguy hiểm:** Để mặc định có thể serving source code PHP/Node nhạy cảm (`.env`, config file) ra ngoài nếu lỗi cấu hình.
    *   **Solution:** Luôn ẩn file config và chỉ cho phép truy cập public vào `index.html` hoặc entry point.

3.  **Bỏ qua DNS TTL (Time To Live):**
    *   **Nguy hiểm:** Khi đổi hosting mà TTL quá cao, người dùng sẽ phải chờ rất lâu (vài giờ đến 1 ngày) để thấy website mới.
    *   **Solution:** Luôn set TTL thấp (ví dụ: 300s) trước khi đổi máy chủ.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
*   **Small Blog / Portfolio:** Shared Hosting (Đơn giản, rẻ).
*   **App Custom / Backend API:** VPS (Cần quyền điều khiển).
*   **App "Viral" / Lớn nhanh:** Cloud Hosting (Mở rộng tự động).

### Decision Logic (If-Else)
*   **If** Budget < $5/month + Traffic thấp -> **Shared Hosting**.
*   **If** Cần cài đặt Custom OS / SSH Access -> **VPS**.
*   **If** Traffic tăng/giảm đột ngột -> **Cloud Hosting**.

### Top 3 Things to Remember
1.  **Hosting** là nơi chứa code, **Web Server** là phần mềm chạy code.
2.  **VPS** là bước đầu tiên để học cách quản trị server thực sự.
3.  Luôn dùng **Git** để quản lý code trên Hosting/VPS, không dùng FTP upload từng file.