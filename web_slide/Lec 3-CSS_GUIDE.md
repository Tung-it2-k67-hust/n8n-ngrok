# DEVELOPER DECISION GUIDE: Lec 3-CSS.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 17:50:54



<!-- CHUNK 1-10 -->

# Developer Decision Guide: CSS Fundamentals (Lec 3)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **CSS (Cascading Style Sheets - Bảng样式 Kế thừa):** A language used to describe the presentation of a document written in HTML. It separates content (HTML) from visual appearance (colors, fonts, layout).
- **Selector (Bộ chọn):** The pattern used to target specific HTML elements to apply styles to them.
- **The Cascade (Quy trình Kế thừa):** The algorithm browsers use to resolve conflicts when multiple rules apply to the same element. It calculates specificity and priority.

### Key Mental Models
1.  **The Box Model:** Every element is a rectangular box. You control its size via `width`/`height`, then add space *inside* (`padding`) and *outside* (`border`, `margin`) of that box.
2.  **Specificity Hierarchy:** When two rules conflict, the browser decides based on this priority score (highest to lowest):
    1.  `!important` (Bypasses logic - avoid if possible).
    2.  Inline styles (The `style` attribute).
    3.  ID selectors (`#id`).
    4.  Class/Attribute/Pseudo-class selectors (`.class`, `[type="text"]`, `:hover`).
    5.  Element selectors (`div`, `p`).
3.  **Source Order:** If specificities are equal, the rule defined *last* in the CSS file (or `<style>` tag) wins.

### Why CSS Separation is Better
- **Maintainability:** Changing the font size of all buttons requires editing one line in one CSS file, not 50 HTML files.
- **Performance:** CSS is cached by the browser; HTML is usually smaller and loads faster.

---

## SECTION 2: DECISION TABLES

### When to Apply Styles (Application Methods)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Testing / Quick fix** | **Inline CSS** (`style="..."`) | Fastest way to see visual changes without file context. | Using Inline for production code, leading to unreadable HTML and inability to reuse styles. |
| **Single page specific styles** | **Internal CSS** (`<style>`) | Keeps styles scoped to one specific page (e.g., distinct layout for the Homepage). | Defining duplicate styles here that are needed on other pages, violating the DRY (Don't Repeat Yourself) principle. |
| **General application styling** | **External CSS** (`.css` file) | Best for reusability, caching, and separation of concerns. | Forgetting to link the file, or updating the CSS without refreshing the browser (caching issue). |

### When to Use Specific Units

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Typography / Font sizing** | `rem` or `em` | Scales relative to the user's browser settings or parent element (Accessibility). | Using `px` for fonts, preventing users from zooming in/out comfortably. |
| **Screen layout / Dimensions** | `%` or `vw`/`vh` | Responsive. Allows elements to stretch/shrink based on the viewport width. | Using fixed `px` widths for main containers, causing horizontal scrollbars on mobile. |
| **Fine-tuning borders/spacing** | `px` (Pixels) | Physical screen pixels. Provides consistent, sharp edges for small values. | Using `rem` for a 1px border; results might vary unpredictably on different zoom levels. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The HTML-CSS-DOM Flow
HTML (Structure) -> DOM Tree -> CSS (Rules) -> Render Tree (Visuals)

### Selector Relationships
```text
[Parent Element]
    |
    |-- [Child Element] (Direct descendant, selected with `>`)
    |       |
    |       |-- [Grandchild Element] (Nested)
    |
    |-- [Sibling Element] (Adjacent, selected with `+` or `~`)
```

### The Box Model Hierarchy (Inside Out)
1.  **Content:** Text or Image.
2.  **Padding:** Space *inside* the border (clears content from border).
3.  **Border:** The visible edge.
4.  **Margin:** Space *outside* the border (separates element from others).

---

## SECTION 4: CODE PATTERNS

### Pattern 1: The "Reset & Define" Setup
**Khi nào dùng:** Bắt đầu mọi dự án web. Ensures consistency across different browsers.
**Tại sao đúng:** Browsers have default styles (e.g., margins on `<body>`). This removes them so you start from zero.

```html
<!-- HTML -->
<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>My Title</h1>
  <p>My paragraph.</p>
</body>
</html>
```

```css
/* style.css */

/* 1. Reset (Bỏ mặc định) */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box; /* Quan trọng: tính padding/border vào kích thước tổng */
}

/* 2. Define (Định nghĩa cơ bản) */
body {
  font-family: Arial, sans-serif; /* Đọc dễ hơn */
  line-height: 1.6; /* Khoảng cách dòng dễ đọc */
  background-color: #f4f4f4;
}

h1 {
  color: #333; /* Màu tối cho tiêu đề */
  margin-bottom: 1rem; /* Khoảng cách với phần tử bên dưới */
}
```

### Pattern 2: The "BEM" Naming Convention (Block__Element--Modifier)
**Khi nào dùng:** Khi project có nhiều component lồng nhau.
**Tại sao đúng:** Tránh xung đột tên class, CSS dễ dò tìm lỗi.

```css
/* Block (Component chính) */
.card {
  border: 1px solid #ccc;
  padding: 1rem;
}

/* Element (Phần tử bên trong Block) */
.card__title {
  font-size: 1.2rem;
  font-weight: bold;
}

/* Modifier (Trạng thái của Block/Element) */
.card--highlighted {
  border-color: blue;
  background-color: lightblue;
}
```

```html
<div class="card card--highlighted">
  <h3 class="card__title">Promo Title</h3>
</div>
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Overusing `!important`
- **The Danger:** It breaks the Cascade (Quy trình Kế thừa). It forces the browser to use this rule regardless of specificity.
- **Why avoid:** It creates a "Specificity War." You will eventually have to write `!important !important` to override it. Use it only for utility classes (e.g., `.hidden`).

### 2. Using Inline CSS for Layouts
- **The Danger:** Makes the HTML file huge and difficult to read. Hard to change later.
- **Why avoid:** It has the highest specificity (excluding `!important`), making it nearly impossible to override with external stylesheets for responsive design.

### 3. `px` for Everything
- **The Danger:** Breaks accessibility.
- **Why avoid:** If a visually impaired user sets their browser base font to 24px, your `px`-based layout won't scale with it. Use `rem`/`em` for scalable UI.

### 4. The `*` Selector in Production CSS
- **The Danger:** Performance hit.
- **Why avoid:** `*` tells the browser to match *every single element* on the page. On complex pages, this slows down rendering. Use specific selectors instead.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
1.  **Specificity Score:** 0-0-0-0 (Inline-ID-Class-Tag).
2.  **Layout Flow:** Block (full width) vs Inline (content width).
3.  **Responsiveness:** Use `%` or `rem` + Media Queries (`@media (max-width: 600px)`).

### Decision Logic (If-Else)
- **If** you need to style one specific element once: **Use Inline CSS**.
- **Else if** the style is only for one specific HTML file: **Use Internal CSS**.
- **Else if** the style is reused across the site: **Use External CSS**.
- **Else** (Targeting elements): **Use Selectors (Class > ID > Tag)**.

### Top 3 Things to Remember
1.  **Box-Sizing:** Always set `box-sizing: border-box` to make math easy.
2.  **Order Matters:** CSS reads top-to-bottom. Last rule wins (if specificity is equal).
3.  **The C in CSS:** The "C" stands for **Cascading**. Understand how rules inherit and override each other to fix bugs.

<!-- CHUNK 11-20 -->

# DEVELOPER DECISION GUIDE: CSS Selectors & Architecture (Lec 3)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **External CSS (CSS bên ngoài)**: File `.css` riêng biệt được liên kết với HTML. Đây là phương pháp chuẩn để xử lý giao diện cho các dự án quy mô lớn vì cho phép tái sử dụng code và tách biệt logic giao diện (UI) khỏi cấu trúc nội dung (HTML).
*   **Selector (Bộ chọn)**: Cơ chế xác định HTML element(s) nào sẽ áp dụng styles. Think of it as the "address" of the element on the page.
*   **Specificity (Độ ưu tiên)**: Quy tắc phân cấp trọng số quyết định style nào được ưu tiên khi có xung đột.

### Key Mental Model: CSS Specificity Hierarchy
Khi trình duyệt render CSS, nó tính toán "điểm số" của selector. Selector nào có điểm cao hơn sẽ thắng. Point system:
1.  `!important` (Highest - Avoid unless emergency)
2.  Inline styles (`style="..."`) - 1000 points
3.  ID (`#id`) - 100 points
4.  Class (`.class`), Attribute (`[type="text"]`), Pseudo-class (`:hover`) - 10 points
5.  Element (`div`, `p`) - 1 point

### Why External CSS > Internal/Inline
*   **Caching**: Trình duyệt tải file `.css` một lần và lưu lại, các trang sau load nhanh hơn.
*   **Maintenance (Bảo trì)**: Sửa 1 file thì thay đổi toàn bộ website. Inline buộc bạn phải sửa từng trang.
*   **Separation of Concerns (Tách biệt trách nhiệm)**: Designer lo CSS, Developer lo HTML structure không bị rối.

---

## SECTION 2: DECISION TABLES

### Table 1: File Location Strategy

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Dự án lớn, nhiều trang** | **External CSS** | **Reusability (Tái sử dụng)** & **Maintainability (Bảo trì)**. Change one file, update site-wide. | Dùng Inline styles cho mọi thẻ `div`. |
| **Single page website** | Internal CSS (trong `<style>`) | Đơn giản hóa file cấu trúc, không cần request thêm file ngoài. | Tạo file `.css` rườm rà cho landing page 1 trang. |
| **Fix lỗi gấp, Proof of Concept** | Inline `style="..."` | Nhanh nhất để override mọi thứ (Highest specificity immediate). | Dùng Inline thường xuyên → Code bẩn, khó bảo trì. |

### Table 2: Selector Strategy

| Use case (Tình huống sử dụng) | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Chọn 1 phần tử duy nhất** | **ID Selector (`#unique`)** | **Specificity cao (100 điểm)**. Dùng cho anchor links, JS hooks. | Dùng ID cho style nhiều phần tử cùng lúc (phá vỡ cấu trúc DOM). |
| **Chọn nhiều phần tử giống nhau** | **Class Selector (`.group`)** | **Reusability**. Dùng cho components (nút, card, form). | Tạo class mới `.btn-red`, `.btn-blue` thay vì dùng 1 class `.btn` kết hợp modifier. |
| **Chọn phần tử không có class/ID** | **Attribute Selector (`[attr]`)** | **Linh hoạt**. Dựa trên thuộc tính dữ liệu (data attributes) hoặc type input. | Viết selector quá dài dòng: `div > ul > li > a`. |
| **Chọn theo trạng thái** | **Pseudo-class (`:hover`)** | **Interactive UX**. Phản hồi hành động người dùng mà không cần thêm class thủ công. | Dùng JS để toggle class `hover` một cách thừa thãi. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### DOM Relationship Hierarchy

```text
[Root Element] <html>
    |
    +-- [Parent] <body>
           |
           +-- [Ancestor] <div id="container">
                  |
                  +-- [Target] <p class="text"> (I am target)
                  |
                  +-- [Child] <span>
                  |
                  +-- [Sibling] <h1>
                  |
                  +-- [Adjacent Sibling] <p> (Select this if using h1+p)
```

### Selector Relationship Logic

1.  **Descendant (`A B`)**: Chọn B bất kỳ nằm trong A (xâu sâu).
    *   *Ví dụ*: `div p` → Chọn tất cả `<p>` trong `<div>`.
2.  **Child (`A > B`)**: Chọn B là con trực tiếp của A (không tính cháu).
    *   *Ví dụ*: `ul > li` → Chọn `<li>` trực tiếp, bỏ qua `<li>` nằm trong `<ol>`.
3.  **Adjacent Sibling (`A + B`)**: Chọn B ngay sát A (phải cùng cha).
    *   *Ví dụ*: `h1 + p` → Chỉ chọn `<p>` nằm ngay sau `<h1>`.

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Class Sandwich" (Best Practice)
**Khi nào dùng**: Khi styling layout hoặc components.
**Tại sao đúng**: Tránh reliance vào `#ID` hoặc thẻ HTML thuần (element), cho phép tái sử dụng và dễ dàng thay đổi HTML structure mà không hỏng CSS.

```html
<!-- HTML -->
<div class="card">
    <h2 class="card-title">Title</h2>
    <p class="card-desc">Description</p>
</div>

<div class="card featured">
    <h2 class="card-title">Featured Title</h2>
    <p class="card-desc">Featured Description</p>
</div>
```

```css
/* CSS */
.card {
    border: 1px solid #ccc;
    padding: 1rem;
}

.card-title {
    font-size: 1.5rem;
    font-weight: bold;
}

/* Modifier Pattern */
.card.featured {
    border-color: gold;
    background-color: #fffbe6;
}
```

### Pattern 2: Attribute-Based Styling
**Khi nào dùng**: Khi bạn có nhiều loại input hoặc phần tử giống nhau nhưng khác thuộc tính (type, data-status).
**Tại sao đúng**: Giảm số lượng class CSS, dùng dữ liệu HTML có sẵn để styling.

```html
<!-- HTML -->
<form>
    <input type="text" placeholder="Username">
    <input type="password" placeholder="Password">
    <input type="submit" value="Login">
</form>
```

```css
/* CSS */
/* Style tất cả input */
input {
    padding: 8px;
}

/* Style riêng text/password */
input[type="text"],
input[type="password"] {
    border: 1px solid #ccc;
    width: 100%;
}

/* Style nút submit */
input[type="submit"] {
    background-color: blue;
    color: white;
    cursor: pointer;
}
```

### Pattern 3: Dynamic Pseudo-Classes
**Khi nào dùng**: Khi cần feedback trực quan cho click/hover/focus.
**Tại sao đúng**: Cải thiện UX ngay lập tức, tách biệt logic trạng thái (hover) ra khỏi logic hiển thị (base).

```html
<button class="btn-primary">Click Me</button>
```

```css
.btn-primary {
    background-color: #007bff;
    color: white;
    padding: 10px 20px;
    transition: background 0.3s; /* Smooth color change */
}

.btn-primary:hover {
    background-color: #0056b3; /* Darker when mouse over */
}

.btn-primary:active {
    transform: translateY(1px); /* Move down slightly when clicked */
}

input:focus {
    outline: 2px solid orange; /* Highlight when typing */
    border-color: orange;
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. The `!important` Abuse
*   **Mô tả**: Dùng `!important` trong mọi dòng style.
*   **Lý do nguy hiểm**: Nó làm **hỏng hệ thống Specificity**. Khi bạn dùng `!important`, bạn buộc phải dùng `!important` ở nơi khác để override nó, tạo ra một mớ hỗn độn không thể sửa được. Chỉ dùng khi override styles của thư viện bên thứ 3.

### 2. Over-Specific Selectors
*   **Mô tả**: `#main > div > ul > li > a.link`
*   **Lý do nguy hiểm**: **Khó bảo trì**. Nếu bạn thay thẻ `ul` thành `ol` thì CSS break hết. Độ ưu tiên quá cao làm cho việc override sau này rất khó khăn. Cố gắng giữ selector ngắn nhất có thể (ví dụ: chỉ dùng `.link`).

### 3. Selecting by Tags for Layouts
*   **Mô tả**: `div { color: red; }`
*   **Lý do nguy hiểm**: Nó áp dụng style cho **tất cả** thẻ div trên trang, kể những cái mà bạn không muốn. Luôn dùng Class cho layout.

### 4. Duplicate IDs
*   **Mô tả**: `<div id="user">...</div> <div id="user">...</div>`
*   **Lý do nguy hiểm**: HTML yêu cầu ID phải là duy nhất. Trình duyệt có thể hành động lạ, JS không select đúng, và Accessibility (A11y) bị vi phạm.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else Style)

*   **IF** Element needs to be unique (Anchor, JS target)? **→** Use `#id`.
*   **ELSE IF** Multiple elements share the same style? **→** Use `.class`.
*   **ELSE IF** Styling based on state (Hover, Focus)? **→** Use `:pseudo-class`.
*   **ELSE IF** Styling based on attribute value (Input type)? **→** Use `[attribute=value]`.
*   **ELSE IF** Styling any element regardless of type? **→** Use `*`.

### Quick Reference: Selector Syntax

| Type | Syntax | Example | Priority (Points) |
| :--- | :--- | :--- | :--- |
| **Universal** | `*` | `* { margin: 0; }` | 1 |
| **Element** | `tag` | `p { color: black; }` | 1 |
| **Class** | `.name` | `.btn { ... }` | 10 |
| **ID** | `#id` | `#header { ... }` | 100 |
| **Attribute** | `[attr]` | `input[type="text"]` | 10 |
| **Child** | `A > B` | `ul > li` | Sum of parts |
| **Descendant** | `A B` | `div p` | Sum of parts |

### Top 5 Rules to Remember
1.  **Always prefer External CSS** for anything more than 1 page.
2.  **Specificity is King**: ID > Class > Element.
3.  **Keep it Flat**: Don't nest selectors more than 3 levels deep (`body div ul li span`).
4.  **Use Classes for Styles, IDs for JavaScript**.
5.  **Order Matters**: In a tie, the last rule written in the CSS file wins.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: CSS Core Concepts

---

## SECTION 1: CORE MENTAL MODEL

### 1.1. CSS Specificity (Thứ tự ưu tiên)
**Definition:** An algorithm calculates a score to determine which CSS rule applies when multiple rules target the same element. Higher specificity wins.

**Mental Model:** Think of it as a hierarchical voting system. The vote with the most specific "weight" counts. `!important` is a veto card (use sparingly).

**Why it's better:** It allows developers to write global styles (`element`) and override them locally (`#id`, `.class`) without rewriting entire stylesheets.

### 1.2. Pseudo-elements (Yếu tố giả)
**Definition:** A keyword added to a selector that lets you style a specific part of the selected element(s).
*   `::before` (Trước phần tử): Inserts content before the element's content.
*   `::after` (Sau phần tử): Inserts content after the element's content.

**Why it's better:** It separates decorative content from the HTML structure, keeping the markup clean and semantic.

### 1.3. Units & Context
**Definition:** The measurement system used for sizing.
*   **Absolute (Cố định):** `px` (Pixel). Fixed size, ignores user settings.
*   **Relative (Tương đối):** `%`, `em`, `rem`, `vw`/`vh`. Scales based on parent or viewport size.

**Mental Model:**
*   Use `px` for strict constraints (borders, fixed shadows).
*   Use `rem` for font sizes (accessibility).
*   Use `%` or `vw/vh` for layout fluidity.

---

## SECTION 2: DECISION TABLES

### Table 1: CSS Specificity Strategy
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Styling a unique element** | **ID Selector (`#id`)** | Highest priority among selectors (Score: 0,1,0,0). Ensures override. | Overusing IDs makes CSS hard to reuse and maintain. |
| **Reusable component styles** | **Class Selector (`.class`)** | High reusability (Score: 0,0,1,0). Easier to override than IDs. | Using inline styles to "fix" class styles quickly. |
| **Emergency override needed** | **`!important`** | Breaks the specificity algorithm immediately. | Using `!important` for layout logic. It creates technical debt and makes future overrides impossible. |
| **Low priority styling** | **Element Selector (`h1`)** | Low specificity (Score: 0,0,0,1). Good for base typography. | Trying to override an ID or inline style with just an element selector (will fail). |

### Table 2: Units Selection
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Font sizing** | **`rem`** | Respects user's browser font settings (Accessibility). Scales predictably from root. | Using `px` for fonts. Users with poor eyesight cannot zoom in. |
| **Container spacing (Padding/Margin)** | **`%` or `em`** | Relative to parent width/size, allowing fluid layouts on different screens. | Using `px` for spacing on containers, causing overflow on mobile. |
| **Full-screen backgrounds/Hero sections** | **`vh` / `vw`** | Directly relates to the viewport size. `100vh` fills the screen height perfectly. | Using `px` for height, causing content cutoff on smaller screens. |
| **Pixel-perfect borders** | **`px`** | A 1px border should remain 1px regardless of zoom levels or parent size. | Using `em` for borders; borders scale with text size, looking inconsistent. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Specificity Hierarchy (Hierarchy)
This flow represents the priority weight from highest to lowest.

```text
[ 1. Inline Styles ]
   ( style="..." )  ← Highest Priority
       ⬇
[ 2. ID Selectors ]
   ( #header )      ← Second Priority
       ⬇
[ 3. Classes / Attributes / Pseudo-Classes ]
   ( .btn, [type="text"], :hover )  ← Third Priority
       ⬇
[ 4. Elements / Pseudo-elements ]
   ( div, ::before )  ← Low Priority
       ⬇
[ 5. Universal Selector ]
   ( * )              ← Lowest Priority
       ⬇
[ !important ]       ← Forces Override (Overrides Everything)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Semantic Decoration" (Pseudo-elements)
**Khi nào dùng:** When you need to add visual elements (icons, separators, decorative shapes) without cluttering the HTML.

**Tại sao đúng:** Keeps the HTML purely for content/data (SEO friendly), while CSS handles the visuals.

```css
/* CSS */
.quote::before {
  content: "“"; /* Adds opening quote */
  font-size: 2em;
  color: gray;
}

.quote::after {
  content: "”"; /* Adds closing quote */
  font-size: 2em;
  color: gray;
}
```
```html
<!-- HTML -->
<p class="quote">Hello World</p>
<!-- Output: “Hello World” (Quotes are purely visual) -->
```

### Pattern 2: The "Fluid Typography" (Relative Units)
**Khi nào dùng:** When building responsive websites where text must look good on both mobile and desktop.

**Tại sao đúng:** `rem` ensures text scales if the user changes their browser settings, and `calc()` allows fine-tuning.

```css
/* CSS */
html {
  font-size: 16px; /* Base size */
}

h1 {
  /* 2 * root size = 32px */
  font-size: 2rem; 
}

p {
  /* 1 * root size = 16px */
  font-size: 1rem;
}

.responsive-box {
  /* 50% of viewport width */
  width: 50vw; 
  /* 10% of viewport height */
  height: 10vh; 
  background-color: lightblue;
}
```

### Pattern 3: The "Specificity Reset" (Important)
**Khi nào used:** When you absolutely must break the specificity hierarchy because you cannot edit the source HTML or existing CSS (e.g., 3rd party libraries).

**Tại sao đúng:** It is the "nuclear option." Use it to force a style to stick, but be aware it makes future overrides extremely difficult.

```css
/* CSS */
/* This will override almost everything, even IDs */
.special-override {
  background-color: red !important; 
  color: white !important;
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **滥用 `!important` (滥用 = Lạm dụng)**
    *   **Danger:** It breaks the natural flow of CSS. Once you use it, you often need `!important` again to override it later. This leads to an unmaintainable "war of specificity."
    *   **Fix:** Use more specific selectors (classes/IDs) or restructure CSS architecture.

2.  **Using `px` for everything**
    *   **Danger:** It creates a rigid design. Users who rely on screen readers or browser zoom will find the site unusable because elements don't scale proportionally.
    *   **Fix:** Use `rem` for text and `em`/`%` for spacing.

3.  **Overusing IDs for CSS**
    *   **Danger:** IDs have maximum specificity. You cannot reuse the style, and you cannot override it with a class selector later.
    *   **Fix:** Use Classes (`.class`) for styling and reserve IDs for JavaScript hooks or anchor links.

4.  **`::before` / `::after` without `content`**
    *   **Danger:** These pseudo-elements do not generate if the `content` property is missing. They will simply not appear.
    *   **Fix:** Always set `content: ""`, even if empty.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)

*   **If** you need a style to apply to *many* items → **Use Class (`.class`)**
*   **If** you need a style to apply to *one unique* item → **Use ID (`#id`)**
*   **If** your style isn't applying → **Check Specificity (Is there an ID? Is there inline style?)**
*   **If** you need to force a style to apply → **Use `!important` (and pray)**
*   **If** you need text to scale with user preference → **Use `rem`**
*   **If** you need a box to fill the screen → **Use `vh` / `vw`**

### Top 5 Specificity Rules
1.  Inline styles win.
2.  ID wins over Class.
3.  Class wins over Element.
4.  `!important` wins over everything (inside the same origin).
5.  Specificity is calculated per rule block, not per file.

### Quick Syntax Reminders
*   **Pseudo-element:** `selector::pseudo-element { }`
*   **Important:** `property: value !important;`
*   **Root Unit:** `rem` (Relative to `html` font-size)
*   **Viewport Unit:** `vw` (1% of width), `vh` (1% of height)

<!-- CHUNK 31-40 -->

# CSS Foundation Decision Guide (Lec 3)

## SECTION 1: CORE MENTAL MODEL

### 1.1. The Box Model (Mô hình Hộp)
Mọi phần tử trong CSS đều là một hình chữ nhật. Hiểu rõ các lớp này giúp kiểm soát layout chính xác.

*   **Content**: Nội dung thực tế (văn bản, hình ảnh).
*   **Padding (Lót trong)**: Khoảng trống giữa nội dung và viền.
*   **Border (Viền)**: Đường bao quanh phần Padding và Content.
*   **Margin (Lề)**: Khoảng trống ngoài cùng, tách biệt phần tử với hàng xóm.

**Key Insight**: `width` và `height` mặc định chỉ bao gồm **Content**. Để tính kích thước thật, cần chú ý `box-sizing`.

### 1.2. Display & Position (Hiển thị & Vị trí)
Hai thuộc tính này quyết định luồng bố cục và cách phần tử tương tác với không gian xung quanh.

*   **Display**: Xác định cách phần tử tạo ra khối layout.
    *   `block`: Chiếm toàn bộ chiều ngang, xuống dòng mới.
    *   `inline`: Chảy theo chiều ngang, không chiếm width/height.
    *   `inline-block`: Chảy ngang nhưng chỉnh được kích thước.
*   **Position**: Xác định tọa độ của phần tử.
    *   `static`: Mặc định, không bị ảnh hưởng bởi offset.
    *   `relative`: Tịnh tiến so với vị trí ban đầu.
    *   `absolute`: Tịnh tiến so với tổ tiên gần nhất có `position` (hoặc document nếu không có).
    *   `fixed`: Cố định theo viewport (không scroll theo trang).
    *   `sticky`: Cố định khi scroll tới một ngưỡng nhất định.

---

## SECTION 2: DECISION TABLES

### Table 1: Khi nào dùng `position`?
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why)? | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Lớp phủ UI (Dropdown, Modal) | **`absolute`** | Tách khỏi luồng文档 (Normal Flow), dễ canh vị trí so với component cha. | Dùng `fixed` cho Modal nhỏ trong khi cha không cần fixed. |
| Thanh điều hướng cố định (Sticky Nav) | **`sticky`** | Giữ nguyên luồng文档 khi cuộn, chỉ cố định khi cần. | Dùng `fixed` làm mất chỗ trống, giao diện giật cục. |
| Icon/biểu tượng nhỏ trong text | **`absolute`** (trong cha `relative`) | Đặt chính xác tọa độ mà không ảnh hưưởng text xung quanh. | Để `top: 0` trong khi cha không có `position: relative`. |
| Element muốn căn chỉnh offset nhỏ | **`relative`` | Thay đổi vị trí nhẹ mà không ảnh hưưởng layout bên ngoài. | Lạm dụng `relative` cho layout chính thay vì dùng Margin. |

### Table 2: Khi nào dùng `display`?
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why)? | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Container chứa nội dung (Card, Wrapper) | **`block`** | Tách biệt rõ ràng,撑满 chiều ngang theo mặc định. | Dùng `inline-block` gây ra khoảng trống trắng (whitespace) không mong muốn. |
| Nút bấm, Badge, Avatar | **`inline-block`** | Chạy theo hàng ngang nhưng chỉnh được Width/Height/Padding. | Dùng `block` làm nút rơi xuống dòng hoặc `inline` không chỉnh được Padding. |
| Ẩn phần tử nhưng vẫn chiếm chỗ | **`visibility: hidden`` | Giữ khoảng trống (layout không thay đổi), chỉ ẩn visual. | Dùng `display: none` làm layout co lại, gây giật cục. |
| Ẩn hoàn toàn, không chiếm chỗ | **`display: none`** | Xóa khỏi flow layout, tối ưu không gian. | Dùng `visibility: hidden` vẫn chiếm chỗ trống rác. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Text-Based Diagram: The Stacking Context (Context xếp chồng)
Khi `position` và `z-index` xuất hiện, thứ tự hiển thị được xác định bởi **Stacking Context**.

```text
[Document Root <html>]
       |
       | (Trường hợp không có context nào tạo ra z-index)
       |
[Element A (Default)]
       |
       +-- [Element B (position: absolute, z-index: 10)] <-- Nằm trên A
       |
       +-- [Element C (position: relative, z-index: 5)] <-- Nằm dưới B nhưng trên A
```

**Quy tắc phân cấp:**
1.  Elements với `position: static` luôn nằm ở dưới cùng.
2.  Elements cùng `z-index` thì ai khai báo sau (DOM sau) sẽ nằm trên.
3.  `z-index` chỉ có tác dụng nếu element tạo ra **Stacking Context** (có `position` không là `static` và `z-index` không là `auto`).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Center Absolute
**Khi nào dùng:** Căn giữa hoàn toàn một phần tử (ví dụ: Icon loading) trong một container.
**Tại sao đúng:** Dựa vào `transform` để bù trừ 50% kích thước, không cần biết kích thước cố định của phần tử con.

```css
.parent {
  position: relative; /* Tạo context cho absolute con */
  width: 300px;
  height: 200px;
  border: 1px solid #000;
}

.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* Bù trừ chính xác một nửa kích thước bản thân */
  
  /* Thử nghiệm: Đặt size để thấy hiệu quả */
  width: 100px;
  height: 50px;
  background-color: red;
}
```

### Pattern 2: Sticky Header Layout
**Khi nào dùng:** Menu hoặc Header cố định khi cuộn nhưng không che mất khi chưa cuộn.
**Tại sao đúng:** Dùng `position: sticky` mượt mà hơn `fixed` vì không cần canh lượng trượt (scroll offset).

```css
body {
  margin: 0;
  font-family: sans-serif;
}

header {
  background: #333;
  color: white;
  padding: 1rem;
  
  /* Magic Stick */
  position: sticky;
  top: 0; /* Cố định khi cách top viewport 0px */
  z-index: 1000; /* Đảm bảo nằm trên nội dung */
}

.content {
  padding: 2rem;
  height: 200vh; /* Fake nội dung dài để scroll */
  background: #f4f4f4;
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Dùng `position: absolute` bừa bãi cho Layout
*   **Tại sao nguy hiểm:** Nó tách phần tử khỏi luồng văn bản (Normal Flow). Khi nội dung thay đổi (ví dụ: text dài hơn), các phần tử khác sẽ không tự động đẩy xuống mà bị chồng lấn (overlap).
*   **Lời khuyên:** Chỉ dùng cho decoration, icon, hoặc modal. Layout chính nên dùng `Flexbox` hoặc `Grid`.

### 2. Quên `z-index` khi dùng `position`
*   **Tại sao nguy hiểm:** Trình duyệt mặc định sẽ ưu tiên phần tử được khai báo sau trong HTML (DOM order). Điều này dẫn đến giao diện không nhất quán, lỗi "biến mất" khi click.
*   **Lời khuyên:** Luôn đặt `z-index` cụ thể khi dùng `absolute`, `fixed`, hoặc `relative` trong các thành phần phức tạp.

### 3. Confuse `display: none` và `visibility: hidden`
*   **Tại sao nguy hiểm:** Làm sai lệch giao diện layout.
    *   `none`: Layout co lại (rất tốt cho menu đóng/mở).
    *   `hidden`: Layout giữ nguyên chỗ trống (dễ gây ra khoảng trắng khó coi nếu dùng sai mục đích).
*   **Lời khuyên:** Dùng `none` khi cần xóa khỏi giao diện. Dùng `hidden` khi che tạm thời nhưng giữ vị trí.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Logic

**1. Căn chỉnh trung tâm:**
*   Nếu biết kích thước con: `margin: 0 auto;` (Block) hoặc `line-height` (Text).
*   Nếu không biết kích thước con: Dùng `Flexbox` hoặc `Absolute + Transform`.

**2. Xử lý Overlap:**
*   Muốn chồng lên nhau: Set `position: absolute`.
*   Muốn đẩy nhau: Dùng `margin`.
*   Muốn điều chỉnh thứ tự: Dùng `z-index` (phải có `position`).

**3. Responsive Logic:**
*   **Mobile First:** Viết CSS cho mobile trước, dùng `min-width` để thêm style cho màn hình lớn hơn.
*   **Flexible Layout:** Hạn chế fixed width (px), dùng `%`, `rem`, hoặc `fr` (trong Grid).

### Top 5 Things to Remember (Exam Focus)
1.  **Box Model:** `width` = Content (trừ khi `box-sizing: border-box`).
2.  **Block vs Inline:** Block xuống dòng, Inline chảy hàng.
3.  **Relative:** Dịch chuyển so với chính nó (không phá layout).
4.  **Absolute:** Dịch chuyển so với cha có position, hoặc body.
5.  **Fixed/Sticky:** Dính vào màn hình viewport.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: RESPONSIVE CSS FOUNDATIONS

---

## SECTION 1: CORE MENTAL MODEL

**Responsive Design (Thiết kế đáp ứng)**: A mobile-first approach where layout and content adapt dynamically to the viewport (không gian nhìn thấy) size.
**Viewport (Không gian nhìn thấy)**: The visible area of a web page on a specific device screen.

**Core Logic:**
1.  **Base (Mobile):** Start with a single column layout. Font sizes are readable on small screens.
2.  **Scale Up (Tablet/Desktop):** Use `Media Queries` to add complexity (multiple columns, wider sidebars) as screen width increases.
3.  **Fluidity:** Use `Relative Units` and `Flexbox` to fill available space without hardcoding pixel values.

**Why it's better:**
-   **Fixed Width (Cố định):** Breaks on screens smaller than the fixed width (requires horizontal scrolling, bad UX).
-   **Responsive (Linhh hoạt):** Content is always accessible, no scrolling, better SEO, and reduces development time for multiple devices.

---

## SECTION 2: DECISION TABLES

### Table 1: Layout Mechanism
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Aligning items in a single row/column (Header, Nav, Cards)** | **Flexbox** | **Flexbox (Hộp linh hoạt)** is a 1D system. It handles space distribution and alignment perfectly in one direction. | Using `float` or `position: absolute` for layout, which breaks the document flow and makes responsive behavior hard to control. |
| **Complex 2D grids (Whole page layout, non-linear structures)** | **CSS Grid** | **CSS Grid (Lưới CSS)** is a 2D system. It handles both rows and columns simultaneously. | Using Flexbox for the entire page when you need strict overlapping rows and columns, leading to "div soup". |
| **Adjusting spacing/size based on screen width** | **Relative Units (rem, %, vh)** | **Relative Units (Đơn vị tương đối)** scale with the root or parent, ensuring text and boxes remain proportional on any device. | Using `px` (pixels) for widths and font sizes, causing text to be unreadable on mobile or tiny on desktops. |

### Table 2: Breakpoint Strategy
| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Device detection (Mobile vs Tablet vs Desktop)** | **Media Queries (min-width)** | **Media Queries (Truy vấn đa phương tiện)** apply CSS only when specific conditions (like screen width) are met. Using `min-width` ensures "Mobile First" logic. | Using `max-width` logic. This forces desktop styles to override mobile, making the code harder to maintain and increasing file size. |
| **Printable version of the webpage** | **Media Query: `@media print`** | Automatically strips background colors, hides navigation, and adjusts fonts for physical paper output. | Forgetting to hide interactive elements (buttons, menus) or wasting ink with dark backgrounds. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

**The Responsive Cascade (The Hierarchy of Adaptation):**

```text
[HTML Structure]
      |
      V
[1. Base Mobile Styles] <----------+
(No media queries)                  |
(1 column layout)                   |
(Standard fonts)                    |
      |                             |
      V                             |
[2. Tablet Styles]                  |
@media (min-width: 577px)           |
(Flexbox: Row layout)               |
(Increased font size)               |
      |                             |
      V                             |
[3. Desktop Styles]                 |
@media (min-width: 993px)           |
(2-3 Column layout)                 |
(Specific container widths)         |
      |                             |
      +-----------------------------+
      (Responsive Loop: Re-evaluates on window resize)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Mobile-First Foundation
**Khi nào dùng:** Bắt đầu mọi dự án web hiện đại.
**Tại sao đúng:** Đảm bảo codebase sạch, chỉ thêm code khi cần thiết thay vì xóa code desktop khi thu nhỏ.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <!-- CRITICAL: Tells mobile browsers to render at device width -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* 1. MOBILE BASE (Default) */
        body {
            font-size: 16px; /* Base size */
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
        }

        .container {
            width: 100%; /* Full width on mobile */
        }

        /* 2. TABLET (Medium Screens) */
        @media (min-width: 577px) {
            body {
                font-size: 18px;
                padding: 20px;
            }
            /* Horizontal layout starts here */
            .container {
                display: flex;
                gap: 15px;
            }
        }

        /* 3. DESKTOP (Large Screens) */
        @media (min-width: 993px) {
            body {
                font-size: 20px;
                padding: 40px;
            }
            /* Center the content on wide screens */
            .container {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Responsive Demo</h1>
        <p>Resize browser window to see changes.</p>
    </div>
</body>
</html>
```

### Pattern 2: The "Safe Image" Rule
**Khi nào dùng:** Luôn luôn sử dụng khi có hình ảnh trong layout linh hoạt.
**Tại sao đúng:** Ngăn chặn hình ảnh tràn ra ngoài bố cục (overflow) khi màn hình thu hẹp.

```css
/* CSS File */
.responsive-image {
    /* Image will shrink down but never grow larger than original */
    max-width: 100%;
    
    /* Keeps the image from getting squished or stretched */
    height: auto;
    
    /* Optional: Helps with layout shifts */
    display: block;
}
```

```html
<!-- HTML Usage -->
<div style="width: 300px; background: #eee;">
    <img src="photo.jpg" class="responsive-image" alt="Safe Image">
</div>
```

### Pattern 3: Flexbox Wrapping
**Khi nào dùng:** Khi xây dựng danh sách (cards, tags, menu items) cần tự động xuống dòng.
**Tại sao đúng:** Thay vì tính toán breakpoints cho từng item, Flexbox tự động xử lý chỗ trống.

```css
.card-container {
    display: flex;
    /* Forces items to wrap to next line if no space */
    flex-wrap: wrap;
    /* Distributes space evenly between items */
    justify-content: space-between;
    gap: 10px; /* Khoảng cách giữa các item */
}

.card {
    /* Base: Mobile takes 100% width */
    flex: 0 0 100%;
    background: white;
    border: 1px solid #ccc;
    padding: 10px;
}

@media (min-width: 768px) {
    .card {
        /* Tablet: Take up to 48% of width (2 per row) */
        flex: 0 0 48%;
    }
}

@media (min-width: 1024px) {
    .card {
        /* Desktop: Take up to 32% of width (3 per row) */
        flex: 0 0 32%;
    }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

**1. Missing Viewport Meta Tag**
-   **Code:** `<html>` without `<meta name="viewport" ...>`
-   **Danger:** Mobile browsers will pretend to be desktop screens (zooming out to fit 980px width), making text microscopic and unreadable. Users will leave immediately.

**2. Using `width` instead of `max-width` for Media Queries**
-   **Code:** `@media (width: 768px) { ... }`
-   **Danger:** This targets *only* screens exactly 768px wide. If the user resizes the window to 769px or 767px, the styles disappear. Always use `min-width` or `max-width` ranges.

**3. `width: 100%` on Images inside Fixed Containers**
-   **Code:** `img { width: 100%; }`
-   **Danger:** If the image aspect ratio is different from the container, the image will stretch vertically (distortion).
-   **Fix:** Use `max-width: 100%` combined with `height: auto`.

**4. Over-reliance on `!important`**
-   **Code:** `color: red !important;`
-   **Danger:** Creates "Specificity Wars". It makes debugging impossible because you can no longer override styles naturally. It's a sign of bad architecture.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Rules
1.  **Always** include `<meta name="viewport" content="width=device-width, initial-scale=1.0">`.
2.  **Start Mobile First** (Code for small screens, add media queries for larger ones).
3.  **Use `rem`** for font sizes (accessibility) and `%` or `vw` for layout widths.
4.  **`max-width: 100%`** for images is non-negotiable.
5.  **Flexbox** for 1D alignment (Rows/Columns).
6.  **CSS Grid** for 2D page layout.
7.  **`min-width`** in Media Queries is the standard.
8.  **Standard Breakpoints:** Mobile (<576px), Tablet (>576px), Desktop (>992px).
9.  **Avoid fixed heights** (e.g., `height: 500px`) on containers; use `min-height` or padding instead.
10. **Test** by resizing your browser window manually; don't just look at the phone.

### Decision Logic (If-Else)
```text
IF (Building Layout) -> 
    Is it a single row/column? -> Use FLEXBOX
    Is it a complex grid? -> Use CSS GRID

IF (Targeting Devices) ->
    Is screen width >= X? -> Use @media (min-width: X)
    Is it for printing? -> Use @media print

IF (Adding Images) ->
    Is the container fluid? -> Set max-width: 100% + height: auto
```

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: Tailwind CSS (Lec 3)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **Utility-First CSS (Tiện ích ưu tiên)**: A methodology where you build UI by composing low-level, single-purpose classes directly in your HTML markup instead of writing custom CSS files. It treats CSS as a toolset of pre-defined functions.
- **JIT (Just-In-Time) Compiler (Biên dịch Đúng giờ)**: Modern Tailwind engine that generates CSS on-demand as you code. This results in extremely small file sizes and infinite design possibilities without configuration bloat.

### Why This Approach Wins
- **No Context Switching**: You stay in HTML. No jumping between `.html` and `.css` files.
- **Design Consistency**: Uses a constrained, pre-defined design system (spacing scale, color palette) automatically, preventing random values like `margin: 13px`.
- **Performance**: Production CSS is tiny because unused classes are never generated.

---

## SECTION 2: DECISION TABLES

### When to Use Tailwind vs Traditional CSS

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Rapid Prototyping / MVP** | **Tailwind** | Speed: `bg-blue-500` is faster than naming a class `.primary-btn` and defining it. | Over-complicating with `@apply` directives, defeating the purpose of utility classes. |
| **Design System / Component Library** | **Tailwind** | Consistency: Enforces spacing (`m-4`, `p-4`) and colors (`text-red-500`) from a single source of truth. | Ignoring the responsive prefix (`md:`, `lg:`), resulting in a broken mobile experience. |
| **Content-heavy blog / CMS** | **Traditional CSS** | Maintainability: Long strings of classes in HTML hurt readability for content managed by non-devs. | Using Tailwind for global typography defaults instead of writing a clean `typography.css` file. |
| **One-off unique landing page** | **Tailwind** | Speed: No need to create a stylesheet structure for a one-time design. | Forgetting to purge unused classes in production, leading to large file sizes. |

### When to Use Spacing Utilities

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Centering a block element horizontally** | **`mx-auto`** | Sets Left/Right margin to `auto`, pushing the element to the center of its container. | Using `text-center` (only centers text inside) or absolute positioning. |
| **Adding breathing room inside a card** | **`p-4` or `px-6 py-2`** | `p-4` is uniform (16px). `px-6 py-2` gives wider horizontal padding than vertical. | Using `m-4` inside a container (pushes element away, doesn't add internal space). |
| **Separating elements vertically** | **`mt-8` or `space-y-4`** | `mt-8` adds space above a specific element. `space-y-4` adds space between all children automatically. | Using empty `<div>` elements for spacing (clutters HTML). |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Breakpoint Hierarchy (Mobile-First)
Tailwind uses a **Mobile-First** approach. Unprefixed classes apply to all screen sizes. Prefixed classes *override* them for larger screens.

```text
[ Base Styles (No Prefix) ]
       ↓ (Screen gets wider)
[ sm: (≥ 640px)  ]  →  Overrides Base
       ↓
[ md: (≥ 768px)  ]  →  Overrides sm
       ↓
[ lg: (≥ 1024px) ]  →  Overrides md
       ↓
[ xl: (≥ 1280px) ]  →  Overrides lg
```

### Visual Hierarchy: Typography → Color → Layout
1. **Content Structure**: Define Text Size (`text-lg`) and Weight (`font-bold`).
2. **Visual Polish**: Apply Colors (`text-white`, `bg-blue-500`).
3. **Layout & Positioning**: Add Spacing (`p-4`) and Flexbox/Grid (`flex`, `grid`).

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The Responsive Button
**Khi nào dùng**: Creating buttons that stack vertically on mobile and horizontally on desktop.

**Tại sao đúng**: Uses the `flex` direction change to adapt to screen real estate without custom media queries.

```html
<!-- Container: Full width on mobile, row on medium screens -->
<button class="
  w-full                 /* width: 100% (Mobile) */
  md:w-auto              /* width: auto (Tablet+) */
  
  flex flex-col          /* Stack items vertically initially */
  md:flex-row            /* Align items horizontally on medium */
  
  items-center justify-center
  
  bg-blue-500            /* Primary color */
  text-white             /* Text color */
  font-bold py-2 px-4    /* Padding: vertical 0.5rem, horizontal 1rem */
  rounded-lg             /* Rounded corners */
  hover:bg-blue-600      /* Hover state */
">
  <span>Icon</span>
  <span class="mt-2 md:mt-0 md:ml-2">Submit</span>
</button>
```

### Pattern 2: The Centered Hero Section
**Khi nào dùng**: Landing pages requiring full viewport height and absolute centering.

**Tại sao đúng**: `min-h-screen` ensures it takes the full height. `flex` + `items-center` + `justify-center` handles both axes.

```html
<section class="
  min-h-screen          /* Minimum height = 100% viewport */
  bg-gray-100           /* Background color */
  flex                  /* Enable Flexbox */
  items-center          /* Center Vertically */
  justify-center        /* Center Horizontally */
">
  <div class="text-center p-8 bg-white shadow-xl rounded-xl">
    <h1 class="text-4xl font-bold text-gray-800 mb-4">Welcome</h1>
    <p class="text-gray-600">Build faster with Tailwind.</p>
  </div>
</section>
```

### Pattern 3: The Responsive Grid (Cards)
**Khi nào dùng**: Displaying items (products, users) in a 1-column layout on mobile, expanding to 3 columns on large screens.

**Tại sao dùng**: `grid-cols-1` is the default. `lg:grid-cols-3` adds the grid definition only when there is enough space.

```html
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  <!-- Card 1 -->
  <div class="bg-white p-6 rounded shadow">
    <h3 class="text-lg font-bold">Card 1</h3>
  </div>
  <!-- Card 2 -->
  <div class="bg-white p-6 rounded shadow">
    <h3 class="text-lg font-bold">Card 2</h3>
  </div>
  <!-- Card 3 -->
  <div class="bg-white p-6 rounded shadow">
    <h3 class="text-lg font-bold">Card 3</h3>
  </div>
</div>
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Overusing Custom CSS (`@apply`)
**The Danger**: Using `@apply` to recreate semantic classes (e.g., `.btn-primary`) defeats the purpose of Tailwind. You add a compilation step and lose the ability to see the styling context immediately.
**Bad**: `.btn { @apply px-4 py-2 bg-blue-500; }`
**Why**: When you look at HTML later, you still have to look up the CSS file to see what `.btn` does.

### 2. Ignoring the "Mobile-First" Logic
**The Danger**: Writing `lg:flex` without a base `flex` often leads to layouts that work on desktop but break on mobile (e.g., items stack incorrectly).
**Bad**: `<div class="hidden lg:block">` (Content invisible on mobile).
**Why**: Users on small devices might miss critical info if it's not explicitly handled.

### 3. The "Rainbow" HTML
**The Danger**: Creating elements with dozens of utility classes that are hard to read.
**Bad**: `<div class="flex flex-col justify-center items-center bg-white text-black p-4 m-4 border border-gray-200 shadow-md rounded...">`
**Why**: If the line exceeds 100 characters, it's unreadable. Use template literals or multi-line formatting in your editor.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Reference Rules
- **Centering**: `flex items-center justify-center`
- **Full Width**: `w-full`
- **Full Screen Height**: `min-h-screen`
- **Vertical Padding**: `py-{n}` (0.5rem steps)
- **Horizontal Padding**: `px-{n}` (0.5rem steps)
- **Responsive**: Add `sm:`, `md:`, `lg:` prefix to any utility.

### Decision Logic (If-Else)
- **IF** screen width < 640px → Use unprefixed classes (Base).
- **IF** screen width ≥ 640px → Use `sm:` prefixed classes.
- **IF** creating a layout → Use `flex` or `grid`.
- **IF** spacing feels wrong → Check if it's `margin` (pushing away) or `padding` (internal space).

### Top 3 Things to Remember
1. **Classes are immutable**: You cannot change Tailwind values (like `p-4` = 16px) without changing the config file. Memorize the scale (4, 8, 12, 16...).
2. **Read classes left-to-right**: They define the element progressively.
3. **Breakpoints are inclusive**: `md:` starts at exactly 768px and goes up.

<!-- CHUNK 61-62 -->

# DEVELOPER DECISION GUIDE - CSS (Lec 3)

---

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

- **CSS (Cascading Style Sheets - Bảng phong cách phân cấp)**: Ngôn ngữ mô tả cách hiển thị các tài liệu HTML. Thuộc tính `style` quyết định giao diện.
- **Selector (Bộ chọn)**: Mẫu xác định element HTML nào sẽ được style. Ví dụ: `h1`, `.class`, `#id`.
- **Property (Thuộc tính)**: Đặc điểm visual cần thay đổi. Ví dụ: `color`, `font-size`, `margin`.
- **Value (Giá trị)**: Giá trị áp dụng cho thuộc tính. Ví dụ: `red`, `20px`, `bold`.

### Key Mental Models: The Box Model

Mọi element HTML đều là một "hộp". Cần hiểu cách tính kích thước và khoảng cách:
1. **Content**: Nội dung thật (text, image).
2. **Padding (Lề trong)**: Khoảng trống giữa nội dung và viền.
3. **Border (Viền)**: Đường kẻ bao quanh padding.
4. **Margin (Lề ngoài)**: Khoảng trống đẩy các hộp khác ra xa.

### Why CSS is Better than Inline Styles
- **Tách biệt (Separation of Concerns)**: Giữ HTML sạch, chỉ chứa cấu trúc. CSS xử lý giao diện.
- **Dễ bảo trì (Maintainability)**: Thay đổi một file CSS cập nhật hàng trăm trang.
- **Tối ưu hiệu năng (Performance)**: Dùng Cache được.

---

## SECTION 2: DECISION TABLES

### Table 1: Choosing the Right Selector
| Tình huống sử dụng | Nên dùng gì | Tại sao (Specificity) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Style 1 element duy nhất | **ID Selector** (`#id`) | Cao nhất. Dùng khi không thể tái sử dụng. | Dùng quá nhiều ID gây trùng lặp code. |
| Style nhiều element giống nhau | **Class Selector** (`.class`) | Cao hơn Tag. Linh hoạt, tái sử dụng tốt nhất. | Quên thêm class vào HTML. |
| Style all element cùng loại | **Tag Selector** (`h1`, `p`) | Thấp nhất. Chỉnh sửa全局样式. | Viết quá rộng, dính unintended side effects. |
| Style khi hover/active | **Pseudo-class** (`:hover`) | Như Class. Thay đổi state động. | Quên state `:focus` cho form input. |

### Table 2: Units Selection
| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Font size, responsive | **rem** (Root em) | Tính theo root `<html>`. Dễ scaling accessibility. | Dùng `px`, người dùng không tăng font được. |
| Padding, Border | **em** | Tính theo font size của cha. Giữ tỉ lệ cân đối. | Dùng `px` làm giao diện bị cứng. |
| Layout, Grid | **%** hoặc **fr** | Tính theo phần trăm container. Responsive tốt. | Quên définir width cho cha. |
| Viền pixel nét | **px** | Luôn cố định 1px, không phụ thuộc cha. | Dùng `rem` cho border làm viền quá mỏng/dày. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### The Cascade & Specificity Hierarchy
CSS quyết định style nào thắng (override) dựa trên độ ưu tiên:

```
[Priority High] -> [Priority Low]
1. !important (Nên tránh)
   ↓
2. Inline Style (style="...")
   ↓
3. ID Selector (#header)
   ↓
4. Class/Pseudo-class/Attribute (.container, :hover)
   ↓
5. Tag/Universal (div, *)
```

### Visual Flow
```text
HTML File
   ↓
Link to CSS (<link rel="stylesheet">)
   ↓
Browser Parse CSS (Top-Down)
   ↓
Apply Cascade Rules (Resolve Conflicts)
   ↓
Render Box Model (Paint to Screen)
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: The "Reset & Global" Pattern
**Khi nào dùng:** Bắt đầu mọi dự án web. Xóa default browser styles để làm lại từ đầu.
**Tại sao đúng:** Tránh conflict giữa các browser (Chrome vs Firefox), đảm bảo giao diện đồng nhất.

```css
/* Reset cơ bản */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box; /* Quan trọng: tính width bao gồm padding & border */
}

body {
  font-family: sans-serif;
  line-height: 1.6;
  background-color: #f4f4f4;
}
```

### Pattern 2: The "BEM" Naming (Block__Element--Modifier)
**Khi nào dùng:** Dự án lớn, nhiều component lồng nhau.
**Tại sao đúng:** Tách biệt rõ ràng, không sợ trùng tên class, dễ hiểu scope.

```html
<!-- HTML Structure -->
<div class="card">
  <h2 class="card__title">Title</h2>
  <p class="card__description">Description</p>
  <button class="card__button card__button--primary">Action</button>
</div>
```

```css
/* CSS Implementation */
.card { /* Block */ }
.card__title { /* Element - con trực tiếp của Block */ }
.card__button { /* Element */ }

.card__button--primary { 
  /* Modifier - State đặc biệt */
  background-color: blue;
  color: white;
}
```

### Pattern 3: Flexbox Centering
**Khi nào dùng:** Cần căn giữa item theo chiều ngang/dọc.
**Tại sao đúng:** Đơn giản hóa layout, ít code hơn Floats hay Table.

```css
.container {
  display: flex;
  justify-content: center; /* Căn giữa ngang */
  align-items: center;     /* Căn giữa dọc */
  height: 100vh;           /* Cần chiều cao để căn giữa dọc hoạt động */
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1.滥用 `!important`
- **Danger:** Dùng `!important` để ghi đè CSS hiện có.
- **Why:** Tạo ra cuộc chiến specificity. Code trở thành "spaghetti", khó sửa lỗi sau này.
- **Fix:** Tăng độ ưu tiên selector đúng cách hoặc sửa lại CSS theo thứ tự đúng.

### 2. Inline Styles Tràn Lan
- **Danger:** `<div style="color: red; font-size: 20px;">`
- **Why:** Không thể tái sử dụng, không Cache được, làm HTML bẩn và cứng nhắc.
- **Fix:** Duyệt qua Class trong file `.css`.

### 3. Dùng `float` cho Layout chính
- **Danger:** `float: left;` cho sidebar và content.
- **Why:** Khó kiểm soát, hay bị "clearfix hack", phá vỡ flow của document.
- **Fix:** Dùng **Flexbox** (`display: flex`) hoặc **Grid** (`display: grid`).

### 4. Selectors quá dài (Deep Nesting)
- **Danger:** `body div.container ul li a.link { ... }`
- **Why:** Hiệu năng chậm, khó override, gây mệt mỏi khi sửa.
- **Fix:** Giữ selector ngắn gọn, dùng Class trực tiếp.

---

## SECTION 6: MASTER CHEAT SHEET

### Decision Logic (If-Else)
- **If** layout 1 chiều (chỉ hàng *hoặc* cột) -> **Use Flexbox**.
- **If** layout 2 chiều (lưới) -> **Use Grid**.
- **If** style cho 1 element duy nhất -> **Use ID** (kiểm tra xem có tái sử dụng được không không).
- **If** style cho nhiều element -> **Use Class**.
- **If** font/spacing/thickness -> **Use rem/em** (tránh px).
- **If** color/opacity -> **Use hex/rgba**.

### Top 5 Things to Remember
1. **Box Model:** `border-box` là bắt buộc.
2. **Cascade:** Càng cụ thể (ID) càng thắng.
3. **DRY:** Đừng lặp lại style. Tạo Class mới nếu lặp lại 3 lần.
4. **Responsiveness:** Luôn test trên mobile view.
5. **Browser DevTools:** F12 là người bạn tốt nhất của bạn.