# DEVELOPER DECISION GUIDE: Lec 9-Web Security.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-06 18:10:02



<!-- CHUNK 1-10 -->

# DEVELOPER DECISION GUIDE: Web Security (Lecture 9)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **XSS (Cross-Site Scripting)**: Lỗ hổng cho phép kẻ tấn công tiêm mã độc (JS) vào trình duyệt của nạn nhân. Nguyên nhân: Website hiển thị dữ liệu người dùng chưa được xử lý.
- **CSRF (Cross-Site Request Forgery)**: Kỹ thuật đánh lừa trình duyệt người dùng gửi request đến website đang đăng nhập mà không hay biết.
- **SQL Injection**: Tiêm mã SQL độc hại vào input để thao tác cơ sở dữ liệu.
- **JWT (JSON Web Token)**: Chuỗi mã hóa JSON dùng để xác thực người dùng trong môi trường không lưu state (stateless).
- **CSP (Content Security Policy)**: Tập hợp quy tắc bảo mật ở phía trình duyệt để giới hạn nguồn script được phép chạy.

### Key Mental Models
**Vòng tròn bảo mật (Defense in Depth)**: Đừng tin tưởng bất kỳ input nào (từ người dùng, API khác, hoặc ngay cả chính hệ thống cũ). Xác thực (Validate), làm sạch (Sanitize), và mã hóa (Encrypt) ở mọi lớp.

### Why Secure by Default?
Việc fix lỗi bảo mật sau khi bị tấn công tốn kém hơn nhiều so với việc code an toàn ngay từ đầu. Một lỗ hổng XSS có thể đánh sập toàn bộ uy tín hệ thống.

---

## SECTION 2: DECISION TABLES

### Khi nào dùng Validation so với Sanitization?

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Kiểm tra dữ liệu nhập vào (Input Validation) | **Kiểm tra định dạng (Validation)** | Dùng `validator` hoặc Regex để đảm bảo dữ liệu đúng cấu trúc (ví dụ: email phải có `@`). Ngăn chặn lỗi logic sớm. | Chỉ kiểm tra ở Frontend. Cần Validate luôn ở Backend. |
| Hiển thị dữ liệu ra màn hình (Output Rendering) | **Làm sạch/Thay thế (Sanitization / Escaping)** | Dùng thư viện như `DOMPurify` hoặc hàm `escape`. Chặn trình duyệt executing mã độc khi render HTML. | Tin tưởng dữ liệu đã lưu trong DB là an toàn. Dữ liệu có thể bị nhiễm độc từ đầu. |

### Khi nào dùng JWT so với Session Cookie?

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Web đơn giản, server render nhiều (SSR) | **Session Cookie** | Quản lý trạng thái server-side, dễ revoke (đăng xuất). An toàn mặc định nếu set `HttpOnly`, `Secure`. | Quên set cờ bảo mật, để Cookie truy cập được qua JS. |
| API cho Mobile/App hoặc Microservices | **JWT** | Stateless (Server không cần lưu session). Tốt cho scale ngang (horizontal scaling). | Lưu trữ JWT quá lâu. Dễ bị đánh cắp (XSS) và không thể thu hồi nếu không có blacklist. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Luồng tấn công & Phòng thủ (Flowchart)

```text
[ Kẻ Tấn Công ]                                [ Hệ Thống ]
       |                                            |
1. Gửi Input Độc (Payload) ---------------------->|
   (URL, Comment, Form)                           |
                                                  | 2. Xác thực & Lọc (Validation/Sanitization)
                                                  |    - Kiểm tra định dạng?
                                                  |    - Loại bỏ mã độc?
       |                                            |
       |<----------------------------------------- 3. Xử lý & Lưu trữ (SQL/Logic)
       |    (Nếu bỏ qua bước 2)                    |
       |                                            |
4. Trình duyệt bấm link/submit ------------------>|
                                                  | 5. Trả về Response (HTML/JSON)
                                                  |    - Dùng Output Escaping
       |                                            |
6. Kịch bản độc hại kích hoạt <-------------------|
   (Cookie bị đánh cắp, Redirect...)               |
```

**Quan hệ chính:** Dữ liệu người dùng (Input) luôn là mối đe dọa. Phải đi qua bộ lọc (Validation) trước khi xử lý (Logic) và trước khi hiển thị (Output Escaping).

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Ngăn chặn XSS khi render HTML (Output Escaping)

**Khi nào dùng:** Khi bạn hiển thị dữ liệu người dùng (comment, tên người dùng, kết quả search) ra HTML.

**Tại sao đúng:** Trình duyệt sẽ coi chuỗi `<script>` là mã lệnh nếu không được chuyển đổi thành ký tự hiển thị thông thường (`&lt;script&gt;`).

**Code Demo (Node.js / Express):**
```javascript
// CÀI ĐẶT: npm install express helmet
const express = require('express');
const helmet = require('helmet');
const app = express();

// 1. Dùng Helmet để set CSP tự động
app.use(helmet.contentSecurityPolicy({
  directives: { defaultSrc: ["'self'"] }
}));

// 2. Template Engine tự động Escaping (EJS/Pug/Jade)
// Ví dụ EJS: <div><%= userInput %></div>
// Nếu userInput = "<script>alert(1)</script>", kết quả an toàn.

// 3. Custom Escape function (Nếu dùng vanilla JS)
function escapeHtml(text) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, function(m) { return map[m]; });
}

app.get('/search', (req, res) => {
  const query = req.query.q; // Untrusted data
  // MÃNH: Dùng escapeHtml trước khi render
  res.send(`<p>Kết quả cho: ${escapeHtml(query)}</p>`);
});

app.listen(3000);
```

### Pattern 2: Xác thực SQL (SQL Injection Prevention)

**Khi nào dùng:** Mỗi khi truy vấn cơ sở dữ liệu với dữ liệu động từ người dùng.

**Tại sao đúng:** Phân tách mã SQL và dữ liệu (Parameterized Query) giúp DB hiểu đâu là lệnh, đâu là giá trị, triệt tiêu tác hại của input độc.

**Code Demo (Node.js / MySQL2):**
```javascript
// CÀI ĐẶT: npm install mysql2
const mysql = require('mysql2/promise');

async function login(username, password) {
  const connection = await mysql.createConnection({ /* config */ });

  // SAI: Dùng template literal (Dễ bị SQL Injection)
  // const query = `SELECT * FROM users WHERE username = '${username}'`;
  
  // ĐÚNG: Dùng Parameterized Query (?)
  const query = 'SELECT * FROM users WHERE username = ? AND password = ?';
  
  const [rows] = await connection.execute(query, [username, password]);
  
  return rows;
}

// Test: username = "admin' OR '1'='1" -> Kết quả: An toàn, không inject được.
```

### Pattern 3: Xác thực CSRF (Double Submit Cookie)

**Khi nào dùng:** Khi dùng Session Cookie để xác thực, có thực hiện thay đổi dữ liệu (POST, PUT, DELETE).

**Tại sao đúng:** Server tạo token random, gửi xuống Client (dạng Cookie HttpOnly và Hidden Field). Server kiểm tra 2 giá trị này khớp nhau. Kẻ tấn công không thể đọc giá trị Cookie để copy vào Form do chính sách Same-Origin.

**Code Demo (Node.js / Express):**
```javascript
// CÀI ĐẶT: npm install express csurf cookie-parser
const express = require('express');
const cookieParser = require('cookie-parser');
const csrf = require('csurf');
const app = express();

app.use(cookieParser());
const csrfProtection = csrf({ cookie: true });

// 1. Trang có form (GET) - Tạo token
app.get('/form', csrfProtection, (req, res) => {
  // Chèn token vào input ẩn
  res.send(`
    <form action="/submit" method="POST">
      <input type="hidden" name="_csrf" value="${req.csrfToken()}">
      <button type="submit">Gửi</button>
    </form>
  `);
});

// 2. Xử lý submit (POST) - Kiểm tra token
app.post('/submit', csrfProtection, (req, res) => {
  res.send('Form hợp lệ, chống CSRF thành công!');
});

app.listen(3000);
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Tin tưởng Client-side Validation:**
    *   **Tại sao nguy hiểm:** Người dùng có thể tắt JS hoặc dùng Postman/Curl để gửi request trực tiếp đến API. Luôn validate lại ở Backend.

2.  **Lưu JWT trong LocalStorage:**
    *   **Tại sao nguy hiểm:** JavaScript độc (do XSS) có thể đọc `window.localStorage` và đánh cắp token. Dùng `HttpOnly Cookie` để lưu token.

3.  **Bỏ qua HTTPS ở API Gateway:**
    *   **Tại sao nguy hiểm:** Dữ liệu (mật khẩu, token) truyền đi dưới dạng plaintext. Kẻ tấn công trên cùng mạng WiFi (Man-in-the-Middle) đọc được hết.

4.  **Dùng `innerHTML` để chèn dữ liệu người dùng:**
    *   **Tại sao nguy hiểm:** `innerHTML = userInput` sẽ execute code JS ngay lập tức. Luôn dùng `textContent` hoặc `innerText` nếu không cần hiển thị HTML.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Quy Tắc Vàng
1.  **Input:** Không bao giờ tin tưởng dữ liệu đầu vào.
2.  **Output:** Luôn Escaping trước khi render ra trình duyệt.
3.  **SQL:** Luôn dùng Parameterized Queries.
4.  **Cookie:** Set `HttpOnly` (chặn JS đọc) và `Secure` (chỉ gửi qua HTTPS).
5.  **CSP:** Luôn bật Content Security Policy.
6.  **HTTPS:** Bắt buộc ở mọi môi trường production.
7.  **JWT:** Không lưu trữ thông tin nhạy cảm trong payload (chỉ dùng để verify).
8.  **CSRF:** Dùng token cho mọi request làm thay đổi dữ liệu.
9.  **CORS:** Không set `Access-Control-Allow-Origin: *` cho API cần xác thực.
10. **Update:** Duy trì thư viện để patch lỗi bảo mật.

### Logic Quyết Định (If-Else)
*   **Nếu** render dữ liệu người dùng ra HTML: **Thì** dùng Escape hoặc Sanitize.
*   **Nếu** query DB với variable: **Thì** dùng Parameterized Query.
*   **Nếu** cần xác thực session web: **Thì** dùng Cookie + CSRF Token.
*   **Nếu** cần xác thực API/Mobile: **Thì** dùng JWT (lưu trong Cookie HttpOnly).

<!-- CHUNK 11-20 -->

# Lec 9: Web Security - Developer Decision Guide

--------------------------------
SECTION 1: CORE MENTAL MODEL
--------------------------------

### 1. Cross-site Request Forgery (CSRF)
**CSRF (Cross-site Request Forgery - Xâm nhập yêu cầu chéo trang web)** là một tấn công où kẻ xấu lợi dụng session hợp lệ của người dùng để thực hiện hành động không mong muốn. Trình duyệt tự động gửi cookie kèm request, không phân biệt nguồn gốc.

**Mental Model:**
Kẻ tấn công không lấy cắp mật khẩu; chúng chỉ lợi dụng việc bạn đã đăng nhập (session cookie tồn tại). Khi bạn truy cập trang độc, trình duyệt gửi request đến trang thật cùng cookie, thực hiện hành động (chuyển tiền, đổi pass) thay mặt bạn.

**Why better:** Hiểu cách trình duyệt xử lý cookie (gửi tự động) là chìa khóa. Các giải pháp bảo vệ phải nằm ở server hoặc cấu hình trình duyệt, không thể mong đợi người dùng không truy cập trang độc.

### 2. SQL Injection (SQLi)
**SQL Injection (SQLi - Tiêm mã SQL)** là khi input người dùng được chèn trực tiếp vào câu lệnh SQL mà không được xử lý, biến input thành code thực thi.

**Mental Model:**
Nếu bạn nối chuỗi `SELECT * FROM users WHERE name = '` + input + `'`, input `' OR '1'='1` sẽ làm câu lệnh luôn đúng. Database không phân biệt đâu là data, đâu là command nếu bạn không định nghĩa rõ ràng.

**Why better:** Phải luôn xem input người dùng là "dữ liệu độc hại". Cách duy nhất an toàn là tách biệt dữ liệu và mã lệnh (Parameterized Query).

--------------------------------
SECTION 2: DECISION TABLES
--------------------------------

### Bảng 1: Chọn cơ chế chống CSRF

| Tình huống sử dụng | Nên dùng gì | Tại sao (EN term + VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Web app thuần (không có cross-site request)** | **SameSite Cookies** (`Strict` hoặc `Lax`) | **Browser-Level Protection**: Trình duyệt chặn gửi cookie theo request từ site lạ, chặn attack ngay browser. | Quên set `Secure` flag, để cookie truyền qua HTTP không mã hóa. |
| **API Server (REST, GraphQL)** | **Origin/Referer Validation** | **Server-Side Protection**: Kiểm tra header `Origin`/`Referer` có phải domain của server không. Nhanh, không cần state. | Bỏ qua validation nếu header bị thiếu hoặc CORS configured sai. |
| **Web app truyền thống (Server-render)** | **CSRF Token (Synchronizer)** | **Stateful Protection**: Server sinh token, lưu session, verify token match. An toàn tuyệt đối. | Để token lộ trong URL (log server, browser history). |
| **Single Page App (SPA), Microservices** | **Double-Submit Cookie Pattern** | **Stateless Protection**: Token nằm ở cookie và header/Form. Server verify match mà không cần lưu state (không cần DB/Lưu trữ). | Gửi token qua URL query params (dễ bị log/lộ). |

### Bảng 2: Xử lý SQL Injection

| Tình huống | Nên dùng gì | Tại sao (EN term + VI) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Query có tham số động (WHERE, IN, VALUES)** | **Prepared Statements (Parameterized Queries)** | **Separation of Concerns**: Tách biệt Logic SQL và Data. DB hiểu rõ tham số là giá trị chuỗi, không phải command. | Dùng string concatenation (`"WHERE name = '" + input + "'"`) để "cho nhanh". |
| **Có điều kiện phức tạp (JOIN, Sorting)** | **Stored Procedures** hoặc **ORM (Object-Relational Mapping)** | **Abstraction**: ORM thường xử lý escape tự động. SP biên dịch sẵn câu lệnh. | Tin tưởng hoàn toàn vào ORM mà không validate input đầu vào. |
| **Tìm lỗi (Pentest)** | **Union-based / Boolean-based Blind** | **Inference**: Để kiểm tra lỗ hổng bằng cách quan sát kết quả trả về hoặc thời gian phản hồi. | Dùng Blind SQLi để dò dữ liệu trong môi trường production (quá chậm, dễ bại lộ). |

--------------------------------
SECTION 3: ARCHITECTURE & RELATIONSHIPS
--------------------------------

###Luồng tấn công & Phòng thủ (CSRF)

```text
[Browser Tab 1: Bank.com]             [Browser Tab 2: Evil.com]
      | (Đăng nhập thành công)                |
      v                                      |
[Session Cookie: sid=abc]                   |
      |                                      |
      | (User click link Evil)               |
      | ------------------------------------> |
      |                                       \
      |    [Browser Request to Bank.com]       \ (Script tự động gọi)
      |    GET /transfer?to=attacker           \
      |    Cookie: sid=abc (Gửi tự động!) -----> [Server Bank]
      |                                         (Kiểm tra session hợp lệ)
      |                                         -> Thực thi chuyển tiền
```

###Luồng tấn công & Phòng thủ (SQL Injection)

```text
[User Input] --> "input: ' OR 1=1 --"
                   |
                   v
[Application Logic] --> Lỗi: Concatenate chuỗi
                        "SELECT * FROM users WHERE name = '' OR 1=1 --'"
                                      |
                                      v
[Database Engine] --> Thực thi "1=1" (Luôn đúng)
                      -> Trả về toàn bộ users (Rò rỉ dữ liệu)
```

**Mối quan hệ chính:**
1. **Browser Trust:** CSRF tin tưởng trình duyệt gửi cookie đúng cách.
2. **Data vs Logic:** SQL Injection phá vỡ ranh giới giữa dữ liệu (User Input) và mã lệnh (SQL Command).

--------------------------------
SECTION 4: CODE PATTERNS (READY TO USE)
--------------------------------

### Pattern 1: Double-Submit Cookie (Chống CSRF cho SPA)

**Khi nào dùng:** Khi bạn build API Stateless (Node.js, Go,..) cho React/Vue và không muốn lưu token vào DB/Session.

**Tại sao đúng:** Kẻ tấn công không thể đọc cookie của site khác (SameSite policy) nên không thể tạo request trùng khớp giữa cookie và header.

```javascript
// 1. Server: Sinh token và set Cookie
const crypto = require('crypto');
app.get('/api/csrf-token', (req, res) => {
    const token = crypto.randomBytes(32).toString('hex');
    res.cookie('csrf-token', token, { 
        httpOnly: true, 
        sameSite: 'strict',
        secure: true 
    });
    res.json({ token }); // Gửi token về client để dùng ở Form/Header
});

// 2. Client: Gửi token trong Header
// (JS lấy token từ response ở trên)
fetch('/api/transfer', {
    method: 'POST',
    headers: {
        'X-CSRF-Token': token // Token từ response JSON
    },
    body: JSON.stringify({ to: 'attacker', amount: 1000 })
});

// 3. Server: Verify
app.post('/api/transfer', (req, res) => {
    const headerToken = req.headers['x-csrf-token'];
    const cookieToken = req.cookies['csrf-token'];
    
    if (!headerToken || headerToken !== cookieToken) {
        return res.status(403).json({ error: 'CSRF detected' });
    }
    // Logic chuyển tiền...
});
```

### Pattern 2: Parameterized Query (Chống SQL Injection)

**Khi nào dùng:** Luôn luôn dùng cho mọi SQL query có chứa variable từ người dùng.

**Tại sao đúng:** DB engine tách biệt câu lệnh và tham số. Input `' OR 1=1` sẽ bị coi là chuỗi literal, không phải command.

```javascript
// Ví dụ: Node.js với mysql2 hoặc pg
const userInput = req.body.username; // Input: admin' --
const passwordInput = req.body.password;

// SAI (Dễ bị tấn công):
// const query = `SELECT * FROM users WHERE username = '${userInput}'`;

// ĐÚNG (Parameterized):
const sql = 'SELECT * FROM users WHERE username = ? AND password = ?';
const values = [userInput, passwordInput];

connection.execute(sql, values, (err, results) => {
    if (results.length > 0) {
        // User exists
    }
});
```

### Pattern 3: Origin/Referer Validation

**Khi nào dùng:** Khi xây dựng REST API cho Web/Mobile app và không muốn dùng CSRF Token (tránh phức tạp state).

**Tại sao đúng:** Request từ site độc (`evil.com`) sẽ có header `Origin` là `evil.com`, không khớp với danh sách cho phép của server.

```javascript
app.post('/transfer', (req, res) => {
    const allowedOrigins = ['https://bank.com', 'https://app.bank.com'];
    const origin = req.headers.origin;

    // Kiểm tra strict origin
    if (allowedOrigins.includes(origin)) {
        // Proceed logic
        res.json({ success: true });
    } else {
        // Block request từ site lạ hoặc Postman (nếu dùng credentials)
        res.status(403).json({ error: 'Invalid Origin' });
    }
});
```

--------------------------------
SECTION 5: ANTI-PATTERNS & WARNINGS
--------------------------------

1.  **String Concatenation trong SQL (SQLi):**
    *   *Tại sao nguy hiểm:* Cho phép kẻ tấn công đóng mở dấu nháy (`'`) để chèn lệnh `DROP`, `UNION`, `DELETE`. Hỏng hoàn toàn database.
    *   *Luôn nhớ:* `input` là dữ liệu, không bao giờ là câu lệnh.

2.  **Trusting `Referer` Header một cách mù quáng:**
    *   *Tại sao nguy hiểm:* Một số trình duyệt hoặc Proxy có thể gửi header này rỗng hoặc sửa đổi. Nếu logic chỉ là `if (referer)`, attacker có thể qua mặt.
    *   *Luôn nhớ:* Chỉ dùng để hỗ trợ, không nên là lớp bảo vệ duy nhất nếu không xử lý trường hợp header bị thiếu.

3.  **CSRF Token Hardcoded trong HTML:**
    *   *Tại sao nguy hiểm:* Nếu token được sinh 1 lần và hardcode trong source code hoặc hiển thị public (không bound vào session), mọi người dùng đều dùng chung token. Attacker lấy token public này là hack được tất cả.
    *   *Luôn nhớ:* Token phải sinh ngẫu nhiên, tồn tại phiên (session), và bind với user.

4.  **Bỏ qua SameSite Cookie:**
    *   *Tại sao nguy hiểm:* Để mặc định (Lax) cho các giao dịch nhạy cảm có thể chấp nhận request GET từ site khác (ví dụ link referrer).
    *   *Luôn nhớ:* Dùng `SameSite=Strict` cho app ngân hàng/admin.

--------------------------------
SECTION 6: MASTER CHEAT SHEET
--------------------------------

**Quick Decision Logic:**

*   **IF** app is pure SPA (React/Vue) -> **USE** Double-Submit Cookie + SameSite.
*   **IF** app is traditional server-render -> **USE** CSRF Token (Synchronizer).
*   **IF** building API mobile/third-party -> **USE** Origin Validation.
*   **IF** executing SQL -> **ALWAYS** use Parameterized Queries (Prepared Statements).

**Top 5 Rules to Remember:**

1.  **CSRF:** Kẻ tấn công lợi dụng Session hợp lệ. Session là tang vật phạm tội.
2.  **SQLi:** Input người dùng là Dữ liệu, không bao giờ là Lệnh.
3.  **Fix SQLi:** Dùng `?` thay vì `+` để nối chuỗi SQL.
4.  **Fix CSRF:** `Origin` header phải khớp với domain server.
5.  **Double Submit:** Cookie (httpOnly) và Header có giá trị giống nhau -> Server verify match mà không cần lưu state.

<!-- CHUNK 21-30 -->

# DEVELOPER DECISION GUIDE: Web Security (Lec 9)

## SECTION 1: CORE MENTAL MODEL

### SQL Injection (SQLi) & NoSQL Injection
**SQL Injection (SQLi)** là kỹ thuật tấn công où người dùng nhập mã SQL độc hại vào input để điều khiển câu truy vấn cơ sở dữ liệu. Cơ chế hoạt động: Application kết hợp input người dùng trực tiếp vào câu lệnh SQL mà không kiểm tra, khiến input trở thành một phần của logic truy vấn.

**Blind SQLi (SQLi Mù)** là dạng tấn công khi ứng dụng không trả về lỗi hoặc dữ liệu trực tiếp, hacker phải dùng kỹ thuật suy luận dựa trên hành vi server (ví dụ: thời gian phản hồi). Ví dụ: `IF(SUBSTRING(password,1,1)='a', SLEEP(5), 0)`. Nếu server delay 5s, ký tự đoán đúng.

**NoSQL Injection** là tấn công vào cơ sở dữ liệu NoSQL (MongoDB) bằng cách chèn các toán tử truy vấn (như `$ne`, `$gt`) vào input, thay đổi logic lọc dữ liệu. Ví dụ: `{"password": {"$ne": null}}` luôn trả về true nếu password không null.

### Authentication (Xác thực) & Session (Phiên)
**Authentication (Xác thực)** là quá trình xác minh danh tính người dùng (Proof of Identity). Đây là bước đầu tiên trước khi cấp quyền (Authorization). Các phương thức chính: Password, MFA, Biometrics, Tokens (JWT/Session), OAuth.

**Session-Based Auth** là phương thức xác thực có trạng thái (Stateful). Server tạo và lưu trữ `SessionID` (thường trong Redis hoặc Memory). Khi login thành công, server gửi `SessionID` về client dưới dạng **HttpOnly Cookie**. Client gửi cookie này trong mọi request sau đó. Server lookup session để xác định user.

**Token-Based Auth (JWT)** là phương thức xác thực không trạng thái (Stateless). Server ký một chuỗi JSON (JWT) bằng secret key và gửi cho client. Client lưu trữ token và gửi trong header `Authorization: Bearer <token>`. Server chỉ cần verify signature mà không cần lưu trữ trạng thái.

### Session Fixation
**Session Fixation** là lỗ hổng bảo mật où người tấn công ép buộc người dùng sử dụng một `SessionID` do chính kẻ tấn công tạo ra. Khi người dùng đăng nhập bằng SessionID đó, kẻ tấn công ngay lập tức có quyền truy cập vào tài khoản của nạn nhân vì cả hai cùng dùng chung một phiên hợp lệ.

---

## SECTION 2: DECISION TABLES

### Table 1: SQLi Prevention Strategies
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Có SQL queries có chứa input người dùng | **Prepared Statements (Parameterized Queries)**<br>`db.execute("SELECT * FROM users WHERE id = ?", [id])` | Separation of Logic & Data (Tách biệt Logic & Dữ liệu). Database hiểu rõ đâu là command, đâu là data nên không thể injected. | Dùng string concatenation: `"SELECT * FROM users WHERE id = " + id`. |
| Tránh thao tác SQL trực tiếp | **ORM (Object-Relational Mapping)**<br>`User.findAll({where: {id: id}})` | ORM tự động sanitize input và escape ký tự nguy hiểm, tạo query chuẩn. | Viết raw SQL manual trong ORM (vô hiệu bảo vệ). |
| Kiểm tra format input | **Allowlist Validation (Input Whitelist)**<br>`regex /^[a-zA-Z0-9_]+$/` | Chặn các ký tự đặc biệt (`'`, `;`, `--`) trước khi query, loại trừ các mẫu input xấu. | Denylist (chặn từng ký tự nguy hiểm) - dễ bị bỏ sót biến thể. |

### Table 2: SQL Injection vs NoSQL Injection Prevention
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Dùng SQL Database (MySQL, PostgreSQL) | **Parameterized Queries** | Truy vấn SQL tách biệt logic và dữ liệu. | Concatenate string vào câu lệnh SQL. |
| Dùng MongoDB (NoSQL) | **Schema Validation (Mongoose)**<br>`new mongoose.Schema(..., { strict: "throw" })` | Ensures data type (Đảm bảo kiểu dữ liệu). Nếu input là object thay vì string, schema validation sẽ chặn ngay. | Để schema loose (không kiểm tra type), cho phép input là object `{ "$ne": null }` lọt vào. |
| NodeJS + MongoDB | **Middleware Sanitization**<br>`mongoSanitize()` | Loại bỏ các toán tử `$gt`, `$ne` ra khỏi request body trước khi xử lý. | Để input trần truồng vào query MongoDB. |

### Table 3: Session-Based vs Token-Based Authentication
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Web App Server-Rendered (Classic), cần revoke session tức thì | **Session-Based Auth** | Dễ dàng tắt quyền truy cập bằng cách xóa session ở server (Redis/Memory). | Lưu SessionID trong localStorage (không an toàn). |
| SPA (React/Vue), Mobile App, Microservices | **Token-Based Auth (JWT)** | Stateless (không cần shared storage), dễ scale ngang. | Set expiration quá dài hoặc không dùng Refresh Token. |
| Cần bảo mật cao cho Session | **HttpOnly Cookie** | Ngăn XSS đọc và đánh cắp SessionID/Token. | Lưu token trong `localStorage` hoặc `sessionStorage`. |

### Table 4: Session Fixation Prevention
| Tình huống sử dụng | Nên dùng gì | Tại sao (Why) | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| Xử lý request login thành công | **Regenerate Session ID**<br>`req.session.regenerate()` | Tạo SessionID mới sau khi xác thực thành công, SessionID cũ của hacker trở nên vô dụng. | Giữ nguyên SessionID từ pre-login sang post-login. |
| Chấp nhận SessionID từ URL | **Từ chối URL SessionID** | Tránh bị lộ SessionID qua referer hoặc người dùng nhầm link. | Sử dụng `sessionID` từ query param. |
| Cấu trúc Cookie | **Set Attribute: SameSite, Secure, HttpOnly** | `SameSite=Strict/Lax` chống CSRF, `Secure` bắt buộc HTTPS, `HttpOnly` chống XSS. | Bỏ qua các attribute bảo mật. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flowchart: Quy Trình Xác Thực & Chống Tấn Công

```text
[Input User] 
    |
    V
[1. Input Validation & Sanitization]
    | (Kiểm tra format và loại bỏ ký tự/toán tử nguy hiểm)
    |
    V
[2. Pre-Auth Check]
    |
    +---> [XSS Protection?] -> Set Cookie: HttpOnly + Secure
    |
    +---> [Session Fixation?] -> Tạo Session ID MỚI nếu đăng nhập thành công
    |
    V
[3. Authentication Logic]
    |
    +--> [SQL DB?] ----> Use Parameterized Query (Prepared Statements)
    |                   SELECT * FROM users WHERE id = ?
    |
    +--> [NoSQL DB?] --> Use Schema Validation (Mongoose)
    |                   Type check: String ONLY,严禁 Object Injection
    |
    V
[4. Grant Access]
    |
    +--> [Session-Based] -> Set Cookie (SessionID) -> Server Lookup Session
    |
    +--> [Token-Based]   -> Sign JWT -> Return Token (Bearer)
```

---

## SECTION 4: CODE PATTERNS

### Pattern 1: Parameterized Query (SQL)
**Khi nào dùng:** Khi cần truy vấn cơ sở dữ liệu SQL có sử dụng dữ liệu nhập từ người dùng.

**Tại sao đúng:** Truy vấn được biên dịch trước (pre-compiled), biến `?` chỉ nhận dữ liệu thô. Kẻ tấn công không thể chèn lệnh SQL vào dữ liệu này.

```javascript
// NodeJS với mysql2 hoặc pg
const mysql = require('mysql2');

// KHÔNG NÊN:
// connection.query(`SELECT * FROM users WHERE username = '${req.body.username}'`, ...);

// NÊN DÙNG:
const username = req.body.username;
const query = "SELECT * FROM users WHERE username = ?";

connection.execute(query, [username], function(err, results) {
    if (err) throw err;
    console.log(results);
});
```

### Pattern 2: NoSQL Schema Validation (Mongoose)
**Khi nào dùng:** Khi dùng MongoDB và NodeJS để tránh NoSQL Injection (ví dụ: injection operators `$ne`, `$gt`).

**Tại sao đúng:** Mongoose Schema buộc dữ liệu input phải tuân thủ strict type. Nếu hacker gửi object thay vì string, Mongoose sẽ ném lỗi hoặc tự động cast, ngăn chặn injection.

```javascript
const mongoose = require('mongoose');

// Định nghĩa Schema nghiêm ngặt
const UserSchema = new mongoose.Schema({
    username: { type: String, required: true },
    password: { type: String, required: true }
}, { 
    // 'throw' sẽ báo lỗi nếu có field không được định nghĩa
    strict: "throw" 
});

const User = mongoose.model('User', UserSchema);

// Tìm kiếm an toàn
app.post('/login', async (req, res) => {
    try {
        // Nếu req.body.username = { "$ne": null }, Mongoose type check sẽ fail hoặc không interpret là operator
        const user = await User.findOne({
            username: req.body.username,
            password: req.body.password
        });
        res.json(user);
    } catch (e) {
        res.status(400).send("Invalid Input Format");
    }
});
```

### Pattern 3: Session Security (Express)
**Khi nào dùng:** Xây dựng web application server-side rendered, cần bảo mật session.

**Tại sao đúng:** Sử dụng middleware `express-session` với cấu hình `secure`, `httpOnly`, `sameSite` để chống XSS và CSRF. Quan trọng nhất là gọi `req.session.regenerate()` sau khi login thành công để tránh Session Fixation.

```javascript
const session = require('express-session');
const express = require('express');
const app = express();

// 1. Cấu hình Session Cookie an toàn
app.use(session({
    secret: 'super-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { 
        secure: true,      // Chỉ gửi qua HTTPS
        httpOnly: true,    // Không cho Javascript truy cập
        sameSite: 'strict' // Chống CSRF
    }
}));

// 2. Xử lý Login và Chống Session Fixation
app.post('/login', (req, res) => {
    const { user, pass } = req.body;
    
    if (isValid(user, pass)) {
        // QUAN TRỌNG: Regenerate ID trước khi gán info
        req.session.regenerate((err) => {
            if (err) return res.sendStatus(500);
            
            // Gán info vào session mới
            req.session.userId = user.id;
            res.send('Logged in');
        });
    } else {
        res.status(401).send('Invalid credentials');
    }
});
```

### Pattern 4: JWT Stateless Auth
**Khi nào dùng:** Khi build API cho SPA/Mobile, hoặc hệ thống microservices không muốn chia sẻ session store.

**Tại sao đúng:** Server không cần lưu trữ gì cả, chỉ cần verify signature. Sử dụng refresh token để quản lý vòng đời.

```javascript
const jwt = require('jsonwebtoken');

// Secret key (luôn giữ an toàn)
const ACCESS_SECRET = 'access_secret';
const REFRESH_SECRET = 'refresh_secret';

// 1. Sinh token sau khi login
app.post('/login', (req, res) => {
    const user = { id: 123, name: 'dev' };
    
    // Access Token (short life)
    const accessToken = jwt.sign(user, ACCESS_SECRET, { expiresIn: '15m' });
    
    // Refresh Token (long life)
    const refreshToken = jwt.sign(user, REFRESH_SECRET, { expiresIn: '7d' });

    // Gửi về client (nên lưu refreshToken ở HttpOnly Cookie nếu dùng Web)
    res.json({ accessToken, refreshToken });
});

// 2. Middleware verify token
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer <token>

    if (!token) return res.sendStatus(401);

    jwt.verify(token, ACCESS_SECRET, (err, user) => {
        if (err) {
            // Token hết hạn hoặc sai
            return res.sendStatus(403);
        }
        req.user = user;
        next();
    });
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **String Concatenation in SQL**
    *   **Lý do nguy hiểm:** `query = "SELECT * FROM " + table`. Cho phép hacker inject `DROP TABLE` hoặc `UNION SELECT`. Luôn dùng Parameterized Queries.

2.  **Trusting NoSQL Input (Operator Injection)**
    *   **Lý do nguy hiểm:** `User.find({ username: req.query.user })`. Nếu user input là `{"$ne": ""}`, app sẽ tìm tất cả user thay vì fail. Phải dùng Schema Validation hoặc Sanitize.

3.  **SessionID trong URL**
    *   **Lý do nguy hiểm:** `example.com/login?sessionid=123`. URL được lưu trong logs, browser history, và gửi qua Referer header. Luôn dùng HttpOnly Cookie.

4.  **LocalStorage cho JWT/Session**
    *   **Lý do nguy hiểm:** Javascript có thể truy cập LocalStorage. Nếu site bị XSS, attacker lấy token ngay lập tức. Phải dùng `HttpOnly Cookie`.

5.  **Không Regenerate SessionID sau Login**
    *   **Lý do nguy hiểm:** Dễ bị Session Fixation attack. Phải gọi `req.session.regenerate()` hoặc tạo session ID mới hoàn toàn sau khi xác thực thành công.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 10 Things To Remember
1.  **SQL:** Dùng `?` (Prepared Statements) luôn.
2.  **NoSQL:** Dùng Schema (Type Check) luôn.
3.  **Session ID:** Lưu trong `HttpOnly Cookie`, không bao giờ trong `LocalStorage`.
4.  **Login Flow:** `Regenerate Session ID` ngay lập tức.
5.  **Cookie:** Bật `Secure` (HTTPS), `HttpOnly`, `SameSite=Strict`.
6.  **JWT:** Set expiration ngắn (15p) + Refresh token.
7.  **Input:** Validate type (string là string, number là number) trước khi xử lý.
8.  **Blind SQLi:** Nghi ngờ nếu response có delay bất thường (Time-based).
9.  **NoSQL Operators:** Chặn các ký tự `$` nếu không cần thiết từ input người dùng.
10. **Authorization:** Authentication (đăng nhập) != Authorization (quyền). Luôn check quyền sau khi xác thực.

### Logic Quyết Định (If-Else)
*   **IF** app dùng SQL -> **USE** Parameterized Query.
*   **IF** app dùng MongoDB -> **USE** Mongoose Schema Validation + `strict: "throw"`.
*   **IF** app cần scale ngang (microservices) -> **USE** JWT (Token-Based).
*   **IF** app web server-rendered -> **USE** Session-Based (Server-side store).
*   **IF** có login -> **REGENERATE** Session ID ngay lập tức.
*   **IF** lưu trữ secret (token/session) ở client -> **USE** HttpOnly Cookie.

<!-- CHUNK 31-40 -->

# DEVELOPER DECISION GUIDE: Web Security

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

1.  **Session Hijacking (Chiếm đoạt phiên làm việc)**
    *   Attacker steals a valid `sessionID` to impersonate a user.
    *   *Reality:* Happens via XSS (stealing cookies), network sniffing (no HTTPS), or predictable IDs.

2.  **Insecure Direct Object Reference (IDOR) (Tham chiếu đối tượng trực tiếp không an toàn)**
    *   App exposes database IDs (e.g., `/user/123`) without checking if the current user owns or is allowed to access that ID.
    *   *Reality:* Attacker changes `123` to `124` and sees private data.

3.  **JWT (JSON Web Token) (Mã thông báo web JSON)**
    *   Stateless token containing data.
    *   **Header** (Algo), **Payload** (Data), **Signature** (Integrity check).
    *   *Mental Model:* A signed document. The server doesn't store it (stateless), but verifies the signature to ensure it wasn't tampered with.

### Why Secure Cookies + MFA?
*   **Secure Cookies:** Blocks JavaScript access (`HttpOnly`) and forces HTTPS (`Secure`). Prevents the two most common theft vectors.
*   **MFA (Multi-Factor Authentication):** Renders stolen passwords useless.

---

## SECTION 2: DECISION TABLES

### Table 1: Session Management Strategy

| Use Case (Tình huống) | Should Use (Nên dùng) | Why (Tại sao) | Common Mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **High Security App (Banking)** | **Re-Authentication** (MFA/Password) + **Session Timeout** | **Re-Auth** ensures user presence for critical actions. **Timeout** minimizes exposure if device is idle. | Relying solely on the initial login for the entire session duration. |
| **General Web App** | **Session ID Regeneration** (Rotation) + **Secure Cookies** | **Regeneration** prevents Session Fixation. **Secure Cookies** (HttpOnly/Secure) prevent theft via XSS/Sniffing. | Using predictable session IDs or forgetting to invalidate old IDs after login. |

### Table 2: Cookie Flags Configuration

| Flag (Cờ) | When to Use | Why (Tại sao) | Common Mistake |
| :--- | :--- | :--- | :--- |
| **HttpOnly** | **Always** (Except for specific JS-required tokens) | Blocks `document.cookie` access. Prevents **XSS** from stealing session tokens. | Leaving it off, allowing malicious scripts to read the session ID. |
| **Secure** | **Always** (In Production) | Ensures cookie is sent only over **HTTPS**. Prevents **Session Hijacking** via network sniffing. | Using on `localhost` (HTTP) causing session loss during dev. |
| **SameSite** | **Strict** or **Lax** (Default) | Prevents **CSRF** (Cross-Site Request Forgery) by controlling cookie sending on cross-site requests. | Setting `None` without `Secure`, allowing CSRF attacks. |

### Table 3: Access Control Logic

| Scenario | Should Use | Why (Tại sao) | Common Mistake |
| :--- | :--- | :--- | :--- |
| **User accessing own data** | **Ownership Check** (`requestedUserId === loggedInUserId`) | Prevents **IDOR**. Verifies that the user is only accessing their own resources. | Trusting the ID in the URL without comparing it to the logged-in user. |
| **Role-based features** | **RBAC (Role-Based Access Control)** | **Scalability**. Permissions are managed by Role (Admin, Editor), not per user. | Hardcoding permissions for specific users instead of using roles. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Security Layer Flow

```text
[ Client Request ] 
       |
       v
[ 1. Transport Layer ]
       |
   HTTPS (TLS)  <-- Prevents Sniffing
       |
       v
[ 2. Authentication ]
       |
   [ Cookies / JWT ]  <-- Identity
       |
   HttpOnly / Secure / SameSite  <-- Anti-XSS / Anti-CSRF
       |
       v
[ 3. Authorization (Server) ]
       |
   [ RBAC Check ]  <-- Role check
   [ IDOR Check ]  <-- Ownership check (Current User == Target User)
       |
       v
[ 4. Session Management ]
       |
   [ Regenerate ID ]  <-- On Login/Privilege Escalation
   [ Timeout Check ]  <-- Auto-logout
   [ Re-Auth ]        <-- For High-Risk Actions
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Secure Cookie Configuration
**When to use:** Setting session cookies in an Express/Node.js app.
**Why:** Enforces browser security rules to mitigate theft and CSRF.

```javascript
const express = require('express');
const session = require('express-session');
const app = express();

app.use(session({
  secret: 'your-secure-secret-key',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,      // JS cannot access (Anti-XSS)
    secure: true,        // Only send over HTTPS (Anti-Sniffing)
    sameSite: 'strict',  // Block cross-site requests (Anti-CSRF)
    maxAge: 1000 * 60 * 30 // 30 min session timeout
  }
}));
```

### Pattern 2: Password Hashing (Bcrypt)
**When to use:** Storing new user passwords or validating login.
**Why:** One-way hashing makes stolen database dumps useless.

```javascript
const bcrypt = require('bcrypt');
const saltRounds = 10;

// 1. Register: Hash Password
async function hashPassword(plainText) {
  return await bcrypt.hash(plainText, saltRounds);
}

// 2. Login: Compare Password
async function verifyPassword(plainText, hashFromDB) {
  return await bcrypt.compare(plainText, hashFromDB);
}
```

### Pattern 3: Preventing IDOR (Insecure Direct Object Reference)
**When to use:** Any API endpoint that accesses a resource by ID (e.g., `/orders/:id`).
**Why:** Checks if the logged-in user owns the requested resource.

```javascript
// Vulnerable:
// app.get('/orders/:id', (req, res) => {
//   const order = db.orders.find(req.params.id); 
//   res.send(order); // Attacker sees Alice's order
// });

// Secure:
app.get('/orders/:id', (req, res) => {
  const orderId = req.params.id;
  const currentUserId = req.user.id; // From Session/JWT

  const order = db.orders.find(orderId);

  if (!order) return res.status(404).send();
  
  // CRITICAL CHECK: Does this order belong to the user?
  if (order.userId !== currentUserId) {
    return res.status(403).send("Forbidden: Access Denied");
  }

  res.send(order);
});
```

### Pattern 4: JWT Generation & Verification
**When to use:** Stateless authentication (e.g., Single Page Apps, Microservices).
**Why:** Server doesn't need to store sessions, just a secret key.

```javascript
const jwt = require('jsonwebtoken');
const SECRET_KEY = 'super-secret-key';

// 1. Sign (Login)
function generateToken(user) {
  const payload = { 
    id: user.id, 
    role: user.role, 
    exp: Math.floor(Date.now() / 1000) + (60 * 60) // 1 hour expiration
  };
  return jwt.sign(payload, SECRET_KEY);
}

// 2. Verify (Middleware)
function verifyToken(req, res, next) {
  const token = req.headers['authorization'];
  if (!token) return res.status(401).send("Access Denied");

  try {
    const decoded = jwt.verify(token, SECRET_KEY); // Throws if invalid/tampered
    req.user = decoded; // Attach user to request
    next();
  } catch (err) {
    res.status(400).send("Invalid Token");
  }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Storing Passwords in Plaintext**
    *   **Danger:** If the database is leaked, all user accounts are instantly compromised. No recovery.

2.  **Allowing JS to Read Auth Cookies (`HttpOnly: false`)**
    *   **Danger:** Any XSS vulnerability (injecting scripts) becomes a full session hijack. The script simply reads `document.cookie` and sends it to the attacker.

3.  **Trusting Client-Side Authorization**
    *   **Danger:** Hiding an "Admin" button on the UI doesn't protect the API. An attacker can call the API directly using tools like Postman.
    *   **Fix:** Always enforce authorization on the **Server**.

4.  **Using `SameSite: None` without `Secure`**
    *   **Danger:** Allows cookies to be sent in cross-site requests over insecure connections, opening the door to CSRF attacks.

5.  **Not Regenerating Session IDs**
    *   **Danger:** If a user clicks a link in a phishing email (Session Fixation), the attacker might know the session ID. Failing to regenerate it after login allows the attacker to hijack the authenticated session.

---

## SECTION 6: MASTER CHEAT SHEET

### The "Must-Do" Checklist
1.  **HTTPS Everywhere:** No security without encryption.
2.  **HttpOnly + Secure Cookies:** The golden standard for session storage.
3.  **Hash Passwords:** Use `bcrypt` or `Argon2`.
4.  **Check Ownership:** `if (req.user.id === resource.userId)`.
5.  **Regenerate ID:** On login and privilege escalation.

### Decision Logic (If-Else)

*   **IF** storing a session token: **THEN** set `HttpOnly`, `Secure`, `SameSite=Strict`.
*   **IF** handling passwords: **THEN** hash with salt (Cost Factor 10+).
*   **IF** URL contains an ID to fetch data: **THEN** check `ID == currentUser.id`.
*   **IF** doing financial/privileged action: **THEN** trigger **Re-Authentication** (MFA).
*   **IF** using JWT: **THEN** verify signature on every request and set a short `exp`.

### Top 3 Takeaways for Exam/Coding
1.  **IDOR:** Never trust the `id` in the URL. Match it to the logged-in user.
2.  **JWT:** Signed (integrity), not Encrypted (payload is visible).
3.  **Session Fixation:** Regenerate session ID immediately after successful login.

<!-- CHUNK 41-50 -->

# DEVELOPER DECISION GUIDE: Web Security (Lec 9)

## SECTION 1: CORE MENTAL MODEL

### JWT (Json Web Token)
- **Definition**: JSON Web Token (JWT - Chữ ký Web JSON) là tiêu chuẩn RFC 7519 định nghĩa cách đóng gói thông tinClaims (thông tin yêu cầu) vào một đối tượng JSON để truyền đi an toàn giữa các bên, có chữ ký điện tử.
- **Mental Model**: JWT là "vé số có chữ ký". Ai cũng đọc được số trên vé (Payload), nhưng chỉ người phát hành (Server) mới ký được lên vé. Nếu ai đó sửa số trên vé, chữ ký sẽ bị h hỏng.
- **Reality Check**: JWT là Stateless (không lưu trạng thái trên Server). Server chỉ việc kiểm tra chữ ký, không cần query Database.
- **Why it's better**: Giảm tải Database vì không cần lưu session, dễ dàng chia sẻ giữa nhiều service (Microservices).

### HTTPS / TLS (Transport Layer Security)
- **Definition**: TLS (Lớp Bảo mật Truyền tải) là giao thức mật mã học dùng để bảo vệ thông tin truyền qua mạng Internet.
- **Mental Model**: TLS tạo ra một đường ống kín (Encrypted Tunnel). Dù ai đó nghe trộm đường ống, họ cũng chỉ thấy chuỗi ký tự rác (Encrypted).
- **Reality Check**: TLS không chỉ mã hóa mà còn đảm bảo tính toàn vẹn (Integrity - dữ liệu không bị sửa đổi) và xác thực danh tính (Authentication - đúng server).

---

## SECTION 2: DECISION TABLES (TOKEN SECURITY)

### Bảng 1: Lưu trữ Access Token ở đâu?

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **App cần XSS Protection cao** | **Memory (RAM)** | Truy cập nhanh, không persist, hacker không đọc được nếu không dùng XSS thành công ăn cắp bộ nhớ. | Lưu vào `localStorage` (dễ bị XSS read). |
| **App cần Auto-Send request** | **HttpOnly Cookie** | Trình duyệt tự gửi Cookie, không cần attach header thủ công. | Dùng HttpOnly cho Access Token (không gọi được APIs từ JS). |
| **App cần.csrf Protection** | **Memory or Header** | Cookie auto-sent → dễ dính CSRF. Token trong Header/Storage không auto-sent → an toàn CSRF. | Quên xử lý CSRF khi dùng Cookie. |

### Bảng 2: Access Token vs Refresh Token

| Tính năng | Access Token | Refresh Token |
| :--- | :--- | :--- |
| **Lifetime (Thời gian sống)** | Ngắn (5-15 phút) | Dài (7-30 ngày) |
| **Gửi mỗi request?** | Có (trong Header `Authorization`) | Không (chỉ khi Access Token hết hạn) |
| **Lưu trữ an toàn nhất** | Memory (hoặc `localStorage`) | HttpOnly Cookie (Bắt buộc) |
| **Rủi ro nếu bị đánh cắp** | Thấp (hết hạn nhanh) | Cao (dùng để tạo Access Token mới) |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### JWT Login Flow & Token Rotation

```text
[Client]                   [Server]
   |                          |
   | 1. Login (User/Pass)     |
   |------------------------->|
   |                          | -- Kiểm tra DB & Đúng Pass -->
   |                          |
   |                          | -- Tạo A1 (Access), R1 (Refresh) --
   |                          |
   | 2. Response (A1 + R1)    |
   |<-------------------------|
   |                          |
   | 3. Lưu A1 (Memory)       |
   |    Lưu R1 (HttpOnly)     |
   |                          |
   | 4. Gọi API (gửi A1)      |
   |------------------------->|
   |                          | -- Kiểm tra Chữ ký A1 -->
   |                          |
   | 5. Hết hạn?              |
   |    [NO] -> Truy cập OK   |
   |    [YES]-> Gọi Refresh   |
   |      |                   |
   |      | 6. Gửi R1         |
   |      |------------------>|
   |      |                   | -- Kiểm tra R1 Hợp lệ? -->
   |      |                   |
   |      |                   | -- Xóa R1 (Invalid)       |
   |      |                   | -- Tạo A2 + R2 Mới       |
   |      |                   |
   |      | 7. Nhận A2 + R2   |
   |<-----|-------------------|
```

**Rotation Logic (Logic Xoay vòng):**
`R1 used` → `Invalid` → `Mới R2` → `Client update R2`

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: HttpOnly Cookie Setup (Server-Side)

**Khi nào dùng:** Khi Server cần set Refresh Token cho Client một cách an toàn nhất.

**Tại sao đúng:** Chặn JavaScript đọc được token (Anti-XSS).

```javascript
// Node.js / Express Example
const express = require('express');
const app = express();

app.post('/login', (req, res) => {
    // 1. Validate user
    const user = { id: 1, role: 'admin' };
    
    // 2. Generate Tokens
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    // 3. Set Refresh Token in HttpOnly Cookie
    res.cookie('refreshToken', refreshToken, {
        httpOnly: true,   // ✅ JS cannot read
        secure: true,     // ✅ HTTPS only (Production)
        sameSite: 'None', // ✅ CSRF protection (if cross-site)
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });

    // 4. Send Access Token in JSON/Body (Client will store in Memory)
    res.json({ accessToken: accessToken });
});
```

### Pattern 2: Client-Side Token Storage Strategy

**Khi nào dùng:** Khi Frontend cần quản lý Access Token sau khi login.

**Tại sao đúng:** Truy cập API nhanh, không phụ thuộc Cookie.

```javascript
// Client-side JavaScript

const authService = {
  // Lưu Access Token vào Memory (Biến toàn cục)
  accessToken: null,

  login: async (credentials) => {
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    const data = await response.json();
    
    // Lưu Access Token vào biến class/class variable
    // ✅ KHÔNG dùng localStorage.setItem('token', data.accessToken)
    this.accessToken = data.accessToken; 
  },

  callApi: async (url) => {
    // Đính kèm token vào header
    const headers = {};
    if (authService.accessToken) {
      headers['Authorization'] = `Bearer ${authService.accessToken}`;
    }

    return fetch(url, { headers });
  },

  // Logic xử lý khi Token hết hạn (401)
  handle401: async () => {
    // Gọi Refresh Token API (Cookie tự động gửi đi)
    const res = await fetch('/api/refresh', { method: 'POST' });
    const data = await res.json();
    // Cập nhật Access Token mới
    authService.accessToken = data.accessToken;
  }
};
```

### Pattern 3: Refresh Token Rotation (Validation)

**Khi nào dùng:** Khi hệ thống yêu cầu bảo mật cao, không cho phép Refresh Token cũ tái sử dụng.

**Tại sao đúng:** Ngăn hành vi "Replay Attack" nếu token bị đánh cắp.

```javascript
// Server-side Logic
async function handleRefreshToken(req, res) {
    const refreshToken = req.cookies.refreshToken;
    
    if (!refreshToken) return res.sendStatus(401);

    // 1. Verify token & Check DB (Is it the latest token?)
    const storedToken = await db.refreshTokens.findOne({ token: refreshToken });
    
    if (!storedToken || storedToken.isUsed) {
        return res.status(403).json({ message: "Token stolen or invalid" }); 
        // 🔒 Force logout client here
    }

    // 2. Mark old token as Used/Invalidated
    await db.refreshTokens.updateOne({ token: refreshToken }, { isUsed: true });

    // 3. Generate NEW Pair
    const user = { id: storedToken.userId };
    const newAccess = generateAccessToken(user);
    const newRefresh = generateRefreshToken(user);

    // 4. Save NEW Refresh Token
    await db.refreshTokens.create({ token: newRefresh, userId: user.id, isUsed: false });

    // 5. Return
    res.cookie('refreshToken', newRefresh, { httpOnly: true, secure: true });
    res.json({ accessToken: newAccess });
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Storing Secrets in JWT Payload
- **Nguy hiểm**: JWT Payload chỉ được mã hóa Base64URL, ai bắt được gói tin đều đọc được (Base64 decode dễ dàng).
- **Tại sao nguy hiểm**: Người dùng có thể xem và sửa đổi nội dung (ví dụ: `"role": "user"` thành `"role": "admin"`). Tuy nhiên, nếu họ không có Key ký (Secret Key) thì Server sẽ từ chối. **Nhưng** thông tin nhạy cảm (API Key, Password, SSN) bị lộ hoàn toàn.
- **Quy tắc**: Chỉ lưu `userId`, `role`, `exp` (thời gian hết hạn). KHÔNG lưu mật khẩu hay thông tin cá nhân nhạy cảm.

### 2. Dùng `localStorage` cho Refresh Token
- **Nguy hiểm**: Bất kỳ script độc hại nào trên trang web (do XSS) đều có thể gọi `localStorage.getItem('refreshToken')` và gửi về server của hacker.
- **Tại sao nguy hiểm**: Refresh Token có thời hạn dài. Hacker có thể làm mới Access Token thoải mái dù user không online.
- **Quy tắc**: Refresh Token phải nằm ở **HttpOnly Cookie**.

### 3. Không dùng `Secure` flag trên Cookie
- **Nguy hiểm**: Cookie được truyền qua kết nối HTTP không mã hóa.
- **Tại sao nguy hiểm**: Hacker ở cùng mạng (Man-in-the-Middle) có thể đánh cắp cookie.
- **Quy tắc**: Luôn bật `secure: true` (trừ môi trường dev localhost).

### 4. Quên CORS / SOP khi dùng Cookie
- **Nguy hiểm**: Dù có HttpOnly, nếu CORS cho phép `Origin: *`, hacker có thể dùng request từ domain lạ để đánh cắp cookie (nếu không phải SameSite=None).
- **Tại sao nguy hiểm**: Gây ra tấn công CSRF.
- **Quy tắc**: Cấu hình CORS chặt chẽ và dùng `SameSite=Strict` hoặc `Lax` nếu không cần chia sẻ chéo domain.

---

## SECTION 6: MASTER CHEAT SHEET

### Quick Rules (Luật nhanh)
1. **Access Token**: Ngắn hạn → Lưu **Memory** (hoặc Header).
2. **Refresh Token**: Dài hạn → Lưu **HttpOnly Cookie** (Bắt buộc).
3. **HTTPS**: Bắt buộc ở Production (dùng TLS).
4. **JWT Payload**: Không bao giờ chứa Secret (Mật khẩu, Key API).
5. **Rotation**: Luôn đổi Refresh Token sau khi dùng.

### Decision Logic (Logic Ra quyết định)
*   **Cần lưu Token ở Client?**
    *   Nếu là **Access Token**: Dùng Variable trong RAM. (Mục đích: Tránh XSS, truy cập API).
    *   Nếu là **Refresh Token**: Dùng HttpOnly Cookie. (Mục đích: An toàn, tự động gửi).
*   **Token bị lỗi 401 (Expired)?**
    *   Gọi API `/refresh` (Cookie gửi automatic) → Nhận A2, R2.
    *   Nếu `/refresh` lỗi (403) → Đăng nhập lại.
*   **Cần truyền dữ liệu an toàn qua Internet?**
    *   Dùng **HTTPS** (TLS) → Cung cấp Encryption, Integrity, Authentication.

### Top 3 Things to Remember (Top 3 cần nhớ)
1. **Base64 != Encryption**: JWT có thể đọc được nội dung nếu không có Signature check.
2. **XSS vs CSRF**:
    *   Dùng **Memory/LocalStorage** → Chống CSRF tốt, dính XSS là chết.
    *   Dùng **HttpOnly Cookie** → Chống XSS tốt, dính CSRF nếu không có CSRF Token.
3. **TLS là nền tảng**: Không có HTTPS, mọi thứ khác đều vô nghĩa vì hacker nghe được hết.

<!-- CHUNK 51-60 -->

# DEVELOPER DECISION GUIDE: Web Security (Lec 9)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions

*   **HTTPS (Hypertext Transfer Protocol Secure)**
    *   **VN:** Giao thức truyền tải siêu văn bản bảo mật.
    *   **Mental Model:** HTTPS là HTTP được bọc trong một lớp mã hóa (SSL/TLS). Khi bạn gửi `password` qua HTTP, nó đi trần trụi qua mạng. Khi dùng HTTPS, dữ liệu bị "bí ẩn" (mã hóa) để kẻ tấn công nghe trộm (sniff) cũng không đọc được.

*   **SOP (Same-Origin Policy)**
    *   **VN:** Chính sách cùng nguồn.
    *   **Mental Model:** Trình duyệt là người gác cổng. Nó cho phép trang web A lấy dữ liệu từ chính nó (cùng origin: protocol + domain + port), nhưng chặn A lấy dữ liệu từ trang web B (khác origin). Mục đích:防止 trang web giả mạo trộm cookie hay thông tin từ trang web ngân hàng đang mở ở tab bên cạnh.

*   **CORS (Cross-Origin Resource Sharing)**
    *   **VN:** Chia sẻ tài nguyên nguồn chéo.
    *   **Mental Model:** SOP là "cửa đóng", CORS là "chìa khóa" bạn đưa cho trình duyệt để mở cửa cho một domain cụ thể nào đó. Nó là sự thỏa thuận giữa trình duyệt và server về việc cho phép truy cập chéo.

### Why HTTPS is Non-Negotiable
So với HTTP, HTTPS loại bỏ hoàn toàn nguy cơ "Man-in-the-Middle" (nghe trộm) trong việc đánh cắp thông tin nhạy cảm. Nếu bạn không dùng HTTPS, bất kỳ ai trên cùng mạng Wi-Fi (ví dụ: quán cà phê) đều có thể thấy username/password của người dùng.

---

## SECTION 2: DECISION TABLES

### Table 1: SOP vs CORS (Browser Behavior)

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Embedding Resource**<br>(Hiển thị ảnh/video từ domain khác) | **SOP (Allow)**<br>Trình duyệt cho phép mặc định. | **Read vs Embed**<br>Browser allows *embedding* (rendering) but blocks *reading* (accessing pixels/data). | Cố gắng dùng JavaScript `img.src` để đọc dữ liệu binary ảnh từ domain khác mà không cần CORS. |
| **Fetching Data (API)**<br>(React app gọi API backend) | **CORS**<br>Cần cấu hình `Access-Control-Allow-Origin`. | **Controlled Relaxation**<br>SOP chặn mọi fetch chéo origin. CORS là cơ chế để server cho phép client cụ thể truy cập. | Để wildcard `*` khi cần truyền Credentials (Cookie/Auth header). Bị tấn công CSRF ngay. |
| **Submitting Form**<br>(Gửi form sang endpoint khác) | **SOP (Allow)**<br>Browser cho phép submit sang action URL bất kỳ. | **Form Submission**<br>Form submission là "side-effect", không phải "read data", nên SOP không chặn (trừ trường hợp CORSPreflight). | Quên xử lý CORS Preflight (OPTIONS) nếu dùng `fetch` hoặc `XMLHttpRequest` thay vì `<form>`. |

### Table 2: Rate Limiting Algorithms

| Use case (Tình huống sử dụng) | Should use (Nên dùng gì) | Why (Tại sao) | Common mistake (Sai lầm thường gặp) |
| :--- | :--- | :--- | :--- |
| **Brute-force Login**<br>(Tấn công đăng nhập) | **Token Bucket** | **Smooth Burst**<br>Cho phép burst (vượt mức) nhưng kiểm soát t tổng thể. Dễ chịu hơn với người dùng thật vô tình click nhanh. | Dùng Fixed Window: Kẻ tấn công gõ 1000 lần ngay giây cuối window, reset xào gõ tiếp 1000 lần ngay giây đầu window mới (Bypass limit). |
| **API Protection (DDoS)**<br>(API Public) | **Fixed Window** | **Performance**<br>Đơn giản, nhanh, ít tốn tài nguyên nhớ. Dùng cho số lượng request lớn, không cần mượt mà. | Quên Reset Counter sau mỗi window导致 memory leak nếu implement sai. |

---

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flowchart: Preflight Request (CORS)

```text
[Client: Frontend]                  [Server: Backend]
      |                                   |
      | 1. Real Request (PUT/DELETE)?    |
      |---------------------------------->|
      |      (Blocked by Browser)         |
      |                                   |
      | 2. Pre-check (OPTIONS)            |
      |---------------------------------->|
      |                                   |
      | 3. Server Config Check            |
      |    (Allow Origin? Allow Method?)  |
      |<----------------------------------|
      |    (Access-Control-Allow-Origin)  |
      |                                   |
      | 4. Send Real Request              |
      |---------------------------------->|
      |                                   |
      | 5. Receive Data                   |
      |<----------------------------------|
```

---

## SECTION 4: CODE PATTERNS (READY TO USE)

### Pattern 1: Implementing CORS Headers (Node.js/Express)

**Khi nào dùng:** Khi Frontend (ví dụ: `localhost:3000`) gọi API Backend (ví dụ: `localhost:8080`) ở domain/port khác.

**Tại sao đúng:** Server phải chủ động告诉浏览器 "Tôi cho phép trang này truy cập" bằng cách set header. Without this, browser blocks response.

```javascript
// Backend (Node.js / Express)
const express = require('express');
const cors = require('cors');
const app = express();

// Cấu hình CORS an toàn
const corsOptions = {
  origin: 'http://localhost:3000', // Chỉ cho phép domain này
  methods: ['GET', 'POST'],        // Chỉ cho phép method này
  allowedHeaders: ['Content-Type', 'Authorization'], 
  credentials: true                // Cần thiết nếu dùng Cookie/Session
};

app.use(cors(corsOptions));

app.post('/api/data', (req, res) => {
  res.json({ msg: "Dữ liệu an toàn từ server" });
});

app.listen(8080);
```

### Pattern 2: Rate Limiting (Token Bucket Algorithm)

**Khi nào dùng:** Bảo vệ API Login hoặc API tính năng quan trọng khỏi bị spam request.

**Tại sao đúng:** Token Bucket cho phép "dư" một chút (burst) nhưng vẫn hạn chế tổng lượng request trong dài hạn, tránh việc kẻ tấn công tua nhanh window như Fixed Window.

```javascript
// Logic Token Bucket (Pseudo-code có thể áp dụng vào Redis/Memory)
class TokenBucket {
  constructor(capacity, refillRate) {
    this.capacity = capacity;     // Max tokens (e.g., 10)
    this.tokens = capacity;
    this.refillRate = refillRate; // Tokens per second
    this.lastRefill = Date.now();
  }

  consume(tokens = 1) {
    this.refill(); // Cập nhật token trước khi kiểm tra

    if (this.tokens >= tokens) {
      this.tokens -= tokens;
      return true; // Allow
    }
    return false; // Deny
  }

  refill() {
    const now = Date.now();
    const elapsed = (now - this.lastRefill) / 1000; // seconds
    const newTokens = elapsed * this.refillRate;
    
    if (newTokens > 0) {
      this.tokens = Math.min(this.capacity, this.tokens + newTokens);
      this.lastRefill = now;
    }
  }
}

// Usage
const bucket = new TokenBucket(5, 1); // 5 tokens max, refill 1 token/sec

// Middleware check
function rateLimiter(req, res, next) {
  if (bucket.consume()) {
    next();
  } else {
    res.status(429).send("Too Many Requests");
  }
}
```

---

## SECTION 5: ANTI-PATTERNS & WARNINGS

1.  **Setting `Access-Control-Allow-Origin: *` with Credentials**
    *   **Why dangerous:** Nếu server trả lời "Mọi trang web đều được truy cập" (`*`) nhưng lại cho phép gửi Credentials (Cookie, Authorization header), trình duyệt sẽ chặn request ngay lập tức vì lý do bảo mật. Đây là cấu hình sai logic.
    *   **Fix:** Phải set `Access-Control-Allow-Origin` chính xác tên domain, không dùng `*` khi `credentials: true`.

2.  **Ignoring Preflight (OPTIONS) for State-Changing Requests**
    *   **Why dangerous:** Nếu bạn dùng `PUT`, `DELETE`, hoặc custom headers mà không xử lý `OPTIONS`, trình duyệt sẽ không bao giờ gửi request thật. Website sẽ bị "đứng" mà không rõ lý do.
    *   **Fix:** Luôn luôn trả lời HTTP 200 cho request `OPTIONS` với headers CORS đầy đủ.

3.  **Dùng Fixed Window cho Login Brute-force**
    *   **Why dangerous:** Kẻ tấn công có thể chia đều request ra rìa của mỗi giây/phút để vượt quá giới hạn cho phép.
    *   **Fix:** Dùng Token Bucket hoặc Rolling Window.

4.  **Gửi Password qua HTTP**
    *   **Why dangerous:** Dễ dàng bị sniffing.
    *   **Fix:** Luôn dùng HTTPS (TLS) cho mọi traffic có thông tin nhạy cảm.

---

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules to Remember
1.  **HTTPS** = Encryption. Không có nó, mọi thứ đều công khai.
2.  **SOP** là "Chặn". **CORS** là "Mở". SOP chặn read, cho phép embed/write.
3.  **Preflight (OPTIONS)** là bắt buộc cho các request không đơn giản (Simple Request là GET/POST thông thường, không có header tự定义).
4.  **Rate Limit** = Hạn chế tốc độ. Token Bucket tốt hơn Fixed Window cho bài toán "Brute Force".
5.  **CORS Headers** phải khớp chính xác: `Origin` của client phải bằng `Access-Control-Allow-Origin` của server.

### Decision Logic (If-Else)
*   **IF** gửi dữ liệu nhạy cảm (Password, Token) **THEN** Bắt buộc HTTPS.
*   **IF** Frontend gọi API Backend khác domain **THEN** Backend phải set CORS Headers (`Access-Control-Allow-Origin`).
*   **IF** Frontend gọi API Backend có Credentials (Cookie) **THEN** Origin không được là `*`.
*   **IF** Request là `PUT`, `DELETE`, hoặc có `Authorization` header **THEN** Browser sẽ gửi `OPTIONS` trước. Server phải trả lời OK.

<!-- CHUNK 61-63 -->

# DEVELOPER DECISION GUIDE - Web Security: API Authentication (OAuth2)

## SECTION 1: CORE MENTAL MODEL

### Core Definitions
- **OAuth2 (OAuth 2.0 - Giao thức ủy quyền thế hệ 2)**: Giao thức chuẩn cho phép ứng dụng truy cập dữ liệu người dùng trên dịch vụ khác (ví dụ: Google, Facebook) mà không cần chia sẻ mật khẩu.
- **Access Token (Mã truy cập)**: Chuỗi ký tự bí mật dùng để xác thực yêu cầu API thay cho mật khẩu người dùng. Có thời hạn sử dụng (thường ngắn).
- **Authorization Code (Mã ủy quyền)**: Mã tạm thời, một lần sử dụng, được cấp sau khi người dùng đồng ý cấp quyền. Dùng để đổi lấy Access Token.
- **Client ID & Secret (Mã định danh và Bí mật ứng dụng)**: Credentails xác định ứng dụng của bạn với Authorization Server.

### Key Mental Model: "Bảo Tàng (Không Cho Mượn Vé)" - The Valet Key Model
Hãy tưởng tượng bạn đưa chìa khóa xe (Password) cho nhân viên giữ xe (Application). Nếu họ có thể làm mất hoặc đánh cắp xe bạn. OAuth2 hoạt động như hệ thống "Valet Key":
1. Bạn (User) đến quầy tiếp tân (Authorization Server - Google).
2. Bạn trình CMND (Đăng nhập).
3. Tiếp tân in cho bạn một vé giữ xe có mã số (Authorization Code).
4. Nhân viên giữ xe lấy vé này, nộp lại quầy, và nhận chìa khóa phụ (Access Token) chỉ mở được cốp xe và khởi động máy (Quyền hạn hạn chế), không mở được cốp đồ trong xe (Quyền hạn riêng tư).
5. Nhân viên giữ xe dùng chìa khóa phụ để lái xe帮你 làm việc.

**Tại sao cách này tốt hơn?**
- **Bảo mật cao**: Ứng dụng không bao giờ biết hoặc lưu trữ mật khẩu người dùng.
- **Kiểm soát quyền (Scopes)**: Người dùng có thể chỉ cấp quyền "đọc email" thay vì "toàn quyền tài khoản".
- **Thu hồi dễ dàng**: Bạn có thể thu hồi Access Token mà không cần đổi mật khẩu.

## SECTION 2: DECISION TABLES

### Table 1: Chọn Phê duyệt Theo Phê duyệt (Authorization Code) vs Ẩn danh (Implicit)

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Web Server App (Có server backend)** | **Authorization Code Flow** | **Confidential Client (Client Secret an toàn)**. Server có thể lưu trữ bí mật để đổi code lấy token một cách bảo mật. | Dùng Implicit Flow cho Web Server. Dễ lộ Client Secret. |
| **Single Page App (SPA - Chỉ có JS)** | **Authorization Code Flow + PKCE** (Hoặc Implicit nếu không hỗ trợ PKCE) | **Public Client (Không lưu trữ được Secret an toàn)**. PKCE (Proof Key for Code Exchange) chống lại cuộc tấn công trộm code. | Dùng Authorization Code Flow *không* có PKCE. Code bị đánh cắp có thể đổi lấy token. |
| **Mobile App** | **Authorization Code Flow + PKCE** | **Public Client**. PKCE bắt buộc để bảo vệ luồng trao đổi code trên môi trường di động không tin cậy. | Dùng Implicit Flow. Token bị lộ ngay trên URL hoặc log. |

### Table 2: Xác thực (Authentication) vs Ủy quyền (Authorization)

| Tình huống sử dụng | Nên dùng gì | Tại sao | Sai lầm thường gặp |
| :--- | :--- | :--- | :--- |
| **Tôi cần biết người dùng là ai (Login)** | **OpenID Connect (OIDC)** | OIDC là lớp mở rộng của OAuth2. Nó trả về cả Access Token và **ID Token** (Chứa thông tin định danh như email, tên). | Dùng OAuth2 thuần. Cần build thêm logic để phân tích quyền. |
| **Tôi cần cho phép truy cập API (Phân quyền)** | **OAuth2 (Access Token + Scopes)** | Focus vào việc cấp quyền truy cập resource (API) thay vì định danh người dùng. | Không kiểm tra Scope trong API. Cho phép mọi token truy cập mọi endpoint. |

## SECTION 3: ARCHITECTURE & RELATIONSHIPS

### Flow Chart: Authorization Code Flow (Full Stack)

```text
[Browser/App] 
    |
    1. Yêu cầu đăng nhập (Redirect)
    |
    v
[Authorization Server (Google)]
    |
    | 2. Người dùng nhập info
    |
    v
[Browser] <-(3. Redirect với Code: ?code=ABC123)-
    |
    | 4. Gửi Code + Client Secret (POST /token)
    |
    v
[Backend Server (App)]
    |
    | 5. Gửi yêu cầu API (Header: Bearer <Access Token>)
    |
    v
[Resource Server (API)]
    |
    | 6. Phản hồi dữ liệu (Nếu Token hợp lệ & Scope đủ)
    |
    v
[Backend Server]
```

**Lưu ý quan trọng**: Trong luồng này, `Client Secret` chỉ được truyền ở bước 4 (giữa Backend App và Authorization Server), **không bao giờ** qua Browser.

## SECTION 4: CODE PATTERNS

### Pattern 1: Validate Access Token trong API Backend (Node.js/Express)

**Khi nào dùng**: Khi API của bạn nhận request từ Frontend (SPA, Mobile) hoặc Server khác.

**Tại sao đúng**: Phải xác minh token là thật, chưa hết hạn, và do chính server bạn tạo ra trước khi cho phép truy cập dữ liệu.

```javascript
// Middleware xác thực (authMiddleware.js)
const jwt = require('jsonwebtoken'); // Dùng nếu dùng JWT làm Access Token

function authenticateToken(req, res, next) {
    // Lấy token từ Header: Authorization: Bearer <token>
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.sendStatus(401); // Unauthorized
    }

    // Xác minh token (Có thể dùng thư viện hoặc gọi API check introspect của Auth Server)
    jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) => {
        if (err) {
            // Token hết hạn hoặc giả mạo
            return res.sendStatus(403); // Forbidden
        }
        
        req.user = user; // Lưu thông tin user vào request
        next();
    });
}

// Sử dụng trong Route
app.get('/api/data', authenticateToken, (req, res) => {
    res.json({ data: "Secret Data", user: req.user });
});
```

### Pattern 2: Exchange Authorization Code for Access Token (Backend)

**Khi nào dùng**: Sau khi nhận `code` từ Redirect URL của người dùng.

**Tại sao đúng**: Đây là bước duy nhất sử dụng `Client Secret`. Phải thực hiện server-to-server (HTTP Request), không qua trình duyệt.

```javascript
// authController.js
const axios = require('axios');
const querystring = require('querystring');

async function getAccessToken(authCode) {
    const tokenUrl = 'https://oauth2.server.com/token';
    
    const data = {
        grant_type: 'authorization_code',
        code: authCode, // Code nhận được từ Redirect
        client_id: process.env.CLIENT_ID,
        client_secret: process.env.CLIENT_SECRET, // Bảo mật tuyệt đối
        redirect_uri: 'https://yourapp.com/callback'
    };

    try {
        const response = await axios.post(tokenUrl, querystring.stringify(data), {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        
        // Trả về: { access_token: "...", refresh_token: "...", expires_in: 3600 }
        return response.data;
    } catch (error) {
        console.error("Exchange failed:", error);
        return null;
    }
}
```

## SECTION 5: ANTI-PATTERNS & WARNINGS

### 1. Lưu Access Token trong LocalStorage (LocalStorage Vulnerability)
- **Tại sao nguy hiểm**: LocalStorage có thể truy cập dễ dàng bởi mọi Javascript chạy trên trang (XSS Attack). Hacker chỉ cần inject một đoạn script là lấy được token.
- **Cách đúng**: Lưu trong `HttpOnly Cookie` (không truy cập được qua JS) hoặc dùng **Memory Storage** (biến biến toàn cục, nhưng sẽ bị mất khi refresh).

### 2. Truyền Client Secret qua Frontend (Frontend Secret Exposure)
- **Tại sao nguy hiểm**: `Client Secret` phải là bí mật tuyệt đối. Nếu để trong code HTML/JS của SPA, ai cũng có thể xem source và lấy được. Hacker có thể giả lập ứng dụng bạn.
- **Cách đúng**: `Client Secret` chỉ được nằm ở **Backend Server** (Node.js, Python, Java...). Frontend chỉ giữ `Client ID`.

### 3. Không kiểm tra Redirect URI (Open Redirect)
- **Tại sao nguy hiểm**: Nếu không so khớp chính xác `redirect_uri`, hacker có thể đánh lừa Authorization Server trả token về website của hacker.
- **Cách đúng**: Luôn validate strict `redirect_uri` trùng khớp với URL đã đăng ký trước đó (hardcode hoặc whitelist).

### 4. Gửi Token qua URL Parameter (URL Leakage)
- **Tại sao nguy hiểm**: URL được lưu trong history trình duyệt, logs server, referrer header. Token dễ bị lộ.
- **Cách đúng**: Luôn gửi trong **HTTP Header**: `Authorization: Bearer <token>`.

## SECTION 6: MASTER CHEAT SHEET

### Top 5 Rules OAuth2 Security
1.  **Code Exchange**: Luôn dùng `Authorization Code Flow` cho Server-side. Client Secret không bao giờ ra khỏi Server.
2.  **PKCE**: Bắt buộc cho Mobile/SPA để bảo vệ Code Exchange.
3.  **Storage**: Access Token -> Memory/HttpOnly Cookie. Refresh Token -> HttpOnly Cookie (Secure, SameSite).
4.  **Validation**: Luôn verify signature và `aud` (Audience) của token.
5.  **HTTPS**: Bắt buộc tất cả các bước. Không dùng HTTP.

### Logic Quyết định (If-Else)

*   **Nếu** bạn code Backend (Node, PHP, Java...):
    *   **=>** Dùng **Authorization Code Flow**.
    *   **=>** Giữ `Client Secret` ở Backend.
    *   **=>** Lưu Token trong Session/Cookie.

*   **Nếu** bạn code SPA (React, Angular, VueJS):
    *   **=>** Dùng **Authorization Code Flow + PKCE** (nếu có thể).
    *   **=>** Chỉ giữ `Client ID`. Không giữ Secret.
    *   **=>** Lưu Token trong Memory hoặc HttpOnly Cookie (nếu Backend set cookie).

*   **Nếu** bạn thấy Token trong URL (`#access_token=...`):
    *   **=>** **NGUY HIỂM**. Dừng lại, thiết kế lại luồng.