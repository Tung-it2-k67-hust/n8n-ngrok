# DEVELOPER DECISION GUIDE: it4735_iot_va_ung_dung_v2025_16.1m.pdf

> Generated by OpenRouter (xiaomi/mimo-v2-flash:free) on 2026-01-12 13:38:32



<!-- SECTION 3-4 -->

## IoT (pages 3-4)

**Global Section Summary: IoT**

Mục tiêu chính của phần này là cung cấp cái nhìn tổng quan toàn diện về IoT, từ kiến trúc, công nghệ đến quá trình phát triển và bảo mật hệ thống.

-   **Khái niệm cốt lõi:**
    *   Kiến trúc và mô hình phân lớp IoT.
    *   Các thành phần hệ thống (cảm biến, thiết bị, truyền thông, đám mây).
    *   Giao thức truyền thông và lập trình ứng dụng.
    *   Vấn đề an toàn, bảo mật và thiết kế hệ thống.
-   **Phụ thuộc:** Không có phụ thuộc chuyên sâu, là phần giới thiệu nền tảng.
-   **Từ khoá:** IoT, Architecture (Kiến trúc), Sensors (Cảm biến), Cloud (Đám mây), Protocols (Giao thức), Programming (Lập trình), Security (Bảo mật).



<!-- CHUNK 3-4 -->

# DEVELOPER DECISION GUIDE: IoT

## Core Mental Model

Hãy xem IoT là một cơ thể số, bao gồm 4 hệ thống chính:

1.  **Thiết bị (Edge/Device):** "Bộ não" tại chỗ - Thu thập dữ liệu & điều khiển vật lý.
2.  **Mạng truyền dẫn (Gateway/Network):** "Mạch máu" - Đẩy dữ liệu lên Cloud.
3.  **Cloud (Cloud Platform):** "Trung tâm điều khiển" - Phân tích, lưu trữ & xử lý logic phức tạp.
4.  **Người dùng (Application):** "Giao diện tương tác" - Giám sát & ra lệnh.

**Quyết định cốt lõi:** Logic nào chạy ở Edge (nhanh, offline) vs Logic nào chạy ở Cloud (nặng, cần Big Data)?

---

## Decision Tables

### 1. Chọn giao thức truyền thông (Communication Protocol)

| Kịch bản | Tiêu chí | Giao thức đề xuất |
| :--- | :--- | :--- |
| **Nhà thông minh** | Cần cấu hình wifi, băng thông vừa phải, tương thích Router cũ. | **Wi-Fi (802.11)** |
| **Cảm biến công nghiệp** | Pin yếu, khoảng cách xa, xuyên tường, dữ liệu nhỏ. | **LoRaWAN / Zigbee** |
| **Ô tô / Di động** | Cần định vị, băng thông cao, di chuyển tốc độ cao. | **Cellular (4G/5G)** |
| **Tiêu dùng đại trà** | Message nhỏ, publish/subscribe, dùng điện thoại kiểm soát. | **MQTT** |
| **Web API** | Truy cập tài nguyên RESTful từ remote. | **HTTP/HTTPS** |

### 2. Chọn nơi xử lý Logic (Data Processing)

| Phân tích | Edge Processing | Cloud Processing |
| :--- | :--- | :--- |
| **Đặc điểm** | Xử lý tại thiết bị/cổng nối (Gateway). | Xử lý trên Server/VPS. |
| **Lợi thế** | *Low Latency* (trễ thấp), hoạt động được khi mất mạng (*Offline*). | *Scalability* (có thể scale tài nguyên vô hạn), *Storage* (lưu trữ lớn). |
| **Phù hợp** | An toàn sinh học (phát hiện đột nhập ngay lập tức), Cảnh báo lỗi máy móc tức thì. | Phân tích xu hướng dài hạn (Dữ liệu 1 năm), Dashboard tổng hợp, ML/AI. |

---

## Architecture & Components

### Mô hình phân lớp (Layered Architecture)

1.  **Perception Layer (Cảm biến):** Nhiệt độ, Áp suất, Cảm biến chuyển động.
2.  **Network Layer (Truyền thông):** Gửi dữ liệu qua MQTT/HTTP qua Gateway.
3.  **Middleware Layer (Cloud):** IoT Core, Database, Rules Engine.
4.  **Application Layer (App):** Mobile App/Web để xem dữ liệu.

### Các thành phần chính

*   **Sensors (Cảm biến):** Thu thập dữ liệu môi trường. Ví dụ: DHT11 (Nhiệt độ/Độ ẩm).
*   **Actuators (Tác tử):** Thực thi hành động. Ví dụ: Relay (Rơ-le điều khiển đèn).
*   **Gateway (Cổng nối):** Thiết bị trung gian (ESP32, Raspberry Pi) xử lý dữ liệu thô trước khi gửi lên Cloud.

---

## Code Patterns

### Pattern 1: Cấu hình an toàn (Secure Credentials)

Luôn tách biệt thông tin nhạy cảm (Wi-Fi, Broker) ra khỏi code cứng (Hardcode).

```python
# main.py
import network
import json

def load_config():
    # Đọc file config.json để tránh hardcode mật khẩu
    try:
        with open('config.json', 'r') as f:
            return json.load(f)
    except:
        return {"ssid": "MyWifi", "pass": "123456789", "broker": "broker.hivemq.com"}

config = load_config()

# Kết nối Wi-Fi
sta_if = network.WLAN(network.STA_IF)
if not sta_if.isconnected():
    print(f"Connecting to {config['ssid']}...")
    sta_if.active(True)
    sta_if.connect(config['ssid'], config['pass'])
```

### Pattern 2: IoT Mô phỏng (Simulated Device & MQTT)

Mô phỏng một thiết bị sensor gửi dữ liệu lên broker MQTT públic (Thử nghiệm nhanh).

```python
# device_simulator.py (Chạy trên PC hoặc MicroPython)
from umqtt.simple import MQTTClient
import time
import random

# Cấu hình MQTT Broker (Dùng public broker để test)
MQTT_BROKER = "broker.hivemq.com"
CLIENT_ID = "esp32_device_01"
TOPIC = b"home/sensor/temp"

def connect_mqtt():
    client = MQTTClient(CLIENT_ID, MQTT_BROKER)
    client.connect()
    print("Connected to MQTT Broker!")
    return client

def main():
    client = connect_mqtt()
    while True:
        # Giả lập dữ liệu nhiệt độ
        temp = round(random.uniform(25.0, 35.0), 2)
        payload = f"{{\"temp\": {temp}}}"
        
        # Gửi dữ liệu
        client.publish(TOPIC, payload.encode())
        print(f"Sent: {payload} to {TOPIC}")
        
        time.sleep(5) # Gửi mỗi 5 giây

if __name__ == "__main__":
    main()
```

### Pattern 3: Edge Logic (Kiểm tra ngưỡng tại chỗ)

Chỉ gửi cảnh báo lên Cloud khi cần thiết để tiết kiệm pin/băng thông.

```python
# edge_logic.py
MAX_TEMP_THRESHOLD = 50.0

def read_sensor_data():
    # Giả lập đọc cảm biến
    return 52.0 

def check_and_report():
    current_temp = read_sensor_data()
    
    # Logic xử lý tại Edge
    if current_temp > MAX_TEMP_THRESHOLD:
        # Chỉ gửi khi vượt ngưỡng an toàn
        print(f"ALERT: Nóng quá ({current_temp}C) -> Gửi email/SMS ngay!")
        # trigger_publish_mqtt(current_temp)
    else:
        print(f"System Normal: {current_temp}C -> Im lặng.")

check_and_report()
```

---

## Anti-Patterns (Lỗi thiết kế cần tránh)

❌ **Hardcode Credentials:**
Lưu Wi-Fi password hoặc API Key ngay trong file code `.ino` hoặc `.py`. Nếu code bị rò rỉ, hệ thống bị chiếm quyền ngay.
✅ **Fix:** Sử dụng file cấu hình JSON, biến môi trường (Environment Variables) hoặc trang bị bảo mật phần cứng (TPM/Secure Element).

❌ **Trust-All IoT (Không kiểm tra TLS):**
Gửi dữ liệu cảm biến qua HTTP không mã hóa hoặc MQTT không dùng SSL/TLS.
✅ **Fix:** Luôn dùng `MQTT over SSL` (Port 8883) hoặc `HTTPS`. Dữ liệu nhạy cảm bị sniffing rất dễ dàng.

❌ **Keep-Alive Logic (Vòng lặp vô tận):**
Viết vòng lặp `while True` mà không có `try-except` hay `deep-sleep`. Nếu thiết bị lỗi mạng, nó sẽ treo hoặc crash.
✅ **Fix:** Dùng `Watchdog timer` hoặc cơ chế reboot lại nếu mất kết nối quá 5 lần.

❌ **Toàn bộ Logic trên Cloud:**
Đè mọi thứ lên Cloud ngay cả việc bật/tắt công tắc đèn (chỉ vài byte). Nếu mạng lag, đèn sẽ bật chậm 2-3s.
✅ **Fix:** Logic tức thì (Latency < 100ms) phải xử lý ở Edge/Local Network.

---

## Cheat Sheet

*   **MQTT:** Giao thức Publish/Subscribe. Nén nhỏ, phù hợp IoT. (QoS 0: Nhanh, QoS 2: Đảm bảo).
*   **HTTP:** Phù hợp Device yêu cầu/Server trả lời (Request/Response).
*   **CoAP:** Dùng cho thiết bị siêu tiết kiệm năng lượng, thay thế HTTP.
*   **OTA (Over-The-Antenna):** Cập nhật phần mềm từ xa mà không cần cắm cáp.
*   **MQTT Broker:** Server trung gian nhận/đẩy tin nhắn. (Nổi bật: Mosquitto, HiveMQ, AWS IoT Core).
*   **Payload:** Dữ liệu gửi đi. Nên dùng **JSON** (dễ đọc) hoặc **Protobuf** (tiết kiệm dung lượng).



<!-- SECTION 5-15 -->

## Chương 1. Tổng quan về IoT | 1. Pre-Internet: https://en.wikipedia.org/wiki/History_of_the_telephone (pages 5-15)

Global Section Summary

Mục tiêu chính: Cung cấp định nghĩa và tầm nhìn tổng quan về IoT, từ khái niệm cốt lõi đến vai trò và quá trình hình thành.

Khái niệm cốt lõi:
*   IoT là mạng các "vạn vật" (things) có định danh, nhúng phần mềm thông minh, cảm biến và kết nối Internet.
*   Hoạt động: Thiết bị thu thập dữ liệu → IoT Gateway/Edge (phân tích cục bộ) → Cloud → Xử lý/AI → Hành động.
*   Vai trò: Giúp cuộc sống thông minh hơn, tối ưu hóa doanh nghiệp (giám sát real-time, tự động hóa).

Phụ thuộc quan trọng:
*   Không có yêu cầu đọc phần trước. Đây là phần mở đầu (Chương 1).

Từ khoá cần nhớ:
*   IoT (Internet of Things)
*   Sensors (Cảm biến)
*   Identifiers (Định danh)
*   Edge Device
*   IoT Gateway
*   Kevin Ashton
*   M2M (Machine-to-Machine)
*   Digital Twins



<!-- CHUNK 5-15 -->

# DEVELOPER DECISION GUIDE: IoT Fundamentals

## Core Mental Model

IoT là một mạng lưới các "vật thể" (things) có khả năng định danh riêng biệt, nhúng phần mềm thông minh, cảm biến và kết nối Internet liên tục. Mục tiêu chính là thu thập dữ liệu môi trường, xử lý và tự động hóa hành động.

**Quy trình hoạt động cốt lõi (Data Flow):**
1.  **Thu thập (Edge):** Thiết bị IoT/Cảm biến (Sensors) thu thập dữ liệu thô.
2.  **Trung gian (Gateway/Edge):** IoT Gateway hoặc Edge Device đóng vai trò trung tâm, thu thập dữ liệu và phân tích cục bộ (Local Processing) để giảm tải băng thông trước khi gửi lên Cloud.
3.  **Xử lý (Cloud):** Nền tảng đám mây nhận dữ liệu, chạy AI/Machine Learning để tạo ra thông tin chi tiết (Insights).
4.  **Hành động (Action):** Hệ thống tự động kích hoạt thiết bị hoặc gửi thông báo cho con người.

**Phân loại theo mục đích sử dụng:**
*   **IoE (Internet of Everything):** Mối quan hệ giữa Con người (People), Quy trình (Process), Dữ liệu (Data) và Vật thể (Things).
*   **Digital Twins:** Bản sao ảo của một thực thể hoặc quy trình trong thế giới thực, dùng để mô phỏng và phân tích.

---

## Decision Tables (Bảng Quyết Định)

### Lựa chọn Kiến trúc Xử lý Dữ liệu

| Tiêu chí | Cloud-Only (Toàn bộ lên Cloud) | Edge Computing (Phân tích cục bộ) | Hybrid (Lai) |
| :--- | :--- | :--- | :--- |
| **Bandwidth (Băng thông)** | Cao (Gửi liên tục) | Thấp (Chỉ gửi kết quả/tóm tắt) | Trung bình |
| **Latency (Độ trễ)** | Cao (Phụ thuộc mạng) | Siêu thấp (Xử lý tại chỗ) | Thấp |
| **Quyết định** | Khi nào cần phân tích dữ liệu histórico lớn, không cần phản hồi tức thì. | Khi cần phản hồi trong miligiây (VD: Tự động phanh xe, kiểm soát dây chuyền). | Kết hợp cả hai: Cấp báo cáo thời gian thực ở Edge, lưu trữ và học máy ở Cloud. |

### Lựa chọn Giao thức Kết nối (IoT Protocols)

| Giao thức | Ưu điểm | Nhược điểm | Dùng khi nào? |
| :--- | :--- | :--- | :--- |
| **MQTT** | Nhẹ, Publish/Subscribe, xử lý kém kết nối (Lossy network). | Cần Broker trung gian. | **Standard choice** cho hầu hết các bài toán IoT low-bandwidth. |
| **HTTP/REST** | Phổ biến, dễ debug, hỗ trợ bởi mọi thứ. | Cồng kềnh header, overhead lớn, Pull-based (không phù hợp IoT nhiều sensor). | Web dashboard, API gateway cho hệ thống lớn. |
| **CoAP** | Rất nhẹ, dùng cho device resource-constrained. | Phạm vi phủ sóng cộng đồng nhỏ hơn MQTT. | Thiết bị nhúng cực thấp năng lượng (Sensor node). |

---

## Architecture: Components & Flow

Hệ thống IoT tiêu chuẩn bao gồm các thành phần sau:

1.  **Edge Layer (Sensors/Actuators):**
    *   **Sensors:** Cảm biến vật lý (nhiệt độ, ánh sáng...).
    *   **Identifiers:** Định danh duy nhất (MAC address, UUID).
    *   **Hardware:** Microcontroller (ESP32, Arduino), Communication module (Wi-Fi, LoRa, 5G).

2.  **Gateway/Edge Layer:**
    *   Thực hiện **Filtering** (Lọc nhiễu) và **Aggregation** (Tổng hợp dữ liệu).
    *   **Edge Logic:** Chạy các quy tắc "If-Then" đơn giản mà không cần Cloud.

3.  **Network Layer:**
    *   Chuyển dữ liệu từ Edge lên Cloud (Internet).

4.  **Cloud & Application Layer:**
    *   **Data Ingestion:** Nhận dữ liệu (MQTT Broker).
    *   **Database:** Lưu trữ thời gian thực (Time-series DB).
    *   **AI/ML:** Phân tích xu hướng, dự đoán lỗi.
    *   **Dashboard:** Hiển thị cho người dùng.

---

## Code Patterns

### 1. Edge Logic (Phân tích cục bộ)
Tránh việc gửi tất cả dữ liệu thô lên Cloud. Sử dụng Logic nhúng để chỉ gửi khi cần thiết.

```python
# edge_logic.py
class EdgeProcessor:
    def __init__(self, threshold=30.0):
        self.threshold = threshold

    def process_sensor_data(self, raw_value):
        """
        Logic chạy tại Edge/Device.
        Chỉ trả về None (không làm gì) hoặc payload có ý nghĩa.
        """
        if raw_value > self.threshold:
            # Giả lập gửi alert
            return {"status": "CRITICAL", "value": raw_value, "msg": "Overheat"}
        
        # Dữ liệu ổn định, không cần spam Cloud
        return None

# Usage
processor = EdgeProcessor(raw_value=45.5)
result = processor.process_sensor_data(45.5)
if result:
    print(f"Sending to Cloud: {result}")
else:
    print("Normal operation, skip sending.")
```

### 2. Pub/Sub với MQTT (Device Simulator)
Thiết kế để thiết bị kết nối, publish dữ liệu và xử lý lỗi kết nối.

```python
# device_simulator.py (PC hoặc MicroPython)
import paho.mqtt.client as mqtt
import json
import time
import random

class IoTSensorNode:
    def __init__(self, broker, topic):
        self.client = mqtt.Client(client_id="Node_01")
        self.broker = broker
        self.topic = topic
        
        # Attach callbacks
        self.client.on_connect = self.on_connect
        self.client.on_disconnect = self.on_disconnect

    def on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            print("Connected to MQTT Broker!")
        else:
            print(f"Connection failed code: {rc}")

    def on_disconnect(self, client, userdata, rc):
        print(f"Disconnected. Reason code: {rc}")
        # Implement Auto-reconnect logic here

    def run(self):
        self.client.connect(self.broker, 1883, 60)
        self.client.loop_start()
        
        while True:
            # Giả lập dữ liệu cảm biến
            temp = 25 + random.uniform(-2, 2)
            
            # Edge Logic trước khi gửi
            payload = {"sensor_id": "Node_01", "temp": round(temp, 2)}
            
            # Publish (QoS 1 đảm bảo ít nhất 1 lần đến)
            info = self.client.publish(self.topic, json.dumps(payload), qos=1)
            
            # Kiểm tra trạng thái publish (Lưu vào log nếu fail)
            if info.rc != mqtt.MQTT_ERR_SUCCESS:
                print("Failed to send data, buffering required.")
            
            time.sleep(5)

# Chạy thử
# node = IoTSensorNode("broker.emqx.io", "iot/sensor/data")
# node.run()
```

---

## Anti-Patterns (Lỗi thiết kế cần tránh)

1.  **Hardcoded Credentials (Mật khẩu hardcode):**
    *   *Vấn đề:* Đặt pass Wi-Fi/MQTT trực tiếp trong code. Nếu leak source code là mất quyền điều khiển thiết bị.
    *   *Giải pháp:* Sử dụng biến môi trường (Environment Variables) hoặc file cấu hình an toàn được mã hóa.

2.  **No Offline Strategy (Thiếu cơ chế ngoại tuyến):**
    *   *Vấn đề:* Thiết bị chỉ gửi dữ liệu khi kết nối Internet. Khi mất mạng, dữ liệu bị mất vĩnh viễn.
    *   *Giải pháp:* Sử dụng **Queue** (Hàng đợi) bộ nhớ đệm local (Local Buffering) và cơ chế **Store and Forward** (Lưu và Chuyển tiếp) khi kết nối trở lại.

3.  **Polling liên tục (Busy Wait):**
    *   *Vấn đề:* Viết vòng lặp `while True: read_data()` liên tục tốn CPU, pin.
    *   *Giải pháp:* Sử dụng **Interrupt** (Hardware Interrupt) hoặc **Sleep modes** để thiết bị nghỉ ngơi khi không cần làm việc.

---

## Cheat Sheet

*   **MQTT QoS Levels:**
    *   `QoS 0`: Fire and forget (Gửi一次, không đảm bảo).
    *   `QoS 1`: Đảm bảo nhận ít nhất 1 lần (Có thể trùng lặp).
    *   `QoS 2`: Đảm bảo nhận chính xác 1 lần (Đắt tiền về tài nguyên).
*   **IoT Security Checklist:**
    *   Luôn mã hóa dữ liệu (TLS/SSL).
    *   Đặt tên Unique cho Device ID.
    *   Ngắt các Port không cần thiết.
*   **Common Protocols:**
    *   **CoAP:** HTTP-like, dùng cho Ultra-Low Power.
    *   **AMQP:** Dùng cho hệ thống Enterprise message queue phức tạp.
    *   **LWIP:** Lightweight IP cho vi điều khiển (ESP32).



<!-- SECTION 16-38 -->

## Internet (pages 16-38)

**Mục tiêu chính:** Giới thiệu khái niệm IoT, tiến hóa, kiến trúc t tổng quan, các công nghệ nền tảng và lĩnh vực ứng dụng chính.

**Các khái niệm cốt lõi:**
*   **Tiến hóa IoT:** Chuyển từ "Human-to-Things" sang "Things-to-Things" và là yếu tố chính của Cách mạng Công nghiệp 4.0.
*   **Kiến trúc IoT:** Bao gồm các tầng (layered architecture) và 4 trụ cột chính: *Connections, Collection, Computation, Creation*.
*   **Công nghệ IoT:** Bao gồm phần cứng (vi điều khiển, cảm biến, thiết bị đeo), truyền thông (NFC, Bluetooth, WiFi), giao thức (MQTT, CoAP), phân tích dữ liệu và nền tảng đám mây.
*   **Ứng dụng:** Chăm sóc sức khỏe, bán lẻ, nhà thông minh, nông nghiệp và tiện ích.

**Phụ thuộc quan trọng:** Cần hiểu các thành phần phần cứng cơ bản để phân tích kiến trúc hệ thống.

**Từ khóa cần nhớ:**
*   4IR (Cách mạng Công nghiệp 4.0)
*   Cảm biến (Sensors)
*   MQTT/CoAP
*   Nền tảng đám mây (Cloud Platforms)



<!-- CHUNK 16-27 -->

# DEVELOPER DECISION GUIDE: IoT Fundamentals & Architecture

## Core Mental Model

Hệ sinh thái IoT được xây dựng trên 4 trụ cột không thể tách rời, biến đổi dữ liệu vật lý thành giá trị số.

1.  **Connections (Kết nối):** Khả năng giao tiếp của thiết bị (Bluetooth, WiFi, LoRa).
2.  **Collection (Thu thập):** Quá trình hút dữ liệu thô từ các cảm biến (*Sensors*) và thiết bị.
3.  **Computation (Tính toán):** Xử lý dữ liệu tại chỗ (*Edge*) hoặc trên *Cloud Platform*.
4.  **Creation (Sáng tạo):** Tạo ra giá trị mới qua mô hình kinh doanh hoặc tự động hóa (ví dụ: *Things-to-Things* interaction).

**Bối cảnh历史：**
*   **4IR (Cách mạng Công nghiệp 4.0):** IoT là động lực chính, xóa nhòa ranh giới giữa vật lý, kỹ thuật số và sinh học.
*   **Tiến hóa:** Chuyển từ mô hình **Human-to-Things** (con người điều khiển) sang **Things-to-Things** (máy tự động giao tiếp).

---

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Chọn Nền tảng Phần cứng (Hardware)

| Yêu cầu | Vi điều khiển (MCU) | Máy tính nhúng (SBC/OS) |
| :--- | :--- | :--- |
| **Ví dụ thiết bị** | ESP32, Arduino Uno | Raspberry Pi, Intel Galileo |
| **Hệ điều hành** | Không (Bare-metal) hoặc RTOS (FreeRTOS) | Embedded Linux (Raspbian, Ubuntu) |
| **Năng lượng** | Siêu thấp (Battery) | Cao (Cắm nguồn) |
| **Xử lý** | Đơn giản, điều khiển logic | Phức tạp, phân tích dữ liệu nặng |
| **Quyết định khi:** | Thiết bị cảm biến nhỏ, cần pin lâu, chỉ thu thập & gửi dữ liệu (*Collection*). | Cần xử lý ảnh, chạy AI tại biên (*Computation*), hoặc chạy nhiều tiến trình. |

### Bảng 2: Lựa chọn Giao thức Truyền thông (Protocols)

| Giao thức | Đặc điểm | Ideal Use Case |
| :--- | :--- | :--- |
| **MQTT** | Publish/Subscribe, nhẹ, dùng TCP. **QoS** (Chất lượng dịch vụ) tốt. | Hệ thống điều khiển, IoT tổng quát. **Khuyến nghị làm broker:** `broker.emqx.io`. |
| **CoAP** | Giao thức UDP, siêu nhẹ, mô phỏng HTTP. | Thiết bị năng lượng thấp, mạng không ổn định. |
| **NFC/RFID** | Khoảng cách rất ngắn, tap-to-connect. | Thanh toán, kiểm soát truy cập. |
| **WiFi/BLE** | Tốc độ cao, kết nối trực tiếp. | Nhà thông minh, thiết bị đeo. |

---

## Architecture & Components

Kiến trúc IoT phân tầng (Layered Architecture - ITU-T) thường bao gồm:

1.  **Thiết bị/Cảm biến (Device/Sensor Layer):**
    *   **Sensors (Cảm biến):** Bộ phận quan trọng nhất, đầu ra Analog hoặc Digital.
    *   **Embedded Computers:** Thu thập và xử lý tín hiệu ban đầu.
2.  **Mạng/Layer (Network Layer):** Truyền dữ liệu lên trên qua Internet hoặc Intranet (sử dụng MQTT/CoAP).
3.  **Đám mây/Cloud Layer:** Nơi diễn ra *Computation*. Nền tảng lưu trữ và phân tích dữ liệu lớn.
4.  **Ứng dụng/Application Layer:** Trực quan hóa dữ liệu và điều khiển (User Interface).

---

## Code Patterns

Mẫu code sau minh họa quy trình **Collection** (Thu thập) và **Connection** (Kết nối) cơ bản nhất, sử dụng giao thức MQTT - tiêu chuẩn của IoT.

### Pattern: Gửi Dữ liệu Cảm biến lên Cloud (MQTT)

Đây là boilerplate cho một *IoT Sensor Node* chạy trên MicroPython/C++.

```python
from umqtt.simple import MQTTClient
import time
import random

# Cấu hình Connection
BROKER = "broker.emqx.io"  # Public Broker
PORT = 1883
TOPIC = b"iot/sensor/data"
CLIENT_ID = b"device_001"

# Mô phỏng dữ liệu cảm biến (Collection)
def read_sensor():
    # Giả lập nhiệt độ và độ ẩm
    temp = round(random.uniform(25.0, 35.0), 2)
    return temp

def main():
    # 1. Khởi tạo kết nối (Connections)
    client = MQTTClient(CLIENT_ID, BROKER, port=PORT)
    try:
        client.connect()
        print(f"Connected to {BROKER}")
        
        while True:
            # 2. Thu thập dữ liệu (Collection)
            value = read_sensor()
            payload = f'{{"device": "{CLIENT_ID}", "temp": {value}}}'
            
            # 3. Gửi dữ liệu (Computation/Creation start)
            client.publish(TOPIC, payload.encode())
            print(f"Sent: {payload}")
            
            time.sleep(2)
            
    except Exception as e:
        print(f"Error: {e}")
    finally:
        client.disconnect()

if __name__ == "__main__":
    main()
```

---

## Anti-Patterns (Lỗi thiết kế cần tránh)

1.  **Bảo mật="{!!Security!}":**
    *   * sai lầm:* Gửi dữ liệu nhạy cảm qua MQTT không mã hóa (không dùng SSL/TLS) hoặc hardcode mật khẩu WiFi/MQTT trong code nguồn.
    *   *Hậu quả:* Dễ bị đánh cắp dữ liệu hoặc kiểm soát thiết bị trái phép.

2.  **Năng lượng ("Battery Drain"):**
    *   *Sai lầm:* Sử dụng Raspberry Pi (tiêu tốn điện) cho các tác vụ chỉ cần đọc cảm biến đơn giản và gửi 1 giờ/lần.
    *   *Hậu quả:* Thiết bị nhanh hết pin,发热 (nóng), giảm tuổi thọ. Nên dùng ESP32 hoặc MCU 8-bit.

3.  **Tắc nghẽn ("Data Tsunami"):**
    *   *Sai lầm:* Cấu hình cảm biến gửi dữ liệu lên Cloud mỗi giây (High Frequency) mà không cần thiết.
    *   *Hậu quả:* Tốn băng thông mạng, tăng chi phí Cloud (*Computation cost*), quá tải Server.

---

## Cheat Sheet

*   **4IR:** Cuộc cách mạng công nghiệp lần thứ 4, nơi IoT và AI là trung tâm.
*   **Sensors:** Cảm biến ( Analog/Digital ). Là "nguồn cấp dữ liệu" của IoT.
*   **MQTT:** Giao thức Publish/Subscribe tiêu chuẩn để thiết bị giao tiếp với Server (Broker).
*   **CoAP:** Giao thức thay thế MQTT cho thiết bị rất hạn chế về năng lượng.
*   **Cloud Platforms:** Nơi xử lý logic phức tạp (AWS IoT, Azure IoT, hay đơn giản là MQTT Broker public).
*   **Collection → Computation → Creation:** Quy trình giá trị cơ bản của IoT.



<!-- CHUNK 28-38 -->

# DEVELOPER DECISION GUIDE: IoT Fundamentals & Architecture

## Core Mental Model

Hãy hình dung IoT như một hệ thống sinh vật điện tử. Nó không phải là một cỗ máy tĩnh, mà là một dòng chảy liên tục của dữ liệu từ "vật thể" (Thing) lên "đám mây" (Cloud) và ngược lại.

**Mô hình 4 Trụ cột (4 Pillars) quyết định mọi thiết kế IoT:**

1.  **Connections (Kết nối):** Vật thể nói gì và bằng ngôn ngữ nào?
    *   *Thiết bị:* Headsets, Watches (Wearables).
    *   *Nghĩa đen:* Làm sao dữ liệu đi được (Bluetooth, WiFi).
2.  **Collection (Thu thập):** Chúng ta lắng nghe ở đâu?
    *   *Gateway/Edge:* Nơi thu thập hàng loạt cảm biến (Sensors).
3.  **Computation (Tính toán):** Dữ liệu có ý nghĩa gì?
    *   *Cloud:* Phân tích, lưu trữ, xử lý logic phức tạp.
4.  **Creation (Tạo ra):** Hành động được sinh ra là gì?
    *   *Action:* Dashboard, Alert, Tự động hóa (Smart Home).

---

## Decision Tables (Bảng Quyết Định)

Bảng này giúp bạn chọn công nghệ phù hợp dựa trên ngữ cảnh thực tế.

### Bảng 1: Chọn Giao thức Truyền thông (Protocol)

Khi bạn cần gửi dữ liệu từ "Cảm biến" lên "Máy chủ", bạn dùng cái gì?

| Tiêu chí | **MQTT** (Message Queue Telemetry Transport) | **HTTP/REST** | **CoAP** (Constrained App Protocol) |
| :--- | :--- | :--- | :--- |
| **Bối cảnh** | Hệ thống quy mô lớn, cần **Real-time** (Thời gian thực), môi trường không ổn định (như mạng di động yếu). | Web API thông thường, yêu cầu tương tác với web server sẵn có. | Thiết bị **"Ngõng" (Constrained)** - RAM/CPU cực thấp, mạng yếu (LPWAN). |
| **Ưu điểm** | Rất nhẹ, có cơ chế **QoS** (Chất lượng dịch vụ), hỗ trợ **Publish/Subscribe**. | Phổ biến, dễ debug, mọi người đều biết. | Dựa trên REST, tối ưu cho packet nhỏ, tiết kiệm pin. |
| **Nhược điểm** | Cần Broker (Nhà môi giới) ở giữa, hơi phức tạp setup ban đầu. | Nặng nề (Header lớn), tốn pin/băng thông, không có tính năng Push真正 (không cần poll). | Ít tính năng hơn MQTT, ecosystem nhỏ hơn. |
| **Lựa chọn** | **Lựa chọn hàng đầu cho IoT thực thụ.** | Dùng cho Adapter/Proxy hoặc khi device đủ mạnh. | Dùng cho Sensor nodes chạy pin. |

### Bảng 2: Chọn Nền tảng Đám mây (Cloud Platform)

| Tiêu chí | **AWS IoT** | **Google Cloud IoT** | **Azure IoT** |
| :--- | :--- | :--- | :--- |
| **Điểm mạnh** | Ecosystem cực rộng, integrate tốt với AWS Lambda/S3. Phù hợp doanh nghiệp lớn. | Xử lý dữ liệu thời gian thực (Pub/Sub) mạnh, tích hợp AI/ML tốt. | Dễ dùng nếu bạn đã dùng stack Microsoft (Windows, .NET), tích hợp tốt Power BI. |
| **Phù hợp** | Startups cần scale nhanh, Enterprise. | Dữ liệu lớn (Big Data), AI-heavy applications. | Doanh nghiệp có sẵn hạ tầng Microsoft. |

---

## Architecture & Components

Kiến trúc IoT chia làm 3 lớp chính. Lớp nào quyết định tài nguyên nào cần dùng.

1.  **Thiết bị/Cảm biến (Device/Sensor Layer):**
    *   **Hardware:** Vi điều khiển (MCU - ESP32, STM32), Cảm biến (DHT11 - nhiệt độ), Thiết bị đeo (Wearables).
    *   **Logic:** Đọc giá trị thô -> Mã hóa -> Gửi đi.

2.  **Mạng/Trung gian (Network/Gateway Layer):**
    *   **Bridge:** Nối các giao thức khác nhau (Ví dụ: Bluetooth -> MQTT/WiFi).
    *   **Edge Computing:** Xử lý sơ bộ dữ liệu tại đây để giảm tải cho Cloud.

3.  **Đám mây & Ứng dụng (Cloud & Application Layer):**
    *   **IoT Core (Hub):** Nhận hàng triệu kết nối (MQTT).
    *   **Database:** Time-series database (InfluxDB) cho dữ liệu cảm biến.
    *   **Dashboard/Visualizer:** Hiển thị cho người dùng.

---

## Code Patterns

Dưới đây là các mẫu code cơ bản để minh họa luồng giao tiếp.

### Pattern 1: Gửi Dữ liệu Cảm biến qua MQTT (Publish)

Mô hình "Things-to-Things". Một thiết bị gửi dữ liệu nhiệt độ lên Broker.

```python
import paho.mqtt.client as mqtt
import json
import time
import random

# Cấu hình Broker (Connection)
BROKER = "broker.hivemq.com"
PORT = 1883
TOPIC = "iot/sensors/temp"

client = mqtt.Client("Sensor_Node_01")

def on_connect(client, userdata, flags, rc):
    print(f"Kết nối thành công: {rc}")

client.on_connect = on_connect
client.connect(BROKER, PORT, 60)

# Vòng lặp gửi dữ liệu (Collection & Connection)
client.loop_start()
try:
    while True:
        temp = 25 + random.uniform(-2, 2) # Giả lập cảm biến
        payload = {
            "device_id": "ESP32_Kitchen",
            "value": round(temp, 2),
            "timestamp": time.time()
        }
        
        # Publish (Gửi đi)
        client.publish(TOPIC, json.dumps(payload))
        print(f"Đã gửi: {payload}")
        time.sleep(5)
except KeyboardInterrupt:
    client.loop_stop()
```

### Pattern 2: Kiểm tra Logic "Edge" (Nếu/Ngại)

Trước khi gửi lên Cloud, hãy xử lý tại chỗ (Edge). Tránh gửi quá nhiều dữ liệu rác.

```python
# Edge Logic Processing
def process_sensor_data(raw_value, threshold=30):
    """
    Chỉ gửi dữ liệu nếu nó quan trọng (Deviation detection).
    """
    if raw_value > threshold:
        return {"status": "CRITICAL", "value": raw_value, "alert": True}
    elif raw_value > (threshold - 5):
        return {"status": "WARNING", "value": raw_value, "alert": False}
    else:
        return None # Implied: Giữ im lặng, không gửi gì cả (Tiết kiệm năng lượng)

# Ví dụ sử dụng
data = process_sensor_data(32.5)
if data:
    # Gọi hàm MQTT publish ở trên tại đây
    print("Phát hiện bất thường, chuẩn bị gửi Cloud...")
else:
    print("Môi trường ổn định, tiết kiệm pin...")
```

---

## Anti-Patterns (Lỗi thiết kế cần tránh)

1.  **Gửi quá nhiều dữ liệu (Data Flooding):**
    *   *Lỗi:* Đọc cảm biến mỗi giây và gửi lên Cloud ngay lập tức.
    *   *Hậu quả:* Tốn băng thông, nhanh hết pin thiết bị, quá tải Server.
    *   *Khắc phục:* Sử dụng **Batching** (gói dữ liệu) hoặc **Threshold** (chỉ gửi khi thay đổi).

2.  **Bỏ qua QoS (Quality of Service):**
    *   *Lỗi:* Sử dụng MQTT với QoS 0 (gửi một lần, không xác nhận) cho dữ liệu quan trọng.
    *   *Hậu quả:* Mất gói tin giữa đường, dữ liệu bị hổng.
    *   *Khắc phục:* Luôn dùng **QoS 1** (bắt buộc phải nhận) cho các sự kiện quan trọng.

3.  **Bảo mật yếu (Weak Security):**
    *   *Lỗi:* Gửi dữ liệu không mã hóa qua MQTT hoặc dùng default port không bảo mật.
    *   *Hậu quả:* Dễ bị đánh cắp dữ liệu hoặc kiểm soát thiết bị trái phép.
    *   *Khắc phục:* Sử dụng **MQTT over TLS/SSL** (Port 8883), X.509 Certificates cho thiết bị.

---

## Cheat Sheet (Bảng Tóm tắt)

| Thuật ngữ | Giải thích nhanh |
| :--- | :--- |
| **4IR** | Cách mạng Công nghiệp 4.0, nơi IoT đóng vai trò kết nối Vật lý - Kỹ thuật số. |
| **Wearables** | Thiết bị đeo (Ví dụ: Vòng tay, kính thông minh - Head/Glasses/Arm). |
| **MQTT** | Giao thức Publish/Subscribe, **nhẹ nhất**, tốt nhất cho IoT Mobile/IoT yếu. |
| **CoAP** | Giao thức lightweight dạng REST, tốt cho Sensor pin yếu. |
| **HTTP** | Giao thức Web chuẩn, nặng hơn, dùng cho API hoặc Device mạnh. |
| **Gateway** | Thiết bị trung gian (Edge), đổi giao thức (Bluetooth -> WiFi/4G). |
| **IoT Platform** | AWS IoT / Azure IoT / Google Cloud IoT - Nơi chứa Database và Logic Cloud. |
| **Collection** | Quá trình thu thập dữ liệu từ nhiều nguồn cảm biến. |



<!-- SECTION 39-46 -->

## Healthcare (pages 39-46)

**Global Section Summary: Healthcare**

Phần này làm nổi bật vai trò tiên phong của IoT trong lĩnh vực y tế, coi đây là một trong những ngành áp dụng IoT nhanh nhất. Trọng tâm chính là việc sử dụng số lượng lớn cảm biến để theo dõi bệnh nhân, cải thiện quy trình chăm sóc sức khỏe.

*   **Mục tiêu chính:** Trình bày vai trò và tốc độ ứng dụng IoT trong ngành Y tế.
*   **Các khái niệm cốt lõi:**
    *   IoT trong Y tế (Healthcare IoT).
    *   Theo dõi bệnh nhân qua cảm biến (Patient tracking).
*   **Phụ thuộc quan trọng:** Không có thông tin phụ thuộc cụ thể trong phần này.
*   **Từ khóa/Thuật ngữ:** Healthcare, Sensors, Patient tracking.



<!-- CHUNK 39-46 -->

## DEVELOPER DECISION GUIDE: IoT Healthcare Implementation

### Core Mental Model

**Bệnh viện là một "Node System" sinh học.**

Hãy hình dung bệnh viện như một mạng IoT tập trung. Mỗi bệnh nhân được đóng gói成为一个 "Data Stream" thông qua các cảm biến đeo được (wearable sensors). Mục tiêu của lập trình viên là xây dựng các "Edge Gateways" thu thập dữ liệu nhịp tim, SpO2, và vị trí theo thời gian thực để tạo ra các "Alert Triggers" tự động khi giá trị vượt ngưỡng an toàn.

### Decision Tables (Bảng Quyết định)

| Yêu cầu nghiệp vụ | Giải pháp IoT đề xuất | Cấu phần cần thiết (Software/Hardware) |
| :--- | :--- | :--- |
| **Theo dõi liên tục** bệnh nhân có nguy cơ cao (ICU) | **Telemetry Streaming**: Gửi dữ liệu sinh học liên tục lên Cloud/Server. | MQTT Broker (EMQX), Sensor Node (ESP32 + Pulse Sensor), Time-Series DB. |
| **Cảnh báo khẩn cấp** khi bệnh nhân té ngã hoặc ngưng tim | **Edge Processing & Real-time Alert**: Xử lý logic tại Gateway để giảm độ trễ. | Raspberry Pi (Gateway), Logic Handler (Python/Node-RED), SMS/Email API. |
| **Quản lý thiết bị** trong kho (dụng cụ y tế) | **Asset Tracking**: Sử dụng RFID/UWB để định vị thiết bị. | RFID Readers, UWB Tags, Inventory Management Dashboard. |
| **Chẩn đoán từ xa** (Telehealth) | **Bi-directional Communication**: Cho phép bác sĩ tương tác và nhận dữ liệu. | WebRTC (Video), MQTT (Data), Encrypted Storage. |

---

### Architecture Patterns

#### 1. Vital Signs Collection (Thu thập chỉ số sinh tồn)

Mô hình thu thập dữ liệu cảm biến chuẩn từ các node cảm biến bệnh nhân (Patient Sensor Node) gửi về Central Broker.

```python
import time
import random

class PatientSensorNode:
    def __init__(self, broker, topic):
        self.broker = broker
        self.topic = topic
        self.patient_id = "PAT-001"

    def read_vitals(self):
        # Mô phỏng việc đọc cảm biến y tế
        return {
            "heart_rate": random.randint(60, 100),
            "spo2": random.uniform(95, 99),
            "temperature": random.uniform(36.5, 37.5)
        }

    def run(self):
        print(f"[*] Start monitoring patient {self.patient_id} @ {self.broker}")
        while True:
            data = self.read_vitals()
            payload = f"Patient: {self.patient_id}, Data: {data}"
            # Giả lập gửi dữ liệu qua MQTT
            print(f"-> Sending: {payload}")
            time.sleep(5)

# Khởi tạo và chạy node
# node = PatientSensorNode("broker.emqx.io", "healthcare/patient001/vitals")
# node.run()
```

#### 2. Edge Alert Logic (Xử lý biên cảnh báo)

Mô hình xử lý tại cổng (Gateway) để cân bằng tải hệ thống và độ trễ. Logic cảnh báo sẽ chạy tại biên thay vì gửi tất cả dữ liệu thô lên Cloud.

```python
class EdgeHealthcareGateway:
    def __init__(self):
        self.heart_rate_threshold = 120  # Ngưỡng nhịp tim nguy hiểm

    def process_data(self, raw_data):
        # Phân tích dữ liệu ngay tại Edge
        hr = raw_data.get("heart_rate")
        
        if hr > self.heart_rate_threshold:
            return self.trigger_emergency_alert(hr)
        else:
            return "Data normal"

    def trigger_emergency_alert(self, hr):
        # Gửi cảnh báo khẩn cấp tới bác sĩ
        alert_msg = f"CRITICAL: Patient heart rate is {hr} bpm!"
        # Logic gửi SMS/Email sẽ ở đây
        print(f"!!! ALERT TRIGGERED: {alert_msg}")
        return alert_msg

# Sử dụng
gateway = EdgeHealthcareGateway()
incoming_data = {"heart_rate": 135, "spo2": 98}
result = gateway.process_data(incoming_data)
```

---

### Anti-Patterns (Cạm bẫy cần tránh)

1.  **Gửi Dữ Liệu Thô Không Kiểm Soát (Raw Data Flooding):**
    *   *Vấn đề:* Gửi liên tục dữ liệu cảm biến y tế (100Hz) dù không có thay đổi lớn làm nghẽn mạng bệnh viện và tốn kém băng thông Cloud.
    *   *Giải pháp:* Implement **Edge Filtering** hoặc **Delta Update** (chỉ gửi khi giá trị thay đổi > 1%).

2.  **Bỏ Quên An Toàn Dữ Liệu (HIPAA/GDPR Violation):**
    *   *Vấn đề:* Gửi dữ liệu bệnh nhân nhạy cảm qua MQTT không mã hóa (cleartext).
    *   *Giải pháp:* Luôn sử dụng TLS/SSL cho kết nối MQTT (`mqtts://`) và mã hóa payload ở lớp ứng dụng.

3.  **Phụ Thuộc Vào Kết Nối Mạng Cloud:**
    *   *Vấn đề:* Nếu mạng Internet断, thiết bị y tế ngừng hoạt động hoặc không thể kích hoạt cảnh báo cơ bản.
    *   *Giải pháp:* Viết **Local Fallback Logic** (ví dụ: rung/buzzer mạnh khi kết nối Cloud bị mất và ngưỡng sinh tồn bất thường).

---

### Cheat Sheet (Bảng Tóm tắt)

| Thuật ngữ (English) | Giải thích (Tiếng Việt) | Cấu hình/Mã lệnh ví dụ |
| :--- | :--- | :--- |
| **Telemetry** | Dữ liệu遥测 (Dữ liệu cảm biến gửi đi từ xa). | Gửi JSON `{temp: 37}` định kỳ. |
| **Wearable Sensor** | Cảm biến đeo được (Dây đeo tay, cảm biến dán). | Hardware: Fitbit, Holter Monitor. |
| **QoS 1 (MQTT)** | Quality of Service 1 - Đảm bảo nhận ít nhất 1 lần. | **Quan trọng với y tế**: `client.publish(topic, payload, qos=1)`. |
| **Threshold** | Ngưỡng cảnh báo (Giá trị cực đại/ực tiểu cho phép). | `if heart_rate > 120: trigger_alert()`. |
| **Edge Gateway** | Bộ xử lý biên (Nối cảm biến và Cloud). | Raspberry Pi, Industrial IoT Gateway. |

### Code Patterns (Common Snippets)

**Mẫu xử lý Logic An toàn (Safe Logic Wrapper):**
Luôn xử lý lỗi khi đọc cảm biến y tế để tránh crash hệ thống.

```python
def safe_read_sensor():
    try:
        # Thử đọc giá trị từ cảm biến phần cứng
        val = read_hardware_sensor() 
        if val is None or val < 0:
            raise ValueError("Invalid reading")
        return val
    except Exception as e:
        # Log lỗi và trả về giá trị mặc định an toàn hoặc dừng
        print(f"Sensor Error: {e}")
        return None # Hoặc giá trị an toàn để tránh kích hoạt sai cảnh báo
```



<!-- SECTION 47-60 -->

## Transportation (pages 47-60)

**TÓM TẮT MỤC: TRANSPORTATION & IOT TRONG SẢN XUẤT**

Mục tiêu chính: Khám phá ứng dụng IoT trong ngành sản xuất (IIoT) để tối ưu hóa quy trình, tăng cường an toàn và khả năng đáp ứng thị trường, đồng thời chỉ ra các thách thức kỹ thuật và xã hội lớn khi triển khai.

*   **Khái niệm cốt lõi:**
    *   *Intelligent Product:* Tăng cường sản phẩm thông minh.
    *   *Resource Optimization:* Tối ưu hóa tài nguyên, giảm chi phí và rác thải.
    *   *Edge Computing:* Chuyển xử lý dữ liệu ra thiết bị biên để tránh tắc nghẽn.
    *   *IT/OT Convergence:* Hội tụ công nghệ thông tin và vận hành.
*   **Phụ thuộc:** Hiểu các công nghệ IoT cốt lõi (Chương 2) và thiết kế hệ thống (Chương 5) để áp dụng vào sản xuất.
*   **Thuật ngữ cần nhớ:**
    *   *Brownfield deployment:* Triển khai trên hạ tầng cũ.
    *   *IIoT:* Công nghiệp IoT.
    *   *Off-loading:* Chuyển tác vụ xử lý.
    *   *Actionable intelligence:* Thông tin thông minh có thể hành động.



<!-- CHUNK 47-58 -->

# DEVELOPER DECISION GUIDE: IoT Manufacturing & Transportation

## Core Mental Model

Khi xây dựng hệ thống IoT cho sản xuất (IIoT) và giao thông, bạn không chỉ kết nối thiết bị mà đang tạo ra một **hệ thống sinh thái thông minh**. Mục tiêu là biến dữ liệu thô từ các sensor và thiết bị cũ thành **Actionable Intelligence (Thông tin thông minh có thể hành động)**, cho phép tối ưu hóa tài nguyên, tăng cường an toàn và đáp ứng thị trường linh hoạt.

Quan trọng nhất là phải xử lý 3 thách thức lớn:
1.  **Tắc nghẽn dữ liệu (Data Bottlenecks):** Không thể đưa tất cả dữ liệu lên cloud.
2.  **Hạ tầng cũ (Brownfield):** Làm việc với máy móc cũ kỹ.
3.  **Hội tụ IT/OT:** Kết nối thế giới mạng CNTT (IT) và thế giới máy móc công nghiệp (OT).

---

## Decision Tables

### Bảng 1: Phân tích lựa chọn xử lý dữ liệu (Cloud vs Edge)

| Thuộc tính | **Cloud-First** | **Edge Computing (Biên)** | Khi nào chọn? |
| :--- | :--- | :--- | :--- |
| **Độ trễ (Latency)** | Cao (phụ thuộc mạng) | Thấp (xử lý tại chỗ) | Chọn **Edge** cho các tác vụ an toàn khẩn cấp hoặc điều khiển máy móc tức thì. |
| **Băng thông (Bandwidth)** | Tiêu thụ cao | Tiết kiệm | Chọn **Edge** nếu chi phí dữ liệu cao hoặc mạng không ổn định (ví dụ: xe hàng di chuyển). |
| **Complexity** | Đơn giản (máy chủ集中) | Phức tạp (phân tán) | Chọn **Cloud** cho phân tích dài hạn (historical analytics) và model training. |
| **Off-loading (Tải ngoài)** | Ít cần thiết | Bắt buộc | Sử dụng **Edge** để xử lý nhiễu lọc dữ liệu, chỉ gửi cảnh báo quan trọng về server. |

### Bảng 2: Triển khai hệ thống mới (Brownfield vs Greenfield)

| Thuộc tính | **Brownfield Deployment** | **Greenfield Deployment** | Khi nào chọn? |
| :--- | :--- | :--- | :--- |
| **Mô tả** | Tích hợp IoT vào hạ tầng/máy móc đã có sẵn. | Xây dựng hệ thống mới hoàn toàn. | **Brownfield**: Khi bạn đang nâng cấp nhà máy cũ. **Greenfield**: Khi xây dựng nhà máy/in nhà kho thông minh từ đầu. |
| **Thách thức** | **IT/OT Convergence**: Máy cũ dùng giao thức riêng (ví dụ: Modbus), khó kết nối Internet. | Thiết kế toàn diện theo tiêu chuẩn IoT. | Cần giải pháp **Gateway** chuyển đổi giao thức OT thành IT (MQTT/HTTP) cho Brownfield. |
| **Chi phí** | Hợp lý (tận dụng tài sản). | Cao ban đầu. | Chọn Brownfield nếu máy móc vẫn chạy tốt và chỉ cần theo dõi. |

---

## Architecture Patterns

### 1. Mô hình Edge Off-loading (Giảm tải Server)

Áp dụng khi kết nối Server/Client truyền thống bị quá tải do số lượng thiết bị lên tới hàng triệu.

*   **Logic:** "Sưu tầm -> Phân tích -> Gửi". Phân tích cục bộ tại Edge, chỉ gửi dữ liệu tinh gọn.
*   **Ví dụ Code (Python - Mô phỏng Logic Edge):**

```python
import random

class EdgeDevice:
    def __init__(self, threshold=50):
        self.threshold = threshold  # Ngưỡng cảnh báo

    def read_sensor(self):
        # Giả lập đọc dữ liệu thô từ máy móc (OT)
        return random.randint(0, 100)

    def process_locally(self, raw_data):
        # Logic xử lý tại biên (Edge Computing)
        if raw_data > self.threshold:
            return f"WARNING: Value {raw_data} exceeds limit!"
        return None # Dữ liệu thông thường không gửi đi, tiết kiệm băng thông

# Vòng lặp xử lý tại Edge
edge_node = EdgeDevice(threshold=80)
for _ in range(5):
    data = edge_node.read_sensor()
    result = edge_node.process_locally(data)
    if result:
        print(result)  # Chỉ in ra khi có sự kiện quan trọng
```

### 2. Mô hình Tích hợp IT/OT (IT/OT Convergence)

Áp dụng cho Brownfield deployment, nơi máy móc cũ (OT) cần giao tiếp với hệ thống CNTT hiện đại (IT).

*   **Logic:** Cổng giao tiếp (Gateway) thu thập dữ liệu từ máy cũ (dùng giao thức công nghiệp) và chuyển đổi sang giao thức Internet (MQTT) để xử lý IT.
*   **Ví dụ Code (Python - Mô phỏng Gateway):**

```python
import time

class LegacyMachineSimulator:
    # Mô phỏng thiết bị OT cũ (ví dụ: PLC)
    def read_plc_data(self):
        return {"status": "RUNNING", "temp": 65.5, "vibration": 0.2}

class IoTGateway:
    # Chuyển đổi OT -> IT
    def __init__(self, mqtt_client):
        self.mqtt_client = mqtt_client

    def bridge_data(self, ot_data):
        # Transform: Ép kiểu dữ liệu OT thành JSON payload cho IT
        it_payload = {
            "device_id": "factory_machine_01",
            "metrics": ot_data,
            "timestamp": time.time()
        }
        # Gửi qua MQTT (giao thức IT)
        self.mqtt_client.publish("manufacturing/floor01/data", it_payload)
        print(f"[Gateway] Pushed IT payload: {it_payload}")

# Simulation
class MockMQTT:
    def publish(self, topic, payload):
        pass # Giả lập gửi tin

gateway = IoTGateway(MockMQTT())
legacy_machine = LegacyMachineSimulator()

# Quá trình hội tụ: Lấy OT -> Chuyển đổi -> Gửi IT
ot_data = legacy_machine.read_plc_data()
gateway.bridge_data(ot_data)
```

---

## Code Patterns

### Pattern: Xử lý Actionable Intelligence (Trích xuất hành động)

Thách thức: Dữ liệu IoT là "Big Data" nhưng thô. Cần biến nó thành thông tin có thể ra quyết định.

```python
def analyze_production_line(sensor_stream):
    """
    Phân tích luồng dữ liệu thời gian thực để tạo Actionable Intelligence.
    """
    # 1. Lọc nhiễu (Noise reduction)
    clean_data = [x for x in sensor_stream if x > 0]
    
    if not clean_data:
        return "No data detected."

    # 2. Phân tích (Analytics)
    avg_val = sum(clean_data) / len(clean_data)
    
    # 3. Ra quyết định (Actionable)
    if avg_val < 5:
        return "STOP: Production line jammed."
    elif avg_val > 95:
        return "MAINTAIN: Equipment overheating."
    else:
        return "OPTIMIZE: Run normally."

# Dữ liệu cảm biến thô
raw_stream = [10, 0, 0, 12, 98, 11, 0, 5] 
action = analyze_production_line(raw_stream)
print(f"Decision: {action}")
```

---

## Anti-Patterns (Cái bẫy cần tránh)

1.  **"Pipe to Cloud" Anti-Pattern:**
    *   *Hiện tượng:* Mang tất cả dữ liệu thô (Raw Data) từ cảm biến lên Cloud 24/7.
    *   *Hệ quả:* Tắc nghẽn băng thông (Bottleneck), chi phí lưu trữ và xử lý c cực kỳ cao, lag hệ thống.
    *   *Giải pháp:* Luôn áp dụng **Edge Computing** để xử lý và lọc dữ liệu tại nguồn.

2.  **"One-Size-Fits-All" Protocol:**
    *   *Hiện tượng:* Cố gắng dùng chung một giao thức mạng (ví dụ HTTP) cho mọi thiết bị, kể cả thiết bị công nghiệp cũ và cảm biến pin yếu.
    *   *Hệ quả:* Không khả thi về hiệu năng và năng lượng. Cảm biến pin yếu sẽ hết pin nhanh chóng nếu dùng HTTP overhead.
    *   *Giải pháp:* Chấp nhận **Dealing with non-standard communication protocols**. Dùng LoRaWAN cho cảm biến xa, Modbus cho máy cũ, MQTT cho hệ thống chính.

---

## Cheat Sheet (Bảng Tóm tắt)

| Thuật ngữ | Giải thích ngắn gọn | Ví dụ thực tế |
| :--- | :--- | :--- |
| **IIoT** | Industrial IoT. IoT áp dụng trong công nghiệp nặng. | Dò tìm lỗi trên dây chuyền sản xuất xe hơi. |
| **Brownfield** | Triển khai trên hạ tầng/máy móc cũ đã có sẵn. | Lắp sensor IoT vào máy CNC từ năm 2010. |
| **Off-loading** | Chuyển tác vụ xử lý từ server chính sang thiết bị biên. | Cảm biến camera tự nhận diện chướng ngại vật thay vì gửi video về server. |
| **Edge Computing** | Xử lý dữ liệu ngay tại thiết bị/thiết bị biên. | Cổng giao thông tự điều chỉnh đèn đỏ tại ngã tư. |
| **IT/OT Convergence** | Kết hợp hệ thống CNTT (Dữ liệu) và Vận hành (Máy móc). | Dữ liệu sản xuất (OT) được hiển thị realtime trên Dashboard Sales (IT). |
| **Actionable Intelligence** | Dữ liệu được phân tích để đưa ra hành động cụ thể. | Biết nhiệt độ cao -> Tự động tắt máy để tránh cháy nổ. |



<!-- CHUNK 59-60 -->

# DEVELOPER DECISION GUIDE: IoT & Công Nghệ Sản Xuất (IIoT)

**Đối tượng:** Kỹ sư phần mềm, Kiến trúc sư hệ thống và Nhà quản lý kỹ thuật.
**Mục tiêu:** Cung cấp công cụ ra quyết định thực hành để triển khai IIoT trong môi trường sản xuất thực tế, tối ưu từ Edge đến Cloud.

---

## Core Mental Model

Hãy tư duy hệ thống IoT dưới dạng một cơ thể sinh học:

1.  **Cảm Giác (Edge/OT):** Giống như hệ thần kinh ngoại biên. Thu thập dữ liệu thô (Raw Sensor Data) tại nguồn. *Thách thức: Phải xử lý nhanh, chịu môi trường khắc nghiệt.*
2.  **Phản Xạ (Edge Computing):** Giống phản xạ gót chân Achilles. Xử lý tức thời tại chỗ (Off-loading) để ngăn tắc nghẽn và đảm bảo an toàn nhà máy mà không cần hỏi Server.
3.  **Trí Tuệ (IT/Cloud):** Não bộ. Phân tích dữ liệu lớn, tạo Actionable Intelligence (Thông tin có thể hành động) để tối ưu hóa tài nguyên và chuỗi cung ứng.

**Nguyên tắc:** **Brownfield deployment** (triển khai trên hạ tầng cũ) là tiêu chuẩn, không phải ngoại lệ. Hệ thống phải giao tiếp được với máy móc đời cũ.

---

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Xử lý Dữ liệu - Khi nào dùng Edge Computing?

| Tiêu chí | Cloud Processing | **Edge Computing (Ưu tiên)** |
| :--- | :--- | :--- |
| **Thời gian cần thiết (Latency)** | Có thể chấp nhận (phút/giờ) | **Bắt buộc (Miligiây)** (VD: Tự động dừng máy) |
| **Băng thông mạng** | Dồi dào, ổn định | **Hạn chế, không ổn định** (VD: Nông trại/Nhà máy rộng) |
| **Quy mô dữ liệu** | Dữ liệu lịch sử lớn, Training Model | Dữ liệu thời gian thực, Filtering (Lọc nhiễu) |
| **Quy tắc xử lý** | Phân tích sâu, Trending | Logic đơn giản, Cảm biến biên |

> **Quyết định:** Nếu hệ thống yêu cầu **An toàn (Safety)** hoặc **Thời gian thực (Real-time)**, luôn bắt đầu xử lý tại **Edge**.

### Bảng 2: Triển khai - Brownfield (Cũ) vs Greenfield (Mới)

| Phân loại | Brownfield (Triển khai trên cơ sở hạ tầng hiện có) | Greenfield (Xây dựng từ đầu) |
| :--- | :--- | :--- |
| **Đặc điểm** | Máy móc cũ, Controller độc quyền, Giao thức khép kín. | Thiết bị chuẩn IoT, API mở, Mạng có dây/Wi-Fi chuẩn. |
| **Phương pháp** | Sử dụng **Gateway**, Protocol Converter (Biến đổi giao thức), Cảm biến rung/âm thanh ngoài. | Thiết kế hệ sinh thái IoT từ đầu. |
| **Lưu ý** | Phải xử lý **Legacy System** (Hệ thống kế thừa). | Dễ tích hợp nhưng chi phí đầu tư cao. |

---

## Architecture Patterns (Mẫu Kiến Trúc)

### 1. Mẫu "Cánh Tay Robot Biến Đổi" (Brownfield Adapter)

**Vấn đề:** Dây chuyền sản xuất cũ dùng Modbus/RS232, không có kết nối Internet.
**Giải pháp:** Dùng Edge Gateway để "dịch" ngôn ngữ máy cũ sang MQTT (giao thức IoT chuẩn).

**Code Ví dụ (Python - Giả lập Gateway):**
```python
import time
import random
# Giả lập thư viện giao tiếp với thiết bị cũ (Legacy PLC)
def read_legacy_plc():
    return random.randint(0, 100)

# Chuyển đổi dữ liệu cũ sang cấu trúc JSON chuẩn IoT
def transform_to_mqtt_json(raw_data, sensor_id):
    payload = {
        "sensor_id": sensor_id,
        "timestamp": int(time.time()),
        "value": raw_data,
        "unit": "temperature"
    }
    return payload

# Vòng lặp xử lý tại biên (Edge Loop)
while True:
    raw = read_legacy_plc()
    message = transform_to_mqtt_json(raw, "PLC_Line_01")
    # publish(message, topic="factory/sensors")
    print(f"Gateway sending: {message}")
    time.sleep(2)
```

### 2. Mẫu "Tối ưu hóa Tài nguyên" (Resource Optimization)

**Vấn đề:** Giảm rác thải và điện năng tiêu thụ.
**Giải pháp:** Phân tích dữ liệu cảm biến để điều khiển thiết bị (Actionable Intelligence).

**Code Ví dụ (Python - Logic điều khiển thông minh):**
```python
# Dữ liệu nhập vào từ Edge (có thể là Stream)
def analyze_energy_usage(sensor_data):
    threshold = 50.0  # Ngưỡng tiêu hao năng lượng
    
    # Logic "Hành động" (Actionable)
    if sensor_data['power_consumption'] > threshold and sensor_data['production_status'] == 'idle':
        return "STOP_MACHINE" # Tự động tắt máy nếu chạy không tải và tốn năng lượng
    return "KEEP_RUNNING"

# Mô phỏng dữ liệu
data_packet = {"power_consumption": 65.5, "production_status": "idle"}
action = analyze_energy_usage(data_packet)
print(f"Hệ thống quyết định: {action}")
```

---

## Code Patterns (Mã Mẫu)

### Pattern: "Coroutine" (Tiến trình rút gọn) để xử lý song song

**Mục đích:** Xử lý đồng thời việc đọc cảm biến và gửi dữ liệu mà không làm阻塞 (block) hệ thống. Rất quan trọng trong môi trường nhúng/Edge.

```python
import asyncio
import random

async def read_sensor():
    """Giả lập việc đọc cảm biến"""
    await asyncio.sleep(1) # Chờ IO
    return random.randint(20, 30)

async def send_data(data):
    """Giả lập gửi dữ liệu lên Cloud"""
    print(f"Đang gửi dữ liệu: {data}")
    await asyncio.sleep(0.5)
    print("Đã gửi xong!")

async def main():
    while True:
        data = await read_sensor() # Lấy dữ liệu
        await send_data(data)       # Gửi đi ngay lập tức

# Chạy song song
# asyncio.run(main()) 
```

---

## Anti-Patterns (Cái bẫy cần tránh)

1.  **"Gửi tất cả về Server" (The Cloud-Only Trap):**
    *   *Hậu quả:* Nếu mạng mất, nhà máy dừng. Dữ liệu thô (Raw Sensor Data) quá lớn làm nghẽn băng thông.
    *   *Phải làm:* Luôn xử lý logic An toàn và Phản ứng nhanh tại **Edge**.

2.  **"Bảo mật bằng Khoảng cách" (Security by Obscurity):**
    *   *Hậu quả:* Cho rằng mạng OT là "kín" nên không cần bảo vệ.
    *   *Phải làm:* Áp dụng **IT/OT Convergence** (Hội tụ CNTT-Vận hành) – hiểu rằng hacker có thể đột nhập qua IoT Gateway.

3.  **"Mô hình hoàn hảo" (Perfectionist Modeling):**
    *   *Hậu quả:* Dựa quá nhiều vào Digital Twin (Mô hình số) mà quên kiểm tra thực tế trên Brownfield (Hạ tầng cũ).
    *   *Phải làm:* Thu thập **Dữ liệu cảm biến thô** thực tế trước khi mô hình hóa.

---

## Cheat Sheet (Bảng Tóm Tắt Khi Giải Quyết)

*   **Cần độ trễ thấp?** -> **Edge Computing**.
*   **Máy cũ, không kết nối?** -> **Brownfield Gateway (Biến đổi giao thức)**.
*   **Dữ liệu quá lớn?** -> **Lọc/Phân tích tại nguồn, chỉ gửi Metadata/Trend**.
*   **Muốn giảm rác thải?** -> **Tối ưu hóa tài nguyên (Resource Optimization)**.
*   **Muốn sản phẩm giá trị cao?** -> **Intelligent Product (Nâng cao tính năng sản phẩm)**.



<!-- SECTION 61-63 -->

## Chương 2. Các công nghệ IoT (pages 61-63)

**Global Section Summary: Chương 2. Các công nghệ IoT**

Mục tiêu chính là giới thiệu các thành phần công nghệ cốt lõi trong hệ sinh thái IoT, từ phần cứng đến phần mềm và giao thức kết nối.

*   **Các khái niệm cốt lõi:**
    *   **Cảm biến và Thiết bị (Devices):** Đơn vị thu thập dữ liệu vật lý. Đôi khi hai khái niệm này được gộp chung, trong đó cảm biến ghi nhận thay đổi và thiết bị xử lý/gửi dữ liệu.
    *   **Chuẩn truyền thông:** Các giao thức cấp thấp (ví dụ: LPWAN, RFID) dùng để kết nối thiết bị.
    *   **Giao thức ứng dụng:** Các chuẩn giao tiếp (ví dụ: MQTT, CoAP) cho phép thiết bị và ứng dụng trao đổi dữ liệu.
    *   **Nền tảng Cloud:** Hệ thống lưu trữ và xử lý dữ liệu tập trung.

*   **Phụ thuộc quan trọng:** Không có phụ thuộc cụ thể cho phần tóm tắt này, nhưng cần hiểu kiến thức cơ bản về mạng máy tính để nắm sâu các chuẩn truyền thông và giao thức.

*   **Từ khóa cần nhớ:** Cảm biến (Sensors), Thiết bị (Devices), Nền tảng IoT (IoT Platform), Giao thức (Protocols), Cloud.



<!-- CHUNK 61-63 -->

# DEVELOPER DECISION GUIDE: Công Nghệ IoT - Phần Cảm Biến & Thiết Bị

## Core Mental Model (Mô hình Tư duy Cốt lõi)

Hãy tư duy hệ thống IoT như một cơ thể người:
1.  **Cảm biến (Sensors):** Là các cơ quan giác quan (mắt, tai). Chúng chỉ *nhìn* và *nghe* nhưng không thể quyết định.
2.  **Thiết bị (Devices/Gateways):** Là hệ thần kinh trung ương. Chúng nhận tín hiệu giác quan, xử lý sơ bộ và truyền lệnh.
3.  **Cloud:** Là não bộ. Nó chứa logic phức tạp và lưu trữ kiến thức.

**Quy tắc vàng:** *Cảm biến sinh ra dữ liệu thô (Raw Data). Thiết bị biến nó thành thông tin (Information). Cloud biến nó thành tri thức (Knowledge).*

---

## Decision Tables (Bảng Quyết định)

### Bảng 1: Lựa chọn mô hình xử lý

| Tình huống | architectural Pattern (Mẫu Kiến trúc) | Khi nào áp dụng? |
| :--- | :--- | :--- |
| **Thiết bị chỉ có Wi-Fi yếu, yêu cầu phản hồi ngay lập tức** | **Vòng lặp xử lý tại biên (Edge Loop)** | Khi độ trễ (Latency) là tử số. Ví dụ: Robot tự hành tránh va chạm. Không chờ Cloud. |
| **Dữ liệu cảm biến thay đổi liên tục, cần lưu trữ历史历史** | **Dữ liệu nhập vào từ Edge (Stream)** | Khi cần phân tích xu hướng. Ví dụ: Đong đếm điện năng tiêu thụ hàng giờ. Gửi gói tin batch lên Cloud. |
| **Thiết bị cũ (Legacy PLC) không h hỗ trợ MQTT** | **Giả lập thư viện giao tiếp** | Khi bạn không thể thay đổi phần cứng. Cần chuyển đổi tín hiệu analog/Modbus cũ sang JSON. |

### Bảng 2: Phân tích vai trò "Thiết bị"

| Định nghĩa | Phạm vi | Ví dụ thực tế |
| :--- | :--- | :--- |
| **Đơn vị thu thập (Device-only)** | Gửi dữ liệu cảm biến, ít logic. | Cảm biến nhiệt độ Bluetooth đơn năng lượng. |
| **Đơn vị xử lý (Edge Device)** | Thu thập + Rửa dữ liệu (Xử lý JSON) + Gửi Cloud. | Raspberry Pi đọc cảm biến + Chạy Python. |

---

## Architecture (Kiến trúc)

Mô hình luồng dữ liệu chuẩn (Data Flow):

1.  **Physical Layer:** `Sensor` (Analog/Digital) ↔ `Device` (MCU/SoC).
2.  **Processing Layer:** `Device` thực hiện `Data Cleansing` (Rửa dữ liệu) và `Protocol Encoding` (Mã hóa giao thức).
3.  **Transport Layer:** `Device` → `Gateway/Cloud` qua `MQTT/CoAP`.

**Lưu ý quan trọng:** Trong nhiều tài liệu, thuật ngữ **"Thiết bị" (Device)** thường được sử dụng bao trùm cả phần cảm biến. Khi thiết kế API, hãy để `DeviceID` là root identifier, và `SensorID` là child node.

---

## Code Patterns (Mã Mẫu)

Dưới đây là ví dụ về mô phỏng hành động của một "Thiết bị IoT" có cảm biến đi kèm, sử dụng Python để xử lý và chuẩn bị dữ liệu gửi đi.

### Ví dụ 1: Mô phỏng Device & Sensor (Sync)

```python
import random
import time

class Sensor:
    """Đại diện cho cảm biến vật lý"""
    def read_temperature(self):
        # Giả lập reading giá trị nhiệt độ thay đổi
        return round(random.uniform(20.0, 35.0), 2)

class IoTDevice:
    """Đại diện cho thiết bị thu thập (Gateway/Device)"""
    def __init__(self, device_id):
        self.device_id = device_id
        self.sensor = Sensor()  # Ghép cặp Sensor với Device

    def collect_and_package(self):
        # 1. Thu thập dữ liệu thô (Raw Data)
        raw_temp = self.sensor.read_temperature()
        
        # 2. Chuyển đổi sang cấu trúc JSON chuẩn IoT
        payload = {
            "device_id": self.device_id,
            "temp_celsius": raw_temp,
            "status": "normal" if raw_temp < 30.0 else "warning"
        }
        
        # 3. Chuẩn bị gửi đi (Mock send)
        return payload

# Running
smart_meter = IoTDevice(device_id="SN-2024-X")
data_packet = smart_meter.collect_and_package()
print(f"Data Ready to Send: {data_packet}")
```

### Ví dụ 2: Xử lý song song (Asyncio) - Dành cho Edge Loop

Khi thiết bị cần đọc nhiều cảm biến đồng thời hoặc xử lý khi mất kết nối mạng.

```python
import asyncio
import random

async def fetch_sensor_data(sensor_name):
    # Giả lập độ trễ I/O
    await asyncio.sleep(random.uniform(0.1, 0.5))
    return f"{sensor_name}: {random.randint(20, 100)}"

async def edge_loop():
    tasks = [
        fetch_sensor_data("Temp_Sensor"),
        fetch_sensor_data("Humi_Sensor"),
        fetch_sensor_data("Vibration_Sensor")
    ]
    results = await asyncio.gather(*tasks)
    
    # Xử lý logic tại biên (Edge Logic)
    for res in results:
        print(f"[Edge Processing] {res}")

# Chạy vòng lặp xử lý tại biên
if __name__ == "__main__":
    asyncio.run(edge_loop())
```

---

## Anti-Patterns (Cạm bẫy Kỹ thuật)

1.  **Biến Sensor thành Sensor:**
    *   *Lỗi:* Kết nối trực tiếp cảm biến (nếu có thể) vào Cloud mà không qua Gateway/Device xử lý.
    *   *Tác hại:* Tiêu tốn năng lượng, quá tải Cloud với dữ liệu nhiễu (noise), không xử lý được khi mất mạng.
    *   *Sửa:* Luôn có lớp "Device" để tổng hợp và rửa dữ liệu trước.

2.  **Gửi dữ liệu thô (Raw Data) không nén:**
    *   *Lỗi:* Gửi chuỗi bit/byte dài liên tục qua MQTT/HTTP.
    *   *Tác hại:* Tốn băng thông, chi phí 3G/4G cao.
    *   *Sửa:* Sử dụng **JSON** hoặc **Protobuf** để nén struct trước khi gửi.

3.  **Quên cơ chế Offline Buffer (Bộ đệm offline):**
    *   *Lỗi:* Code chỉ xử lý `if connected: send()`.
    *   *Tác hại:* Mất dữ liệu vĩnh viễn khi mất mạng vài giây.
    *   *Sửa:* Luôn có cơ chế lưu vào hàng đợi (Queue) local, gửi lại khi mạng phục hồi.

---

## Cheat Sheet (Bảng Tóm tắt)

*   **Device (Thiết bị):** Chức năng chính là **Thu thập** và **Trung chuyển**.
*   **Sensor (Cảm biến):** Chức năng chính là **Đo lường**.
*   **JSON:** Chuỗi ký tự đại diện cho Object/Sensor Data.
*   **Edge Loop:** Logic chạy trên thiết bị, không cần Cloud.
*   **LPWAN:** Giao thức cho thiết bị pin yếu, truyền dữ liệu xa (LoRaWAN, Sigfox).



<!-- SECTION 64-115 -->

## cloud (pages 64-115)

Dưới đây là bản tóm tắt toàn cục cho phần tài liệu được cung cấp:

**Mục tiêu chính**
Phần này giới thiệu các đặc tính của thiết bị IoT và các tiêu chí kỹ thuật để lựa chọn cảm biến phù hợp cho các hệ thống IoT khác nhau. Nội dung cũng đề cập đến các loại thông tin thiết bị, lệnh điều khiển và các chuẩn truyền thông phổ biến trong mạng IoT.

**Khái niệm cốt lõi**
*   **Đặc tính thiết bị IoT:** Hạn chế tài nguyên tính toán, giao tiếp qua trung gian (BLE), xử lý dữ liệu tại biên (edge).
*   **Tiêu chí lựa chọn cảm biến:** Bao gồm độ bền (Durability), độ chính xác (Accuracy), tính linh hoạt (Versatility), mức tiêu thụ điện năng (Power Consumption) và chi phí (Cost).
*   **Phân loại thông tin:** gồm Metadata (thông tin mô tả), Telemetry (dữ liệu môi trường - chỉ đọc) và State (trạng thái thiết bị - đọc/ghi).
*   **Định nghĩa thiết bị:** Có thể linh hoạt xử lý riêng lẻ từng cảm biến hoặc gom nhóm nhiều cảm biến vào một đơn vị logic.
*   **Chuẩn truyền thông:** Liệt kê các chuẩn phổ biến như NFC, Bluetooth, WiFi, GSM, ZigBee.

**Phụ thuộc quan trọng**
Không có phụ thuộc cụ thể vào các chương/chương trình trước đó trong phần này. Đây là kiến thức nền tảng cho các hệ thống IoT.

**Từ khoá / Thuật ngữ**
*   Telemetry & State information
*   Edge computing / Edge processing
*   Durability, Accuracy, Versatility, Power Consumption
*   Device Metadata
*   Communication Standards (NFC, Bluetooth, WiFi, GSM, ZigBee)



<!-- CHUNK 64-75 -->

# DEVELOPER DECISION GUIDE: IoT Devices & Sensors

## Core Mental Model (Mô hình Tư duy Cốt lõi)

Mô hình này định nghĩa cách tiếp cận khi thiết kế hệ thống IoT tập trung vào đặc tính "biên" (Edge) của thiết bị và dữ liệu.

*   **Edge-First Processing (Xử lý tại Biên):**
    *   Thiết bị IoT thường có tài nguyên hạn chế (CPU/RAM thấp).
    *   **Quyết định:** Luôn cân nhắc việc xử lý/gom gói dữ liệu tại thiết bị trước khi gửi lên Cloud để tiết kiệm băng thông và pin.
    *   *Ví dụ:* Thay vì gửi nhiệt độ mỗi giây, thiết bị chỉ gửi khi nhiệt độ thay đổi > 0.5 độ.

*   **The Data Spectrum (Phổ Dữ liệu):**
    *   Dữ liệu trong IoT không đồng nhất. Bạn cần phân loại rõ ràng trước khi lưu trữ.
    *   **Phân loại:**
        1.  **Metadata:** Thông tin định danh, ít thay đổi (Ví dụ: Serial Number).
        2.  **Telemetry (Dữ liệu遥测):** Dữ liệu môi trường chỉ đọc, có timestamp (Ví dụ: Nhiệt độ hiện tại).
        3.  **State (Trạng thái):** Trạng thái thiết bị, có thể ghi đè/điều khiển (Ví dụ: Đèn đang Bật/Tắt).

*   **The 5-Factor Selection (Tứ tố lựa chọn):**
    *   Việc chọn cảm biến là một sự đánh đổi (Trade-off) giữa 5 yếu tố chính: **Durability** (Độ bền), **Accuracy** (Độ chính xác), **Versatility** (Tính linh hoạt), **Power Consumption** (Tiêu thụ năng lượng), và **Cost** (Chi phí).

---

## Decision Tables (Bảng Quyết định)

### Bảng 1: Lựa chọn Tiêu chí Kỹ thuật (Technical Selection Criteria)

| Yếu tố Tecnical | Kịch bản Ứng dụng | Yêu cầu Đặc tả | Trade-off | Ví dụ điển hình |
| :--- | :--- | :--- | :--- | :--- |
| **Durability** (Độ bền) | Môi trường khắc nghiệt (Ngoài trời, hóa chất) | Chịu nước, chống bụi (IP rating), vật liệu chống ăn mòn | Chi phí cao hơn, kích thước lớn hơn | Cảm biến nhiệt cho trạm thời tiết (Cần IP67) |
| **Accuracy** (Độ chính xác) | Y tế hoặc Công nghiệp chính xác | Sai số cực thấp (±0.2°C) | Đòi hỏi calib phức tạp, giá thành đắt | Cảm biến nhiệt phòng mổ |
| **Versatility** (Tính linh hoạt) | Biến động môi trường cao | Hoạt động trong dải nhiệt/nhiệt độ rộng | Có thể làm giảm độ chính xác tối đa so với cảm biến chuyên dụng | Cảm biến outdoor (Mùa hè/nông đông) |
| **Power Consumption** (Năng lượng) | Thiết bị dùng Pin/Năng lượng mặt trời | Có chế độ Sleep/Wake-up, tiêu thụ nano-ampe khi nghỉ | Tần suất lấy mẫu (Sampling rate) thấp hơn | Cảm biến đo nước nông nghiệp |
| **Cost** (Chi phí) | Hệ thống quy mô lớn (Massive IoT) | Giá thiết bị + chi phí bảo trì/lắp đặt phải thấp | Giảm độ bền hoặc độ chính xác nếu chấp nhận được | Cảm biến Smart Home hàng loạt |

### Bảng 2: Phân loại Dữ liệu & Phân tích (Data Strategy)

| Loại Dữ liệu | Định nghĩa | Quy tắc xử lý | Giao thức/Truy cập |
| :--- | :--- | :--- | :--- |
| **Device Metadata** | Thông tin mô tả cố định (ID, Model, Serial) | Lưu trữ CSDL tham chiếu,很少 (rất ít) khi thay đổi | Đọc một lần khi khởi tạo Device Twin |
| **Telemetry** | Dữ liệu cảm biến (Read-only) | Luôn có timestamp, lưu chuỗi thời gian (Time-series DB), không cho phép ghi đè | Xuất bản (Publish) định kỳ qua MQTT/HTTP |
| **State Information** | Trạng thái hoạt động (On/Off, Error, Mode) | Là mutable data (có thể thay đổi), lưu snapshot trạng thái hiện tại | Cho phép Command/Control (Gửi lệnh từ Cloud) |

---

## Architecture (Kiến trúc)

### Mô hình tương tác Thiết bị - Cloud

Hệ thống IoT tuân theo mô hình **Device Twin (Bản sao ảo thiết bị)** hoặc **Shadow Device**.

1.  **Physical Device (Thiết bị Vật lý):**
    *   Cảm biến phần cứng (Sensor).
    *   Module Vi điều khiển (ESP32, STM32).
    *   Thực thi **Edge Processing**: Lọc nhiễu, gom dữ liệu (Batching).
2.  **Communication Gateway (Cổng trung gian):**
    *   Nếu thiết bị không có WiFi/4G trực tiếp, nó dùng **BLE (Bluetooth Low Energy)** để kết nối Hub.
3.  **Cloud Platform:**
    *   **Device Registry:** Quản lý Metadata (ID, Key).
    *   **Telemetry Pipeline:** Xử lý dòng dữ liệu Sensor.
    *   **Command Interface:** Gửi lệnh điều khiển thay đổi State.

### Flow xử lý tại biên (Edge Processing Flow)

```mermaid
Logic Flow:
Trigger (Timer/Sensor Event) 
   -> Read Raw Data 
   -> [Filter & Normalize] 
   -> [Check Threshold] 
   -> [Queue Buffer] 
   -> [Transmit via Protocol] 
   -> Cloud
```

---

## Code Patterns (Mã Mẫu)

Dưới đây là các mẫu code Python minh họa cho việc xử lý dữ liệu IoT trên thiết bị biên (Edge).

### Pattern 1: Handling Telemetry & State (Xử lý Dữ liệu & Trạng thái)

Mô hình này phân biệt giữa dữ liệu chỉ đọc (Telemetry) và trạng thái điều khiển (State).

```python
import time
import json
import random

class IoTDevice:
    def __init__(self, device_id):
        self.metadata = {
            "id": device_id,
            "model": "TempSensor-v1",
            "location": "Warehouse-A"
        }
        # State là mutable (có thể thay đổi), init mặc định
        self.state = {"status": "idle", "mode": "normal"} 
        self.last_telemetry = {}

    def read_sensor(self):
        # Simulate reading temp (Telemetry - Read only)
        return round(random.uniform(20.0, 30.0), 2)

    def update_state(self, new_mode):
        # State modification (Write/Update)
        if new_mode in ["eco", "normal", "performance"]:
            self.state["mode"] = new_mode
            self.state["status"] = "active"
            print(f"[State Updated] Mode: {self.state['mode']}")

    def pack_telemetry(self):
        temp = self.read_sensor()
        payload = {
            "metadata": self.metadata,
            "telemetry": {
                "temperature": temp,
                "timestamp": int(time.time())
            },
            "state": self.state
        }
        return json.dumps(payload)

# Usage
device = IoTDevice("DEV-001")
print(device.pack_telemetry())

# Cloud sends command to change mode
device.update_state("eco")
```

### Pattern 2: Power Saving Logic (Logic Tiết kiệm Năng lượng)

Minh họa cách xử lý dữ liệu Edge để hạn chế việc truyền dữ liệu (giúp tiết kiệm pin).

```python
import time

class EdgeProcessor:
    def __init__(self, threshold=0.5):
        self.threshold = threshold # Ngưỡng thay đổi
        self.last_sent_value = None

    def process_reading(self, raw_value):
        """
        Chỉ gửi dữ liệu nếu thay đổi đủ lớn (Edge Filtering)
        Giả định: Dữ liệu ẩn danh là 'Telemetry'
        """
        if self.last_sent_value is None:
            # Lần đầu tiên
            self.last_sent_value = raw_value
            return self._transmit(raw_value)
        
        diff = abs(raw_value - self.last_sent_value)
        
        if diff >= self.threshold:
            self.last_sent_value = raw_value
            return self._transmit(raw_value)
        else:
            # Tiết kiệm pin: Không truyền dữ liệu
            print(f"Skip transmission. Change is too small: {diff}")
            return None

    def _transmit(self, value):
        # Giả lập hành động gửi đi (MQTT/HTTP)
        print(f"Transmitting Telemetry: {value}")
        return value

# Simulation
sensor = EdgeProcessor(threshold=1.0)
readings = [20.0, 20.2, 20.8, 21.5, 21.6] # Simulated stream

for r in readings:
    sensor.process_reading(r)
    time.sleep(0.1)
```

---

## Anti-Patterns (Cạm bẫy Kỹ thuật)

### 1. Gửi Dữ Liệu Thô (Raw Data Flooding)
*   **Vấn đề:** Gửi dữ liệu cảm biến thô (Raw) chưa được xử lý lên Cloud quá thường xuyên.
*   **Hậu quả:** Phí băng thông cao, tốn pin (nếu dùng di động), quá tải Cloud.
*   **Giải pháp:** Luôn áp dụng logic **Edge Processing** (lọc, gom gói, chỉ gửi khi cần) trước khi dữ liệu rời thiết bị.

### 2. Bỏ qua Phân loại Dữ liệu (Data Confusion)
*   **Vấn đề:** Xem trạng thái thiết bị (State) và dữ liệu môi trường (Telemetry) là như nhau, hoặc lưu State vào DB chuỗi thời gian (Time-series DB).
*   **Hậu quả:** Khó khăn trong việc điều khiển thiết bị (Vd: không biết lệnh "Bật" có thành công không) và khó truy vấn trạng thái hiện tại.
*   **Giải pháp:** Tách biệt Channel/Topic:
    *   Topic `telemetry/sensor_id` (Chỉ ghi).
    *   Topic `state/setting/device_id` (Đọc/Ghi - Command).

### 3. Chọn sai Durability cho môi trường
*   **Vấn đề:** Dùng cảm biến Indoor cho môi trường Outdoor hoặc hóa chất.
*   **Hậu quả:** Thiết bị hỏng hóc liên tục, chi phí bảo trì (OpEx) vượt quá chi phí thiết bị (CapEx).
*   **Giải pháp:** Luôn ưu tiên **Durability** và **Versatility** (khả năng chịu nhiệt/kháng nước) trước khi xem xét chi phí cho các hệ thống outdoor.

---

## Cheat Sheet (Bảng Tóm Tắt Khi Giải Quyết)

| Khi thiết kế System IoT, hãy hỏi... | Câu trả lời / Hành động |
| :--- | :--- |
| **Môi trường hoạt động là gì?** | Chọn **Durability** (IP rating, vật liệu). Nếu outdoor: Cần IP65+. |
| **Pin hay Điện lưới?** | Nếu là Pin: Kích hoạt **Power Consumption** mode (Sleep/Wake), cân nhắc BLE. |
| **Độ chính xác quan trọng bao nhiêu?** | Chọn **Accuracy**. Y tế/Safety yêu cầu cao, giám sát thường yêu cầu vừa phải. |
| **Dữ liệu có thay đổi theo ngữ cảnh không?** | Nếu có (ví dụ: Cảm biến nước mặn/nước ngọt), cần **Versatility** (Calib linh hoạt). |
| **Làm sao tối ưu chi phí số lượng lớn?** | Xem xét **Cost**. Có thể chấp nhận độ bền/độ chính xác thấp hơn cho các cảm biến dự phòng/thay thế nhanh. |
| **Loại dữ liệu nào đang xử lý?** | Phân loại ngay: **Metadata** (ID), **Telemetry** (Log), **State** (Control). |
| **Kênh truyền thông nào?** | **NFC** (Cận trường), **BLE** (Khoảng ngắn/Thiết bị ít pin), **WiFi/4G** (Tốc độ cao), **ZigBee** (Mạng Mesh). |



<!-- CHUNK 76-87 -->

# Hướng Dẫn Quyết Định Kỹ Thuật cho IoT: Thiết Bị & Chuẩn Truyền Thông

## Core Mental Model (Mô hình Tư duy Cốt lõi)

Hãy tư duy về IoT Devices không chỉ là phần cứng, mà là các **Edge Nodes** (Nút biên) có khả năng xử lý và giao tiếp. Mô hình này xoay quanh việc xác định ranh giới giữa "Device" và "Cloud" để tối ưu hóa chi phí và độ trễ.

1.  **Device Definition (Định nghĩa Thiết bị):**
    *   **Phương pháp 1 (Sensor-centric):** Mỗi cảm biến là một thiết bị độc lập. *Khi nào dùng:* Khi cần độ tin cậy cao, cảm biến nằm rải rác xa nhau, không muốn lỗi một cảm biến ảnh hưởng toàn bộ.
    *   **Phương pháp 2 (Gateway-centric):** Một thiết bị gom dữ liệu nhiều cảm biến, xử lý biên (Edge Processing) trước khi gửi. *Khi nào dùng:* Khi cần tiết kiệm băng thông, giảm chi phí kết nối (1 SIM 4G cho nhiều sensor), hoặc cần tính toán trung bình/tổng hợp tại chỗ.

2.  **Data Classification & Command (Phân loại Dữ liệu & Lệnh):**
    *   **Telemetry (Dữ liệu môi trường - Read-only):** Dữ liệu cảm biến thay đổi liên tục (Nhiệt độ, độ ẩm). Dòng chảy một chiều.
    *   **State (Trạng thái - Read/Write):** Trạng thái có thể thay đổi bởi Cloud (Bật/Tắt đèn, Đóng/Mở c cửa). Yêu cầu phản xạ ngược lại thiết bị.
    *   **Metadata (Siêu dữ liệu):** Thông tin cố định của thiết bị (Serial, Vị trí cài đặt).

3.  **Communication Trade-offs (Trade-off Giao tiếp):**
    *   Việc lựa chọn chuẩn truyền thông là sự đánh đổi giữa **Khoảng cách (Range)**, **Tốc độ (Data Rate)** và **Tiêu thụ điện năng (Power Consumption)**. Ví dụ: Bluetooth Low Energy tốt cho pin nhưng ngắn range; WiFi nhanh nhưng ngốn pin.

---

## Decision Tables (Bảng Quyết định)

### Bảng 1: Lựa chọn Standard Communication dựa trên Use Case

| Tiêu chí / Use Case | NFC | Bluetooth (BLE) | WiFi | ZigBee | GSM (4G/LTE) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Khoảng cách (Range)** | < 20cm (Siêu ngắn) | 1-100m (Ngắn) | ~100m (Trung bình) | 10-100m (Tử ngoại) | Bất kỳ đâu (Toàn cầu) |
| **Tiêu thụ Pin** | Cực thấp | Thấp | Cao | Rất thấp | Cao |
| **Tốc độ dữ liệu** | Thấp (~424 kbps) | Trung bình (1-2 Mbps) | Cao (100+ Mbps) | Thấp (250 kbps) | Rất cao |
| **Ví dụ điển hình** | Thanh toán không tiếp xúc, Tag thông tin | Tai nghe, Tracker sức khỏe, Thiết bị y tế | Camera, Smart Home Hub | Nhà thông minh (Sensor network), Bật tắt đèn | Xe hơi, Asset tracking, Thiết bị không có WiFi |
| **Quyết định khi nào dùng** | Khi cần bảo mật cao, tương tác vật lý | Khi cần kết nối linh hoạt với điện thoại, tiết kiệm pin | Khi cần truyền大量 dữ liệu (ảnh/video) hoặc kết nối có dây ảo | Khi xây dựng mesh network (nhiều thiết bị tự động nối nhau) | Khi thiết bị di chuyển hoặc không có nguồn WiFi ổn định |

### Bảng 2: Chiến lược Lựa chọn Cảm biến (Sensor Selection)

| Tiêu chí | Durability (Độ bền) | Accuracy (Độ chính xác) | Versatility (Tính linh hoạt) | Power Consumption (Tiêu thụ điện) | Cost (Chi phí) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Mô tả** | Khả năng chịu môi trường (nước, bụi, sốc) | Sai số cho phép của dữ liệu | Một cảm biến làm nhiều việc (Ví dụ: Cảm biến 3 trong 1) | Lượng pin/hao tốn khi hoạt động | Giá thành hardware |
| **Quy tắc lựa chọn** | **Cao** nếu đặt ngoài trời/industrial. **Thấp** nếu trong nhà điều hòa. | **Cao** cho thiết bị y tế/nghiên cứu. **Thấp** cho cảnh báo thông thường. | **Cao** nếu muốn tiết kiệm không gian/vật liệu. **Thấp** nếu cần độ ổn định tuyệt đối từng cảm biến riêng lẻ. | **Thấp** nếu dùng pin hoặc năng lượng mặt trời. **Cao** nếu cắm nguồn trực tiếp. | **Thấp** nếu triển khai số lượng lớn (Mass deployment). **Cao** chấp nhận được nếu chỉ vài thiết bị quan trọng. |

---

## Architecture (Kiến trúc)

### Kiến trúc 1: Direct-to-Cloud (Mỗi cảm biến một thiết bị)

*   **Mô tả:** Cảm biến 1 -> WiFi/4G -> Cloud. Cảm biến 2 -> WiFi/4G -> Cloud.
*   **Ưu điểm:** Đơn giản, không cần xử lý trung gian, dễ sửa chữa thay thế.
*   **Nhược điểm:** Quản lý nhiều Device ID, tốn tài nguyên Cloud connection, chi phí SIM/Data cao.
*   **Khi nào dùng:** Hệ thống nhỏ (< 10 thiết bị), cảm biến nằm rải rác không thể kéo dây.

### Kiến trúc 2: Edge Gateway (Thu gom và xử lý tại biên)

*   **Mô tả:** Cảm biến (BLE/ZigBee) -> Gateway (RPi/ESP32) -> Cloud (MQTT/HTTPS).
*   **Ưu điểm:** Tiết kiệm băng thông (gửi 1 lần nhiều data), xử lý logic cục bộ (Ví dụ: Nếu nhiệt độ > 50°C thì tắt van, không cần đợi Cloud), bảo mật tốt hơn (Gateway là bức tường lửa).
*   **Nhược điểm:** Phải code thêm phần mềm cho Gateway, điểm lỗi đơn (Gateway chết là cả cụm sensor offline).
*   **Khi nào dùng:** Hệ thống nhà thông minh, nhà máy, nơi tập trung nhiều cảm biến trong một khu vực.

---

## Code Patterns (Mã Mẫu)

### Pattern 1: Phân loại dữ liệu Telemetry vs State trong JSON Payload

Đây là cấu trúc payload tiêu chuẩn khi gửi lên Cloud để hệ thống backend dễ dàng phân biệt trường dữ liệu chỉ đọc và trường điều khiển.

```json
{
  "metadata": {
    "deviceId": "sensor-room-128",
    "firmwareVersion": "1.2.0",
    "location": "Hallway"
  },
  "telemetry": { // Read-only: Cloud không thể sửa
    "temperature": 24.5,
    "humidity": 60,
    "batteryLevel": 85
  },
  "reportedState": { // Read/Write: Cloud có thể sửa để thay đổi trạng thái
    "lightState": "OFF",
    "valvePosition": "OPEN"
  },
  "timestamp": "2023-10-27T10:00:00Z"
}
```

### Pattern 2: Logic Edge Processing (Thuật toán "Gateway-centric")

Ví dụ code Python chạy trên Gateway (Raspberry Pi) để gom dữ liệu từ 3 cảm biến và chỉ gửi dữ liệu tổng hợp nếu cần thiết, giảm tải network.

```python
import random

def read_sensors():
    # Giả lập đọc dữ liệu từ 3 cảm biến nhiệt độ
    return [random.uniform(20, 25), random.uniform(20, 25), random.uniform(20, 25)]

def edge_processing():
    temps = read_sensors()
    avg_temp = sum(temps) / len(temps)
    
    # Logic tại biên: Chỉ gửi telemetry nếu nhiệt độ trung bình thay đổi > 0.5 độ
    # so với lần gửi trước (giả lập), hoặc gửi định kỳ.
    payload = {
        "deviceId": "gateway-room-128",
        "telemetry": {
            "temp_floor": temps[0],
            "temp_ceiling": temps[1],
            "temp_bedside": temps[2],
            "average_temp": round(avg_temp, 2)
        }
    }
    
    # Giả lập hàm gửi lên Cloud
    print(f"Sending aggregated data: {payload}")

# Chạy
edge_processing()
```

---

## Anti-Patterns (Cạm bẫy Kỹ thuật)

1.  **"Device Sprawl" (Tàn sát Connection):**
    *   *Định nghĩa:* Khi bạn kết nối hàng trăm cảm biến trực tiếp lên Cloud qua HTTP/HTTPS hoặc MQTT không đúng cách.
    *   *Vấn đề:* Cloud Broker (như AWS IoT Core) có giới hạn kết nối (Connection Limit). Mỗi kết nối consume tài nguyên RAM/CPU.
    *   *Giải pháp:* Luôn dùng **Gateway** nếu số lượng thiết bị > 50 hoặc khi dùng giao thức có độ trễ cao.

2.  **"Trusting the Wire" (Niềm tin sai lầm):**
    *   *Định nghĩa:* Gửi dữ liệu Telemetry và Command trên cùng một topic không phân biệt quyền hạn.
    *   *Vấn đề:* Lỗ h hổng bảo mật cho phép hacker gửi lệnh giả mạo (Ví dụ: Gửi payload `{"state": "OPEN"}` vào topic telemetry).
    *   *Giải pháp:* Phân tách topic rõ ràng: `devices/{id}/telemetry` (Chỉ gửi data), `devices/{id}/cmd` (Chỉ nhận lệnh).

3.  **"Heavy Payload on Battery" (Tự sát pin):**
    *   *Định nghĩa:* Gửi metadata cố định (Tên thiết bị, vị trí, model) lặp lại mỗi giây kèm telemetry.
    *   *Vấn đề:* Hao tốn pin và dung lượng truyền dữ liệu không cần thiết.
    *   *Giải pháp:* Chỉ gửi **Delta (Sự thay đổi)** của Telemetry. Metadata chỉ gửi 1 lần khi thiết bị khởi động (Provisioning).

---

## Cheat Sheet (Bảng Tóm Tắt Khi Giải Quyết)

| Hành động | Câu hỏi quyết định | Recommendation |
| :--- | :--- | :--- |
| **Chọn giao thức** | Thiết bị có di chuyển không? Có cần tiết kiệm pin không? | **Có di chuyển/Kém pin:** BLE, ZigBee, GSM. <br>**Có nguồn/cố định/ cần tốc độ:** WiFi, Ethernet. |
| **Định nghĩa Device** | Cần 1 hay nhiều địa chỉ IP/MAC? | **Cần track chi tiết từng vị trí:** 1 Device / Sensor. <br>**Cần xử lý trung bình/tổng hợp:** 1 Device cho nhiều Sensor. |
| **Gửi Command (Lệnh)** | Lệnh yêu cầu phản hồi tức thì hay không? | **Có (Real-time):** Dùng MQTT/QoS 1 (Gửi lại nếu mất kết nối). <br>**Không (Background):** Dùng HTTP POST. |
| **Bảo mật** | Giao tiếp có qua môi trường công cộng? | **Có:** Dùng TLS/SSL (HTTPS/MQTTs). Đặt tên device ngẫu nhiên (UUID), không dùng tên thật. |



<!-- CHUNK 88-99 -->

# Hướng Dẫn Quyết Định Kỹ Thuật: Giao Thức & Tích Hợp Dữ Liệu IoT

## Core Mental Model (Mô hình Tư duy)

Khi thiết kế hệ thống IoT, việc lựa chọn giao thức truyền thông và cách thức trao đổi dữ liệu là then chốt. Mô hình này xoay quanh việc cân bằng giữa **Năng lực tính toán của thiết bị (Device Capability)** và **Yêu cầu của ứng dụng (Application Requirements)**.

1.  **Dữ liệu và Trạng thái (Data & State):**
    *   **Telemetry (Dữ liệu môi trường):** Dữ liệu chỉ đọc (ví dụ: nhiệt độ 25°C). Thường được gửi định kỳ.
    *   **State (Trạng thái thiết bị):** Trạng thái có thể thay đổi (ví dụ: công tắc Bật/Tắt). Cần khả năng đồng bộ và điều khiển hai chiều.
    *   **Metadata:** Thông tin cấu hình/định danh thiết bị.

2.  **Xử lý tại Biên (Edge Computing):**
    *   Thay vì gửi toàn bộ dữ liệu thô lên Cloud, thiết bị IoT có thể xử lý logic đơn giản tại chỗ (Edge Processing) để tiết kiệm băng thông và giảm độ trễ.

3.  **Phương thức Giao tiếp:**
    *   **Giao thức Vận chuyển (Transport):** Chọn dựa trên khoảng cách, tiêu thụ năng lượng (BLE, WiFi, ZigBee).
    *   **Giao thức Ứng dụng (Application):** Chọn dựa trên định dạng dữ liệu và độ tin cậy (HTTP, MQTT).

---

## Decision Tables (Bảng Quyết định)

### Bảng 1: Lựa chọn Chuẩn truyền thông (Physical/Network Layer)

| Tiêu chí | ZigBee | Thread | Bluetooth (BLE) | WiFi | GSM/LTE |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Khoảng cách** | 10-100m (Mesh) | Tốt (Mesh) | Ngắn (<10m) | Trung bình (<50m) | Rộng (Theo vùng phủ sóng) |
| **Tiêu thụ năng lượng** | Thấp | Thấp | Rất thấp | Cao | Rất cao |
| **Tốc độ dữ liệu** | 250 kbps | Tốt | 1-2 Mbps | Cao (Mbps - Gbps) | Cao |
| **Độ phức tạp** | Trung bình | Cao (Dựa trên IP) | Thấp | Trung bình | Cao |
| **Phù hợp cho** | Nhà thông minh, mạng Sensor | Tự động hóa tòa nhà, Smart Home | Thiết bị đeo, kết nối ngắn | Video, Data-heavy apps | Giám sát từ xa, Tracking |

### Bảng 2: Lựa chọn Giao thức Ứng dụng (Application Layer)

| Tiêu chí | HTTP/HTTPS | MQTT | AMQP |
| :--- | :--- | :--- | :--- |
| **Mô hình** | Request-Response (Client-Server) | Publish-Subscribe (Broker-based) | Peer-to-Peer / Queue |
| **Độ trễ** | Cao (Do overhead header, bắt tay TCP) | Thấp (Connection luôn mở) | Trung bình |
| **Độ tin cậy** | Cao (Tồn tại sẵn) | Cao (QoS 0,1,2) | Rất cao (Tương tác doanh nghiệp) |
| **Vốn liếng (Overhead)** | Lớn (Header text-heavy) | Rất nhỏ (Binary, Header tối thiểu) | Trung bình |
| **Phù hợp cho** | Lấy cấu hình, API RESTful, Dashboard | Gửi Telemetry, điều khiển thời gian thực | Tích hợp hệ thống Backend phức tạp |

---

## Architecture (Kiến trúc)

### Kiến trúc "Data Ingestion" tiêu chuẩn (HTTP vs MQTT)

Khi xây dựng hệ thống thu thập dữ liệu, bạn có 2 lựa chọn kiến trúc chính:

1.  **Kiến trúc Web Cổ điển (HTTP/REST):**
    *   **Luồng:** Device -> Gửi GET/POST (Payload trong URL/Body) -> Server -> Xử lý.
    *   **Đặc điểm:** Đơn giản, dễ debug, nhưng thiết bị phải "gọi" server (Polling). Phù hợp khi server cần điều khiển device (Cloud send command).

2.  **Kiến trúc Nhắn tin (MQTT/Event-Driven):**
    *   **Luồng:** Device -> Publish vào Topic (ví dụ: `sensors/temp`) -> Broker -> Subscribers (App/Server) nhận dữ liệu.
    *   **Đặc điểm:** Thiết bị không cần biết Server ở đâu, giảm thiểu traffic (chỉ gửi khi có thay đổi). Phù hợp cho hệ thống quy mô lớn và Sensor mạng điện năng thấp.

---

## Code Patterns (Mẫu Mã)

### Pattern 1: Gửi Telemetry qua HTTP (GET Query String)
Phù hợp cho các thiết bị có năng lực tính toán cơ bản, dữ liệu nhỏ, không cần bảo mật quá cao (nên dùng POST cho bảo mật hơn, nhưng GET phổ biến trong ví dụ đơn giản).

```java
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class HttpTelemetrySender {
    public static void sendTelemetry(String apiKey, int temp, int humidity) {
        try {
            // 1. Xây dựng URL với dữ liệu Telemetry (Field1, Field2)
            // Chú ý: Dùng GET với query params là ví dụ cho đơn giản, thực tế nên dùng POST
            String urlStr = String.format(
                "https://api.thingspeak.com/update?api_key=%s&field1=%d&field2=%d",
                apiKey, temp, humidity
            );

            URL url = new URL(urlStr);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");

            // 2. Đọc phản hồi (Mã 200 là thành công)
            int responseCode = conn.getResponseCode();
            if (responseCode == 200) {
                BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String response = in.readLine(); // ID bản ghi mới trên server
                System.out.println("Data Uploaded. Entry ID: " + response);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        // Giả lập dữ liệu cảm biến
        sendTelemetry("T7H40F0X82VGW7L5", 28, 65); 
    }
}
```

### Pattern 2: Kiểm soát Trạng thái (State Management)
Thiết bị IoT cần xử lý cả việc **nhận lệnh** (Command) từ Cloud (VD: `Cloud sends command to change mode`) và **báo cáo trạng thái** (State) hiện tại.

```java
class IoEDevice {
    String deviceId;
    boolean isOn = false; // State (Trạng thái)

    // Xử lý lệnh từ Cloud (Command)
    public void handleCloudCommand(String command) {
        if ("TURN_ON".equals(command)) {
            this.isOn = true;
            System.out.println("Device State changed: ON");
            // Gửi lại State xác nhận (Telemetry về State)
            reportState(isOn);
        } else if ("TURN_OFF".equals(command)) {
            this.isOn = false;
            System.out.println("Device State changed: OFF");
            reportState(isOn);
        }
    }

    // Báo cáo Telemetry/State về Cloud
    private void reportState(boolean state) {
        // Logic gửi HTTP/MQTT về server với payload: { "state": true }
        System.out.println("Reporting State to Cloud: " + (state ? "ON" : "OFF"));
    }
}
```

---

## Anti-Patterns (Cạm bẫy Kỹ thuật)

1.  **Gửi HTTP Payload quá lớn trong URL (Query String):**
    *   **Vấn đề:** Các ví dụ trong tài liệu sử dụng `GET` với tham số trong URL (`?field1=20&field2=33`).
    *   **Tại sao sai:** URL có giới hạn độ dài (thường ~2000 ký tự). Dữ liệu lớn hoặc phức tạp sẽ bị cắt. Ngoài ra, log server thường ghi lại URL, dễ lộ dữ liệu nhạy cảm.
    *   **Giải pháp:** Sử dụng `POST` với Body (JSON/Protobuf) cho mọi dữ liệu Telemetry hoặc Command có payload.

2.  **Không xử lý lỗi mất kết nối (Flaky Connection):**
    *   **Vấn đề:** IoT môi trường thực tế thường mất mạng (GSM chập chờn, WiFi yếu). Code mẫu chỉ in log và exit.
    *   **Tại sao sai:** Dữ liệu mất trắng, thiết bị không tự phục hồi.
    *   **Giải pháp:** Luôn implement cơ chế **Retry (Thử lại)** với Exponential Backoff và **Local Buffer (Bộ nhớ đệm cục bộ)** để giữ dữ liệu khi mất mạng.

3.  **Mặc định dùng HTTP cho mọi thứ:**
    *   **Vấn đề:** Dùng HTTP cho việc giám sát liên tục (Polling).
    *   **Tại sao sai:** Tiêu tốn pin và băng thông đáng kể do overhead của TCP handshake và HTTP Headers.
    *   **Giải pháp:** Chỉ dùng HTTP để lấy cấu hình ban đầu hoặc API admin. Dùng MQTT cho dữ liệu thời gian thực.

---

## Cheat Sheet (Bảng Tóm tắt)

*   **ZigBee/Thread:** Chọn khi cần **tiêu thụ điện thấp** và mạng **nhiều节点 (Node)** (Mesh Network).
*   **HTTP:** Dùng cho **API cấp cao**, cấu hình device, hoặc device đã có nguồn điện ổn định.
*   **MQTT:** Dùng cho **Telemetry**, thiết bị pin yếu, và điều khiển thời gian thực (Real-time).
*   **Data Types:**
    *   **Telemetry:** Gửi lên (Read-only).
    *   **State:** Đồng bộ 2 chiều (Read/Write).
*   **URL Encoding:** Hạn chế dùng cho dữ liệu lớn; ưa tiên **JSON trong Body POST**.



<!-- CHUNK 100-111 -->

# DEVELOPER DECISION GUIDE: Giao tiếp HTTP & Tích hợp Nền tảng IoT

## Core Mental Model (Mô hình Tư duy)

Hãy tư duy về thiết bị IoT như một **"Nhân viên giao dịch tự động"**:
*   **Vai trò:** Ghi nhận dữ liệu (Telemetry) và chấp nhận mệnh lệnh (Command).
*   **Hành lang giao dịch:** Sử dụng giao thức HTTP tiêu chuẩn (POST/GET) làm ngôn ngữ giao tiếp.
*   **Kho lưu trữ:** Nền tảng IoT (như ThingSpeak/AWS) là nơi tiếp nhận và lưu trữ báo cáo.
*   **Quy tắc vàng:** Luôn đóng gói dữ liệu (Payload) ở định dạng JSON để đảm bảo tính cấu trúc và dễ mở rộng.

---

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Chọn Phương pháp Gửi Dữ Liệu (HTTP POST)

| Tiêu chí | Gửi qua URL Query (`GET`) | Gửi qua Request Body (`POST - JSON`) |
| :--- | :--- | :--- |
| **Bảo mật** | **Kém**: Dữ liệu lộ rõ trên thanh URL, dễ bị log. | **Tốt**: Dữ liệu ẩn trong body, an toàn hơn. |
| **Độ phức tạp** | Đơn giản, phù hợp dữ liệu nhỏ. | Cần đóng gói JSON, nhưng xử lý được cấu trúc dữ liệu phức tạp. |
| **Giới hạn kích thước** | Giới hạn độ dài URL (~2000 ký tự). | Không giới hạn (hoặc rất lớn), phù hợp dữ liệu lớn/mảng. |
| **Khuyến nghị** | Chỉ dùng cho request đơn giản, test nhanh. | **NÊN DÙNG** cho hệ thống sản xuất (Production). |

### Bảng 2: Phân Loại Dữ Liệu IoT (Kiểu "Channel" logic)

| Loại Dữ Liệu | Định nghĩa | Ví dụ | Quyền truy cập |
| :--- | :--- | :--- | :--- |
| **Metadata** | Thông tin mô tả cố định về thiết bị. | Tên model, Phiên bản firmware, Vị trí GPS cố định. | Đọc (Read-only) |
| **Telemetry** | Dữ liệu quan sát, cảm biến (thay đổi liên tục). | Nhiệt độ, độ ẩm, tọa độ GPS thời gian thực. | Đọc (Read-only) |
| **State** | Trạng thái thiết bị có thể thay đổi được. | "Bật/Tắt", "Chế độ Eco", "Ngưỡng cảnh báo". | Đọc/Ghi (Read/Write) |

---

## Architecture (Kiến trúc Giao tiếp)

Trong kiến trúc HTTP-based IoT, luồng tín hiệu diễn ra như sau:

1.  **Device (Sensor Node):** Thu thập `Telemetry`.
2.  **Data Packager:** Biến dữ liệu thô thành chuỗi JSON (Payload).
3.  **Transport Layer (HTTP Client):** Tạo `POST` request đến Cloud API.
4.  **Cloud Endpoint:** Server xử lý và lưu vào Database.
5.  **Cloud to Device (Reverse):** Cloud gửi `Command` (thường là PUT/POST) để thay đổi `State`.

**Mô hình hóa luồng tín hiệu:**
`Sensor -> [Edge Processing] -> JSON Payload -> HTTP POST -> Cloud API -> Database`

---

## Code Patterns (Mẫu Mã)

### Pattern 1: Gửi Telemetry (Dữ liệu Read-only) dạng JSON
Dùng `POST` với `Request Body` để đảm bảo tính toàn vẹn và bảo mật.

```java
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;

public class IotTelemetrySender {
    public static void main(String[] args) {
        try {
            // 1. Thiết lập Endpoint và API Key (Metadata)
            String apiKey = "T7H40F0X82VGW7L5";
            URL url = new URL("https://api.thingspeak.com/update?api_key=" + apiKey);
            
            // 2. Mở kết nối HTTP
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json");
            conn.setDoOutput(true);

            // 3. Đóng gói Telemetry (Field1: Temp, Field2: Humidity)
            String jsonPayload = "{\"field1\": 25.5, \"field2\": 60.0}";
            
            // 4. Gửi dữ liệu
            try (OutputStream os = conn.getOutputStream()) {
                byte[] input = jsonPayload.getBytes(StandardCharsets.UTF_8);
                os.write(input, 0, input.length);
            }

            // 5. Xác nhận (Acknowledgement)
            int responseCode = conn.getResponseCode();
            if (responseCode == 200) {
                System.out.println("Telemetry sent successfully.");
            }
            conn.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### Pattern 2: Gửi Command Request (Ghi State)
Mô phỏng Cloud gửi lệnh xuống Device để thay đổi trạng thái (ví dụ: Bật đèn).

```java
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.DataOutputStream;

public class CloudCommandSender {
    public static void main(String[] args) {
        try {
            // Cloud gọi API của Device để thay đổi State
            String deviceId = "DEVICE_001";
            URL url = new URL("http://device-ip-address/api/control");
            
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST"); // Hoặc PUT
            conn.setRequestProperty("Content-Type", "application/json");
            conn.setDoOutput(true);

            // Payload: Thay đổi State
            String command = "{\"state\": \"ON\", \"mode\": \"Eco\"}";

            try (DataOutputStream wr = new DataOutputStream(conn.getOutputStream())) {
                wr.writeBytes(command);
                wr.flush();
            }

            int status = conn.getResponseCode();
            System.out.println("Command sent. Device Status: " + (status == 200 ? "Applied" : "Failed"));
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

---

## Anti-Patterns (Cạm bẫy Kỹ thuật)

1.  **"The Naked URL Trap" (Lạm dụng Query String):**
    *   *Hành vi:* Gửi dữ liệu cảm biến qua URL `?temp=30&humidity=80`.
    *   *Tại sao sai:* Dễ dàng bị sniffing (nghe trộm), giới hạn ký tự URL, không xử lý được dữ liệu dạng object lồng nhau.
    *   *Khắc phục:* Luôn dùng `POST` với body là JSON payload.

2.  **"Chatty IoT" (Giao tiếp quá thường xuyên):**
    *   *Hành vi:* Gửi request HTTP mỗi giây một lần.
    *   *Tại sao sai:* Device resource (pin) cạn kiệt nhanh, Cloud API bị quá tải (Rate limit).
    *   *Khắc phục:* Sử dụng **Batching** (gom nhóm dữ liệu) hoặc **Edge Processing** (chỉ gửi khi có thay đổi đột biến).

3.  **"Fire and Forget" (Quên kiểm tra Response):**
    *   *Hành vi:* Gửi data xong không kiểm tra HTTP Response Code.
    *   *Tại sao sai:* Nếu server lỗi (500) hoặc API Key sai (403), dữ liệu bị mất trắng mà không có log cảnh báo.
    *   *Khắc phục:* Bắt buộc kiểm tra `responseCode == 200/201` trước khi kết thúc chu kỳ gửi.

---

## Cheat Sheet (Bảng Tóm Tắt Khi Giải Quyết)

*   **Kiểm tra kết nối:**
    *   Ping IP Device -> OK.
    *   Truy cập API manual (Postman/Curl) -> OK.
*   **Kiểm tra Payload:**
    *   Dùng `JSON.stringify()` hoặc thư viện JSON.
    *   Đảm bảo tên trường (field) khớp với định nghĩa trên Cloud.
*   **Kiểm tra Header:**
    *   `Content-Type: application/json` (Bắt buộc).
    *   `Authorization: Bearer <token>` (Nếu dùng xác thực).
*   **Lỗi thường gặp:**
    *   `403 Forbidden`: Sai API Key.
    *   `413 Payload Too Large`: JSON quá kích thước cho phép.
    *   `500 Internal Server Error`: Lỗi xử lý phía Cloud (hoặc format JSON sai).



<!-- CHUNK 112-115 -->

# DEVELOPER DECISION GUIDE: Giao tiếp HTTP & Tích hợp Nền tảng IoT

## Core Mental Model

Hãy tư duy về thiết bị IoT như một **"cửa hàng bưu điện nhỏ"**:
1.  **Thư từ (Data):** Dữ liệu cảm biến (Telemetry) là những bức thư cần gửi đi.
2.  **Địa chỉ (Endpoint):** URL là địa chỉ người nhận.
3.  **Phong bì (Payload):** Giao thức HTTP là phương tiện chuyển phát, JSON là nội dung thư bên trong.
4.  **Biên lai (Response):** Phản hồi từ server là xác nhận đã nhận thư.

Mục tiêu là **gửi dữ liệu một cách tin cậy** với **lượng tài nguyên (pin, băng thông) tối thiểu**.

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Chọn phương thức HTTP Method

| Tình huống ứng dụng | Dữ liệu cần gửi | Phương thức khuyến nghị | Lý do kỹ thuật |
| :--- | :--- | :--- | :--- |
| **Gửi Telemetry định kỳ** | Dữ liệu cảm biến (Nhiệt độ, Độ ẩm) | `GET` (Query Params) | Đơn giản, nhẹ nhàng, dễ caching, phù hợp với các API IoT cơ bản (VD: ThingSpeak). |
| **Gửi Packet lớn / JSON phức tạp** | Log file, Dữ liệu nhiều trường | `POST` (Body) | Hạn chế độ dài URL, bảo mật hơn, hỗ trợ cấu trúc dữ liệu đa cấp (JSON nested). |
| **Cấu hình lại thiết bị** | Lệnh thay đổi trạng thái (On/Off) | `POST` hoặc `PUT` | Khẳng định hành động thay đổi trạng thái (State) trên server. |

### Bảng 2: Xử lý lỗi và Tình trạng mạng

| Mã lỗi HTTP (Status Code) | Ý nghĩa | Hành động của Device (Edge) |
| :--- | :--- | :--- |
| **200 OK** | Thành công | Xóa dữ liệu khỏi bộ nhớ đệm (Buffer), tiếp tục chu kỳ sau. |
| **400 Bad Request** | Dữ liệu gửi sai định dạng | Kiểm tra lại cấu trúc JSON, log lỗi, **không** retry ngay (sửa code mới gửi được). |
| **429 Too Many Requests** | Quá tải API | **Back-off ngay lập tức**: Tăng khoảng thời gian chờ (Exponential Backoff) trước khi retry. |
| **Timeout / 503** | Lỗi mạng / Server bận | Lưu lại dữ liệu vào Queue (Bộ nhớ đệm), retry lại sau (Lưu ý: Thử lại 3 lần thì dừng). |

## Architecture

### Kiến trúc "Device to Cloud" (Direct HTTP)

Phổ biến nhất cho các dự án Proof of Concept (POC) hoặc thiết bị WiFi có nguồn ổn định.

*   **Flow:** Sensor -> MCU (ESP32/Raspberry Pi) -> **HTTP Client** -> Internet -> **Cloud API**.
*   **Ưu điểm:** Dễ triển khai, không cần Gateway trung gian.
*   **Nhược điểm:** Tiêu thụ nhiều pin (do giữ kết nối WiFi), không xử lý được khi mất mạng.

### Kiến trúc "Edge Buffering" (Đệm biên)

Phù hợp thiết bị pin, môi trường mạng không ổn định.

*   **Flow:** Sensor -> MCU -> **Queue/SD Card (Bộ đệm)** -> **HTTP Client** -> Internet.
*   **Logic:**
    *   Nếu mạng tốt: Gửi batch (gói) dữ liệu (VD: 10 mẫu/ lần gửi).
    *   Nếu mạng mất: Tạm ngưng gửi, giữ dữ liệu trong bộ đệm.
*   **Ưu điểm:** Tiết kiệm pin (chỉ bật module Wifi khi cần), đảm bảo không mất dữ liệu (QoS).

## Code Patterns (Mẫu Mã)

### Pattern 1: Gửi JSON qua POST (Cơ bản)
Dùng thư viện `requests` để đóng gói dữ liệu và gửi đi.

```python
import requests
import json
import time

def send_telemetry(api_url, api_key, sensor_data):
    """
    Gửi dữ liệu cảm biến dạng JSON qua HTTP POST.
    sensor_data: dict chứa dữ liệu (VD: {'temp': 25.5, 'humidity': 60})
    """
    # Tạo full URL với API Key (Method ThingSpeak)
    full_url = f"{api_url}?api_key={api_key}"
    
    try:
        # Gửi POST request với body là JSON
        response = requests.post(full_url, json=sensor_data, timeout=5)
        
        # Kiểm tra trạng thái
        if response.status_code == 200:
            print("✅ Gửi thành công:", response.text)
            return True
        else:
            print(f"❌ Lỗi HTTP {response.status_code}: {response.text}")
            return False
            
    except requests.exceptions.RequestException as e:
        print(f"❌ Lỗi kết nối mạng: {e}")
        return False

# Ví dụ sử dụng
data = {"field1": 28.5, "field2": 80}
send_telemetry("https://api.thingspeak.com/update", "YOUR_API_KEY", data)
```

### Pattern 2: Xử lý Backoff (Tự động tái thử)
Mẫu code tăng thời gian chờ khi gặp lỗi mạng, tránh gây sập server.

```python
import time
import random

def send_with_backoff(data, max_retries=3):
    delay = 1  # Bắt đầu với 1 giây
    for attempt in range(max_retries):
        success = try_sending(data) # Giả định hàm gửi HTTP
        if success:
            return True
        
        print(f"Thử lại sau {delay}s... (Lần {attempt + 1})")
        time.sleep(delay)
        delay *= 2  # Tăng gấp đôi thời gian chờ (Exponential backoff)
        
    print("Hết retries. Lưu dữ liệu vào bộ nhớ offline.")
    return False
```

## Anti-patterns (Các sai lầm cần tránh)

1.  **Blocking I/O trong vòng lặp chính (Main Loop):**
    *   *Hành vi:* Gửi HTTP request và đứng yên đợi phản hồi (Blocking).
    *   *Hậu quả:* Cảm biến không thể đọc dữ liệu mới trong khi chờ server phản hồi (mất data thực tế).
    *   *Giải pháp:* Chạy tác vụ gửi HTTP trên một **thread** (luồng) riêng hoặc dùng **Coroutine**.

2.  **Gửi "Chatty" Traffic (Giao tiếp quá nhiều):**
    *   *Hành vi:* Cứ mỗi 1 giây lại gửi 1 request lên server.
    *   *Hậu quả:* Hết pin nhanh chóng, tốn chi phí dữ liệu di động, bị server chặn (Rate Limit).
    *   *Giải pháp:* **Batching**: Gom nhiều mẫu dữ liệu lại rồi gửi 1 lần.

3.  **Không xử lý lỗi Timeout:**
    *   *Hành vi:* Để mặc định timeout vô hạn.
    *   *Hậu quả:* Thread bị treo vĩnh viễn nếu server không phản hồi, thiết bị phải reset.
    *   *Giải pháp:* Luôn đặt `timeout` (VD: 5-10s) trong mọi request.

## Cheat Sheet (Bảng Tóm tắt)

| Thuật ngữ (English) | Thuật ngữ (Tiếng Việt) | Mô tả nhanh |
| :--- | :--- | :--- |
| **Telemetry** | Dữ liệu遥测 (Dữ liệu môi trường) | Dữ liệu chỉ đọc (Read-only), cảm biến gửi lên (VD: 25°C). |
| **Edge Processing** | Xử lý tại biên | Xử lý/Filter dữ liệu ngay trên thiết bị trước khi gửi HTTP. |
| **Endpoint** | Điểm kết thúc | URL nơi nhận dữ liệu (VD: `api.thingspeak.com/update`). |
| **Payload** | Đơn hàng / Payload | Dữ liệu thực tế mang theo request (thường là JSON). |
| **Status Code** | Mã trạng thái | Phản hồi từ server (200=OK, 404=Không tìm thấy). |
| **Exponential Backoff** | Gia số mũ | Chiến thuật chờ tăng dần (1s, 2s, 4s...) khi lỗi mạng. |
| **Batching** | Gói dữ liệu | Gom nhiều mẫu dữ liệu vào 1 lần gửi để tiết kiệm năng lượng. |



<!-- SECTION 116-150 -->

## Lockers | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example | Chương trình MQTT Example – Hàm callback() | Chương trình MQTT Example – Hàm callback() | Chương trình MQTT Example – Hàm callback() | Chương trình MQTT Example – Hàm callback() | Chương trình MQTT Example – Hàm callback() | Chương trình MQTT Example – Dữ liệu json | Chương trình MQTT Example – Dữ liệu json | Chương trình MQTT Example – Dữ liệu json (pages 116-150)

Dưới đây là tóm tắt toàn cầu (Global Section Summary) cho phần tài liệu được cung cấp:

**Mục tiêu chính**
Phần tài liệu này trình bày các phương pháp trao đổi dữ liệu trong IoT, tập trung so sánh và hướng dẫn thực hành giao thức HTTP (REST API) và MQTT cho hệ thống Smart Locker, đồng thời cung cấp công cụ và bài tập thực tế.

**Khái niệm cốt lõi**
*   **Giao thức HTTP:** Sử dụng phương thức `POST` để gửi dữ liệu (mã hóa JSON hoặc URL) và `GET` để nhận dữ liệu, kiểm tra mã trạng thái (Response Codes: 200, 404, 500...).
*   **Giao thức MQTT:** Hoạt động theo mô hình **Publish/Subscribe** (Xuất bản/Theo dõi) thông qua **Broker**, hứa hẹn độ tin cậy cao với băng thông thấp.
*   **Chất lượng dịch vụ (QoS):** Các mức độ đảm bảo giao nhận tin nhắn (QoS 0, 1, 2).

**Phụ thuộc quan trọng**
*   Cần hiểu cơ bản về lập trình mạng và cấu trúc JSON trước khi áp dụng các đoạn code mẫu (Java/Python).
*   Nên làm quen với các khái niệm về API REST trước khi chuyển sang MQTT.

**Từ khoá / Thuật ngữ**
*   **HTTP:** `HttpURLConnection`, `JSONObject`, `Response Code`, `Thingspeak API`.
*   **MQTT:** `Broker`, `Client`, `Topic`, `Publish`, `Subscribe`, `QoS`, `Paho MQTT Client`, `MQTTBox`.



<!-- CHUNK 116-127 -->

# HƯỚNG DẪN QUYẾT ĐỊNH KỸ THUẬT: GIAO TIẾP HTTP & MQTT CHO HỆ THỐNG SMART LOCKER

## Core Mental Model (Mô hình Tư duy)

Lựa chọn giao thức phụ thuộc vào **bối cảnh hệ thống** và **yêu cầu thời gian thực**:

1.  **HTTP (Request/Response):** Tốt nhất cho các tác vụ **không khẩn cấp**, cần độ chính xác cao và tương tác với API chuẩn (REST). Think: "Tôi cần dữ liệu ngay bây giờ hoặc đặt lệnh c cụ thể."
2.  **MQTT (Publish/Subscribe):** Tốt nhất cho **IoT quy mô lớn**, giám sát dữ liệu liên tục, băng thông thấp và cần **độ tin cậy cao** (QoS). Think: "Các thiết bị tự động report trạng thái về mà không cần hỏi."

---

## Decision Tables (Bảng Quyết định)

| Tiêu chí lựa chọn | HTTP (REST API) | MQTT |
| :--- | :--- | :--- |
| **Mô hình giao tiếp** | **Client-Server** (Gửi yêu cầu → Chờ phản hồi) | **Broker-Centric** (Xuất bản/Tiếp nhận qua Trung gian) |
| **Độ trễ & Real-time** | Cao hơn (do overhead header, bắt tay TCP) | Thấp hơn, rất tốt cho Event-driven |
| **Băng thông** | Lớn (Header HTTP nặng) | Rất thấp (Header chỉ 2 byte) |
| **Xử lý ngắt quãng mạng** | Kém (Yêu cầu bị mất nếu mất kết nối) | **Tốt** (QoS 1, 2 đảm bảo giao nhận lại) |
| **Phù hợp nhất cho** | Cấu hình thiết bị, App mobile, Web dashboard | Cảm biến, Locker controller, Hệ thống báo động |

### Chi tiết về QoS trong MQTT (Quan trọng)

*   **QoS 0 (At most once):** Gửi một lần, không xác nhận. (Nhanh nhưng dễ mất).
*   **QoS 1 (At least once):** Gửi lại nếu không nhận được ACK. (Đảm bảo đến nơi, có thể trùng lặp).
*   **QoS 2 (Exactly once):** Trao đổi 4 bước để đảm bảo duy nhất 1 lần. (Chắc chắn nhất, chậm nhất).

---

## Architecture (Kiến trúc Giao tiếp)

### 1. Kiến trúc HTTP cho Smart Locker
Dữ liệu đi thẳng từ Client (Android/ATmega) đến Server.

```mermaid
[Device/Client] --(POST/GET JSON)--> [Server API] --(Xử lý)--> [Database]
```

*   **Ứng dụng:** Người dùng App quét QR → Gửi HTTP POST → Server kiểm tra → Mở Locker.

### 2. Kiến trúc MQTT cho Smart Locker
Có lớp Broker trung gian, giảm tải cho Server chính.

```mermaid
[Locker Controller] --(Publish Status)--> [MQTT Broker] <--(Subscribe)--> [Monitoring Server]
[Admin App] --(Publish Command)--> [MQTT Broker] --> [Locker Controller]
```

*   **Ứng dụng:** Locker tự động report "Cửa đã mở" lên Broker mà Server không cần poll liên tục.

---

## Code Patterns (Mẫu Mã)

### Pattern 1: HTTP POST với JSON (Java)
Dùng `HttpURLConnection` để gửi dữ liệu RFID/QR Code lên Server.

```java
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import org.json.JSONObject; // Cần thư viện JSON

public String sendLockerData(String apiLink, String devId, String qrValue) {
    String result = "";
    try {
        URL url = new URL(apiLink);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        
        // Cấu hình Request
        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-Type", "application/json; charset=utf-8");
        conn.setDoOutput(true);

        // Tạo JSON Payload
        JSONObject jsonPayload = new JSONObject();
        jsonPayload.put("deviceId", devId);
        jsonPayload.put("qrCodeValue", qrValue);

        // Ghi dữ liệu
        try (OutputStream os = conn.getOutputStream()) {
            byte[] input = jsonPayload.toString().getBytes("utf-8");
            os.write(input, 0, input.length);
        }

        // Đọc Response Code
        int code = conn.getResponseCode();
        if (code == 200) {
            // Đọc dữ liệu trả về
            try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), "utf-8"))) {
                StringBuilder response = new StringBuilder();
                String responseLine;
                while ((responseLine = br.readLine()) != null) {
                    response.append(responseLine.trim());
                }
                result = response.toString();
            }
        } else {
            result = "Error: " + code;
        }
        conn.disconnect();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return result;
}
```

### Pattern 2: MQTT Publish/Subscribe (Python)
Sử dụng thư viện `paho-mqtt`. Ví dụ: Locker Controller gửi trạng thái (Publish) và nhận lệnh mở (Subscribe).

```python
import paho.mqtt.client as mqtt
import json

# Cài đặt Broker
BROKER = "broker.hivemq.com"
PORT = 1883
TOPIC_STATUS = "locker/device/status"
TOPIC_CONTROL = "locker/device/control"

def on_connect(client, userdata, flags, rc):
    print("Connected with result code "+str(rc))
    # Đăng ký nhận lệnh điều khiển
    client.subscribe(TOPIC_CONTROL)

def on_message(client, userdata, msg):
    print(f"Received message on {msg.topic}: {msg.payload.decode()}")
    # Logic xử lý mở khóa tại đây
    if msg.payload.decode() == "OPEN":
        print("Opening Locker...")

# Khởi tạo Client
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect(BROKER, PORT, 60)

# Vòng lặp publish status (Giả lập)
client.loop_start()

import time
while True:
    status_data = {"locker_id": 1, "status": "locked", "battery": "90%"}
    # Publish dữ liệu (QoS 1)
    client.publish(TOPIC_STATUS, json.dumps(status_data), qos=1)
    print("Status sent")
    time.sleep(10)
```

---

## Anti-patterns (Các sai lầm cần tránh)

1.  **Sử dụng HTTP Polling liên tục:**
    *   *Lỗi:* Viết vòng lặp `while(true)` gọi API GET mỗi giây để kiểm tra xem có ai mở cửa không.
    *   *Hậu quả:* Server quá tải, pin thiết bị cạn kiệt, lag hệ thống.
    *   *Khắc phục:* Dùng **MQTT Push** hoặc Webhook.

2.  **Quên xử lý Response Code trong HTTP:**
    *   *Lỗi:* Assume luôn thành công (200 OK).
    *   *Hậu quả:* Dữ liệu bị mất khi Server lỗi 500 hoặc 401 (Unauthorized) nhưng client không hay biết.

3.  **Gửi JSON trong URL (GET Request):**
    *   *Lỗi:* `GET /api?data={"field":1}`.
    *   *Hậu quả:* Dễ bị giới hạn độ dài URL, dữ liệu nhạy cảm bị log trong server history.
    *   *Khắc phục:* Dùng **POST** với dữ liệu trong **Body** cho các request phức tạp.

---

## Cheat Sheet (Bảng tra nhanh)

### HTTP Status Codes (Smart Locker Context)
*   `200 OK`: Yêu cầu thành công, dữ liệu hợp lệ. (Ví dụ: Tìm thấy người dùng, mở khóa).
*   `201 Created`: Tạo mới thành công (Ví dụ: Tạo log truy cập mới).
*   `401 Unauthorized`: Sai API Key hoặc Token.
*   `403 Forbidden`: Hết quyền truy cập (Ví dụ: Card bị blacklist).
*   `404 Not Found`: Device ID không tồn tại.
*   `500 Internal Server Error`: Lỗi Server (Cần kiểm tra log backend).

### MQTT Keywords
*   **Broker:** "Bưu điện" nhận và phát tin nhắn (Ví dụ: HiveMQ, Mosquitto).
*   **Topic:** "Địa chỉ" thư (Ví dụ: `home/livingroom/light`).
*   **Payload:** "Nội dung" thư (Thường là JSON string).
*   **Clean Session:** Xóa toàn bộ lịch sử đăng ký khi Client ngắt kết nối (Nên `True` để tránh rác).



<!-- CHUNK 128-139 -->

# HƯỚNG DẪN QUYẾT ĐỊNH KỸ THUẬT: MQTT CHO HỆ THỐNG SMART LOCKER

Phần tài liệu này tập trung vào việc thực thi giao thức MQTT,דגש vào cấu hình Quality of Service (QoS), sử dụng thư viện Paho MQTT trong Java, và thiết lập kết nối Publish/Subscribe thông qua Broker.

---

## 1. Core Mental Model (Mô hình Tư duy)

Hãy hình dung MQTT như một **hệ thống bưu điện tự động (Pub/Sub)** thay vì điện thoại trực tiếp (HTTP):

1.  **Người gửi (Publisher):** Drop tin nhắn vào hòm thư tại một **địa chỉ cụ thể (Topic)**.
2.  **Bưu điện trung tâm (Broker):** Nhận tin và phân phát cho bất kỳ ai đăng ký nhận thư tại địa chỉ đó.
3.  **Người nhận (Subscriber):** Ngồi đợi tại địa chỉ được đăng ký để nhận thư.

**Điểm khác biệt cốt lõi:** Người gửi không cần biết người nhận là ai, chỉ cần biết địa chỉ (Topic). Điều này giúp hệ thống Smart Locker có thể mở rộng (Scalability) mà không thay đổi mã nguồn của thiết bị.

---

## 2. Decision Tables (Bảng Quyết định)

### Bảng 1: Chọn mức độ đảm bảo tin nhắn (QoS Level)

| Mức QoS | Tên gọi | Đặc điểm | Tình huống ứng dụng (Smart Locker) |
| :--- | :--- | :--- | :--- |
| **QoS 0** | *Fire and Forget* | Gửi 1 lần, không xác nhận. Nhanh nhất, rủi ro mất gói tin cao. | Gửi dữ liệu cảm biến nhiệt độ định kỳ (không quan trọng nếu mất 1-2 gói). |
| **QoS 1** | *At Least Once* | Gửi đến khi nhận được xác nhận (ACK). Có thể nhận trùng tin. | **Trạng thái Locker (Mở/Đóng).** Quan trọng là phải nhận ít nhất 1 lần, có thể xử lý trùng lặp. |
| **QoS 2** | *Exactly Once* | Bắt tay 4 bước để đảm bảo nhận đúng 1 lần. Chậm nhất, tốn tài nguyên. | Lệnh xác nhận thanh toán hoặc mở khóa. Không được phép nhận trùng lệnh. |

---

## 3. Architecture (Kiến trúc Giao tiếp)

Kiến trúc MQTT cho Smart Locker thường bao gồm các thành phần sau:

1.  **Device Client (Locker Controller):**
    *   **Vai trò:** Xuất bản (`Publish`) trạng thái khóa và đăng ký nhận lệnh (`Subscribe`).
    *   **Topic mẫu:** `locker/{id}/status`, `locker/{id}/cmd`
2.  **Cloud Broker (Message Broker):**
    *   **Vai trò:** Trung gian chịu trách nhiệm định tuyến tin nhắn.
    *   **Protocol:** TCP/TLS (Port 1883/8883).
3.  **Mobile App / Server Backend:**
    *   **Vai trò:** Theo dõi (`Subscribe`) trạng thái và gửi lệnh mở khóa (`Publish`).
    *   **Topic mẫu:** `locker/{id}/cmd`

---

## 4. Code Patterns (Mẫu Mã)

### Mẫu 1: Khởi tạo Client & Cài đặt Callback (Java)
*Mô tả:* Thiết lập kết nối tới Broker và xử lý các sự kiện hệ thống (mất kết nối, nhận tin).

```java
import org.eclipse.paho.client.mqttv3.*;

public class MqttClientSetup {
    private static final String BROKER = "tcp://broker.emqx.io:1883";
    private static final String CLIENT_ID = "LockerController_01";

    public static void main(String[] args) {
        try {
            // 1. Khởi tạo Client
            MqttClient client = new MqttClient(BROKER, CLIENT_ID, null);
            MqttConnectOptions options = new MqttConnectOptions();
            options.setCleanSession(true);

            // 2. Thiết lập Callback (Xử lý sự kiện)
            client.setCallback(new MqttCallback() {
                @Override
                public void connectionLost(Throwable cause) {
                    System.err.println("Mat ket noi: " + cause.getMessage());
                    // Logic tự động reconnect nên được đặt ở đây
                }

                @Override
                public void messageArrived(String topic, MqttMessage message) {
                    System.out.println("Nhan lenh tu topic " + topic + ": " + new String(message.getPayload()));
                    // Xử lý logic mở khóa tại đây
                }

                @Override
                public void deliveryComplete(IMqttDeliveryToken token) {
                    System.out.println("Da gui trang thai thanh cong!");
                }
            });

            // 3. Ket noi
            client.connect(options);
            System.out.println("Da ket noi den Broker");
            
            // 4. Dang ky nhan lenh (Subscribe)
            client.subscribe("locker/01/cmd", 1); // QoS 1

        } catch (MqttException e) {
            e.printStackTrace();
        }
    }
}
```

### Mẫu 2: Publish Dữ liệu JSON (Trạng thái Locker)
*Mô tả:* Gửi gói tin JSON chứa thông tin Locker lên Broker.

```java
// Kế tiếp đoạn code trên, sau khi đã connect
public void publishStatus(MqttClient client, String status) throws MqttException {
    // Tạo nội dung JSON
    String jsonPayload = String.format(
        "{\"locker_id\": \"01\", \"status\": \"%s\", \"timestamp\": %d}", 
        status, System.currentTimeMillis()
    );

    // Tạo tin nhắn
    MqttMessage message = new MqttMessage(jsonPayload.getBytes());
    message.setQos(1); // Đảm bảo tin nhắn đến ít nhất 1 lần

    // Xuất bản
    client.publish("locker/01/status", message);
    System.out.println("Da xuat ban trang thai: " + status);
}
```

---

## 5. Anti-patterns (Các sai lầm cần tránh)

1.  **Lose Connection Logic (Quên xử lý mất kết nối):**
    *   *Lỗi:* Code MQTT không có `try-catch` hoặc logic reconnect trong `connectionLost()`.
    *   *Hậu quả:* Thiết bị Locker bị treo, không nhận lệnh mở khóa nếu mạng chập chờn.
    *   *Cách khắc phục:* Luôn bật `CleanSession = false` và Implement vòng lặp reconnect với khoảng cách thời gian (Backoff).

2.  **Wrong QoS Selection (Chọn sai mức QoS):**
    *   *Lỗi:* Dùng QoS 0 cho lệnh mở khóa/quan trọng.
    *   *Hậu quả:* Lệnh mở khóa có thể bị mất trong môi trường mạng không ổn định, người dùng không mở được tủ.
    *   *Cách khắc phục:* Luôn dùng **QoS 1** hoặc **QoS 2** cho các sự kiện quan trọng (Cửa đóng/mở, Thanh toán).

3.  **Security Negligence (Bỏ qua bảo mật):**
    *   *Lỗi:* Kết nối không mã hóa (sử dụng `tcp://` thay vì `ssl://`), không sử dụng User/Pass.
    *   *Hậu quả:* Dễ bị hacker nghe lén lệnh mở khóa hoặc giả mạo thiết bị.
    *   *Cách khắc phục:* Sử dụng `MqttConnectOptions.setUserNamePassword` và kết nối qua SSL/TLS (Port 8883).

---

## 6. Cheat Sheet (Bảng tra nhanh)

| Thuật ngữ | Định nghĩa | Lệnh/Tham số Java (Paho) |
| :--- | :--- | :--- |
| **Broker** | Server trung gian | `tcp://broker_url:1883` |
| **Topic** | Đường dẫn logic gửi/nhận | `String topic = "home/livingroom/temp";` |
| **QoS 0** | Gửi 1 lần | `message.setQos(0);` |
| **QoS 1** | Gửi đến khi ACK | `message.setQos(1);` |
| **QoS 2** | Gửi đúng 1 lần | `message.setQos(2);` |
| **Subscribe** | Đặt hàng nhận tin | `client.subscribe("topic", qos);` |
| **Publish** | Gửi tin đi | `client.publish("topic", message);` |
| **Clean Session** | Xóa tin nhắn cũ khi reconnect | `options.setCleanSession(true);` |
| **Tool Test** | Kiểm tra Broker | **MQTTBox** (Desktop) hoặc **MQTT Explorer** |



<!-- CHUNK 140-150 -->

# KẾT NỐI IOT: HƯỚNG DẪN QUYẾT ĐỊNH KỸ THUẬT (MQTT & HTTP)

Tài liệu này tổng hợp kiến thức từ các chương thực hành MQTT Example, tập trung vào việc lựa chọn và triển khai giao thức cho hệ thống Smart Locker.

---

## 1. Core Mental Model (Mô hình Tư duy)

Để xây dựng hệ thống IoT hiệu quả, bạn cần hiểu hai mô hình giao tiếp chính:

### A. HTTP (Request/Response)
*   **Khái niệm:** Kiểu giao tiếp "Hỏi - Đáp". Client phải chủ động gửi yêu cầu để nhận dữ liệu.
*   **Thực tế:** Dùng `POST` để gửi lệnh (như mở khóa) và `GET` để kiểm tra trạng thái.
*   **Ký thuật:** `REST API`. Phản ứng chậm hơn do độ trễ kết nối (connection overhead).

### B. MQTT (Publish/Subscribe)
*   **Khái niệm:** Kiểu giao tiếp "Nhà báo - Người đọc". Không có sự kết nối trực tiếp giữa sender và receiver.
*   **Thành phần chính:**
    *   **Broker:** "Bưu điện" trung gian (ví dụ: `tcp://broker.emqx.io:1883`).
    *   **Client:** Gửi (Publish) hoặc nhận (Subscribe) tin nhắn qua các **Topic**.
*   **Ưu điểm:** Tối ưu băng thông, độ trễ thấp, phù hợp IoT.

---

## 2. Decision Tables (Bảng Quyết định)

Sử dụng bảng sau để lựa chọn giao thức phù hợp cho tính năng Smart Locker:

| Tiêu chí lựa chọn | Sử dụng HTTP (REST API) | Sử dụng MQTT |
| :--- | :--- | :--- |
| **Mục đích** | Cấu hình cứng, truy vấn dữ liệu History, Authen. | Giám sát thời gian thực (Real-time), điều khiển tức thì. |
| **Tần suất gửi** | Thấp (Ví dụ: 5 phút/lần báo cáo). | Cao (Liên tục hoặc ngay lập tức khi có sự kiện). |
| **Tài nguyên thiết bị** | Cao (Cần xử lý TCP/IP stack nhiều). | Thấp (Gọn nhẹ, phù hợp vi điều khiển). |
| **Đải báo thức** | Server phải polling (hỏi đều). | Server nhận ngay khi Client Publish. |
| **Khuyến nghị cho Locker** | Dùng cho API Admin (xem thống kê, tạo user). | Dùng cho `Command/Open`, `Status/Update`. |

---

## 3. Architecture (Kiến trúc Giao tiếp)

Hệ thống Smart Locker sử dụng MQTT với kiến trúc Centralized Broker.

### Flow giao tiếp:
1.  **Locker Client** (Arduino/ESP32): Kết nối Broker, Subscribe topic `locker/cmd` (lệnh mở).
2.  **Mobile App/Admin**: Publish JSON đến `locker/cmd` yêu cầu mở.
3.  **Broker**: Nhận tin và chuyển tiếp đến Locker Client.
4.  **Locker Client**: Xử lý lệnh, sau đó Publish kết quả lên `locker/status`.

### Cấu trúc Topic (ví dụ):
*   `home/locker/001/cmd`: Gửi lệnh điều khiển.
*   `home/locker/001/status`: Báo cáo trạng thái (Open/Close/Error).

---

## 4. Code Patterns (Mẫu Mã)

Dưới đây là các mẫu code hoàn chỉnh áp dụng từ các trang tài liệu, tối ưu cho thực tế.

### Mẫu 1: Khởi tạo Client & Connect (Java - Paho MQTT)
Đây là bước bắt buộc để tạo cổng kết nối với Broker.

```java
import org.eclipse.paho.client.mqttv3.*;

public class BasicConnection {
    // Broker công cộng (demo)
    private static final String BROKER_URL = "tcp://broker.emqx.io:1883";
    private static final String CLIENT_ID = "LockerDevice_01";

    public static void main(String[] args) {
        try {
            // 1. Tạo Client instance
            MqttClient client = new MqttClient(BROKER_URL, CLIENT_ID, null);
            
            // 2. Thiết lập Option (Keep Alive, QoS...)
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);

            // 3. Kết nối
            System.out.println("Đang kết nối tới Broker...");
            client.connect(connOpts);
            System.out.println("Đã kết nối!");

            // 4. Ngắt kết nối (Cleanup)
            client.disconnect();
        } catch (MqttException e) {
            e.printStackTrace();
        }
    }
}
```

### Mẫu 2: Hàm Callback & Subscribe (Java)
Xử lý sự kiện khi có tin nhắn mới đến (Cần thiết cho việc lắng nghe lệnh mở).

```java
import org.eclipse.paho.client.mqttv3.*;

public class SubscriberCallback {
    private static final String TOPIC_SUB = "iot/locker/cmd";

    // Lớp xử lý sự kiện tin nhắn
    static class Callback implements IMqttMessageHandler {
        @Override
        public void messageArrived(String topic, MqttMessage message) throws Exception {
            String payload = new String(message.getPayload());
            System.out.println("Nhận lệnh từ [" + topic + "]: " + payload);
            
            // Logic: Nếu payload là "OPEN" -> Kích hoạt relay
            if (payload.equals("OPEN")) {
                System.out.println(">> CHẾ ĐỘ MỞ KHÓA <<");
            }
        }
    }

    public static void main(String[] args) throws Exception {
        MqttClient client = new MqttClient("tcp://broker.emqx.io:1883", "JavaSub", null);
        client.setCallback(new Callback()); // Gắn callback
        client.connect();

        // Đăng ký nhận tin
        client.subscribe(TOPIC_SUB, 1); 
        System.out.println("Đang lắng nghe lệnh...");
    }
}
```

### Mẫu 3: Xử lý dữ liệu JSON (Gửi & Nhận)
IoT giao tiếp chủ yếu qua JSON.

```java
import org.eclipse.paho.client.mqttv3.*;
import org.json.JSONObject; // Cần thêm thư viện org.json

public class JsonHandling {
    public static void main(String[] args) {
        try {
            MqttClient client = new MqttClient("tcp://broker.emqx.io:1883", "JsonClient", null);
            client.connect();

            // 1. GỬI DỮ LIỆU (PUBLISH) - Build JSON
            JSONObject data = new JSONObject();
            data.put("locker_id", "L01");
            data.put("status", "LOCKED");
            data.put("battery", 95);
            
            MqttMessage msg = new MqttMessage(data.toString().getBytes());
            client.publish("iot/locker/status", msg);
            System.out.println("Đã gửi: " + data);

            // 2. NHẬN DỮ LIỆU (SUBSCRIBE) - Parse JSON
            client.subscribe("iot/locker/cmd", (topic, message) -> {
                String jsonStr = new String(message.getPayload());
                JSONObject receivedData = new JSONObject(jsonStr);
                
                // Trích xuất giá trị an toàn
                if (receivedData.has("action")) {
                    String action = receivedData.getString("action");
                    System.out.println("Action: " + action);
                }
            });
            
            client.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

---

## 5. Anti-patterns (Các sai lầm cần tránh)

Khi triển khai MQTT cho Smart Locker, hãy tránh các lỗi sau:

1.  **Hardcode Broker Credentials:**
    *   *Sai:* Đặt username/password (nếu có) ngay trong code source.
    *   *Đúng:* Dùng biến môi trường (Environment Variables) hoặc file config ẩn (`.env`).

2.  **Missing QoS (Chất lượng dịch vụ):**
    *   *Sai:* Để mặc định QoS 0. Nếu mạng chập chờn, lệnh "Mở khóa" có thể bị mất.
    *   *Đúng:* Dùng **QoS 1** (At least once) cho lệnh điều khiển để đảm bảo server nhận được tin.

3.  **Block Main Thread (Thread Blocking):**
    *   *Sai:* Code MQTT nằm trên Main Thread của App Mobile sẽ làm App bị treo (Not Responding) khi mất kết nối.
    *   *Đúng:* Chạy MQTT trong **Background Service** hoặc **Async Task**.

4.  **Payload quá lớn:**
    *   MQTT phù hợp gói tin nhỏ (< 256KB). Đừng gửi file ảnh hay log dài qua MQTT.

---

## 6. Cheat Sheet (Bảng tra nhanh)

Lưu các lệnh và khái niệm quan trọng khi tra cứu tài liệu.

| Thuật ngữ | Code / Command | Ghi chú |
| :--- | :--- | :--- |
| **Connect** | `client.connect()` | Thiết lập phiên làm việc. |
| **Publish** | `client.publish(topic, message)` | Gửi tin đi (Fire & Forget hoặc có xác nhận). |
| **Subscribe** | `client.subscribe(topic, qos)` | Lắng nghe tin trên Topic. |
| **Disconnect** | `client.disconnect()` | Tắt kết nối gọn gàng. |
| **QoS 0** | `qos=0` | Gửi 1 lần, không đảm bảo到达 (Best effort). |
| **QoS 1** | `qos=1` | Đảm bảo到达 ít nhất 1 lần (Có thể lặp). |
| **QoS 2** | `qos=2` | Đảm bảo到达 chính xác 1 lần (Chậm nhất, tốn tài nguyên). |
| **LWT** | `setWill(...)` | Gửi tin nhắn cuối cùng nếu bị ngắt kết nối đột ngột (Useful cho "Mất kết nối"). |



<!-- SECTION 151-172 -->

## Chương trình MQTT Example - Reconnect (pages 151-172)

Dưới đây là bản tóm tắt toàn cảnh cho tài liệu được cung cấp:

**Mục tiêu chính:**
Hướng dẫn thực hành tích hợp hai giao thức MQTT và AMQP vào ứng dụng Java. Tài liệu cung cấp các ví dụ code thực tế để kết nối broker, gửi/nhận dữ liệu (JSON) và xử lý tái kết nối, chuyển đổi từ môi trường demo sang môi trường cloud thực tế.

**Khái niệm cốt lõi:**
*   **MQTT Reconnect:** Tính năng tự động kết nối lại khi mất mạng (Client ID phải duy trì tính duy nhất).
*   **AMQP (RabbitMQ):** Giao thức dùng hàng đợi (Queue) với vai trò Producer (người gửi) và Consumer (người nhận).
*   **CloudAMQP:** Dịch vụ cung cấp RabbitMQ Broker miễn phí trên đám mây.
*   **Exchange/Queue:** Cơ chế định tuyến và lưu trữ thông điệp trong RabbitMQ.

**Phụ thuộc quan trọng:**
*   **Thư viện (Libraries):** Cần cài đặt thư viện `Eclipse Paho` cho MQTT và `RabbitMQ Client` cho AMQP.
*   **Công cụ:** Cần cài đặt `MQTTBox` để minh họa giao tiếp MQTT.
*   **CloudAMQP:** Cần tạo tài khoản và lấy thông tin Host/User/Password để chạy code RabbitMQ mẫu.

**Từ khóa cần nhớ:**
*   `BROKER`, `TOPIC`, `PUBLISH/SUBSCRIBE`
*   `QUEUE`, `EXCHANGE`, `PRODUCER/CONSUMER`
*   `CLOUDAMQP`, `AMQPS` (SSL), `JSON`



<!-- CHUNK 151-162 -->

# HƯỚNG DẪN QUYẾT ĐỊNH KỸ THUẬT: MQTT & AMQP

Tài liệu này cung cấp hướng dẫn thực hành để tích hợp giao thức MQTT và AMQP vào ứng dụng Java, tập trung vào việc xử lý tái kết nối và chuyển đổi từ môi trường demo sang môi trường cloud thực tế.

---

## 1. Core Mental Model (Mô hình Tư duy)

*   **MQTT (Message Queuing Telemetry Transport):**
    *   **Mô tả:** Giao thức publish/subscribe dựa trên Broker (trung gian). Phù hợp cho IoT, băng thông thấp, và cần cơ chế "Last Will" (di chúc cuối cùng).
    *   **Vai trò:** Thiết bị (Client) gửi dữ liệu lên **Topic** (Chủ đề), Broker sẽ chuyển tiếp đến các Client khác đang đăng ký Topic đó.
    *   **Key Concept:** `BROKER`, `TOPIC`, `PUBLISH/SUBSCRIBE`.

*   **AMQP (Advanced Message Queue Protocol):**
    *   **Mô tả:** Giao thức tin nhắn hướng hàng đợi (Queue-based). Phù hợp cho hệ thống doanh nghiệp, xử lý giao dịch đảm bảo (Guaranteed Delivery).
    *   **Vai trò:** **Producer** gửi tin nhắn vào **Queue** (Hàng đợi), **Consumer** nhận tin nhắn từ Queue. RabbitMQ là broker tiêu chuẩn.
    *   **Key Concept:** `QUEUE`, `EXCHANGE`, `PRODUCER/CONSUMER`.

---

## 2. Decision Tables (Bảng Quyết định)

| Tiêu chí lựa chọn | Sử dụng MQTT | Sử dụng AMQP (RabbitMQ) |
| :--- | :--- | :--- |
| **Mô hình giao tiếp** | **Publish/Subscribe (Pub/Sub):** Một tác vụ gửi, nhiều tác vụ nhận (One-to-Many). | **Point-to-Point hoặc Pub/Sub:** Hàng đợi đảm bảo giao dịch, xử lý tin nhắn顺序 hoặc phân tích luồng (Routing). |
| **Bối cảnh** | IoT, Sensor, Thiết bị di động, Mạng không ổn định. | Backend service, Microservices, Hệ thống doanh nghiệp (Enterprise). |
| **Tính năng đặc biệt** | **QoS (Quality of Service):** Đảm bảo giao hàng ở mức level 0, 1, 2. **Retained Message:** Lưu tin nhắn cuối cùng cho client mới kết nối. | **Exchange Types:** Linh hoạt định tuyến tin nhắn (Direct, Fanout, Topic, Headers). **Dead Letter Queue:** Xử lý lỗi tự động. |
| **Bảo mật/Cloud** | Dùng TCP/TLS. Broker public (emqx.io) dễ test. | Dùng AMQPS (SSL). Nên dùng dịch vụ cloud (CloudAMQP) để tránh quản lý server. |

---

## 3. Architecture (Kiến trúc Giao tiếp)

### 3.1. MQTT Architecture
Client kết nối trực tiếp tới Broker qua TCP. Client không cần biết nhau, chỉ cần biết Topic.
*   **Flow:** `Device (Client)` -> `BROKER (tcp://...:1883)` -> `App (Client)`.

### 3.2. AMQP (RabbitMQ) Architecture
Sử dụng khái niệm Exchange để nhận tin nhắn từ Producer và routing vào Queue.
*   **Flow:** `Producer` -> `Exchange` -> `Binding Key` -> `Queue` -> `Consumer`.

---

## 4. Code Patterns (Mẫu Mã)

### Pattern 1: MQTT Client với Tái kết nối (Reconnect)
*Lưu ý: `Eclipse Paho` library.*

**Mục tiêu:** Kết nối Broker, gửi/nhận JSON, xử lý mất kết nối tự động.

```java
package mqttDemo;
import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
import java.nio.charset.StandardCharsets;

public class MqttExample {
    private static final String BROKER = "tcp://broker.emqx.io:1883";
    private static final String TOPIC_IN = "iot/in";
    private static final String TOPIC_OUT = "iot/out";
    private static final String CLIENT_ID = "JavaClientExample_01"; // Phải duy nhất
    
    // Template JSON
    private static final String JSON_PAYLOAD = 
        "{\"DeviceName\":\"%s\", \"temperature\":%d, \"humidity\":%d}";

    public static void main(String[] args) {
        try {
            // 1. Khởi tạo Client với MemoryPersistence (không lưu trữ cứng)
            MqttClient client = new MqttClient(BROKER, CLIENT_ID, new MemoryPersistence());

            // 2. Cấu hình Option để Tái kết nối (Reconnect)
            MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true); // True: Xóa session cũ khi reconnect
            connOpts.setAutomaticReconnect(true); // Bật tự động reconnect
            connOpts.setConnectionTimeout(10); // Timeout kết nối

            // 3. Xử lý sự kiện khi mất kết nối/Reconnect (Callback)
            client.setCallback(new MqttCallback() {
                @Override
                public void connectionLost(Throwable cause) {
                    System.err.println("Mất kết nối! Đang cố gắng reconnect...");
                }

                @Override
                public void messageArrived(String topic, MqttMessage message) {
                    String payload = new String(message.getPayload());
                    System.out.println("Nhận tin từ " + topic + ": " + payload);
                }

                @Override
                public void deliveryComplete(IMqttDeliveryToken token) {
                    // Gọi khi publish thành công
                }
            });

            // 4. Kết nối và Subscribe
            client.connect(connOpts);
            System.out.println("Đã kết nối tới Broker: " + BROKER);
            client.subscribe(TOPIC_IN); // Lắng nghe tin nhắn vào

            // 5. Publish dữ liệu JSON (Giả lập Sensor)
            for (int i = 0; i < 5; i++) {
                String payload = String.format(JSON_PAYLOAD, CLIENT_ID, 30 + i, 60 + i);
                MqttMessage message = new MqttMessage(payload.getBytes(StandardCharsets.UTF_8));
                message.setQos(2); // QoS 2: Đảm bảo giao hàng một lần duy nhất
                client.publish(TOPIC_OUT, message);
                System.out.println("Đã gửi: " + payload);
                Thread.sleep(2000);
            }

            // Chờ nhận tin (simulate)
            Thread.sleep(5000);
            client.disconnect();
            client.close();
            System.out.println("Đã ngắt kết nối.");

        } catch (MqttException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

---

### Pattern 2: RabbitMQ Producer & Consumer (Local & Cloud)
*Lưu ý: Cần add dependency `amqp-client`.*

**Mục tiêu:** Gửi tin nhắn vào Queue và nhận ra.

#### A. Producer (Người gửi)

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import java.nio.charset.StandardCharsets;

public class Producer {
    private final static String QUEUE_NAME = "ktmt_queue";
    // Thay bằng URL CloudAMQP nếu dùng cloud: "amqps://user:pass@host/vhost"
    private final static String HOST = "localhost"; 

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST);
        // Nếu dùng CloudAMQP, uncomment dòng dưới và xóa setHost/setUser/setPass
        // factory.setUri("amqps://user:pass@host/vhost");

        if (!HOST.equals("localhost")) {
             factory.setUsername("guest"); // CloudAMQP tự sinh User/Pass
             factory.setPassword("guest");
        }

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {
            
            // Khai báo Queue (Durable: giữ lại queue nếu server restart)
            channel.queueDeclare(QUEUE_NAME, true, false, false, null);
            
            String message = "Hello RabbitMQ! Time: " + System.currentTimeMillis();
            
            // Publish tin nhắn
            channel.basicPublish("", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8));
            System.out.println(" [x] Sent '" + message + "'");
        }
    }
}
```

#### B. Consumer (Người nhận)

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.DeliverCallback;
import java.nio.charset.StandardCharsets;

public class Consumer {
    private final static String QUEUE_NAME = "ktmt_queue";
    private final static String HOST = "localhost";

    public static void main(String[] argv) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(HOST);
        
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        // Đảm bảo Queue tồn tại (giống Producer)
        channel.queueDeclare(QUEUE_NAME, true, false, false, null);
        System.out.println(" [*] Đang chờ tin nhắn. Nhấn Ctrl+C để thoát.");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(" [x] Received '" + message + "'");
        };

        // autoAck = true: Server tự động xóa tin nhắn sau khi gửi cho Consumer
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });
    }
}
```

---

## 5. Anti-patterns (Các sai lầm cần tránh)

1.  **Sử dụng Client ID trùng lặp (MQTT):**
    *   **Lỗi:** Nhiều client cùng ID sẽ làm bay kết nối của nhau (do Broker quản lý session).
    *   **Khắc phục:** Sinh ID duy nhất, ví dụ: `JavaClient_" + UUID.randomUUID()`.

2.  **Không bật Auto Reconnect (MQTT):**
    *   **Lỗi:** Mất mạng là application chết hẳn, không tự động sống lại.
    *   **Khắc phục:** Luôn set `connOpts.setAutomaticReconnect(true)`.

3.  **Quên đặt QoS (MQTT):**
    *   **Lỗi:** Dùng QoS 0 (At most once) cho dữ liệu quan trọng => mất tin nhắn nếu network đứt.
    *   **Khắc phục:** Dùng **QoS 1** (At least once) hoặc **QoS 2** (Exactly once) cho dữ liệu quan trọng.

4.  **Kết nối RabbitMQ không dùng SSL (AMQPS) khi lên Cloud:**
    *   **Lỗi:** Dùng `amqp://` (port 5672) thay vì `amqps://` (port 5671) sẽ bị firewall chặn hoặc lỗi bảo mật.
    *   **Khắc phục:** Luôn kiểm tra URL CloudAMQP bắt đầu bằng `amqps://`.

---

## 6. Cheat Sheet (Bảng tra nhanh)

### MQTT Commands
| Hành động | Hàm/Thao tác (Eclipse Paho) |
| :--- | :--- |
| **Kết nối** | `client.connect(options)` |
| **Tái kết nối** | `options.setAutomaticReconnect(true)` |
| **Gửi (Publish)** | `client.publish(topic, message)` |
| **Nhận (Subscribe)** | `client.subscribe(topic)` |
| **Lưu JSON** | `new String(message.getPayload())` |

### RabbitMQ Commands
| Hành động | Hàm/Thao tác (RabbitMQ Client) |
| :--- | :--- |
| **Cài đặt Host** | `factory.setHost("localhost")` hoặc `factory.setUri("amqps://...")` |
| **Khai báo Queue** | `channel.queueDeclare(name, durable, exclusive, autoDelete, args)` |
| **Gửi tin** | `channel.basicPublish("", queue, null, body.getBytes())` |
| **Nhận tin** | `channel.basicConsume(queue, autoAck, callback)` |
| **Tạo Instance Cloud** | Truy cập `cloudamqp.com` -> Tạo Instance -> Copy URL kết nối. |



<!-- CHUNK 163-172 -->

# DEVELOPER DECISION GUIDE: AMQP & Cloud Integration (RabbitMQ)

## 1. Core Mental Model (Mô hình Tư duy)

Hãy tư duy hệ thống dựa trên các khái niệm sau:

*   **Producer / Consumer (Người gửi / Người nhận):**
    *   **Producer:** Ứng dụng chịu trách nhiệm tạo và gửi thông điệp vào hệ thống.
    *   **Consumer:** Ứng dụng hoặc dịch vụ lắng nghe và xử lý thông điệp từ hệ thống. Chúng có thể chạy độc lập và tách biệt hoàn toàn.

*   **Exchange / Queue (Trạm trung chuyển / Hàng đợi):**
    *   **Queue:** Là nơi lưu trữ thông điệp tạm thời (FIFO - Vào trước ra trước). Đảm bảo thông điệp không bị mất nếu Consumer bị sập.
    *   **Exchange:** Là "bộ định tuyến" nhận tin từ Producer và đẩy vào các Queue phù hợp dựa trên quy tắc (Binding).

*   **CloudAMQP (Dịch vụ Managed):**
    *   Thay vì tự setup RabbitMQ Server (Cài đặt, cấu hình SSL, bảo mật), CloudAMQP cung cấp sẵn Broker trên Cloud. Developer chỉ cần lấy thông tin **Host, User, Password, Port** và kết nối.

## 2. Decision Tables (Bảng Quyết định)

| Tình huống | Giải pháp kỹ thuật | Lý do & Cân nhắc |
| :--- | :--- | :--- |
| **Phải xử lý tín hiệu yếu/thất lạc mạng?** | Sử dụng **MQTT** với chế độ **Reconnect** (Keep Alive). | MQTT được thiết kế cho môi trường không ổn định. Client tự động giữ kết nối (heartbeat). |
| **Cần đảm bảo tin nhắn không mất, thứ tự xử lý nghiêm ngặt?** | Sử dụng **AMQP (RabbitMQ)** với cơ chế **Acknowledgement**. | AMQP mạnh ở việc quản lý hàng đợi, giao dịch (transaction) và đảm bảo "exactly-once delivery" nếu cấu hình đúng. |
| **Triển khai nhanh trên Cloud không có server?** | Dùng **CloudAMQP** (Free Tier). | Tiết kiệm thời gian setup, SSL đã được cấu hình sẵn, dễ dàng scale khi cần. |
| **Giao tiếp One-way (Push notification) hoặc Event-driven?** | **MQTT** (QoS 1 hoặc 2). | Đơn giản, overhead thấp, ideal cho IoT. |
| **Giao tiếp Two-way hoặc cần xử lý phức tạp (Work Queue)?** | **AMQP** (Producer/Consumer). | Phù hợp cho các tác vụ xử lý后台 (backend job), task queueing. |

## 3. Architecture (Kiến trúc Giao tiếp)

### Mô hình CloudAMQP (RabbitMQ)

Đây là kiến trúc chuẩn cho việc tích hợp ứng dụng Java với CloudAMQP:

1.  **Application (Producer):** Tạo kết nối -> Tạo Channel -> Khai báo Queue (nếu chưa có) -> Publish tin nhắn.
2.  **CloudAMQP Broker:** Nhận tin -> Lưu vào Queue.
3.  **Application (Consumer):** Tạo kết nối -> Tạo Channel -> Subscribe Queue -> Nhận và xử lý tin nhắn.

**Lưu ý Bảo mật:**
*   **AMQPS (Port 5671):** Luôn sử dụng giao thức SSL/TLS khi kết nối tới CloudAMQP để bảo vệ dữ liệu.
*   **Virtual Host:** Là không gian tách biệt các tài nguyên trên Broker. CloudAMQP thường tạo mặc định trùng với User.

## 4. Code Patterns (Mã Mẫu)

### Mẫu 1: Cấu hình kết nối CloudAMQP (Java)

Mẫu cấu hình `ConnectionFactory` là bước bắt buộc trước khi tạo bất kỳ Producer hay Consumer nào.

```java
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;

public class CloudConfig {
    public static ConnectionFactory createFactory() {
        ConnectionFactory factory = new ConnectionFactory();
        
        // Thông tin từ CloudAMQP Dashboard
        factory.setHost("armadillo.rmq.cloudamqp.com");
        factory.setUsername("cohushpn");
        factory.setPassword("m_PtS6PB02IfLhaAa7LPDr0yAHZhcIF_");
        factory.setVirtualHost("cohushpn"); // Thường trùng Username
        
        // Quan trọng: Cấu hình SSL an toàn
        factory.setPort(5671); // AMQPS port
        factory.useSslProtocol(); // Kích hoạt SSL/TLS
        
        return factory;
    }
}
```

### Mẫu 2: Producer (Người gửi)

Vai trò: Đẩi dữ liệu (JSON hoặc String) vào hàng đợi.

```java
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

public class ProducerExample {
    private static final String QUEUE_NAME = "testQueue";

    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = CloudConfig.createFactory(); // Sử dụng config đã tạo
        
        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {
            
            // Khai báo hàng đợi (durable=true: tồn tại dù server restart)
            channel.queueDeclare(QUEUE_NAME, true, false, false, null);
            
            // Tạo tin nhắn JSON
            String jsonMessage = "{\"sensor\": \"temp\", \"value\": 25.5}";
            
            // Gửi tin nhắn
            channel.basicPublish("", QUEUE_NAME, null, jsonMessage.getBytes("UTF-8"));
            
            System.out.println(" [x] Đã gửi: " + jsonMessage);
        }
    }
}
```

### Mẫu 3: Consumer (Người nhận)

Vai trò: Lắng nghe và xử lý dữ liệu từ hàng đợi.

```java
import com.rabbitmq.client.*;
import java.nio.charset.StandardCharsets;

public class ConsumerExample {
    private static final String QUEUE_NAME = "testQueue";

    public static void main(String[] args) throws Exception {
        ConnectionFactory factory = CloudConfig.createFactory();
        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.queueDeclare(QUEUE_NAME, true, false, false, null);
        System.out.println(" [*] Đang chờ tin nhắn từ CloudAMQP...");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), StandardCharsets.UTF_8);
            System.out.println(" [x] Nhận được: '" + message + "'");
            
            // Xác nhận đã xử lý xong (ACK)
            // autoAck = true trong basicConsume ở ví dụ mẫu, 
            // nhưng tốt nhất nên dùng channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
        };

        // autoAck = true: Tự động xác nhận ngay khi nhận tin
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> {});
    }
}
```

## 5. Anti-patterns (Các sai lầm cần tránh)

1.  **Hardcode Credentials (Mật khẩu trong code):**
    *   **Lỗi:** Đặt trực tiếp `password` và `user` vào file `.java`.
    *   **Hậu quả:** Rò rỉ thông tin bảo mật nếu code bị public lên GitHub.
    *   **Khắc phục:** Sử dụng biến môi trường (`System.getenv("AMQP_PASSWORD")`) hoặc file cấu hình ngoài.

2.  **Bỏ qua SSL/AMQPS:**
    *   **Lỗi:** Dùng port 5671 nhưng không gọi `useSslProtocol()` hoặc dùng port 5672 ( không mã hóa).
    *   **Hậu quả:** Dữ liệu có thể bị chặn nghe lén trên đường truyền mạng.
    *   **Khắc phục:** Luôn dùng `factory.setPort(5671)` và `factory.useSslProtocol()` khi dùng CloudAMQP.

3.  **Quên xử lý Logic Reconnect (RabbitMQ):**
    *   **Lỗi:** Mất kết nối Cloud -> App bị crash.
    *   **Khắc phục:** Trong RabbitMQ Java Client, cần bắt ngoại lệ `IOException` hoặc `TimeoutException` và implement vòng lặp kết nối lại (retry loop) hoặc dùng thư viện có hỗ trợ retry.

## 6. Cheat Sheet (Bảng tra nhanh)

### Lệnh dòng (Command Line) - MQTT (Dùng MQTTBox hoặc Mosquitto)

*   **Subscribe (Nhận tin):**
    `mosquitto_sub -h test.mosquitto.org -t "sensors/temperature" -v`
*   **Publish (Gửi tin):**
    `mosquitto_pub -h test.mosquitto.org -t "sensors/temperature" -m "25.5"`

### API Java - AMQP (RabbitMQ)

| Thao tác | Phương thức | Ghi chú |
| :--- | :--- | :--- |
| **Kết nối** | `factory.newConnection()` | Tạo kết nối tới Broker |
| **Mở Kênh** | `connection.createChannel()` | Đường truyền logic |
| **Khai báo Queue** | `channel.queueDeclare(q, true, ...)` | Tạo hàng đợi (durable) |
| **Gửi tin** | `channel.basicPublish("", q, ...)` | Gửi tin vào hàng đợi |
| **Nhận tin** | `channel.basicConsume(q, autoAck, ...)` | Lắng nghe tin nhắn |
| **Xác nhận (ACK)** | `channel.basicAck(tag, false)` | Báo đã xử lý xong (nếu autoAck=false) |

### CloudAMQP Thông số
*   **Host:** `*.rmq.cloudamqp.com`
*   **Port:** `5671` (AMQPS)
*   **Protocol:** `SSL/TLS` (Bắt buộc)



<!-- SECTION 173-175 -->

## consumer (pages 173-175)

Dưới đây là bản tóm tắt toàn cục cho phần "consumer" dựa trên nội dung Tutorial 3 đã cung cấp:

**Mục tiêu chính:**
Hướng dẫn cách xây dựng cơ chế **Broadcast (Phát sóng)** trong RabbitMQ, trong đó một Producer gửi message đến nhiều Consumer cùng lúc thay vì chỉ một Consumer.

**Các khái niệm cốt lõi:**
*   **Fanout Exchange:** Sử dụng loại Exchange `"fanout"` để thực hiện việc broadcast message đến tất cả các queue được bind.
*   **Queue Binding:** Consumer cần tạo queue riêng và "bind" nó với Exchange để nhận được message.
*   **Decoupling:** Producer chỉ gửi tin vào Exchange mà không cần biết Consumer nào đang lắng nghe.

**Phụ thuộc quan trọng:**
*   Đây là phần **Tiếp theo (Tutorial 3)** của chuỗi hướng dẫn, dựa trên nền tảng kiến trúc từ Tutorial 1 (kết nối, channel, queue).

**Từ khoá / Thuật ngữ:**
*   `Fanout`
*   `Broadcast`
*   `Exchange`
*   `Binding`
*   `AMQP 0-9-1`



<!-- CHUNK 173-175 -->

# DEVELOPER DECISION GUIDE: Broadcast trong RabbitMQ (Fanout Exchange)

## Core Mental Model (Mô hình Tư duy)

Hãy tưởng tượng RabbitMQ Exchange là một **bưu điện trung tâm**, và các Queue là **hộp thư cá nhân**.

*   **Problem (Vấn đề):** Khi một sự kiện quan trọng xảy ra (ví dụ: "Đơn hàng đã đặt"), bạn cần thông báo đến nhiều hệ thống phụ thuộc (Inventory, Email, Analytics) cùng lúc. Cách gửi tuần tự từng nơi một là chậm và sai kiến trúc.
*   **Solution (Giải pháp):** Producer (người gửi) chỉ việc ném thư vào **Bưu điện trung tâm** (Exchange) và nói "Gửi cho tất cả!". Bưu điện sẽ tự động sao chép thư và nhét vào mọi **Hộp thư** (Queue) đã đăng ký.
*   **Lưu ý quan trọng:** Consumer nào không có Queue (hộp thư) hoặc không绑定 (bind) với Exchange thì sẽ không nhận được tin. Queue bị xóa sau khi Consumer ngắt kết nối (nếu dùng `exclusive`), nên Consumer tự tạo Queue riêng cho mình để đảm bảo tin không bị mất.

## Decision Tables (Bảng Quyết định)

### Bảng 1: Khi nào chọn Fanout Exchange?

| Yếu tố đầu vào | Tình huống | Quyết định / Hành động |
| :--- | :--- | :--- |
| **Mục tiêu Broadcast** | Một Producer cần gửi tin đến **nhiều** Consumer (1-nhiều). | **Dùng Fanout Exchange.** Đây là lựa chọn duy nhất đúng cho broadcast trong AMQP. |
| **Độ tin cậy của Consumer** | Consumer có thể bị rớt hoặc offline khi tin gửi đi. | **KHÔNG** dùng Fanout trực tiếp. Dùng **Worker Queue** (Tutorial 2) kết hợp Fanout hoặc xử lý offline logic ở Consumer. |
| **Độ phức tạp Routing** | Producer muốn gửi tin dựa trên điều kiện (ví dụ: severity, region). | **KHÔNG** dùng Fanout. Chuyển sang **Direct Exchange** (Tutorial 4). |

## Architecture (Kiến trúc Giao tiếp)

Trong mô hình Broadcast (Fanout), luồng dữ liệu 1 chiều như sau:

1.  **Producer:** Kết nối tới Server, khai báo **Exchange** (cổng vào chung).
2.  **Exchange (Fanout):** Nhận tin từ Producer và copy nó.
3.  **Queue (Từng Consumer):** Mỗi Consumer tạo 1 Queue riêng.
4.  **Binding:** Consumer "kéo" Queue của mình và "cắm" vào Exchange.
5.  **Consumer:** Nhận tin từ Queue của mình.

**Quy tắc vàng:**
*   Producer **KHÔNG** bao giờ tự tạo Queue.
*   Queue do Consumer tạo ra phải được **bind** vào Exchange.
*   Tên Exchange phải **trùng khớp** giữa Producer và Consumer.

## Code Patterns (Mã Mẫu)

Dưới đây là mẫu code Java (Spring AMQP风格) ngắn gọn để thực hiện.

### 1. Producer (Người Gửi - Broadcast)

```java
// Cấu hình Exchange (chỉ cần làm 1 lần)
@Autowired
RabbitTemplate rabbitTemplate;

public void broadcastMessage(String message) {
    // "logs.fanout" là tên Exchange đã được khai báo
    // routingKey = "" (vì Fanout bỏ qua routing key)
    // message = nội dung cần gửi
    rabbitTemplate.convertAndSend("logs.fanout", "", message);
    System.out.println(" [x] Sent '" + message + "'");
}
```

### 2. Consumer (Người Nhận - Tự tạo Queue & Bind)

```java
@Component
public class LogConsumer {

    // 1. Khai báo Exchange
    @Bean
    public FanoutExchange logsExchange() {
        return new FanoutExchange("logs.fanout");
    }

    // 2. Tạo Queue tạm thời (Annonymous Queue) để nhận broadcast
    @Bean
    public Queue autoDeleteQueue() {
        return new Queue("", true, true, true); // Tên rỗng = tự sinh ID
    }

    // 3. Bind Queue vào Exchange
    @Bean
    public Binding binding(Queue autoDeleteQueue, FanoutExchange logsExchange) {
        return BindingBuilder.bind(autoDeleteQueue).to(logsExchange);
    }

    // 4. Lắng nghe tin
    @RabbitListener(queues = "#{'autoDeleteQueue'.toString()}")
    public void receive(String in) {
        System.out.println(" [x] Received '" + in + "'");
    }
}
```

## Anti-patterns (Các sai lầm cần tránh)

1.  **Fanout vào Queue Tĩnh (Durable):**
    *   *Lỗi:* Producer hoặc Dev tự tạo một Queue cứng (ví dụ: `my-logs-queue`) và bind vào Exchange Fanout.
    *   *Hậu quả:* Khi có 5 Consumer instances chạy, cả 5 sẽ nhận tin giống nhau (do cùng subscribe vào 1 queue). Mất tính năng broadcast.
    *   *Sửa:* Để Queue rỗng (`""`) hoặc `exclusive` để mỗi Consumer có queue riêng.

2.  **Quên Binding:**
    *   *Lỗi:* Consumer tạo Queue thành công nhưng không thực hiện bước `binding` với Exchange.
    *   *Hậu quả:* Producer gửi tin, Exchange nhận tin nhưng không thể đẩy vào Queue nào -> Tin bị "bốc hơi".
    *   *Sửa:* Luôn nhớ gọi `channel.queueBind(queueName, exchangeName, "")`.

3.  **Producer tự tạo Queue:**
    *   *Lỗi:* Producer gọi `queueDeclare`.
    *   *Hậu quả:* Phá vỡ decoupling. Producer phải biết tên Queue của Consumer.
    *   *Sửa:* Producer chỉ deal với Exchange.

## Cheat Sheet (Bảng tra nhanh)

| Thuật ngữ (EN) | Dịch nghĩa (VN) | Vai trò / Chức năng |
| :--- | :--- | :--- |
| **Fanout Exchange** | Bộ khuếch đại tín hiệu | Loại Exchange bỏ qua routing key, sao chép tin nhắn gửi đến mọi Queue đang bind. |
| **Binding** | Kết nối / Ràng buộc | Quan hệ giữa Queue và Exchange. "Dây dẫn" để nhận tin. |
| **Anonymous Queue** | Queue vô danh | Queue có tên tự sinh (UUID), bền (durable) theo mặc định nhưng xóa khi kết nối đóng (nếu dùng `exclusive`). Lý tưởng cho Worker & Broadcast. |
| **routingKey (trong Fanout)** | Khóa định tuyến | **Bỏ qua**. Để rỗng `""` hoặc `null`. |
| **AMQP 0-9-1** | Protocol chuẩn | Giao thức mà RabbitMQ tuân theo, tách biệt Producer/Consumer qua Exchange. |

### Cú pháp lệnh CLI nhanh (để kiểm tra)

```bash
# Tạo Exchange Fanout
rabbitmqadmin declare exchange name=logs.fanout type=fanout

# Tạo Queue tạm và Bind (Thử nghiệm)
rabbitmqadmin declare queue name=my_test_queue
rabbitmqadmin declare binding source=logs.fanout destination=my_test_queue
```



<!-- SECTION 176-184 -->

## Producer (pages 176-184)

**Global Section Summary: Producer**

- **Mục tiêu chính:** Giới thiệu mô hình Producer-Consumer trong RabbitMQ để định tuyến và trao đổi thông điệp, sau đó mở rộng sang kiến trúc IoT Cloud Platform, nhấn mạnh nhu cầu xử lý dữ liệu quy mô lớn và thời gian thực.
- **Các khái niệm cốt lõi:**
  - **RabbitMQ Messaging:** Sử dụng Exchange (`direct`, `topic`), Routing Keys, và Queues để gửi (`publish`) và nhận (`subscribe`) dữ liệu một cách chọn lọc.
  - **Edge Computing:** Xử lý dữ liệu tại biên mạng (trên thiết bị IoT) trước khi gửi lên Cloud để giảm tải băng thông và cải thiện tốc độ.
  - **IoT Cloud Architecture:** Kiến trúc 4 lớp (Thu thập - Tiếp nhận - Xử lý - Phân tích) dành cho số lượng sự kiện lớn.
- **Phụ thuộc quan trọng:** Nên nắm vững các khái niệm cơ bản về mạng và cấu trúc dữ liệu JSON trước khi thực hiện Bài tập 3.
- **Từ khoá / Thuật ngữ cần nhớ:** `Producer`, `Consumer`, `Routing Key`, `Topic Exchange`, `Edge Computing`, `Cloud IoT Platform` (ThingsBoard, AWS, Google Cloud).



<!-- CHUNK 176-184 -->

# DEVELOPER DECISION GUIDE: Producer & IoT Cloud Integration

## Core Mental Model (Mô hình Nhận thức Cốt lõi)

Hãy hình dung hệ thống như một nhà máy sản xuất tin nhắn.
1.  **Producer (Nhà sản xuất):** Là nguồn phát sinh dữ liệu (thiết bị IoT, server). Nó không gửi trực tiếp đến Consumer mà giao cho **Exchange**.
2.  **Exchange (Bưu điện trung chuyển):** Nhận tin nhắn và dùng **Routing Key** để quyết định hộp thư (Queue) nào sẽ nhận tin.
3.  **Consumer (Người nhận):** Lắng nghe Queue để xử lý dữ liệu.

**Bài học kinh nghiệm:** Trong IoT, đừng biến thiết bị thành "nhà máy in". Hãy để thiết bị (Edge) làm sạch dữ liệu trước, sau đó dùng RabbitMQ để chuyển tiếp thông minh lên Cloud.

---

## Decision Tables (Bảng Quyết Định)

| **Yếu tố** | **Direct Exchange** | **Topic Exchange** |
| :--- | :--- | :--- |
| **Cơ chế Routing** | **Exact match:** `routing_key` phải khớp chính xác tuyệt đối. | **Pattern match:** Dùng ký tự đại diện `*` (1 từ) và `#` (nhiều từ). |
| **Phù hợp khi** | Hệ thống nhỏ, logic xử lý rõ ràng (VD: `error` gửi riêng, `info` gửi riêng). | Hệ thống IoT phức tạp, cần lọc dữ liệu theo cấp bậc (VD: `sensor.temperature.room1`). |
| **Ví dụ Key** | Gửi `"black"` -> Queue chỉ nhận `"black"`. | Gửi `"sensor.temperature.usa"` -> Queue nhận `"sensor.#"` hoặc `"*.temperature.*"` đều được. |

| **Kiến trúc** | **Cloud-Only (Truyền thống)** | **Edge Computing (Hiện đại - IoT)** |
| :--- | :--- | :--- |
| **Xử lý dữ liệu** | Gửi toàn bộ dữ liệu thô (raw) lên Cloud để xử lý. | Xử lý, lọc, gom nhóm ngay tại thiết bị biên (Edge Device). |
| **Tốn băng thông** | **Cao:** Gây ùn tắc网络, tăng chi phí. | **Thấp:** Chỉ gửi dữ liệu sạch hoặc đã nén. |
| **Độ trễ** | Cao (phải chờ phản hồi từ Cloud). | Thấp (phản hồi tức thì ngay tại chỗ). |

---

## Architecture (Kiến Trúc)

### Kiến Trúc IoT Cloud 4 Lớp (Tham chiếu Google Cloud)
Để xử lý hàng trăm triệu sự kiện/giờ, bạn cần phân chia trách nhiệm rõ ràng:

1.  **Data Gathering (Thu thập):** Cảm biến gửi dữ liệu vào Device/Gateway.
2.  **Data Ingest (Tiếp nhận):** RabbitMQ (hoặc MQTT Broker) tiếp nhận luồng tin nhắn từ Producer.
3.  **Data Processing (Xử lý):** Consumer đọc tin nhắn, chuyển đổi định dạng (JSON), lọc nhiễu, lưu vào DB hoặc gửi tiếp đến Stream Processing (e.g., Kafka, Dataflow).
4.  **Data Analysis (Phân tích):** Dùng BI tools, AI/ML để dự báo, visualization.

### Mô hình Edge-to-Cloud Flow
```text
[ Sensor ] --> [ Edge Device (Xử lý cục bộ) ] --(Gửi dữ liệu sạch)--> [ RabbitMQ Exchange ] --(Định tuyến Topic)--> [ Cloud Consumer ] --> [ Database/Analytics ]
```

---

## Code Patterns (Mã Mẫu)

### Pattern 1: Producer Gửi Dữ Liệu IoT (Topic Exchange)
Sử dụng `Topic Exchange` để linh hoạt định tuyến dựa trên các thuộc tính thiết bị.

```java
// Chuẩn bị dữ liệu JSON (Mô phỏng)
String deviceName = "sensor-1";
int temperature = 30;
String routingKey = "sensor.temperature." + deviceName; // Cấu trúc: loai.thietbi

String jsonData = String.format(
    "{\"DeviceName\": \"%s\", \"temperature\": %d}", 
    deviceName, temperature
);

// Gửi tin nhắn
channel.basicPublish(
    EXCHANGE_NAME, 
    routingKey,   // Dùng key có cấu trúc để định tuyến thông minh
    null,         // Properties (có thể thêm persistent: persistent)
    jsonData.getBytes("UTF-8")
);
```

### Pattern 2: Consumer Lọc Tin Nhắn Chọn Lọc (Selective Receiving)
Làm thế nào để một Queue chỉ nhận dữ liệu nhiệt độ nhưng bỏ qua dữ liệu độ ẩm?

```java
// 1. Tạo Exchange type 'topic'
channel.exchangeDeclare("iot_logs", "topic");

// 2. Tạo Queue cho việc xử lý lỗi/cảnh báo
String queueName = "temperature_alert_queue";
channel.queueDeclare(queueName, false, false, false, null);

// 3. Ràng buộc (Bind): Lọc chỉ lấy key bắt đầu bằng "sensor.temperature"
String bindingKey = "sensor.temperature.*"; 
channel.queueBind(queueName, "iot_logs", bindingKey);

// 4. Consumer lắng nghe Queue này
channel.basicConsume(queueName, true, deliverCallback, consumerTag -> {});
```

---

## Anti-patterns (Các sai lầm cần tránh)

1.  **Gửi Dữ Liệu Thô Lên Cloud (No Edge Processing):**
    *   *Hậu quả:* Bạn phải trả phí băng thông cao cho dữ liệu rác hoặc dữ liệu lặp lại (ví dụ: sensor báo sai 100 lần/giây). Cloud sẽ quá tải khi quy mô lên hàng triệu thiết bị.
    *   *Giải pháp:* Thực hiện lọc nhiễu (debounce), gom nhóm (batch) ngay trên thiết bị biên.

2.  **Sử Dụng Fanout Khi Cần Logic Phức Tạp:**
    *   *Hậu quả:* Gửi bừa bãi tất cả tin nhắn cho mọi Queue (bomber memory).
    *   *Giải pháp:* Dùng **Topic Exchange** với `routing_key` chi tiết để đảm bảo mỗi service chỉ nhận dữ liệu nó cần xử lý.

3.  **Thiếu Kiểu Dữ Liệu JSON Cố Định:**
    *   *Hậu quả:* Consumer Crash (đổ vỡ) khi nhận dữ liệu format khác.
    *   *Giải pháp:* Luôn validate JSON trước khi xử lý và chuẩn hóa key name (camelCase hoặc snake_case đều được, nhưng phải thống nhất).

---

## Cheat Sheet (Bảng Tra Nhanh)

### RabbitMQ Command Mapping
*   **Gửi tin (Producer):** `channel.basicPublish(EXCHANGE, ROUTING_KEY, ...)`
*   **Tạo hàng đợi (Queue):** `channel.queueDeclare(NAME, ...)`
*   **Ràng buộc (Binding):** `channel.queueBind(QUEUE_NAME, EXCHANGE, BINDING_KEY)`

### Pattern Matching Rules (Topic Exchange)
*   `*` (Sao): Thay thế **chính xác 1** từ. Ví dụ: `sensor.*` khớp `sensor.temp` nhưng không khớp `sensor.temp.room1`.
*   `#` (Thăng): Thay thế **0 hoặc nhiều** từ. Ví dụ: `sensor.#` khớp `sensor`, `sensor.temp`, `sensor.temp.room1`.

### IoT Cloud Terminology
*   **Producer:** Nguồn dữ liệu (App, Device, Script).
*   **Consumer:** Nơi xử lý dữ liệu (Service, Worker, Database Connector).
*   **Edge Computing:** Xử lý logic tại thiết bị biên (trước khi lên Cloud).
*   **Data Ingestion:** Quá trình đưa dữ liệu vào hệ thống (vai trò của RabbitMQ).



<!-- SECTION 185-190 -->

## learning (pages 185-190)

**Global Section Summary: Google Cloud IoT - Data Handling & Edge Computing**

- **Mục tiêu chính:** Mô tả kiến trúc xử lý dữ liệu của Google Cloud IoT, từ việc thu thập ban đầu đến phân tích, với trọng tâm vào khả năng mở rộng các tác vụ lên Cloud IoT Edge.

- **Các khái niệm cốt lõi:**
    - **Data Gathering:** Quá trình thu thập dữ liệu môi trường bởi cảm biến và thiết bị, bao gồm tiền xử lý, làm sạch dữ liệu trước khi truyền lên Cloud.
    - **Cloud IoT Edge:** Kiến trúc cho phép thực hiện xử lý dữ liệu thời gian thực và Machine Learning trực tiếp trên các thiết bị biên (Edge devices) thay vì chỉ trên Cloud.
    - **Data Analytics:** Phân tích dữ liệu và ML được tích hợp sâu với dữ liệu IoT, có thể triển khai trên Edge hoặc Cloud.

- **Phụ thuộc quan trọng:** Cần hiểu các khái niệm cơ bản về IoT và các thành phần phần cứng trong **Chương 1 (Tổng quan về IoT)** và **Chương 2 (Các công nghệ IoT)** để nắm bắt toàn diện luồng dữ liệu.

- **Từ khóa/Thuật ngữ:**
    *   **Edge Devices:** Thiết bị biên thực hiện xử lý cục bộ.
    *   **Data Ingestion:** Quá trình tiếp nhận dữ liệu vào hệ thống.
    *   **Edge ML:** Machine Learning chạy trên thiết bị biên.
    *   **Android Things OS:** Hệ điều hành dành cho IoT của Google.



<!-- CHUNK 185-190 -->

# HƯỚNG DẪN QUYẾT ĐỊNH KỸ THUẬT: Google Cloud IoT - Edge Computing & Data Handling

## Core Mental Model (Mô hình Nhận thức Cốt lõi)

Hãy tư duy hệ thống IoT không chỉ là "thiết bị gửi data lên cloud", mà là một **lưới xử lý phân tán**.

*   **The Cloud is the Brain (Cloud là Bộ não):** Xử lý khối lượng lớn dữ liệu lịch sử, đào tạo mô hình ML phức tạp, và tổng quan toàn hệ thống.
*   **The Edge is the Reflexes (Edge là Phản xạ):** Xử lý thời gian thực, giảm độ trễ, tiết kiệm băng thông bằng cách chỉ gửi dữ liệu quan trọng hoặc đã được "sàng lọc".
*   **Data Lifecycle (Chu kỳ đời dữ liệu):** Dữ liệu được xử lý càng sớm (gần nguồn cảm biến), giá trị và hiệu quả càng cao.

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Quyết định xử lý dữ liệu tại Edge hay Cloud

| Tiêu chí | Edge Processing (Xử lý tại Biên) | Cloud Processing (Xử lý trên Cloud) |
| :--- | :--- | :--- |
| **Độ trễ (Latency)** | **Siêu thấp (< 10ms)**. Phản ứng tức thời cho các hệ thống an toàn hoặc điều khiển tự động. | **Cao hơn**. Phụ thuộc vào tốc độ mạng và khoảng cách địa lý. |
| **Băng thông (Bandwidth)** | **Tiết kiệm**. Chỉ gửi kết quả hoặc dữ liệu bất thường (Anomaly). | **Tiêu thụ cao**. Cần đường truyền ổn định cho dữ liệu thô hoặc liên tục. |
| **Năng lượng (Power)** | **Hạn chế**. Yêu cầu tối ưu hóa thuật toán cho thiết bị pin. | **Không hạn chế**. Dễ dàng chạy các mô hình ML cồng kềnh. |
| **Tính phức tạp** | **Phức tạp**. Phải tối ưu code, quản lý tài nguyên phần cứng hạn chế. | **Đơn giản**. Dễ dàng scale tài nguyên (thêm CPU/RAM) khi cần. |
| **Khi nào chọn?** | Hệ thống robotic, xe tự lái, hệ thống cảnh báo cháy nổ tức thời. | Phân tích xu hướng dài hạn, training model dự báo xu hướng thị trường. |

### Bảng 2: Phân tích ML (Machine Learning) tại Edge

| Phân loại | **Edge ML** | **Cloud ML** |
| :--- | :--- | :--- |
| **Vai trò** | **Inference (Suy luận)**: Chạy mô hình đã được train sẵn để nhận diện sự kiện ngay lập tức. | **Training (Đào tạo)**: Huấn luyện mô hình từ dữ liệu khổng lồ. |
| **Ví dụ thực tế** | Camera nhận diện khuôn mặt mở cửa tự động (không cần internet). | Camera gửi video đám mây để học hành vi kẻ gian. |
| **Hệ điều hành** | Android Things OS, Linux-based OS. | Google Cloud AI Platform. |

## Architecture (Kiến Trúc)

Kiến trúc luồng dữ liệu chuẩn của Google Cloud IoT (từ Edge lên Cloud):

1.  **Edge Layer (Biên):**
    *   **Sensors/Devices:** Thu thập dữ liệu thô (nhiệt độ, hình ảnh...).
    *   **Edge IoT Core:** Nhận dữ liệu từ sensors -> **Tiền xử lý (Preprocessing)** -> **Làm sạch dữ liệu (Data Cleaning)**.
    *   **Edge ML:** Thực hiện suy luận (Inference) ngay tại chỗ.
2.  **Network Layer (Mạng):**
    *   Giao thức MQTT/AMQP để truyền dữ liệu lên Cloud một cách hiệu quả.
3.  **Cloud Layer (Mây):**
    *   **Cloud IoT Core:** Tiếp nhận dữ liệu (Ingest) và quản lý thiết bị.
    *   **Data Analytics & ML:** Xử lý tổng hợp, training model nâng cao, lưu trữ dữ liệu lịch sử.

## Code Patterns (Mã Mẫu)

Mô phỏng quy trình xử lý kép: Tiền xử lý tại Edge và Gửi data lên Cloud.

**Mô tả:** Một thiết bị Edge (giả lập) thu thập nhiệt độ, lọc nhiễu tại chỗ và chỉ gửi lên Cloud khi cần.

```python
import random
import time
import json

# Cấu hình Edge Device
DEVICE_ID = "sensor-edge-01"
THRESHOLD = 50.0  # Ngưỡng cảnh báo

def read_sensor_data():
    """Mô phỏng đọc cảm biến ngẫu nhiên (có nhiễu)"""
    return random.uniform(20.0, 80.0)

def edge_preprocessing(data):
    """
    Edge Processing (Xử lý tại biên):
    - Tiền xử lý: Lọc dữ liệu (nếu âm tính hoặc lỗi)
    - Kiểm tra ngưỡng
    """
    if data < 0: return None  # Loại bỏ dữ liệu lỗi
    
    # Logic Edge ML đơn giản: Tự động tắt thiết bị nếu quá nhiệt
    if data > THRESHOLD:
        print(f"[Edge ML Action] Tạm dừng thiết bị do nhiệt độ cao: {data}")
        return None # Dữ liệu không được gửi lên Cloud ngay
        
    return {"temp": round(data, 2), "device_id": DEVICE_ID}

def send_to_cloud(data):
    """Giả lập gửi dữ liệu đã xử lý lên Cloud IoT Core"""
    if data:
        payload = json.dumps(data)
        print(f"[Cloud Ingest] Đã gửi payload: {payload}")

# Vòng lặp chính (Running Loop)
if __name__ == "__main__":
    print("Hệ thống Edge đang hoạt động...")
    try:
        while True:
            raw_data = read_sensor_data()
            
            # 1. Edge Processing
            processed_data = edge_preprocessing(raw_data)
            
            # 2. Cloud Ingestion (Chỉ thực hiện nếu dữ liệu hợp lệ)
            send_to_cloud(processed_data)
            
            time.sleep(2)
    except KeyboardInterrupt:
        print("\nTắt hệ thống.")
```

## Anti-Patterns (Các sai lầm cần tránh)

1.  **"Nhồi nhét Cloud" (Cloud Stuffing):**
    *   *Hành vi:* Gửi toàn bộ dữ liệu thô (Raw Data) từ hàng nghìn cảm biến lên Cloud每 giây.
    *   *Hệ quả:* Tốn băng thông, chi phí Cloud c cực kỳ cao, xử lý chậm.
    *   *Giải pháp:* Luôn thực hiện lọc dữ liệu và giảm mẫu (Downsampling) ở Layer Edge trước.

2.  **"Quên chế độ Offline" (Ignoring Offline Mode):**
    *   *Hành vi:* Viết ứng dụng IoT không có cơ chế lưu trữ tạm thời khi mạng mất kết nối.
    *   *Hệ quả:* Mất dữ liệu vĩnh viễn khi mất mạng.
    *   *Giải pháp:* Sử dụng bộ nhớ đệm (Cache/Queue) trên thiết bị Edge để giữ dữ liệu tạm và đồng bộ lại khi mạng phục hồi.

3.  **"ML sai chỗ" (Wrong ML Placement):**
    *   *Hành vi:* Chạy mô hình ML c cực lớn (vd: YOLOv5full) trên thiết bị vi điều khiển (MCU) có RAM 512KB.
    *   *Hệ quả:* Thiết bị treo, phản hồi chậm, nhanh hết pin.
    *   *Giải pháp:* Cắt nhỏ model (Quantization) hoặc chỉ chạy ML trên Edge nếu thiết bị có hỗ trợ NPU/Strong CPU (Android Things/Linux).

## Cheat Sheet (Bảng Tra Nhanh)

| Thuật ngữ | Định nghĩa | Ứng dụng |
| :--- | :--- | :--- |
| **Edge Device** | Thiết bị biên có khả năng tính toán (không chỉ là Sensor). | Raspberry Pi, Gateway, Camera thông minh. |
| **Data Ingestion** | Quá trình tiếp nhận dữ liệu vào hệ thống. | Cloud IoT Core nhận MQTT packet. |
| **Edge ML** | Machine Learning chạy tại chỗ (On-device). | Nhận diện giọng nói tại điểm truy cập Wi-Fi. |
| **Android Things OS** | Hệ điều hành IoT chuyên biệt của Google. | Dùng cho các thiết bị Edge tiêu chuẩn cao. |
| **Preprocessing** | Làm sạch/chuẩn hóa dữ liệu trước khi dùng. | Biến đổi analog ADC -> giá trị thực (Nhiệt độ). |



<!-- SECTION 191-196 -->

## Chương 3. Lập trình ứng dụng IoT (pages 191-196)

**Global Section Summary**

Phần này trình bày các cấp độ lập trình thiết bị IoT từ vi điều khiển 8-bit đến vi xử lý 32/64-bit có hệ điều hành, tập trung vào ESP32. Mục tiêu là làm chủ lập trình firmware và giao tiếp mạng. Các khái niệm cốt lõi bao gồm:
- Các cấp thiết bị IoT (8-bit, 32-bit, SoC/Linux).
- Chuẩn giao tiếp ngoại vi (GPIO, UART, SPI, I2C).
- Giao thức mạng (HTTP, MQTT, Wi-Fi).
- Hệ điều hành thời gian thực (FreeRTOS).
Phụ thuộc: Cần hiểu cơ sở vi điều khiển trước. Thuật ngữ nhớ: ESP32, Firmware, GPIO, HTTP, MQTT, FreeRTOS.



<!-- CHUNK 191-196 -->

# DEVELOPER DECISION GUIDE: Lập trình Ứng dụng IoT

## Core Mental Model (Mô hình nhận thức cốt lõi)

Hãy tư duy IoT như một cơ thể sinh học: **Vi điều khiển là hệ thần kinh trung ương (Firmware)**, **Cảm biến là giác quan (Input)**, **Thiết bị điều khiển là cơ bắp (Output)**, và **Mạng là hệ thần kinh ngoại biên (Giao tiếp Cloud)**.

1.  **The Device Spectrum (Phổ Thiết bị):** IoT không đồng nhất.
    *   **Low-end (8-bit):** "Bộ não sâu" - Tối ưu điện năng, chạy死循环 (Ví dụ: ATmega). Chỉ làm 1 việc cực tốt.
    *   **Mid-range (32-bit SoC):** "Bộ não côn trùng" - Có Wi-Fi, chạy RTOS (Ví dụ: ESP32). *Đây là trọng tâm của IoT hiện đại.*
    *   **High-end (Linux Board):** "Bộ não động vật có vú" - Máy tính mini, đa tác vụ (Ví dụ: Raspberry Pi).
2.  **Firmware là Linh hồn:** Code chạy trên phần cứng (ESP32) quyết định độ ổn định và phản hồi thời gian thực (Real-time). Cloud chỉ là nơi lưu trữ và phân tích.

---

## Decision Tables (Bảng Quyết định Kỹ thuật)

### Bảng 1: Chọn Cấp độ Thiết bị IoT

| Tiêu chí | Vi điều khiển (8-bit) | Vi xử lý SoC (32-bit - ESP32) | Máy tính nhúng (Linux - RPi) |
| :--- | :--- | :--- | :--- |
| **Ví dụ** | ATmega, PIC | **ESP32** (Khuyến nghị) | Raspberry Pi |
| **Hệ điều hành** | Không (Bare-metal) | FreeRTOS (Real-time OS) | Embedded Linux (Ubuntu) |
| **Kết nối** | GPIO, UART, I2C | **Wi-Fi, Bluetooth**, GPIO, SPI | Ethernet, Wi-Fi, USB |
| **Nhiệt độ** | -40°C ~ +85°C | -40°C ~ +125°C (Công nghiệp) | 0°C ~ 70°C (Tiêu dùng) |
| **Khi nào dùng?** | Nguồn pin 3V, ngủ đông 1 năm, logic đơn giản (Sensor node). | **IoT Wi-Fi thông minh**, gateway trung gian, xử lý logic trung bình. | Camera AI, Interface复杂, cần Linux tool (Python/Java). |

### Bảng 2: Giao thức Giao tiếp & Truyền dữ liệu

| Giao thức | Vai trò | Ứng dụng trên ESP32 | Lựa chọn khi nào? |
| :--- | :--- | :--- | :--- |
| **GPIO** | Điều khiển/Tương tác vật lý | Bật LED, Đọc nút nhấn | Luôn có ở mọi thiết bị. |
| **UART** | Giao tiếp song công nối tiếp | Nối module GPS, Debug | Truyền tải ổn định ngắn-distance. |
| **I2C / SPI** | Giao tiếp đa thiết bị (Bus) | Kết nối nhiều sensor (BMP280, OLED) | Tiết kiệm pin, đa thiết bị. |
| **HTTP (REST)** | Giao tiếp Web (Request/Response) | Gửi dữ liệu lên Web API | Cần request/response rõ ràng, human-readable. |
| **MQTT** | Publish/Subscribe (Nhẹ, 1-1 hoặc 1-nhiều) | **IoT Cloud**, điều khiển từ xa | **Nên dùng nhất cho IoT**: Tiết kiệm băng thông, giữ kết nối (Keep-alive). |

---

## Architecture (Kiến trúc ứng dụng ESP32)

Kiến trúc chuẩn cho một thiết bị IoT Mid-range (ESP32) bao gồm 3 lớp chính:

1.  **Hardware Abstraction Layer (HAL):**
    *   Xử lý GPIO (Đèn, Còi), ADC (Đo pin), I2C (Sensor).
2.  **RTOS Layer (FreeRTOS):**
    *   Quản lý tác vụ song song (Multitasking).
    *   *Task 1:* Đọc sensor (1 giây/lần).
    *   *Task 2:* Xử lý MQTT (Nếu có tin nhắn đến).
    *   *Task 3:* Cập nhật Firmware (OTA).
3.  **Application Logic:**
    *   Logic nghiệp vụ: "Nếu nhiệt độ > 50°C -> Gửi cảnh báo MQTT".

---

## Code Patterns (Mẫu Code ESP32)

### Pattern 1: Kết nối Wi-Fi (Bắt buộc)
Sử dụng thư viện `WiFi.h`. Code phải xử lý vòng lặp kết nối lại nếu mất mạng.

```cpp
#include <WiFi.h>

const char* ssid = "Your_SSID";
const char* password = "Your_Password";

void setup() {
  Serial.begin(115200);
  
  // Bắt đầu kết nối
  WiFi.begin(ssid, password);
  Serial.print("Đang kết nối WiFi");

  // Chờ cho đến khi kết nối thành công (Timeout 10s)
  int timeout = 0;
  while (WiFi.status() != WL_CONNECTED && timeout < 20) {
    delay(500);
    Serial.print(".");
    timeout++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nĐã kết nối! IP: " + WiFi.localIP().toString());
  } else {
    Serial.println("\nKết nối thất bại!");
  }
}

void loop() {
  // Logic ứng dụng ở đây
}
```

### Pattern 2: Giao tiếp MQTT (IoT Cloud)
Sử dụng thư viện `PubSubClient.h`. MQTT giúp gửi dữ liệu tiết kiệm pin và băng thông.

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

// Cấu hình Broker (Ví dụ: HiveMQ public broker)
const char* mqtt_server = "broker.hivemq.com";
const int mqtt_port = 1883;
const char* topic_pub = "iot/device/data";

WiFiClient espClient;
PubSubClient client(espClient);

void reconnect() {
  while (!client.connected()) {
    Serial.print("Đang kết nối MQTT...");
    // Tạo ID duy nhất
    String clientId = "ESP32Client-" + String(random(0xffff), HEX);
    
    if (client.connect(clientId.c_str())) {
      Serial.println("Đã kết nối MQTT");
    } else {
      Serial.print("Thất bại, rc=");
      Serial.print(client.state());
      delay(2000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  // ... Code kết nối WiFi (xem Pattern 1) ...
  client.setServer(mqtt_server, mqtt_port);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();

  // Gửi dữ liệu mỗi 5 giây
  static unsigned long lastMsg = 0;
  if (millis() - lastMsg > 5000) {
    String msg = "{\"temp\": 35, \"humidity\": 60}";
    Serial.print("Gửi: ");
    Serial.println(msg);
    client.publish(topic_pub, msg.c_str());
    lastMsg = millis();
  }
}
```

### Pattern 3: Multitasking với FreeRTOS (Nâng cao)
ESP32 là song song thực sự. Tách biệt tác vụ đọc cảm biến và xử lý mạng.

```cpp
// Task 1: Đọc sensor chạy trên Core 0
void readSensorTask(void * parameter) {
  for(;;) {
    // Đọc giá trị cảm biến
    // Đảm bảo không block vòng lặp này quá lâu
    vTaskDelay(1000 / portTICK_PERIOD_MS); // Chờ 1 giây
  }
}

// Task 2: Xử lý mạng chạy trên Core 1
void mqttTask(void * parameter) {
  for(;;) {
    // Kiểm tra tin nhắn MQTT hoặc reconnect
    // Xử lý logic nhanh
    vTaskDelay(10 / portTICK_PERIOD_MS); 
  }
}

void setup() {
  Serial.begin(115200);
  
  // Tạo các task
  xTaskCreatePinnedToCore(readSensorTask, "SensorTask", 10000, NULL, 1, NULL, 0);
  xTaskCreatePinnedToCore(mqttTask, "MqttTask", 10000, NULL, 1, NULL, 1);
}

void loop() {
  // Loop chính có thể bỏ trống nếu đã dùng Task
  vTaskDelete(NULL);
}
```

---

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Blocking Code (Code Chặn/Lock):**
    *   *Lỗi:* Dùng `delay()` lâu hoặc vòng lặp vô hạn chờ input/serial.
    *   *Hậu quả:* Device bị "đóng băng", không thể phản hồi mạng hoặc sensor khác.
    *   *Khắc phục:* Luôn dùng `millis()` (Arduino) hoặc `FreeRTOS Delay` để nhường CPU.

2.  **Tràn Stack (Stack Overflow):**
    *   *Lỗi:* Khai báo biến quá lớn (mảng lớn) bên trong hàm `task` hoặc đệ quy.
    *   *Hậu quả:* Crash bí ẩn, khó debug.
    *   *Khắc phục:* Khai báo biến lớn dưới dạng `static` hoặc `global`. Tăng độ sâu Stack cho task (default通常是 1KB - 4KB).

3.  **Wi-Fi Station List (Lưu trữ Wi-Fi sai cách):**
    *   *Lỗi:* Hardcode SSID/Pass trong code cho hàng loạt device.
    *   *Hậu quả:* Phải up code lại khi đổi Pass Wi-Fi.
    *   *Khắc phục:* Lưu SSID/Pass vào **EEPROM** hoặc **Flash Memory** của ESP32, hoặc dùng **Bluetooth Provisioning** để cấu hình từ App điện thoại.

4.  **OTA không an toàn:**
    *   *Lỗi:* Cập nhật Firmware (OTA) không kiểm tra chữ ký (Signature).
    *   *Hậu quả:* Hacker có thể upload virus brick device.
    *   *Khắc phục:* Luôn dùng OTA qua HTTPS hoặc có cơ chế verify mã hash.

---

## Cheat Sheet (Bảng tra nhanh ESP32)

### Biến & Kiểu dữ liệu
*   `uint8_t` ~ `byte`: 0-255.
*   `unsigned long`: Dùng cho `millis()` (chống tràn số).
*   `String`: Dễ dùng nhưng gây fragment memory (nên dùng `char[]` cho device chạy lâu dài).

### GPIO (Điều khiển chân)
*   `INPUT_PULLUP`: Kích hoạt điện trở kéo lên (không cần nối thêm resistor cho nút bấm).
*   `OUTPUT`: Để điều khiển LED/Relay.
*   `analogRead(PIN)`: Đọc giá trị 0-4095 (12-bit).
*   `digitalWrite(PIN, LOW/HIGH)` : Bật/Tắt.

### Libraries chính
*   **Wi-Fi:** `WiFi.h`
*   **MQTT:** `PubSubClient.h`
*   **HTTP:** `HTTPClient.h`
*   **FreeRTOS:** Đã tích hợp sẵn, dùng hàm `xTaskCreate`.

### Câu lệnh Real-time (Thay thế delay)
*   **Arduino:** `if (millis() - previousTime > interval)`
*   **FreeRTOS:** `vTaskDelay(pdMS_TO_TICKS(1000))`



<!-- SECTION 197-237 -->

## programming (pages 197-237)

**Mục tiêu chính:** Giới thiệu môi trường và cú pháp lập trình Arduino (ESP32) để điều khiển phần cứng, giao tiếp ngoại vi và kết nối mạng IoT.

**Các khái niệm cốt lõi:**
*   **Cấu trúc Arduino:** Hàm `setup()` (khởi tạo) và `loop()` (vòng lặp chính).
*   **GPIO Control:** Đọc/ghi tín hiệu digital (`pinMode`, `digitalRead/Write`), PWM.
*   **Giao tiếp Serial:** In debug, nhận dữ liệu (`Serial.begin`, `Serial.available`).
*   **Lập trình ESP32:** Cài đặt Board Manager, kết nối Wi-Fi (`WiFi.h`).
*   **Giao tiếp HTTP:** Gửi/Nhận dữ liệu lên server bằng `HTTPClient` (GET/POST).

**Phụ thuộc:**
*   Cần cài đặt Arduino IDE và Board ESP32 (từ Board Manager).
*   Cần đọc phần cài đặt Wi-Fi cho ESP32 trước khi thực hiện các ví dụ HTTP.

**Từ khoá cần nhớ:** `void setup()`, `void loop()`, `pinMode`, `digitalWrite`, `Serial.begin`, `WiFi.begin`, `HTTPClient`, `GET/POST`.



<!-- CHUNK 197-208 -->

# DEVELOPER DECISION GUIDE: Lập trình ESP32 với Arduino

Tài liệu này cung cấp các quyết định kỹ thuật cốt lõi, mẫu code và bảng tra nhanh để phát triển ứng dụng IoT trên ESP32 bằng Arduino IDE. Nó được thiết kế để các kỹ sư phần mềm có thể bắt đầu nhanh và tránh các lỗi thường gặp.

---

## Core Mental Model (Mô hình nhận thức cốt lõi)

Hãy coi ESP32 (và Arduino) là một hệ thống **vòng lặp sự kiện đơn luồng (Single-threaded Event Loop)**. Nó không có hệ điều hành đa nhiệm thời gian thực (RTOS) mặc định trong các ví dụ cơ bản, mà chạy tuần tự các lệnh trong `loop()`.

1.  **Hàm `setup()` (Khởi tạo):** Chạy **một lần duy nhất** khi thiết bị bật nguồn. Dùng để cấu hình phần cứng (GPIO, Wi-Fi, Serial).
2.  **Hàm `loop()` (Vòng lặp chính):** Chạy **liên tục vô hạn** sau `setup()`. Nơi bạn xử lý logic chính, đọc cảm biến, điều khiển actuators. Nếu bạn đặt một `delay(1000)` trong này, toàn bộ hệ thống sẽ "đóng băng" trong 1 giây.

**Quyết định:** Khi nào cần xử lý song song? Nếu bạn cần xử lý phức tạp (ví dụ: Web Server + blink LED), hãy cân nhắc sử dụng **FreeRTOS** (xen kẽ luồng) hoặc cấu trúc không đồng bộ, thay vì chỉ dựa vào vòng lặp đơn giản.

---

## Decision Tables (Bảng Quyết định Kỹ thuật)

Bảng này giúp bạn chọn đúng phương pháp cho tác vụ phần cứng và mạng.

### Bảng 1: Giao tiếp GPIO (Điều khiển phần cứng)

| Kịch bản | Chế độ (Mode) | Hàm xử lý | Kết quả |
| :--- | :--- | :--- | :--- |
| **Đèn LED / Relay (Đơn cấp)** | `OUTPUT` | `digitalWrite(pin, HIGH/LOW)` | Bật/Tắt hoàn toàn (0 hoặc 3.3V). |
| **Đèn LED mờ / Tiếng kêu (PWM)** | `OUTPUT` | `analogWrite(pin, 0-255)` | Tạo xung PWM để điều khiển độ mạnh (chân ESP32 cần dùng `ledcSetup` nếu dùng thư viện cũ). |
| **Nút bấm / Cảm biến (Đọc mức)** | `INPUT` | `digitalRead(pin)` | Đọc trạng thái cao/thấp (HIGH/LOW). |
| **Cảm biến áp suất / Nhiệt độ (Đọc tương tự)** | `INPUT` | `analogRead(pin)` | Đọc giá trị từ 0 đến 4095 (ADC 12-bit trên ESP32). |

### Bảng 2: Giao tiếp Mạng (IoT)

| Giao thức | Thư viện | Phù hợp khi... | Lưu ý băng thông |
| :--- | :--- | :--- | :--- |
| **HTTP GET** | `HTTPClient` | Lấy dữ liệu cảm biến từ Server, gọi API đơn giản. | Trung bình, có overhead header. |
| **HTTP POST** | `HTTPClient` | Gửi dữ liệu cảm biến (JSON) lên Server (Database). | Trung bình, bảo mật hơn GET. |
| **Serial (UART)** | `Serial` | Gỡ lỗi (Debug), giao tiếp với module GPS/GSM hoặc máy tính. | Thấp, điểm-điểm (Point-to-Point). |

---

## Architecture (Kiến trúc ứng dụng ESP32)

Một ứng dụng ESP32 chuẩn (ESP-IDF hoặc Arduino) có cấu trúc phần cứng logic như sau:

1.  **Microcontroller Unit (MCU):** Trái tim là ESP32 (Xtensa Dual-Core).
2.  **Peripheral Interface (Giao tiếp ngoại vi):**
    *   **GPIO:** Để điều khiển đèn, đọc nút.
    *   **I2C/SPI:** Để kết nối sensor cao cấp (Accelerometer, BME280), OLED screen.
    *   **UART (Serial):** Giao tiếp với PC hoặc module khác.
3.  **Network Stack (Ngăn xếp mạng):**
    *   **Wi-Fi Station Mode:** Kết nối vào Router internet.
    *   **Wi-Fi AP Mode:** Tạo hotspot riêng để cấu hình (thường dùng `WiFiManager`).
4.  **Application Logic (Nội bộ):** Vòng lặp chính xử lý dữ liệu và gọi hàm mạng.

**Quyết định Kiến trúc:**
*   **Edge Computing:** Đừng gửi tất cả dữ liệu thô lên Cloud. Hãy xử lý logic `if/else` trên ESP32 để giảm chi phí dữ liệu và độ trễ.
*   **OTA (Over-The-Antenna):** Luôn tích hợp sẵn thư viện OTA để update firmware từ xa mà không cần cắm cáp USB.

---

## Code Patterns (Mẫu Code ESP32)

Dưới đây là các mẫu code hoàn chỉnh, đã tối ưu cho ESP32.

### Pattern 1: Cấu trúc cơ bản (Blink + Non-blocking)

**Lưu ý:** Tránh `delay()` để hệ thống vẫn responsive.

```cpp
// Khai báo chân LED (Thường là chân 2 hoặc 22 trên ESP32 DevKit)
const int LED_PIN = 2; 
unsigned long lastTime = 0;
const long interval = 1000; 

void setup() {
  Serial.begin(115200);
  pinMode(LED_PIN, OUTPUT);
  Serial.println("System Started");
}

void loop() {
  // Kiểm tra thời gian thay vì delay
  unsigned long currentMillis = millis();
  
  if (currentMillis - lastTime >= interval) {
    lastTime = currentMillis;
    
    // Đảo trạng thái LED
    int state = digitalRead(LED_PIN);
    digitalWrite(LED_PIN, !state);
    
    Serial.print("LED toggled at: ");
    Serial.println(currentMillis);
  }
  
  // Các tác vụ khác có thể chạy ở đây mà không bị block
}
```

### Pattern 2: Gửi dữ liệu lên Server (HTTP POST)

Yêu cầu: Đã kết nối Wi-Fi. Gửi dữ liệu dạng JSON.

```cpp
#include <WiFi.h>
#include <HTTPClient.h>

const char* ssid = "Ten_Wifi_Cua_Ban";
const char* password = "Mat_Khau_Wifi";

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi Connected");
}

void loop() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    
    // Thay đổi URL của bạn
    http.begin("http://192.168.1.100:3000/api/data");
    http.addHeader("Content-Type", "application/json");

    // Tạo dữ liệu mẫu
    String payload = "{\"sensor\": \"temp\", \"value\": 25.5}";
    
    // Gửi POST request
    int httpResponseCode = http.POST(payload);

    if (httpResponseCode > 0) {
      String response = http.getString();
      Serial.println("Code: " + String(httpResponseCode));
      Serial.println(response);
    } else {
      Serial.print("Error on sending POST: ");
      Serial.println(httpResponseCode);
    }
    http.end();
  } else {
    Serial.println("WiFi Disconnected");
  }
  delay(5000); // Gửi mỗi 5 giây (có thể chấp nhận delay ở đây)
}
```

---

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Blocking Delay Hell:**
    *   *Sai:* Dùng `delay(5000)` trong vòng lặp chính. → Mất khả năng phản hồi Wi-Fi, không đọc được nút bấm, cảm biến bị trễ.
    *   *Đúng:* Dùng `millis()` hoặc RTOS Timer cho các tác vụ định kỳ.

2.  **Biến Toàn Cục (Global Variables) Tràn Lan:**
    *   *Sai:* Khai báo quá nhiều biến global không cần thiết.
    *   *Đúng:* Chỉ khai báo global cho những biến cần dùng giữa `setup()` và `loop()`, hoặc giữa các hàm. Giảm RAM tiêu thụ.

3.  **Không Kiểm Tra Kết Nối Wi-Fi:**
    *   *Sai:* Vào `loop()` là gửi HTTP ngay. Nếu Wi-Fi mất, ESP32 có thể bị crash hoặc reset do Watchdog timer.
    *   *Đúng:* Luôn có khối `if (WiFi.status() == WL_CONNECTED)` trước khi dùng mạng.

4.  **Quên Xử Lý Lỗi (No Error Handling):**
    *   *Sai:* Giả sử mạng luôn thành công.
    *   *Đúng:* Luôn kiểm tra mã trả về của HTTPClient (`httpResponseCode > 0`) và xử lý trường hợp mất gói tin.

---

## Cheat Sheet (Bảng tra nhanh)

Danh sách hàm và thư viện phổ biến nhất cho ESP32 (Arduino).

| Chức năng | Thư viện | Cú pháp / Ghi chú |
| :--- | :--- | :--- |
| **Khởi tạo Serial** | `<HardwareSerial.h>` | `Serial.begin(115200);` (Baudrate cao để ổn định) |
| **Cấu hình GPIO** | Arduino Core | `pinMode(2, OUTPUT);` |
| **Ghi Output** | Arduino Core | `digitalWrite(2, HIGH);` |
| **Đọc Input** | Arduino Core | `int val = digitalRead(4);` |
| **Đọc Analog** | Arduino Core | `int val = analogRead(34);` (Chân 34, 35, 32, 33 là Input chỉ đọc) |
| **Kết nối Wi-Fi** | `<WiFi.h>` | `WiFi.begin(ssid, pass);` |
| **Kiểm tra Wi-Fi** | `<WiFi.h>` | `WiFi.status() == WL_CONNECTED` |
| **Gửi HTTP** | `<HTTPClient.h>` | `http.begin(url); http.POST(data);` |
| **OTA Update** | `<ArduinoOTA.h>` | Cho phép upload code qua Wi-Fi (cần cấu hình trong `setup()`) |
| **Delay Non-Block** | Arduino Core | `millis()` thay cho `delay()` |



<!-- CHUNK 209-220 -->

# DEVELOPER DECISION GUIDE: Lập trình ESP32 với Arduino (IoT Core)

## Core Mental Model (Mô hình nhận thức cốt lõi)

Hãy xem ESP32 là một cỗ máy **state-machine** chạy liên tục trong `loop()`, nơi việc tương tác phần cứng và mạng phụ thuộc hoàn toàn vào việc quản lý trạng thái và ngoại lệ (exception) đúng cách.

1.  **Vòng đời chuẩn (Lifecycle):**
    *   `setup()`: Khởi tạo duy nhất một lần. Cấu hình GPIO, Serial, và kết nối mạng (phải thành công trước khi vào `loop()`).
    *   `loop()`: Vòng lặp vô hạn. Xử lý cảm biến, gửi nhận dữ liệu mạng, và điều khiển actuator.

2.  **Blocking vs. Non-blocking:**
    *   Hàm `delay()` (blocking) tạm dừng toàn bộ vi điều khiển. Trong IoT, điều này gây treo kết nối Wi-Fi hoặc bỏ lỡ gói tin.
    *   **Principle:** Cấu trúc code để xử lý song song (ví dụ: cập nhật cảm biến mỗi 1 giây, nhưng vẫn lắng nghe network socket).

3.  **Quản lý bộ nhớ (Memory Management):**
    *   ESP32 có RAM hạn chế (300-500KB free). Khi làm việc với HTTP (JSON/String), tránh tạo chuỗi lớn liên tục trong `loop()`.

---

## Decision Tables (Bảng Quyết định Kỹ thuật)

### Bảng 1: Chọn phương thức giao tiếp HTTP

| Kịch bản | Phương thức | Cấu trúc dữ liệu | Ví dụ Code ESP32 |
| :--- | :--- | :--- | :--- |
| **Yêu cầu dữ liệu (Read)** | `GET` | Truyền tham số qua **URL Query** (`?key=value`). Dữ liệu nhỏ, không nhạy cảm. | `http.GET()` với URL `.../api?temp=25` |
| **Gửi dữ liệu an toàn/lớn (Create/Update)** | `POST` | Truyền trong **Body** (JSON hoặc Form). Dữ liệu lớn, ẩn. | `http.POST("{\"data\":123}")` |
| **Xác thực (Auth)** | `GET` / `POST` | Token trong **Header** (`Authorization: Bearer ...`). | `http.addHeader("Authorization", token)` |

### Bảng 2: Kiểm soát trạng thái Wi-Fi

| Trạng thái `WiFi.status()` | Ý nghĩa | Hành động của Developer |
| :--- | :--- | :--- |
| `WL_CONNECTED` | Đã kết nối | Thực hiện logic IoT (HTTP, MQTT). |
| `WL_CONNECT_FAILED` | Sai mật khẩu/SSID | Dừng lại, yêu cầu reset hoặc cấu hình lại. |
| `WL_NO_SSID_AVAIL` | SSID không tồn tại | Kiểm tra vùng phủ sóng hoặc tên Wi-Fi. |
| `WL_DISCONNECTED` | Đang ngắt kết nối | Thử reconnect (`WiFi.begin()`), tránh spam request HTTP. |

---

## Architecture (Kiến trúc ứng dụng IoT)

Với ESP32 sử dụng Arduino Core, kiến trúc "Thin Loop" là tối ưu nhất.

**Luồng xử lý (Flow):**

1.  **Boot (`setup`):**
    *   `Serial.begin(115200)`: Để debug.
    *   `WiFi.begin(ssid, pass)`: Kết nối mạng. **Lưu ý:** Dùng vòng lặp `while` để đợi kết nối, nhưng đặt timeout (ví dụ 30s) để tránh brick thiết bị.
2.  **Thực thi (`loop`):**
    *   **Kiểm tra Wi-Fi:** Nếu mất kết nối -> Tự động Reconnect.
    *   **Thu thập dữ liệu:** Đọc cảm biến (GPIO/ADC).
    *   **Gửi dữ liệu (Reporting):** Tạo HTTP Client, đóng gói dữ liệu, gửi đi.
    *   **Xử lý phản hồi:** Đọc response code (200 OK, 404 Not Found...).
    *   **Sleep/Wait:** Dùng `delay()` **hoặc** cơ chế timer để tiết kiệm pin.

---

## Code Patterns (Mẫu Code ESP32)

### Pattern 1: Kết nối Wi-Fi An toàn (Có Timeout)
Ngắt kết nối nếu vượt quá thời gian chờ để tránh treo máy.

```cpp
#include <WiFi.h>

const char* ssid = "Your_SSID";
const char* password = "Your_PASS";

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  
  int timeout = 0;
  while (WiFi.status() != WL_CONNECTED && timeout < 20) { // ~10s timeout
    delay(500);
    Serial.print(".");
    timeout++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConnected!");
  } else {
    Serial.println("\nFailed to connect.");
    // Logic fallback here (e.g., enter deep sleep)
  }
}
void loop() { }
```

### Pattern 2: HTTP GET Request (Lấy dữ liệu)
Gửi dữ liệu cảm biến qua URL để server xử lý.

```cpp
#include <HTTPClient.h>

void sendGetRequest(float temp) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    // Tạo URL với tham số
    String serverPath = "http://yourserver.com/api?temp=" + String(temp);
    
    http.begin(serverPath.c_str());
    int httpResponseCode = http.GET();

    if (httpResponseCode > 0) {
      String payload = http.getString();
      Serial.println(payload);
    } else {
      Serial.print("Error: ");
      Serial.println(httpResponseCode);
    }
    http.end();
  }
}
```

### Pattern 3: HTTP POST Request (Gửi JSON)
Hiện đại và an toàn hơn khi gửi dữ liệu phức tạp.

```cpp
#include <HTTPClient.h>
#include <ArduinoJson.h> // Cần cài thư viện ArduinoJson

void sendPostRequest(float temp, float humid) {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin("http://yourserver.com/api/update");
    http.addHeader("Content-Type", "application/json");

    // Tạo JSON Payload
    String jsonPayload = "{\"temperature\":" + String(temp) + ",\"humidity\":" + String(humid) + "}";
    
    int httpResponseCode = http.POST(jsonPayload);
    Serial.println("Response code: " + String(httpResponseCode));
    http.end();
  }
}
```

### Pattern 4: GPIO & PWM (Điều khiển phần cứng)
Sử dụng `ledc` cho ESP32 để tạo xung PWM (điều khiển độ sáng/tốc độ).

```cpp
const int ledPin = 2;      // Chân LED tích hợp
const int pwmChannel = 0;  // Channel 0-15
const int freq = 5000;     // Tần số 5kHz
const int resolution = 8;  // 8-bit resolution (0-255)

void setup() {
  // Cấu hình PWM cho ESP32
  ledcSetup(pwmChannel, freq, resolution);
  ledcAttachPin(ledPin, pwmChannel);
}

void loop() {
  // Fade LED
  for (int dutyCycle = 0; dutyCycle <= 255; dutyCycle++) {
    ledcWrite(pwmChannel, dutyCycle);
    delay(10);
  }
  for (int dutyCycle = 255; dutyCycle >= 0; dutyCycle--) {
    ledcWrite(pwmChannel, dutyCycle);
    delay(10);
  }
}
```

---

## Anti-Patterns (Các sai lầm cần tránh)

| Sai lầm (Bad) | Hậu quả | Giải pháp (Good) |
| :--- | :--- | :--- |
| **Dùng `delay()` trong vòng lặp mạng** | Làm ESP32 không thể xử lý packet Wi-Fi, gây mất kết nối (Disconnect) hoặc watchdog reset. | Sử dụng `millis()` để tạo timer không blocking hoặc dùng RTOS (FreeRTOS) của ESP32. |
| **Nối tiếp chuỗi String (`String + String`)** | Gây phân mảnh bộ nhớ (Fragmentation), dẫn đến crash bộ nhớ sau thời gian dài chạy. | Sử dụng `String.reserve()` hoặc dùng `char array` và `snprintf`. |
| **Gửi HTTP liên tục không kiểm tra Wi-Fi** | Làm tràn buffer log, pin hết nhanh, server bị spam. | Kiểm tra `WiFi.status()` trước khi khởi tạo `HTTPClient`. Chỉ gửi khi có thay đổi dữ liệu. |
| **Quên xử lý lỗi HTTP** | Không biết tại sao dữ liệu không đến server. | Luôn in `httpResponseCode` và `http.getString()` (payload) để debug. |

---

## Cheat Sheet (Bảng tra nhanh)

### Cấu trúc cơ bản
```cpp
void setup() { /* Khởi tạo */ }
void loop() { /* Lặp */ }
```

### GPIO & Serial
*   `pinMode(PIN, OUTPUT/INPUT);`
*   `digitalWrite(PIN, HIGH/LOW);`
*   `digitalRead(PIN);`
*   `Serial.begin(115200);`
*   `Serial.println("Debug");`

### Wi-Fi & HTTP
*   `WiFi.begin(ssid, password);`
*   `WiFi.status() == WL_CONNECTED`
*   `HTTPClient http;`
*   `http.begin(url);`
*   `int code = http.GET();`
*   `int code = http.POST(data);`
*   `http.end();` (Quan trọng: giải phóng bộ nhớ)

### EPS32 PWM (Khác Arduino Uno)
*   `ledcSetup(channel, freq, resolution);`
*   `ledcAttachPin(pin, channel);`
*   `ledcWrite(channel, dutyCycle);`



<!-- CHUNK 221-232 -->

# DEVELOPER DECISION GUIDE: HTTP POST & Gửi Dữ Liệu ESP32

## Core Mental Model (Mô hình nhận thức cốt lõi)

*   **Request-Response (Yêu cầu - Phản hồi):** ESP32 đóng vai trò là **Client**. Nó thiết lập kết nối TCP/IP, tạo gói tin HTTP (GET/POST) và lắng nghe phản hồi từ **Server**.
*   **Payload Packaging (Đóng gói dữ liệu):** Dữ liệu cảm biến phải được chuyển đổi thành chuỗi ký tự theo chuẩn mà server yêu cầu (URL Encoded, JSON, Plain Text) trước khi gửi.
*   **Header Negotiation (Thỏa thuận tiêu đề):** `Content-Type` là bắt buộc. Nó thông báo cho server cách giải mã dữ liệu gửi lên. Sai `Content-Type` là nguyên nhân phổ biến nhất của lỗi `400 Bad Request`.
*   **Connection Lifecycle (Chu kỳ kết nối):** Kết nối HTTP là tài nguyên tốn kém. Phải gọi `http.end()` sau mỗi request để giải phóng bộ nhớ (RAM) trên ESP32.

## Decision Tables (Bảng Quyết định Kỹ thuật)

| Yêu cầu Dữ liệu | Phương thức | Content-Type | Cấu trúc dữ liệu | Khi nào dùng? |
| :--- | :--- | :--- | :--- | :--- |
| **Đơn giản, chèn tham số** | `GET` | Không cần (thường) | Query Parameters (`?key=value`) | Gửi yêu cầu đơn giản, không có body, hoặc không cần bảo mật dữ liệu (dữ liệu nhìn thấy được trong URL). |
| **Form HTML, Ứng dụng Web cũ** | `POST` | `application/x-www-form-urlencoded` | `key1=val1&key2=val2` | Tương thích với các form HTML chuẩn hoặc API đơn giản. Dễ đóng gói nhưng khó đọc với các cấu trúc dữ liệu phức tạp. |
| **API RESTful hiện đại (IoT)** | `POST` | `application/json` | `{"key": "value"}` | **Khuyến nghị cho ESP32.** Dễ dàng mở rộng cấu trúc dữ liệu, đọc/ghi dễ dàng, chuẩn mực ngành. |
| **Gửi file, blob** | `POST` | `text/plain` hoặc `multipart` | `Văn bản thô` | Gửi log, hoặc dữ liệu không cần structure (cấu trúc). |

## Architecture (Kiến trúc)

Luồng xử lý HTTP POST trên ESP32:

1.  **Kiểm tra kết nối (WiFi):** Nếu `WiFi.status() != WL_CONNECTED`, dừng vòng lặp. Không cố gửi khi offline.
2.  **Khởi tạo HTTP Client:** Tạo đối tượng `HTTPClient`.
3.  **Thiết lập URL:** `http.begin(serverName)`.
4.  **Thiết lập Header:** `http.addHeader("Content-Type", "...")`. Bước này quan trọng nhất.
5.  **Tạo Payload:** Nối chuỗi hoặc dùng thư viện `ArduinoJSON` để tạo chuỗi JSON/URL.
6.  **Gửi (POST):** `http.POST(payload)`. Hàm này trả về mã trạng thái (ví dụ: 200, 404, -1).
7.  **Xử lý Phản hồi:** Đọc `http.getString()` nếu cần, in ra Serial để debug.
8.  **Dọn dẹp:** `http.end()`.

## Code Patterns (Mẫu Code)

### Mẫu 1: POST URL Encoded (Cơ bản)
*Dùng cho các API cũ hoặc form đơn giản.*

```cpp
#include <WiFi.h>
#include <HTTPClient.h>

void sendURLEncoded() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String serverPath = "http://192.168.1.100/api/update";
    
    http.begin(serverPath);
    // Định nghĩa kiểu dữ liệu
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    
    // Tạo chuỗi dữ liệu (key=value&key2=value2)
    String httpRequestData = "sensor=BME280&temp=25.5&humidity=60";
    
    int httpResponseCode = http.POST(httpRequestData);

    if (httpResponseCode > 0) {
      Serial.print("HTTP Response code: ");
      Serial.println(httpResponseCode);
    }
    http.end(); // Giải phóng bộ nhớ
  }
}
```

### Mẫu 2: POST JSON Object (IoT Standard)
*Dùng cho các hệ thống hiện đại, yêu cầu cấu trúc dữ liệu rõ ràng.*

```cpp
#include <WiFi.h>
#include <HTTPClient.h>

void sendJSON() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    String serverPath = "http://192.168.1.100/api/json";
    
    http.begin(serverPath);
    http.addHeader("Content-Type", "application/json");

    // Tạo chuỗi JSON thủ công (cần atenção về dấu ngoặc kép)
    // Hoặc dùng thư viện ArduinoJSON để an toàn hơn
    String jsonPayload = "{\"device_id\":\"esp32_01\", \"temp\": 28.5, \"status\": 1}";
    
    int httpResponseCode = http.POST(jsonPayload);
    
    if (httpResponseCode > 0) {
      String response = http.getString();
      Serial.println(response);
    }
    http.end();
  }
}
```

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Gọi HTTP trong `loop()` không kiểm soát:**
    *   *Vấn đề:* Gửi request liên tục (không có `delay`) làm treo ESP32 hoặc gây overload cho server (nếu server yếu).
    *   *Sửa:* Luôn có `delay()` hoặc dùng `millis()` để timer khoảng cách giữa các lần gửi (ví dụ: 30 giây/lần).

2.  **Quên `http.end()`:**
    *   *Vấn đề:* Không giải phóng kết nối/TCP Socket → Rò rỉ bộ nhớ (Memory Leak) → ESP32 sẽ reboot sau vài giờ/tuần.
    *   *Sửa:* Cấu trúc code luôn bao gồm `http.end()` ngay cả khi có lỗi (dùng `try-catch` hoặc kiểm tra lỗi cẩn thận).

3.  **Sai cú pháp JSON:**
    *   *Vấn đề:* Thiếu dấu phẩy, sai dấu ngoặc kép trong chuỗi `String`. Server không parse được.
    *   *Sửa:* Dùng thư viện **ArduinoJSON** (đề cập trong tài liệu) để sinh chuỗi JSON an toàn thay vì nối chuỗi thủ công.

4.  **Bỏ qua HTTP Status Code:**
    *   *Vấn đề:* Cho rằng dữ liệu đã gửi thành công chỉ vì code không lỗi.
    *   *Sửa:* Luôn kiểm tra `if (httpResponseCode == 200)`.

## Cheat Sheet (Bảng tra nhanh)

| Nhiệm vụ | Hàm/Thư viện | Ví dụ |
| :--- | :--- | :--- |
| **Kết nối WiFi** | `WiFi.h` | `WiFi.begin(ssid, password);` |
| **Khởi tạo HTTP** | `HTTPClient.h` | `HTTPClient http;` |
| **Cấu hình URL** | `http.begin()` | `http.begin("http://example.com");` |
| **Set Header** | `http.addHeader()` | `http.addHeader("Content-Type", "application/json");` |
| **Gửi POST** | `http.POST()` | `int code = http.POST("data");` |
| **Gửi GET** | `http.GET()` | `int code = http.GET();` |
| **Đọc kết quả** | `http.getString()` | `String payload = http.getString();` |
| **Đóng kết nối** | `http.end()` | `http.end();` |



<!-- CHUNK 233-237 -->

# DEV DECISION GUIDE: Lập trình Nâng cao & Giao tiếp Mạng (ESP32)

Tài liệu này cung cấp quyết định kỹ thuật cho lập trình viên ESP32 tập trung vào Web Server, MQTT, và Real-time Multi-tasking.

---

## 1. Core Mental Model

*   **Event-Driven vs. Polling:** Lập trình IoT xoay quanh việc phản hồi sự kiện (Wi-Fi kết nối, HTTP request, MQTT message arrival). Tránh sử dụng `delay()` blocking trong vòng lặp chính.
*   **Single-Threaded Concurrency:** ESP32 (Arduino core) chạy đơn luồng. Để xử lý đồng thời Web/MQTT và cảm biến, cần hiểu về **Non-Blocking Code** hoặc **RTOS Tasks**.
*   **Publish-Subscribe (Pub/Sub):** Mô hình giao tiếp MQTT tách rời publisher và subscriber thông qua Broker, khác với model Client-Server trực tiếp của HTTP.

---

## 2. Architecture

### A. HTTP Client (Request/Response)
*   **Mục đích:** Gửi dữ liệu cảm biến lên Server (Webhook) hoặc lấy cấu hình.
*   **Cấu trúc:**
    1.  `WiFiClient`: Tạo kết nối TCP/IP nền tảng.
    2.  `HTTPClient`: Đóng gói request (GET/POST).
    3.  Gửi Request -> Đọc Response -> Giải phóng bộ nhớ.

### B. MQTT Client (Pub/Sub)
*   **Mục đích:** Điều khiển thiết bị realtime, nhận lệnh IoT.
*   **Cấu trúc:**
    1.  `WiFiClient` (truyền tải).
    2.  `PubSubClient`: Quản lý kết nối Broker, xử lý gói tin.
    3.  **Lưu ý bắt buộc:** Phải có cơ chế `reconnect()` để tự động kết nối lại nếu mất mạng.

### C. Web Server (Asynchronous)
*   **Mục đích:** Cung cấp giao diện điều khiển local hoặc API nội bộ.
*   **Lưu ý:** Web Server trên ESP32 là single-threaded. Không xử lý logic nặng trong event handler (closure) của HTTP request.

---

## 3. Decision Tables (Bảng Quyết Định)

### Bảng 1: Chọn Giao thức Truyền dữ liệu

| Kịch bản | Giao thức | Thư viện ESP32 | Ưu điểm | Nhược điểm |
| :--- | :--- | :--- | :--- | :--- |
| **Gửi dữ liệu cảm biến lên Cloud** | HTTP POST | `HTTPClient` | Đơn giản, tương thích web. | Cao overhead, không realtime. |
| **Điều khiển/Lệnh realtime** | MQTT | `PubSubClient` | Nhẹ, nhanh, giữ kết nối. | Cần Broker trung gian. |
| **Cấu hình/Liên lạc Intranet** | HTTP GET/Server | `WebServer` | Dễ dùng browser truy cập. | Chỉ hoạt động trong mạng LAN. |

### Bảng 2: Kiểu Lập trình ESP32

| Kiểu lập trình | Khi nào dùng? | Cấu trúc Code | Cấu hình |
| :--- | :--- | :--- | :--- |
| **Blocking (Arduino Simple)** | Dự án đơn giản, không cần đa tác vụ. | `loop()` có `delay()`. | Không cần RTOS. |
| **Non-Blocking** | Xử lý nhiều cảm biến + Web/MQTT. | Kiểm tra thời gian (`millis()`). | Arduino Core. |
| **Multi-task (FreeRTOS)** | Logic phức tạp, cần song song (ví dụ: xử lý ảnh + gửi mạng). | Tạo Task `xTaskCreate`. | Kích hoạt RTOS trong IDE. |

---

## 4. Code Patterns

### Pattern 1: HTTP POST Gửi Dữ Liệu (Non-Blocking)
*Dùng `millis()` để tránh `delay()`.*

```cpp
#include <WiFi.h>
#include <HTTPClient.h>

const char* ssid = "Your_SSID";
const char* pass = "Your_PASS";
const char* serverUrl = "http://example.com/api/data";

unsigned long lastTime = 0;
unsigned long timerDelay = 5000; // Gửi mỗi 5 giây

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, pass);
  while(WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
}

void loop() {
  // Non-blocking delay pattern
  if ((millis() - lastTime) > timerDelay) {
    if(WiFi.status() == WL_CONNECTED){
      HTTPClient http;
      http.begin(serverUrl);
      
      // POST Data
      int httpResponseCode = http.POST("{\"sensor\":\"BME280\",\"value\":24.5}");
      
      if(httpResponseCode > 0) {
        String response = http.getString();
        Serial.println(httpResponseCode);
        Serial.println(response);
      }
      http.end();
    }
    lastTime = millis();
  }
  // Logic khác chạy ở đây mà không bị delay chặn
}
```

### Pattern 2: MQTT Pub/Sub với Auto-Reconnect
*Xử lý ngắt kết nối mạng chủ động.*

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

const char* mqtt_server = "broker.hivemq.com";
WiFiClient espClient;
PubSubClient client(espClient);

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i = 0; i < length; i++) Serial.print((char)payload[i]);
  Serial.println();
}

// Hàm bắt buộc: Tự động kết nối lại MQTT
void reconnect() {
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    if (client.connect("ESP32Client")) {
      Serial.println("connected");
      client.subscribe("esp32/command"); // Subscribe ngay khi connect
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200);
  // Setup WiFi omitted for brevity
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop(); // phải gọi liên tục để xử lý tin nhắn đến
  
  // Logic khác...
}
```

---

## 5. Anti-Patterns (Các sai lầm cần tránh)

1.  **`delay()` trong `loop()` (Blocking):**
    *   *Lỗi:* Dùng `delay(1000)` để làm mượt cảm biến.
    *   *Hậu quả:* Web Server/MQTT bị "đóng băng", không nhận được lệnh điều khiển.
    *   *Sửa:* Dùng logic thời gian (`if (millis() - lastTime > interval)`).

2.  **Không xử lý HTTP Payload Size:**
    *   *Lỗi:* Tạo String lớn (`String payload = "["; for...`) rồi mới gửi.
    *   *Hậu quả:* Gây Fragmentation RAM, ESP32 bị Crash (OOM).
    *   *Sửa:* Gửi dữ liệu nhỏ hoặc dùng `client.print()` trực tiếp.

3.  **MQTT "Fire and Forget":**
    *   *Lỗi:* Gửi tin nhắn MQTT mà không kiểm tra `client.connected()` trước.
    *   *Hậu quả:* Mất gói tin quan trọng khi mạng chập chờn.
    *   *Sửa:* Luôn gọi `reconnect()` và kiểm tra trạng thái trước khi `publish()`.

---

## 6. Cheat Sheet (Bảng Tra Nhanh)

### HTTP Client (WiFiClient + HTTPClient)
*   `http.begin(url)`: Chuẩn bị request.
*   `http.POST(data)`: Gửi POST, trả về `int` (HTTP Code).
*   `http.getString()`: Đọc nội dung phản hồi.
*   `http.end()`: Giải phóng kết nối (Bắt buộc để tránh rò rỉ bộ nhớ).

### MQTT (PubSubClient)
*   `client.setServer()`: Cài địa chỉ Broker.
*   `client.setCallback()`: Cài hàm xử lý tin nhắn đến.
*   `client.loop()`: Duy trì kết nối và gọi Callback (Phải ở đầu `loop()`).
*   `client.publish(topic, payload)`: Gửi tin.
*   `client.subscribe(topic)`: Nhận tin.

### FreeRTOS (Lập trình đa tác vụ)
*   `void taskFunction(void * parameter) { ... }`: Định nghĩa tác vụ.
*   `xTaskCreate(taskFunction, "TaskName", 10000, NULL, 1, NULL)`: Khởi tạo tác vụ (Stack size 10k).
*   `vTaskDelay(1000 / portTICK_PERIOD_MS)`: Delay trong Task (không block các Task khác).
*   `vTaskDelete(NULL)`: Xóa Task hiện tại.



<!-- SECTION 238-249 -->

## xTaskCreate (pages 238-249)

**Global Section Summary**

Phần tài liệu này bao gồm hai chủ đề chính: Lập trình đa nhiệm với FreeRTOS và Xây dựng Web API.

- **Mục tiêu chính:** Giới thiệu cách tạo và quản lý tác vụ (task) sử dụng hàm `xTaskCreate` trong FreeRTOS, đồng thời trình bày các khái niệm cơ bản để xây dựng Web API RESTful.
- **Các khái niệm cốt lõi:**
    - **FreeRTOS:** Tạo task (`xTaskCreate`), hàm xử lý task (vòng lặp vô hạn `for(;;)`), tạm dừng tác vụ (`vTaskDelay`).
    - **Web API:** RESTful API, các phương thức HTTP (GET, POST, PUT, DELETE), mô hình MVC (Model-View-Controller), Routing.
- **Phụ thuộc quan trọng:** Cần hiểu cách hoạt động của vòng lặp vô hạn và hàm hoãn thời gian để lập trình task hiệu quả; kiến thức nền tảng về HTTP và C#/.NET để triển khai Web API.
- **Từ khoá/Thuật ngữ:** `xTaskCreate`, `vTaskDelay`, `portTICK_PERIOD_MS`, REST, HTTP methods (GET/POST/PUT/DELETE), ASP.NET Core, Entity Framework, MVC, Routing.



<!-- CHUNK 238-249 -->

# DEVELOPER DECISION GUIDE: FreeRTOS Tasks & Web API

Tài liệu này cung cấp hướng dẫn ra quyết định thực hành để tích hợp hệ thống nhúng đa nhiệm (FreeRTOS) với kiến trúc backend Web API (ASP.NET Core). Mục tiêu là đảm bảo tính ổn định của thiết bị và khả năng giao tiếp dữ liệu hiệu quả.

---

## 1. Core Mental Model

### Hiểu về "Cooperative Multitasking" (Đa nhiệm hợp tác)
Trong FreeRTOS, một tác vụ (Task) không bao giờ được chiếm quyền điều khiển CPU hoàn toàn (trừ khi có ngắt). Nó phải **chủ động nhường CPU** cho các tác vụ khác.
*   **Vấn đề:** Nếu bạn viết một vòng lặp `for(;;)` mà không có `vTaskDelay`, toàn bộ hệ thống sẽ bị treo (System Hang).
*   **Giải pháp:** Xem `vTaskDelay` như một mệnh đề `yield`. Hãy tự hỏi: "Tác vụ này cần nghỉ bao lâu trước khi cần làm việc lại?".

### Mô hình RESTful (Resource-Based)
Web API hoạt động dựa trên **Tài nguyên (Resource)** chứ không phải RPC (Remote Procedure Call).
*   **VRP (Virtual Resource Path):** Thay vì gọi hàm `GetTemperature()`, bạn request vào URL `/api/sensors/temperature`.
*   **Stateless:** Server không nhớ trạng thái trước đó của Client.

---

## 2. Architecture: Lớp Kỹ Thuật

Khi thiết kế hệ thống IoT hỗn hợp (Firmware + Cloud), hãy xác định ranh giới trách nhiệm rõ ràng:

| Lớp | Trách nhiệm | Công nghệ/Tiện ích |
| :--- | :--- | :--- |
| **Hardware Layer** | Đọc/Ghi tín hiệu vật lý, Timer interrupt. | Registers, ISR |
| **RTOS Layer** | Quản lý luồng xử lý (task), đồng bộ hóa, timing chính xác. | **`xTaskCreate`**, `vTaskDelay`, Queues |
| **Comm Layer** | Giao tiếp mạng (MQTT/HTTP), xử lý kết nối Wifi. | LWIP, ESP-IDF HTTP Client |
| **Backend API** | Lưu trữ dữ liệu, xử lý logic phức tạp, cung cấp giao diện Web. | **ASP.NET Core**, Entity Framework |

> **Quyết định quan trọng:** Không xử lý Logic phức tạp (như tính toán AI, Database) trên MCU. MCU chỉ nên là **Data Producer**, Backend là **Data Consumer & Logic Provider**.

---

## 3. Decision Tables (Bảng Quyết Định)

### 3.1. Cấu hình Task FreeRTOS

| Kịch bản | Cấp độ Ưu tiên (Priority) | Dung lượng Stack | Chiến lược Delay |
| :--- | :--- | :--- | :--- |
| **Blink LED / Heartbeat** | `Low` (0 hoặc 1) | 512 bytes | `vTaskDelay` khoảng dài (500ms+) |
| **Đọc Sensor định kỳ** | `Medium` (2 - 4) | 1024 - 2048 bytes | Phụ thuộc tần số sampling |
| **Xử lý Wifi/Network** | `High` (5 - 7) | Tối thiểu 4096 bytes | Dùng Event Group hoặc `vTaskDelay` ngắn |
| **Ngắt cứng (ISR)** | `N/A` | N/A | Không dùng `vTaskDelay` trong ISR |

### 3.2. Chọn phương thức HTTP cho Web API

| Phương thức | Ý nghĩa REST | Khi nào dùng (IoT Context) | Phản hồi phù hợp |
| :--- | :--- | :--- | `200 OK` hoặc `204 No Content` |
| **GET** | Read (Lấy dữ liệu) | ESP32 request lấy cấu hình mới hoặc Server poll dữ liệu cũ. | `200 OK` + JSON |
| **POST** | Create (Gửi dữ liệu) | ESP32 gửi dữ liệu Sensor lên Server (nhật ký, log). | `201 Created` |
| **PUT** | Update (Cập nhật) | Gửi lệnh điều khiển: "Bật đèn" (State: ON). | `200 OK` hoặc `204` |
| **DELETE** | Delete (Xóa) | Xóa file log, reset dữ liệu. | `200 OK` hoặc `410 Gone` |

---

## 4. Code Patterns

### Pattern 1: Vòng lặp vô hạn an toàn (Safe Infinite Loop)
Đây là mẫu code cơ bản nhất cho một Task FreeRTOS. Lưu ý cách tính toán độ trễ.

```c
// Mô hình: Producer (ESP32)
void SensorTask(void *pvParameters) {
    // Khai báo biến
    float temperature;
    
    for(;;) {
        // 1. Thực hiện công việc
        temperature = readSensor();
        
        // 2. Xử lý logic hoặc gửi Queue
        if (temperature > 30.0) {
            // Gửi cảnh báo
        }

        // 3. QUAN TRỌNG: Tạm dừng task
        // delay 1000 ticks. Nếu tick rate = 1000Hz, delay ~1s
        vTaskDelay(1000 / portTICK_PERIOD_MS); 
    }
}
```

### Pattern 2: Khai báo Controller Web API (.NET Core)
Mô hình MVC - Controller định nghĩa Routing và Logic phản hồi.

```csharp
// Mô hình: Consumer (Backend)
[Route("api/[controller]")]
[ApiController]
public class SensorsController : ControllerBase
{
    // Dependency Injection Database
    private readonly IoTContext _context;

    public SensorsController(IoTContext context) {
        _context = context;
    }

    // POST: api/sensors
    [HttpPost]
    public IActionResult PostSensorData([FromBody] SensorData data) {
        if (!ModelState.IsValid) return BadRequest();

        // Lưu vào Database
        _context.SensorLogs.Add(data);
        _context.SaveChanges();

        return CreatedAtAction(nameof(GetById), new { id = data.Id }, data);
    }
    
    // GET: api/sensors/5
    [HttpGet("{id}")]
    public IActionResult GetById(int id) {
        // Logic truy vấn...
        return Ok(new { value = 25.5 }); // Trả về JSON
    }
}
```

---

## 5. Anti-Patterns (Các sai lầm cần tránh)

1.  **"Busy Wait" trong Task:**
    *   *Code:* `while(1) { if (flag) doSomething(); }` (Không có delay).
    *   *Hậu quả:* CPU luôn ở 100%, các tác vụ khác bị chết đói (Starvation), watchdog timer reset hệ thống.
    *   *Sửa:* Luôn luôn đặt `vTaskDelay` hoặc dùng cơ chế Block (Queue/Semaphore).

2.  **Gửi dữ liệu real-time qua HTTP GET/POST quá thường xuyên:**
    *   *Code:* Gửi request HTTP mỗi 10ms để cập nhật UI.
    *   *Hậu quả:* Sập Server, pin ESP32 tụt nhanh, nghẽn mạng.
    *   *Sửa:* Dùng **Batching** (Gom dữ liệu) hoặc chuyển sang **MQTT** (Lightweight Protocol).

3.  **Lồng API Controller quá sâu (God Controller):**
    *   *Code:* Một Controller xử lý cả Sensor, LED, Config, User...
    *   *Hậu quả:* Không thể bảo trì.
    *   *Sửa:* Tách biệt rõ ràng: `DevicesController`, `LogsController`, `ConfigController`.

---

## 6. Cheat Sheet (Bảng Tra Nhanh)

### FreeRTOS - Cú pháp桌上
*   **Tạo Task:** `xTaskCreate(HandlerFunc, "Name", StackDepth, Param, Priority, Handle);`
    *   *StackDepth (bytes):* 1024 là số an toàn cho task cơ bản.
*   **Delay:** `vTaskDelay(Ticks);`
    *   *Chuyển đổi:* `DelayMS / portTICK_PERIOD_MS`
*   **Xóa Task:** `vTaskDelete(NULL);` (Tự xóa chính nó).

### REST API - Chìa khóa tra nhanh
*   **GET:** `/api/items` (Lấy list) hoặc `/api/items/{id}` (Lấy 1).
*   **POST:** `/api/items` (Tạo mới, gửi Body JSON).
*   **PUT:** `/api/items/{id}` (Cập nhật toàn bộ).
*   **Status Codes:**
    *   `200`: OK.
    *   `201`: Created (Thành công tạo mới).
    *   `400`: Bad Request (Client sai dữ liệu).
    *   `404`: Not Found (URL sai hoặc ID không t tồn tại).
    *   `500`: Internal Server Error (Lỗi Server).



<!-- SECTION 250-259 -->

## ValuesController (pages 250-259)

Dưới đây là bản tóm tắt toàn cục cho phần tài liệu được cung cấp, dùng làm ngữ cảnh cho các phân tích tiếp theo.

**Global Section Summary**

Phần tài liệu này mô tả quy trình xây dựng một API cơ bản sử dụng kiến trúc MVC trong ASP.NET Core, tập trung vào xử lý dữ liệu cảm biến. Mục tiêu chính là tạo lập một API CRUD (Create, Read, Update, Delete) đầy đủ, bắt đầu từ việc định nghĩa Route, thiết lập Model với các quy tắc xác thực (Data Annotations), tạo Controller xử lý logic HTTP, và kết nối cơ sở dữ liệu thông qua Entity Framework Core. Quy trình sử dụng công cụ Scaffolding để tự động hóa việc sinh mã nguồn.

**Các khái niệm cốt lõi:**
*   **MVC (Model-View-Controller):** Cấu trúc phần mềm, phần này tập trung vào Model và Controller.
*   **Data Annotations:** Các attribute như `[Required]` để xác thực dữ liệu Model.
*   **Entity Framework Core (EF Core):** ORM (Object-Relational Mapper) để tương tác với database.
*   **Scaffolding:** Công cụ tự động sinh code Controller và Database Context.
*   **CRUD Operations:** Các phương thức HTTP (GET, POST, PUT, DELETE).

**Phụ thuộc quan trọng:**
*   Cần hiểu cấu trúc Project ASP.NET Core (thư mục `Properties`, `Models`, `Data`).
*   Cần có công cụ scaffolding của .NET Core được cài đặt.
*   Dữ liệu cấu hình kết nối Database (file `appsettings.json`).

**Từ khoá / Thuật ngữ cần nhớ:**
*   `ValuesController` / `SensorDatasController`
*   `SensorData` (Model)
*   `DbContext`
*   `Scaffolding`
*   `CRUD`
*   `[Required]` (Data Annotation)
*   `appsettings.json` (Config)
*   `launchSettings.json` (Launch URL)



<!-- CHUNK 250-259 -->

# DEVELOPER DECISION GUIDE: Xây dựng API CRUD với ASP.NET Core MVC & EF Core

## Core Mental Model

Hãy tư duy về việc xây dựng API như một quy trình biến đổi yêu cầu thành dữ liệu có cấu trúc:

1.  **Model (Dữ liệu):** Đây là "DNA" của bạn. Nó định nghĩa cấu trúc dữ liệu và quy tắc hợp lệ (ví dụ: `SensorData` bắt buộc có tên). Bạn không cần lo lắng về cách lưu trữ, chỉ cần định nghĩa lớp đối tượng.
2.  **Controller (Bộ điều khiển):** Là "Bộ não" xử lý HTTP request. Nó nhận request, kiểm tra tính hợp lệ, gọi Model để lấy/gửi dữ liệu, và trả về kết quả (JSON).
3.  **DbContext (Cầu nối):** Là "Cầu nối" giữa Model của bạn và Database thực tế. EF Core (Entity Framework Core) dùng nó để tự động chuyển đổi các thao tác đối tượng (Add, Update) thành câu lệnh SQL.
4.  **Scaffolding (Giàn giáo):** Đừng viết code lặp lại. Hãy dùng công cụ tự động sinh mã nguồn (scaffolding) để tạo Controller và Database Context nhanh chóng, sau đó tùy chỉnh logic nếu cần.

## Architecture: Lớp Kỹ Thuật

Hãy xác định các lớp thành phần chính cần thiết cho một API xử lý cảm biến (Sensor Data):

| Lớp | Vai trò | Ví dụ cụ thể |
| :--- | :--- | :--- |
| **Model Layer** | Định nghĩa entity chính và quy tắc xác thực dữ liệu (Data Annotations). | Class `SensorData` có thuộc tính `[Required] Name`. |
| **Data Layer** | Quản lý kết nối Database và các DbSet (bảng dữ liệu). | Class `WebAPIDemoContext` kế thừa `DbContext`. |
| **Controller Layer** |暴露 API Endpoints (RESTful) và xử lý HTTP Verbs (GET, POST, PUT, DELETE). | Class `SensorDatasController` với phương thức `PostSensorData`. |
| **Configuration Layer** | Cung cấp chuỗi kết nối (Connection String) và cài đặt ứng dụng. | File `appsettings.json`. |

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Chọn phương pháp xử lý Database trong ASP.NET Core

| Tình huống | Giải pháp khuyến nghị | Lý do |
| :--- | :--- | :--- |
| Bạn cần một API nhanh cho prototype hoặc demo cảm biến (IoT). | **Sử dụng Scaffolding (EF Core + Controller)** | Tự động sinh code CRUD chuẩn, ít lỗi, tiết kiệm thời gian đáng kể. |
| Dữ liệu rất phức tạp hoặc cần tối ưu hóa SQL cực kỳ cao. | **Viết Raw SQL hoặc Dapper** | EF Core có thể tạo ra SQL không tối ưu; Dapper nhẹ hơn và kiểm soát SQL tốt hơn. |
| Bạn chỉ muốn thay đổi Model mà không cần Migration. | **Sử dụng In-Memory Database** | Tốt cho testing, không cần cài đặt SQL Server thực tế. |

### Bảng 2: Xử lý Route và HTTP Methods

 | Khi nào | Action Method | Controller Attribute | URL mẫu |
| :--- | :--- | :--- | :--- |
| **Lấy danh sách** dữ liệu cảm biến | `GetSensorData()` | `[HttpGet]` | `/api/SensorDatas` |
| **Lấy 1 bản ghi** theo ID | `GetSensorData(id)` | `[HttpGet("{id}")]` | `/api/SensorDatas/5` |
| **Tạo mới** dữ liệu | `PostSensorData(SensorData data)` | `[HttpPost]` | `/api/SensorDatas` |
| **Cập nhật** toàn bộ bản ghi | `PutSensorData(id, data)` | `[HttpPut("{id}")]` | `/api/SensorDatas/5` |
| **Xóa** bản ghi | `DeleteSensorData(id)` | `[HttpDelete("{id}")]` | `/api/SensorDatas/5` |

## Code Patterns (Mẫu Code)

### 1. Model với Data Annotations (Xác thực dữ liệu)
Đây là lớp entity chính. Chú ý cách sử dụng `[Required]` và `StringLength` để đảm bảo dữ liệu đầu vào hợp lệ.

```csharp
// File: Models/SensorData.cs
using System.ComponentModel.DataAnnotations;

namespace WebAPIDemo.Models
{
    public class SensorData
    {
        public int Id { get; set; }

        [Required] // Bắt buộc
        [StringLength(60, MinimumLength = 3)] // Chiều dài từ 3 đến 60 ký tự
        public string Name { get; set; }

        public float Value { get; set; }

        [DataType(DataType.Date)]
        public DateTime ReceiveTime { get; set; }
    }
}
```

### 2. DbContext (Kết nối cơ sở dữ liệu)
Lớp này đóng vai trò cầu nối. EF Core sẽ tự động tìm `appsettings.json` để lấy chuỗi kết nối.

```csharp
// File: Data/WebAPIDemoContext.cs
using Microsoft.EntityFrameworkCore;
using WebAPIDemo.Models;

namespace WebAPIDemo.Data
{
    public class WebAPIDemoContext : DbContext
    {
        public WebAPIDemoContext(DbContextOptions<WebAPIDemoContext> options)
            : base(options)
        {
        }

        public DbSet<SensorData> SensorData { get; set; }
    }
}
```

### 3. Controller với các hành động CRUD
Sử dụng `async/await` để xử lý bất đồng bộ, giúp ứng dụng không bị block khi truy vấn database.

```csharp
// File: Controllers/SensorDatasController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using WebAPIDemo.Data;
using WebAPIDemo.Models;

namespace WebAPIDemo.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class SensorDatasController : ControllerBase
    {
        private readonly WebAPIDemoContext _context;

        public SensorDatasController(WebAPIDemoContext context)
        {
            _context = context;
        }

        // GET: api/SensorDatas
        [HttpGet]
        public async Task<ActionResult<IEnumerable<SensorData>>> GetSensorData()
        {
            return await _context.SensorData.ToListAsync();
        }

        // POST: api/SensorDatas
        [HttpPost]
        public async Task<ActionResult<SensorData>> PostSensorData(SensorData sensorData)
        {
            _context.SensorData.Add(sensorData);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetSensorData), new { id = sensorData.Id }, sensorData);
        }
    }
}
```

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Cấu hình "hardcode" Connection String:**
    *   *Đừng:* Đặt chuỗi kết nối SQL trực tiếp trong file `.cs`.
    *   *Hãy:* Luôn để trong `appsettings.json` và đọc qua Dependency Injection (DI) trong `Program.cs` (hoặc `Startup.cs`).

2.  **Bỏ qua Data Annotations:**
    *   *Đừng:* Để dữ liệu rác (null, chuỗi rỗng) lọt vào Controller.
    *   *Hãy:* Sử dụng `[Required]`, `[Range]` ngay trong Model. ASP.NET Core sẽ tự động trả về `400 Bad Request` nếu dữ liệu không hợp lệ.

3.  **Blocking Calls (Gọi đồng bộ trong môi trường Async):**
    *   *Đừng:* Dùng `.Result` hoặc `.Wait()` trong Controller API.
    *   *Hãy:* Sử dụng `await` và `async Task<ActionResult>` để giải phóng thread khi chờ I/O (truy vấn DB).

## Cheat Sheet (Bảng Tra Nhanh)

| Công việc | Cú pháp / Lệnh |
| :--- | :--- |
| **Tạo Model** | Right-click `Models` > Add > Class > `SensorData.cs` |
| **Thêm Data Annotation** | `using System.ComponentModel.DataAnnotations;` → `[Required]` |
| **Scaffolding Controller & Context** | Right-click Project > Add > New Scaffolded Item > API Controller with actions, using EF Core |
| **Cập nhật Database (Migration)** | `dotnet ef migrations add InitialCreate` <br> `dotnet ef database update` |
| **Đọc Config (Connection String)** | `builder.Configuration.GetConnectionString("WebAPIDemoContext")` |
| **Test API URL mặc định** | `https://localhost:{port}/api/SensorDatas` |



<!-- SECTION 260-265 -->

## WebAPIDemoContext (pages 260-265)

**Global Section Summary**

Mục tiêu: Hướng dẫn thiết lập Entity Framework Core (EF Core) để quản lý cơ sở dữ liệu (database) cho ứng dụng Web API, bao gồm tạo, cập nhật và truy vấn dữ liệu.

- **Mục tiêu chính:** Thiết lập kết nối cơ sở dữ liệu thông qua WebAPIDemoContext và sử dụng Migrations để tạo/update schema.
- **Các khái niệm cốt lõi:**
    - **DbContext:** Lớp đại diện cho phiên làm việc với database (`WebAPIDemoContext`).
    - **Code First:** Chiến lược thiết kế model code trước, tạo database sau.
    - **Migrations:** Công cụ tự sinh script SQL để đồng bộ model với database.
    - **Dependency Injection:** Chèn context vào Controller.
- **Phụ thuộc:** Cấu hình trong `Startup.cs` (hoặc `Program.cs` ở phiên bản mới).
- **Từ khóa cần nhớ:** `WebAPIDemoContext`, `Add-Migration Initial`, `Update-Database`, `[HttpGet]`.



<!-- CHUNK 260-265 -->

# DEVELOPER DECISION GUIDE: WebAPIDemoContext & EF Core Setup

## Core Mental Model (Mô hình Tư duy)

**DbContext là "Cầu nối" giữa Code và Database.**
Hãy xem `WebAPIDemoContext` như một phiên làm việc (session).live với database. Nó không chỉ đơn thuần là kết nối, mà còn là nơi bạn định nghĩa các quy tắc tương tác dữ liệu (Entities, Relationships).

- **Code First (Code trước):** Bạn viết class model (ví dụ: `SensorData`), EF Core sẽ tự sinh database schema. *Ưu điểm:* Dễ dàng version control code, không lo lệch giữa model và DB.
- **Migrations (Di trú):** Là lịch sử thay đổi schema. Mỗi khi bạn sửa class model, hãy tạo Migration (như commit code) để cập nhật DB mà không mất data.

## Decision Tables (Bảng Quyết Định)

### Bảng 1: Cấu hình DbContext ở đâu?

| Tình huống | Nơi cấu hình | Code/Cấu trúc |
| :--- | :--- | :--- |
| **ASP.NET Core 5/6 (Startup.cs)** | Trong `ConfigureServices` | `services.AddDbContext<WebAPIDemoContext>(options => options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));` |
| **ASP.NET Core 6+ (Program.cs)** | File `Program.cs` | `builder.Services.AddDbContext<WebAPIDemoContext>(options => ...);` |
| **Ứng dụng Console/Worker** | File `Program.cs` | Dùng `AddDbContextFactory` để quản lý lifecycle thủ công. |

### Bảng 2: Lệnh Migration nào dùng khi nào?

| Mục đích | Lệnh PMC (Package Manager Console) | Kết quả |
| :--- | :--- | :--- |
| **Khởi tạo DB lần đầu** | `Add-Migration Initial` | Tạo file Migration chứa code `Up()` (tạo bảng). |
| **Cập nhật Schema** | `Update-Database` | Chạy file Migration vừa tạo vào Database thực tế. |
| **Xử lý lỗi/Làm lại** | `Remove-Migration` | Xóa file Migration chưa được apply (chỉ dùng khi chưa Update-Database). |

## Architecture (Lớp Kỹ Thuật)

Cấu trúc luồng tương tác chuẩn:

1.  **Controller Layer:** Nhận HTTP Request (`GET`, `POST`).
2.  **Dependency Injection (DI):** Cung cấp instance `WebAPIDemoContext`.
3.  **Business Logic:** Xử lý dữ liệu (nếu có).
4.  **DbContext Layer:** Biến query thành SQL.
5.  **Database:** Lưu trữ/Truy xuất.

**Luồng luân chuyển (Flow):**
`HTTP Request` -> `Controller` -> `Context` -> `Database` -> `Response` -> `Client`

## Code Patterns (Mẫu Code)

### Pattern 1: Khai báo DbContext và Entity
Định nghĩa bảng `SensorData` và Context.

```csharp
// 1. Entity Class (Model)
public class SensorData
{
    public int Id { get; set; }
    public string Name { get; set; }
    public DateTime Timestamp { get; set; }
}

// 2. DbContext Class
using Microsoft.EntityFrameworkCore;

public class WebAPIDemoContext : DbContext
{
    public WebAPIDemoContext(DbContextOptions<WebAPIDemoContext> options) : base(options) { }

    // DbSet đại diện cho bảng trong DB
    public DbSet<SensorData> SensorData { get; set; }
}
```

### Pattern 2: Controller với Dependency Injection
注入 (Inject) Context vào Controller để truy vấn dữ liệu.

```csharp
[ApiController]
[Route("api/[controller]")]
public class SensorDataController : ControllerBase
{
    private readonly WebAPIDemoContext _context;

    // Constructor Injection
    public SensorDataController(WebAPIDemoContext context)
    {
        _context = context;
    }

    // GET: api/SensorData
    [HttpGet]
    public ActionResult<IEnumerable<SensorData>> Get()
    {
        // Truy vấn tất cả bản ghi
        return _context.SensorData.ToList();
    }

    // GET: api/SensorData/5
    [HttpGet("{id}")]
    public ActionResult<SensorData> Get(int id)
    {
        var item = _context.SensorData.Find(id);
        if (item == null) return NotFound();
        return item;
    }
}
```

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Chia sẻ một Context Instance (Singleton):**
    *   **Lỗi:** Đăng ký `WebAPIDemoContext` là Singleton.
    *   **Hậu quả:** Dữ liệu "lỗi thời" (stale), lỗi thread-safe khi có nhiều request.
    *   **Đúng:** Đăng ký Scoped (mỗi request một Context mới).

2.  **Mở rộng Scope DbContext:**
    *   **Lỗi:** Inject `DbContext` vào một Service có vòng đời Singleton (Singleton > Scoped).
    *   **Hậu quả:** Bắn ra ngoại lệ `Scoped Service Injection Error`.
    *   **Giải pháp:** Chỉ Inject `DbContext` vào Controller hoặc Service đang có vòng đời Scoped/Transient.

3.  **Quên Migration:**
    *   **Lỗi:** Sửa class Model nhưng không tạo Migration.
    *   **Hậu quả:** Ứng dụng báo lỗi khi truy cập DB (Schema không khớp).

## Cheat Sheet (Bảng Tra Nhanh)

**Lệnh Cấu hình (Startup/Program.cs):**
```csharp
services.AddDbContext<WebAPIDemoContext>(options =>
    options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
```

**Lệnh Terminal (Package Manager Console):**
*   Tạo Migration: `Add-Migration [TênMigration]` (Vd: `Add-Migration Initial`)
*   Cập nhật DB: `Update-Database`
*   Xem SQL sinh ra: `Script-Migration`

**Kiểm tra dữ liệu (SQL Server Object Explorer):**
*   Chuột phải vào Table -> View Data.
*   Chuột phải vào Table -> View Definition (xem Schema).

**Attribute HTTP:**
*   `[HttpGet]`: Đọc dữ liệu.
*   `[HttpPost]`: Tạo dữ liệu mới (cần xử lý `POST` trong Controller để hoàn thiện CRUD).



<!-- SECTION 266-278 -->

## response (pages 266-278)

**Global Section Summary**

Phần này trình bày các phương thức HTTP để tạo, đọc, cập nhật và xóa dữ liệu (RESTful API).
- **Mục tiêu:** Hiểu và sử dụng các phương thức HTTP (GET, POST, PUT, DELETE) để quản lý tài nguyên trong ứng dụng IoT.
- **Khái niệm cốt lõi:**
  - **GET:** Lấy dữ liệu (Một hoặc tất cả), trả về `200 OK` và JSON.
  - **POST:** Tạo dữ liệu mới, gửi trong body, trả về `201 Created`.
  - **PUT:** Cập nhật dữ liệu, trả về `204 No Content`.
  - **DELETE:** Xóa dữ liệu, trả về `200 OK`.
- **Phụ thuộc:** Cần kiến thức về URL endpoint và cấu hình port (port).
- **Từ khoá:** `HTTP Verbs`, `JSON`, `ActionResult<T>`, `Thingsboard`.



<!-- CHUNK 266-277 -->

# DEVELOPER DECISION GUIDE: API Response & HTTP Verbs

## Core mental model

Đây là "bộ công cụ ngôn ngữ" để Client và Server giao tiếp trong kiến trúc Web API. Mỗi hành động tương ứng với một phương thức HTTP (HTTP Verb) có quy ước rõ ràng.

*   **GET (Đọc):** Yêu cầu "mang dữ liệu về". Không thay đổi dữ liệu gốc.
*   **POST (Tạo):** Yêu cầu "tạo mới". Client gửi dữ liệu mẫu, Server sinh ID và lưu.
*   **PUT (Thay thế):** Yêu cầu "cập nhật toàn bộ". Client gửi bản ghi đầy đủ để ghi đè lên bản cũ.
*   **DELETE (Xóa):** Yêu cầu "xóa bỏ". Server xóa bản ghi theo ID.

**Quy tắc vàng:** Luôn trả về HTTP Status Code đúng ý nghĩa (200, 201, 204, 404, 500) kèm dữ liệu JSON.

---

## Decision Tables (Bảng Quyết Định)

Bảng này giúp chọn phương thức và status code chính xác dựa trên mục đích nghiệp vụ.

| Mục đích (Intent) | Phương thức (Method) | Endpoint Ví dụ | Success Code | Response Body | Ghi chú |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Lấy danh sách** | `GET` | `/api/SensorDatas` | `200 OK` | JSON Array `[]` | Dùng để hiển thị bảng biểu. |
| **Lấy chi tiết** | `GET` | `/api/SensorDatas/2` | `200 OK` | JSON Object `{}` | Dùng ID để tìm bản ghi cụ thể. |
| **Tạo mới** | `POST` | `/api/SensorDatas` | `201 Created` | JSON Object (có ID mới) | Gửi dữ liệu trong **Body**. |
| **Cập nhật toàn bộ** | `PUT` | `/api/SensorDatas/2` | `204 No Content` | *Không có* (hoặc `null`) | Yêu cầu gửi đủ dữ liệu đầy đủ. |
| **Xóa** | `DELETE` | `/api/SensorDatas/2` | `200 OK` | Message string | Xóa dựa trên ID. |

---

## Architecture

Kiến trúc Layered (Lớp) cho API Response hoạt động hiệu quả.

1.  **Presentation Layer (Controller):** Nhận HTTP Request, phân tích `Verb` và `Route`.
    *   Trả về `ActionResult<T>`: Cung cấp metadata (Status Code) và body (Data).
2.  **Business Logic Layer (Service):** Thực thi logic (kiểm tra tồn tại, tính toán).
3.  **Data Access Layer (Repository/DbContext):** Tương tác Database.

**Lưu ý quan trọng (Thingsboard/IoT Context):**
Khi làm việc với IoT (như Thingsboard), kết nối cần ổn định. Response Code nhanh (như `204 No Content`) giúp Client biết ngay lập tức để tiếp tục xử lý hoặc tiết kiệm pin/băng thông.

---

## Code Patterns (MẪU CODE)

Dưới đây là các mẫu code hoàn chỉnh cho ASP.NET Core Web API.

### 1. GET Pattern: Đọc dữ liệu

Dùng `ActionResult<T>` để tự động serialize JSON.

```csharp
// File: SensorDataController.cs
[ApiController]
[Route("api/[controller]")]
public class SensorDataController : ControllerBase
{
    // Pattern: Get All
    // Response: 200 OK + JSON Array
    [HttpGet]
    public ActionResult<IEnumerable<SensorData>> GetAll()
    {
        var data = _repository.GetAll(); // Giả định đã có repository
        return Ok(data); // Trả về 200 và JSON
    }

    // Pattern: Get By ID
    // Response: 200 OK (Tìm thấy) hoặc 404 Not Found (Mất tích)
    [HttpGet("{id}")]
    public ActionResult<SensorData> GetById(int id)
    {
        var item = _repository.GetById(id);
        if (item == null)
        {
            return NotFound(); // Trả về 404
        }
        return Ok(item); // Trả về 200 và JSON Object
    }
}
```

### 2. POST Pattern: Tạo mới

Dùng `CreatedAtAction` để tạo header `Location` (nơi tìm thấy tài nguyên mới).

```csharp
// File: SensorDataController.cs
[HttpPost]
public ActionResult<SensorData> PostSensorData(SensorData data)
{
    if (!ModelState.IsValid) return BadRequest(ModelState);

    _repository.Add(data); // Lưu vào DB
    // Trả về 201 Created
    // Header sẽ có: Location: https://localhost:5001/api/SensorData/{id_moi}
    return CreatedAtAction(nameof(GetById), new { id = data.Id }, data);
}
```

### 3. PUT Pattern: Cập nhật

Thay thế hoàn toàn tài nguyên hiện tại. Nếu không có thì tạo mới (phụ thuộc logic).

```csharp
// File: SensorDataController.cs
[HttpPut("{id}")]
public IActionResult PutSensorData(int id, SensorData data)
{
    if (id != data.Id) return BadRequest("ID mismatch");

    var existing = _repository.GetById(id);
    if (existing == null) return NotFound();

    _repository.Update(data); // Cập nhật
    
    // Pattern quan trọng: 204 No Content
    // Tối ưu băng thông, báo hiệu "Tôi đã xử lý xong, không có gì để trả về thêm".
    return NoContent(); 
}
```

### 4. DELETE Pattern: Xóa

```csharp
// File: SensorDataController.cs
[HttpDelete("{id}")]
public IActionResult DeleteSensorData(int id)
{
    var existing = _repository.GetById(id);
    if (existing == null) return NotFound();

    _repository.Delete(id);
    
    return Ok("Deleted successfully"); // Hoặc chỉ return Ok() không nội dung
}
```

---

## Anti-Patterns (Các sai lầm cần tránh)

Tránh những cách làm này để API của bạn không trở thành "cục nợ" kỹ thuật.

1.  **Over-posting (Chấp nhận quá nhiều data):**
    *   *Lỗi:* API `POST`/`PUT` cho phép Client gửi cả `IsAdmin`, `UserId`... trong JSON. Hacker có thể tự tăng quyền.
    *   *Sửa:* Sử dụng **DTOs (Data Transfer Objects)**. Chỉ map những field cần thiết.
2.  **Sai lệch Semantic (Lạm dụng POST cho mọi thứ):**
    *   *Lỗi:* Dùng `POST /api/Delete/1` thay vì `DELETE /api/1`.
    *   *Sửa:* Tuân thủ REST. `DELETE` là để xóa.
3.  **Trả về Internal Exception:**
    *   *Lỗi:* Lỗi database (SQL Error) bị ném thẳng ra Client.
    *   *Sửa:* Bắt lỗi (Try-Catch), log lại, trả về `500 Internal Server Error` kèm message chung chung.
4.  **Over-fetching / Under-fetching:**
    *   *Lỗi:* `GET /api/SensorData` trả về toàn bộ 50 cột của database trong khi UI chỉ cần 3 cột `Temp`, `Hum`, `Time`.
    *   *Sửa:* Tạo API đặc thù hoặc dùng Query String (`?fields=temp,hum`) để lọc.

---

## Cheat Sheet (Bảng Tra Nhanh)

Bảng này dán vào màn hình hoặc note của bạn khi code.

| Xử lý | HTTP Method | HTTP Status | Body Response | Chú thích |
| :--- | :--- | :--- | :--- | :--- |
| **Đọc Danh sách** | `GET` | `200 OK` | Array `[]` | |
| **Đọc 1 Item** | `GET` | `200 OK` hoặc `404` | Object `{}` | |
| **Tạo mới** | `POST` | `201 Created` | Object (Mới) | Có `Location` header |
| **Cập nhật** | `PUT` | `204 No Content` | *Rỗng* | Tiết kiệm bandwidth |
| **Xóa** | `DELETE` | `200 OK` | String (Msg) | |
| **Lỗi Dữ liệu** | Any | `400 Bad Request` | Error Object | Client gửi sai |
| **Lỗi Server** | Any | `500 Internal Error` | *Rỗng* hoặc Msg chung | |

**Lưu ý cho IoT/Realtime:**
*   **204 No Content** là best practice cho `PUT` trong môi trường mạng kém hoặc thiết bị có giới hạn tài nguyên (như ESP8266/ESP32).
*   Đảm bảo **Endpoint URL** ngắn gọn và dễ đoán để việc gọi API từ code Embedded (C/C++) dễ dàng hơn.



<!-- CHUNK 278-278 -->

# DEVELOPER DECISION GUIDE: Lập trình IoT với Thingsboard

## Core Mental Model

**Mô hình tư duy cốt lõi: Thingsboard là một "Hub" trung tâm.**

Hãy tưởng tượng Thingsboard là một trạm trung chuyển thông minh. Thiết bị (Device) của bạn không giao tiếp trực tiếp với ứng dụng người dùng, mà thông qua trạm này.
*   **Thiết bị (Device)**: Ném dữ liệu vào (Ingest) hoặc nhận lệnh từ (Control).
*   **Thingsboard**: Nhận dữ liệu, lưu trữ (Lưu trữ), xử lý (Processing), và cho phép bạn truy vấn (Query) hoặc hiển thị (Visualize).
*   **API của bạn**: Là cánh cổng kết nối giữa Thingsboard và phần mềm tùy chỉnh của bạn.

**Quy tắc vàng:** Luôn xác định rõ vai trò của bạn: Bạn là người **tiêu thụ dữ liệu** (Dùng API Thingsboard để lấy data) hay **cung cấp dữ liệu** (Dùng API Thingsboard để đẩy data)?

## Decision Tables (Bảng Quyết Định)

Bảng này giúp bạn chọn phương thức API phù hợp dựa trên mục tiêu giao tiếp với Thingsboard.

| Mục tiêu nghiệp vụ | Phương thức HTTP | Endpoint Ví dụ | Payload (Body) | Phản hồi mong đợi | Khi nào dùng? |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Đọc dữ liệu Telemetry (Lịch sử)** | `GET` | `/api/plugins/telemetry/DEVICE/{deviceId}/values/timeseries` | Không cần | `200 OK` + JSON (Time-series data) | Khi bạn cần xây dựng biểu đồ, xem lại lịch sử cảm biến. |
| **Gửi dữ liệu mới từ Server** | `POST` | `/api/v1/{deviceId}/telemetry` | JSON `{ "temperature": 25.5 }` | `200 OK` hoặc `204` | Khi server của bạn muốn cập nhật trạng thái thiết bị ảo (Virtual Device). |
| **Cập nhật thuộc tính chung (Attributes)** | `POST` | `/api/plugins/telemetry/DEVICE/{deviceId}/SERVER_SCOPE` | JSON `{"firmware": "v2"}` | `200 OK` | Khi bạn muốn lưu thông tin cấu hình (cần persist). |
| **Tạo mới Device hoặc Entity** | `POST` | `/api/device` | JSON `{"name": "Sensor-01", "type": "thermostat"}` | `201 Created` + `ID` | Dùng khi Provisioning (cấp phát) thiết bị mới tự động. |
| **Xóa Device hoặc Entity** | `DELETE` | `/api/device/{deviceId}` | Không cần | `200 OK` | Khi thiết bị ngừng hoạt động hoặc lỗi. |

## Architecture

**Kiến trúc tích hợp IoT Typical**

Hệ thống thường có 3 lớp chính khi làm việc với Thingsboard:

1.  **Lớp Edge (Device/Gateway):** Thu thập dữ liệu thô (Nhiệt độ, Đèn).
    *   *Protocol:* MQTT (Ưu tiên), CoAP, hoặc HTTP.
2.  **Lớp Platform (Thingsboard):** Nơi dữ liệu sống.
    *   *Function:* Rule Chain (Xử lý logic), Database (Lưu trữ), Dashboard (Hiển thị).
    *   *Access Point:* REST API (`Thingsboard_host:8080`).
3.  **Lớp Ứng dụng (Your Custom App):**
    *   *Task:* Gọi API Thingsboard để lấy dữ liệu hoặc đẩy lệnh điều khiển.
    *   *Method:* Sử dụng `HTTP Verbs` (GET/POST/PUT/DELETE) như đã nêu ở phần Context.

**Dòng chảy dữ liệu (Data Flow):**
`Device` -> `MQTT/HTTP` -> `Thingsboard` -> `REST API` -> `App của bạn`

## Code Patterns

Dưới đây là các mẫu code hoàn chỉnh minh họa cách gọi API Thingsboard trong một ứng dụng .NET (C#) giả định, áp dụng các HTTP Verbs đã học.

### Pattern 1: Lấy dữ liệu Telemetry (GET)
*Khi nào dùng: Hiển thị biểu đồ nhiệt độ实时.*

```csharp
using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;

public class TelemetryReader
{
    private static readonly HttpClient client = new HttpClient();

    public async Task GetDeviceTelemetryAsync(string deviceId, string token)
    {
        // 1. Chuẩn bị URL (Endpoint)
        string url = $"http://localhost:8080/api/plugins/telemetry/DEVICE/{deviceId}/values/timeseries";
        
        // 2. Thiết lập Header (X-Auth-Token)
        client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // 3. Thực thi GET
        try 
        {
            HttpResponseMessage response = await client.GetAsync(url);
            
            if (response.IsSuccessStatusCode) // 200 OK
            {
                string data = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Dữ liệu nhận được: {data}");
                // Kết quả: {"temperature":[{"ts":1700000000000,"value":"25.5"}]}
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Lỗi: {ex.Message}");
        }
    }
}
```

### Pattern 2: Gửi lệnh điều khiển (POST)
*Khi nào dùng: Bật/Tắt đèn từ ứng dụng di động.*

```csharp
public class DeviceController
{
    private static readonly HttpClient client = new HttpClient();

    public async Task SendCommandAsync(string deviceId, string command, string token)
    {
        // 1. Chuẩn bị URL (RPC API)
        string url = $"http://localhost:8080/api/plugins/rpc/twoway/{deviceId}";

        // 2. Tạo Payload (JSON)
        // Thingsboard mong đợi một object JSON chứa method và params
        var payload = new
        {
            method = command, // Ví dụ: "setLights"
            params = new { on = true } 
        };

        // 3. Thiết lập Header
        client.DefaultRequestHeaders.Authorization = 
            new AuthenticationHeaderValue("Bearer", token);

        // 4. Thực thi POST
        var content = new StringContent(
            Newtonsoft.Json.JsonConvert.SerializeObject(payload), 
            System.Text.Encoding.UTF8, 
            "application/json"
        );

        HttpResponseMessage response = await client.PostAsync(url, content);

        if (response.IsSuccessStatusCode)
        {
            Console.WriteLine("Lệnh đã được gửi thành công!");
        }
    }
}
```

## Anti-Patterns (Các sai lầm cần tránh)

1.  **Sử dụng POST thay cho GET để lấy dữ liệu:**
    *   *Lỗi:* Viết code `POST /api/getData`.
    *   *Tại sao sai:* HTTP là stateless. GET dùng để yêu cầu dữ liệu. POST dùng để tạo dữ liệu mới hoặc gửi dữ liệu nặng. GET có thể được cache (tối ưu), POST thì không.
    *   *Hậu quả:* Giảm hiệu năng, không tuân thủ chuẩn REST.

2.  **Quên xử lý `204 No Content`:**
    *   *Lỗi:* Khi gọi API `PUT` (Cập nhật) hoặc một số xóa, server trả về `204` (Không có nội dung) thay vì `200` với JSON.
    *   *Tại sao sai:* Code của bạn đang chờ parse JSON, nhưng body rỗng -> Bị lỗi Exception.
    *   *Cách tránh:* Luôn kiểm tra `StatusCode` trước khi parse body.

3.  **Gửi dữ liệu dạng Text thay vì JSON:**
    *   *Lỗi:* Gửi payload dạng `"value=25"` thay vì `{"value": 25}`.
    *   *Tại sao sai:* IoT Platform (như Thingsboard) là database-centric. Nó cần JSON để hiểu cấu trúc và truy vấn dữ liệu sau này.
    *   *Hậu quả:* Dữ liệu bị từ chối hoặc lưu sai kiểu (lưu thành chuỗi thay vì số).

## Cheat Sheet (Bảng Tra Nhanh)

| Ký hiệu | Ý nghĩa | Phản hồi tiêu chuẩn (Thingsboard) |
| :--- | :--- | :--- |
| **GET** | Lấy thông tin / Kiểm tra kết nối | `200 OK` (Có dữ liệu) hoặc `404 Not Found` |
| **POST** | Tạo mới hoặc Gửi lệnh (RPC) | `201 Created` (Tạo mới) hoặc `200 OK` (Gửi lệnh) |
| **PUT** | Cập nhật thuộc tính / Thông tin | `204 No Content` (Thành công nhưng không trả data) |
| **DELETE** | Xóa thiết bị / Người dùng | `200 OK` hoặc `204 No Content` |
| **Token** | X-Auth-Token (Header Authorization) | Bắt buộc cho mọi request API (trừ public) |
| **Content-Type** | Kiểu dữ liệu gửi đi | `application/json` (Luôn dùng) |



<!-- SECTION 279-291 -->

## MQTT (pages 279-291)

**Global Section Summary**

Mục tiêu chính: Hướng dẫn quy trình thực hành tích hợp thiết bị IoT với nền tảng ThingsBoard thông qua MQTT, từ đăng ký thiết bị đến việc gửi dữ liệu telemetry.

- **Các khái niệm cốt lõi:**
  - MQTT (Publish/Subscribe).
  - ThingsBoard IoT Platform (Broker, Dashboard).
  - Device Provisioning (Quy trình đăng ký tự động).
  - Telemetry Data (Dữ liệu quan trắc).
- **Phụ thuộc quan trọng:** Cần hiểu các khái niệm cơ bản về MQTT (Chương 3.3) và HTTP API (Phần 3.3.2).
- **Từ khoá cần nhớ:** `ACCESS_TOKEN`, `provisionDeviceKey`, `provisionDeviceSecret`, `/provision/request`, `/provision/response`, `v1/devices/me/telemetry`.



<!-- CHUNK 279-290 -->

# DEVELOPER DECISION GUIDE: Tích hợp IoT với ThingsBoard qua MQTT & HTTP

## Core mental model

Hãy hình dung việc tích hợp IoT với ThingsBoard như một quy trình hai giai đoạn độc lập: **Đăng ký (Provisioning)** và **Truyền dữ liệu (Telemetry)**.

*   **Giai đoạn 1 - Provisioning (Gửi yêu cầu truy cập):**
    *   Thiết bị mới chưa có danh tính (Identity). Nó kết nối tới MQTT Broker của ThingsBoard với quyền hạn tối thiểu (tài khoản `provision`).
    *   Nó "gõ cửa" bằng cách gửi `provisionDeviceKey` và `secret` để xin cấp giấy thông hành.
    *   **Kết quả:** Server cấp phát một `ACCESS_TOKEN` riêng biệt cho thiết bị đó.

*   **Giai đoạn 2 - Telemetry (Gửi dữ liệu):**
    *   Thiết bị ngắt kết nối và kết nối lại, lần này sử dụng `ACCESS_TOKEN` vừa nhận được làm username.
    *   Nó định kỳ "thét" dữ liệu (telemetry) lên các topic MQTT hoặc gửi qua HTTP.

> **Lưu ý quan trọng:** `ACCESS_TOKEN` là *chìa khóa* duy nhất cho mỗi thiết bị. Sau khi có nó, bạn không bao giờ dùng lại tài khoản `provision`.

## Decision tables

### Bảng 1: Chọn phương thức truyền dữ liệu (MQTT vs HTTP)

| Tiêu chí | MQTT (Pub/Sub) | HTTP (REST API) |
| :--- | :--- | :--- |
| **Kiến trúc** | **Event-driven**. Client publish message, Broker xử lý. Không cần giữ kết nối chờ response. | **Request-Response**. Client phải gửi request và nhận response rõ ràng. |
| **Tính liên tục** | **Luôn mở (Keep-alive)**. Lý tưởng cho cảm biến gửi dữ liệu định kỳ (heartbeat). | **Ngắn hạn (Request-based)**. Phù hợp cho việc gửi dữ liệu khi có sự kiện (event-based) hoặc gateway không muốn giữ kết nối MQTT. |
| **Băng thông & Overhead** | **Thấp**. Header MQTT rất nhỏ. Tiết kiệm pin/bandwidth cho thiết bị di động/NB-IoT. | **Cao hơn**. Header HTTP lớn, có thể nặng nề nếu gửi tần suất cao. |
| **Phức tạp Code** | Cần thư viện MQTT Client, xử lý connect/disconnect/publish. | Dễ hơn nếu đã quen với HTTP, dùng thư viện `curl` hoặc `requests` cơ bản. |
| **Cổng mạng** | 1883 (MQTT) / 8883 (MQTTs) | 80 (HTTP) / 443 (HTTPS) |

### Bảng 2: Chọn mode Provisioning

| Requirement | Direct Device Provisioning (Cơ bản) | DN-based Provisioning (Nâng cao) |
| :--- | :--- | :--- |
| **Khi nào dùng?** | Số lượng thiết bị ít, bạn tự tay lấy `Key/Secret` trên server và flash vào từng thiết bị. | Sản xuất hàng loạt, bạn muốn thiết bị tự động đăng ký dựa trên `Device Name` (DNS) có sẵn trong mạng. |
| **Thông tin cần thiết** | `provisionDeviceKey`, `provisionDeviceSecret` (Cứng - Hardcoded trong code). | Chỉ cần `provisionDeviceKey` (thường dùng chung cho lô), server tự sinh Device ID. |

## Architecture

Hình ảnh kiến trúc t tổng quan luồng tín hiệu:

1.  **IoT Device (Client):** Nguồn dữ liệu (Sensor).
2.  **MQTT Broker (ThingsBoard):** Trung tâm trung转 messaging.
3.  **Rule Engine:** Xử lý dữ liệu đến.
4.  **Database:** Lưu trữ telemetry.
5.  **Dashboard:** Hiển thị cho người dùng.

**Luồng đăng ký (Provisioning Flow):**
```mermaid
Client ->> Broker: Connect (User: "provision")
Client ->> Broker: Publish "/provision/request" (Key + Secret)
Broker ->> Server: Check Identity
Server ->> Client: Publish "/provision/response" (ACCESS_TOKEN)
Client ->> Client: Lưu token, ngắt kết nối.
```

**Luồng truyền dữ liệu (Telemetry Flow):**
```mermaid
Client ->> Broker: Connect (User: $ACCESS_TOKEN)
Client ->> Broker: Publish "v1/devices/me/telemetry" (JSON Data)
Broker ->> Rule Engine: Push Message
```

## Code patterns

### Pattern 1: Quy trình Provisioning (Python)
Mẫu này thể hiện việc thiết bị "xin chào" để nhận token.

*Thuật ngữ:* `Paho MQTT` (Thư viện MQTT chuẩn cho Python).

```python
import paho.mqtt.client as mqtt
import json

# Cấu hình cố định (hardcoded từ dự án)
PROVISION_HOST = "thingsboard.cloud"
PROVISION_KEY = "YOUR_PROVISION_KEY"
PROVISION_SECRET = "YOUR_PROVISION_SECRET"
PROVISION_TOPIC_REQUEST = "/provision/request"
PROVISION_TOPIC_RESPONSE = "/provision/response"

# Biến lưu token sau khi nhận
received_access_token = None

def on_connect(client, userdata, flags, rc):
    print(f"Kết nối: {rc}")
    if rc == 0:
        # Đăng ký lắng nghe phản hồi
        client.subscribe(PROVISION_TOPIC_RESPONSE)
        
        # Bước 2: Gửi yêu cầu đăng ký
        payload = {
            "deviceName": "MyNewDevice",
            "provisionDeviceKey": PROVISION_KEY,
            "provisionDeviceSecret": PROVISION_SECRET
        }
        client.publish(PROVISION_TOPIC_REQUEST, json.dumps(payload))
        print("Đã gửi yêu cầu Provision...")

def on_message(client, userdata, msg):
    global received_access_token
    data = json.loads(msg.payload)
    print(f"Phản hồi nhận được: {data}")
    
    if data.get("status") == "SUCCESS":
        received_access_token = data.get("credentialsValue")
        print(f"SUCCESS! Token: {received_access_token}")
        client.disconnect() # Kết thúc quá trình Provisioning

# Main execution
client = mqtt.Client(client_id="ProvisionClient", protocol=mqtt.MQTTv5)
client.username_pw_set("provision") # Bắt buộc
client.on_connect = on_connect
client.on_message = on_message

client.connect(PROVISION_HOST, 1883, 60)
client.loop_forever()
```

### Pattern 2: Gửi Telemetry bằng MQTT
Sau khi có token, kết nối lại với danh tính mới.

*Thuật ngữ:* `JSON Payload` (Dữ liệu đóng gói dạng JSON).

```python
import paho.mqtt.client as mqtt
import json
import time

# Thông tin sau khi Provision thành công
ACCESS_TOKEN = "sLzc0gDAZPkGMzFVTyUY" # Thay bằng token thực
HOST = "thingsboard.cloud"
TELEMETRY_TOPIC = "v1/devices/me/telemetry"

def publish_telemetry():
    client = mqtt.Client(client_id="DeviceClient", protocol=mqtt.MQTTv5)
    # Bước quan trọng: Sử dụng ACCESS_TOKEN làm Username
    client.username_pw_set(ACCESS_TOKEN)
    
    client.connect(HOST, 1883, 60)
    
    # Dữ liệu quan trắc (Telemetry)
    data = {
        "ts": int(time.time() * 1000), # Unix timestamp (ms)
        "values": {
            "temperature": 25.5,
            "humidity": 60,
            "status": "OK"
        }
    }
    
    # Publish
    client.publish(TELEMETRY_TOPIC, json.dumps(data))
    print(f"Đã gửi: {data}")
    client.disconnect()

publish_telemetry()
```

### Pattern 3: Gửi Telemetry bằng HTTP API
Phù hợp cho thiết bị không hỗ trợ MQTT hoặc qua Gateway HTTP.

*Thuật ngữ:* `POST Request` (Phương thức HTTP để tạo mới dữ liệu).

```python
import requests
import json
import time

# Thông tin kết nối
ACCESS_TOKEN = "sLzc0gDAZPkGMzFVTyUY" # Thay bằng token thực
HOST = "thingsboard.cloud"
URL = f"http://{HOST}/api/v1/{ACCESS_TOKEN}/telemetry"

# Dữ liệu
payload = {
    "ts": int(time.time() * 1000),
    "values": {
        "battery": 3.7,
        "signal": -85
    }
}

# Gửi yêu cầu POST
try:
    response = requests.post(URL, json=payload, timeout=5)
    if response.status_code == 200:
        print("Gửi dữ liệu thành công!")
    else:
        print(f"Lỗi: {response.status_code} - {response.text}")
except Exception as e:
    print(f"Request failed: {e}")
```

## Anti-patterns

1.  **Hardcoded Provision Credentials Everywhere:**
    *   *Vấn đề:* Đưa `provisionDeviceKey` và `secret` vào code của từng thiết bị và commit lên Git.
    *   *Hậu quả:* Rò rỉ secret -> Ai cũng có thể đăng ký thiết bị giả mạo vào hệ thống của bạn.
    *   *Khắc phục:* Chỉ dùng Provisioning 1 lần để lấy token, sau đó xóa credentials khỏi code/device hoặc dùng Secure Element.

2.  **Gửi JSON không đúng cấu trúc (Telemetry):**
    *   *Vấn đề:* Gửi payload dạng `{"temperature": 25}` trực tiếp lên topic `telemetry`.
    *   *Hậu quả:* ThingsBoard không thể nhận biết timestamp, dữ liệu có thể bị lưu sai thời gian server (mất đi tính năng lọc theo chuỗi thời gian chính xác).
    *   *Khắc phục:* Luôn bao bọc dữ liệu trong cấu trúc `{"ts": ..., "values": {...}}`.

3.  **Không xử lý Keep-alive (MQTT):**
    *   *Vấn đề:* Kết nối rồi quên, không gửi tin nhắn `PINGREQ`.
    *   *Hậu quả:* Broker ngắt kết nối, dữ liệu bị mất tích直到 client reconnect.
    *   *Khắc phục:* Sử dụng thư viện MQTT có hỗ trợ Auto-reconnect và Keep-alive timer.

## Cheat sheet

| Thao tác | Cú pháp / Giá trị | Ghi chú |
| :--- | :--- | :--- |
| **Tài khoản Provision** | Username: `provision` | Để đăng ký thiết bị mới |
| **Topic Request** | `/provision/request` | Gửi Key/Secret |
| **Topic Response** | `/provision/response` | Nhận AccessToken |
| **Tài khoản Telemetry** | Username: `$ACCESS_TOKEN` | Để gửi dữ liệu |
| **Topic MQTT Telemetry** | `v1/devices/me/telemetry` | Gửi JSON {ts, values} |
| **Đường dẫn HTTP** | `.../api/v1/$ACCESS_TOKEN/telemetry` | POST Request |
| **Payload mẫu** | `{"ts":1451649600512, "values":{"key":"value"}}` | Bắt buộc nếu dùng Ts |



<!-- CHUNK 291-291 -->

# DEVELOPER DECISION GUIDE: ThingsBoard IoT Integration via MQTT

## Core mental model (Mô hình tư duy cốt lõi)

Hãy hình dung hệ thống như một mạng lưới **bưu điện an toàn (Secure Post Office)**:
1.  **Device (Thiết bị)** là người gửi thư.
2.  **MQTT Broker (ThingsBoard)** là bưu điện trung tâm, quản lý địa chỉ và chuyển phát.
3.  **Telemetry** là nội dung thư (dữ liệu quan trắc).
4.  **Provisioning** là quá trình đăng ký tự động để nhận "sổ địa chỉ" (Token) chính thức.

**Quy trình chuẩn:**
1.  **Kết nối:** Thiết bị kết nối tới Broker (MQTT).
2.  **Xác thực (Provisioning):** Gửi `provisionDeviceKey/Secret` để đổi lấy `ACCESS_TOKEN`.
3.  **Lưu Token:** Lưu `ACCESS_TOKEN` vào bộ nhớ (EEPROM/NVSRAM) để lần sau không cần đăng ký lại.
4.  **Gửi dữ liệu:** Sử dụng `ACCESS_TOKEN` để publish telemetry vào topic `v1/devices/me/telemetry`.

---

## Decision Tables (Bảng quyết định)

| Kịch bản | Giải pháp được đề xuất | Anti-pattern cần tránh |
| :--- | :--- | :--- |
| **Thiết bị mới ra lò (First Boot)** | Sử dụng **Device Provisioning**. Gửi `provisionDeviceKey` & `secret` lên topic `/provision/request`. | Hardcode `ACCESS_TOKEN` ngay từ đầu (sẽ fail nếu thiết bị chưa được tạo trên Server). |
| **Thiết bị đã từng kết nối** | Đọc `ACCESS_TOKEN` từ bộ nhớ persist. Sử dụng Token này để kết nối MQTT Auth và gửi Telemetry. | Gọi API Provisioning mỗi lần khởi động (lãng phí tài nguyên, tăng độ trễ). |
| **Gửi nhiều dữ liệu trong thời gian ngắn** | Sử dụng **MQTT QoS 1** và batch telemetry (gửi nhiều key-value trong 1 JSON object). | Gửi từng giá trị riêng lẻ qua HTTP POST (quá tải overhead). |
| **Bảo mật kết nối** | Sử dụng **MQTT over TLS/SSL** (Port 8883) hoặc **WSS** (WebSockets). | Sử dụng MQTT không mã hóa (Port 1883) trên môi trường công cộng. |

---

## Architecture (Kiến trúc)

Hệ thống tuân theo mô hình **Push-based Event Streaming**.

```text
[ Device Firmware ]
  |
  | (1. Connect & Provision)
  | Protocol: MQTT
  v
[ ThingsBoard MQTT Broker ]
  | (2. Validate & Assign Token)
  |
  | (3. Store Token)
  v
[ Device Storage (Flash/EEPROM) ]
  ^
  | (4. Read Token on Reboot)
  |
  | (5. Publish Telemetry)
  v
[ ThingsBoard Processing ]
  |
  v
[ Dashboard / Database ]
```

**Flow chi tiết:**
1.  **Provisioning Request:** Device publish JSON chứa `provisionDeviceKey` và `provisionDeviceSecret` tới topic `v1/gateway/provision/request` (hoặc `/provision/request` tùy version).
2.  **Provisioning Response:** Server phản hồi trên topic `v1/gateway/provision/response` với `accessToken`.
3.  **Authentication:** Device ngắt kết nối, reconnect với username là `ACCESS_TOKEN` (hoặc sử dụng `X-Provisioning-Device` header nếu chưa có token).
4.  **Telemetry:** Device publish data `{ "temperature": 25.5 }` tới topic `v1/devices/me/telemetry`.

---

## Code patterns (Mẫu code thực hành)

### Pattern 1: Xử lý chu kỳ kết nối (Provisioning + Telemetry)
Mẫu này xử lý luồng "Vỏ trứng kê": Gửi Provisioning trước, lưu Token, sau đó mới gửi Telemetry.

**C++ (ESP32/Arduino Logic):**

```cpp
#include <WiFi.h>
#include <PubSubClient.h>

// Cấu hình cố định (Chỉ dùng cho Provisioning Key)
const char* PROVISION_DEVICE_KEY = "YOUR_KEY";
const char* PROVISION_DEVICE_SECRET = "YOUR_SECRET";

// Biến toàn cục lưu token
String accessToken = "";

// Callback nhận tin nhắn từ Server
void callback(char* topic, byte* payload, unsigned int length) {
  String message = "";
  for (int i = 0; i < length; i++) message += (char)payload[i];
  
  // 1. Xử lý Phản hồi Provisioning
  if (String(topic) == "/provision/response") {
    // Parse JSON để lấy accessToken
    if (message.indexOf("accessToken") != -1) {
       accessToken = "extract_token_from_json"; 
       // TODO: Lưu accessToken vào EEPROM ở đây!
       Serial.println("Da nhan Token: " + accessToken);
    }
  }
  // 2. Xử lý dữ liệu Telemetry (nếu cần xuống lệnh)
}

void loop() {
  if (!client.connected()) reconnect();
  client.loop();

  if (accessToken.length() > 0) {
    // Gửi Telemetry khi đã có Token
    char msg[50];
    sprintf(msg, "{\"temperature\": %f}", random(20,30));
    client.publish("v1/devices/me/telemetry", msg);
  } else {
    // Gửi Provisioning Request nếu chưa có Token
    char msg[200];
    sprintf(msg, "{\"deviceKey\":\"%s\",\"deviceSecret\":\"%s\"}", PROVISION_DEVICE_KEY, PROVISION_DEVICE_SECRET);
    client.publish("/provision/request", msg);
  }
  
  delay(5000);
}
```

### Pattern 2: Cấu hình Token từافظe (Persistent Storage)
Giả sử Token đã được lưu. Đọc và ưu tiên sử dụng Token đó thay vì Provisioning.

**Python Logic:**

```python
import paho.mqtt.client as mqtt
import json

# Kiểm tra Token có tồn tại không (mô phỏng đọc file/DB)
def get_persistent_token():
    try:
        with open('device_token.txt', 'r') as f:
            return f.read().strip()
    except FileNotFoundError:
        return None

# Main Logic
token = get_persistent_token()
client = mqtt.Client()

if token:
    # Trường hợp 1: Đã có Token -> Connect với Auth
    client.username_pw_set(token)
    client.connect("thingsboard.io", 1883)
    
    # Gửi Telemetry
    client.publish("v1/devices/me/telemetry", json.dumps({"status": "running"}))
else:
    # Trường hợp 2: Chưa có Token -> Provision
    # Lưu ý: Mode Provisioning thường yêu cầu connect KHÔNG có pass 
    # hoặc dùng username là "provision" (tuỳ ThingsBoard config)
    client.connect("thingsboard.io", 1883)
    
    payload = {
        "deviceKey": "YOUR_PROVISION_KEY",
        "deviceSecret": "YOUR_PROVISION_SECRET"
    }
    # Cần subscribe topic response trước khi publish request
    client.subscribe("/provision/response")
    client.publish("/provision/request", json.dumps(payload))
```

---

## Anti-patterns (Lỗi cần tránh)

1.  **Provisioning Loop:**
    *   *Hành vi:* Gửi gói tin Provisioning mỗi khi `loop()` chạy (trong ví dụ C++ ở trên, nếu `else` chạy hoài).
    *   *Tác hại:* Tạo ra hàng nghìn request rác lên server, bị chặn IP hoặc tốn quota.
    *   *Cách khắc phục:* Chỉ gửi 1 lần khi `accessToken` trống. Sau khi nhận, lưu lại và switch режим sang gửi Telemetry.

2.  **Hardcoded Device Credentials:**
    *   *Hành vi:* Đóng gói `accessToken` (hoặc `provisionDeviceSecret`) cứng vào source code và cho bay vào nghìn thiết bị.
    *   *Tác hại:* Lộ bí mật bảo mật, không thể thay đổi secret mà không compile lại firmware.
    *   *Cách khắc phục:* Sử dụng cơ chế **One-time Provisioning** (như Pattern 1) để nhận token động, hoặc dùng Secure Element (TPM/ECC608).

3.  **Truyền dữ liệu JSON lỗi cú pháp:**
    *   *Hành vi:* Gửi payload như `{"temp": 25,}` (dấu phẩy thừa) hoặc không thoát ký tự `"` trong chuỗi.
    *   *Tác hại:* ThingsBoard không parse được, dữ liệu bị丢弃 (drop).
    *   *Cách khắc phục:* Sử dụng thư viện JSON build-in của framework (ArduinoJson, `json.dumps`) thay vì拼接 chuỗi thủ công.

---

## Cheat Sheet (Bảng tra cứu nhanh)

| Concept (Thuật ngữ) | Topic / Giá trị | Mô tả |
| :--- | :--- | :--- |
| **Provision Request** | `/provision/request` | Topic gửi yêu cầu đăng ký thiết bị mới. |
| **Provision Response** | `/provision/response` | Topic nhận `accessToken` từ server. |
| **Telemetry** | `v1/devices/me/telemetry` | Topic gửi dữ liệu quan trắc (nhiệt độ, độ ẩm...). |
| **Attributes (Device)** | `v1/devices/me/attributes` | Topic gửi thông số cấu hình thiết bị (thay đổi chậm). |
| **Attributes (Client)** | `v1/devices/me/attributes/response` | Topic nhận phản hồi khi yêu cầu Server trả về Attribute. |
| **QoS 0** | 0 | Gửi 1 lần, không đảm bảo đến (rất nhanh, dùng cho telemetry thông thường). |
| **QoS 1** | 1 | Đảm bảo đến ít nhất 1 lần (có thể lặp lại nếu mất gói, dùng cho alarm). |
| **Payload Telemetry VD** | `{"temperature": 25.5, "humidity": 60}` | Dạng JSON object. |
| **Payload Telemetry Time-series** | `{"ts": 1700000000, "values": {"temp": 25}}` | Dạng timestamp explicit (nếu cần). |

**Lưu ý quan trọng:**
*   Khi sử dụng **Device Provisioning**, bạn cần đăng nhập vào ThingsBoard Admin để cấu hình `provisioning device` và lấy Key/Secret trước.
*   Nếu dùng **MQTT Gateway**, topic sẽ khác (`v1/gateway/connect`, `v1/gateway/telemetry`), nhưng logic cơ bản giữ nguyên.



<!-- SECTION 292-314 -->

## Chương 4. An toàn và Bảo mật IoT | 1. Giao diện quản trị không an toàn | 2. Cơ chế xác thực không an toàn | 3. Các dịch vụ mạng không an toàn | 4. Thiếu sử dụng mã hóa tầng giao vận | 5. Các vấn đề về quyền riêng tư | 6. Giao diện Cloud không an toàn | 7. Giao diện Mobile không an toàn | 8. Thiếu cấu hình bảo mật | 9. Phần mềm không an toàn | 10. Thiếu bảo mật tầng vật lý (pages 292-314)

**Global Section Summary**

Mục tiêu chính của phần là cung cấp cái nhìn tổng quan về an toàn bảo mật IoT, từ đó liệt kê chi tiết 10 điểm yếu/lỗ hổng bảo mật điển hình cần được khắc phục.

*   **Các khái niệm cốt lõi:**
    *   Vấn đề bảo mật IoT: Chuyển đổi từ mạng riêng sang IP, khó khăn trong cập nhật phần mềm.
    *   Phân loại nguy cơ: Capture (Thu thập), Disrupt (Phá hủy), Manipulate (Can thiệp).
    *   Yêu cầu bảo mật (CIA): Confidentiality, Integrity, Availability, Authenticity.
    *   10 Lỗ hổng bảo mật (I1-I10): Bao gồm giao diện quản trị, xác thực, mã hóa, quyền riêng tư, Cloud/Mobile, cấu hình, phần mềm và vật lý.

*   **Phụ thuộc quan trọng:** Có thể cần tham khảo các kiến thức网络 cơ bản và khái niệm IoT từ các chương trước (Chương 1, 2).

*   **Từ khóa / Thuật ngữ:** CIA (Confidentiality, Integrity, Availability), Spoofing, Sniffing, Denial of Service (DoS), Firmware, Plaintext.



<!-- CHUNK 292-303 -->

# DEVELOPER DECISION GUIDE: An toàn và Bảo mật IoT (Chương 4)

> **Vai trò:** Kỹ sư Phần mềm Cao cấp / Giảng viên Kỹ thuật
> **Đối tượng:** Kiến trúc sư IoT, Developer Backend/Firmware, DevSecOps
> **Nguyên tắc:** Áp dụng **Security by Design** ngay từ giai đoạn thiết kế, không phải sửa lỗi sau khi triển khai.

---

## Core Mental Model (Mô hình tư duy cốt lõi)

Trước khi viết code, hãy luôn visual hóa hệ thống IoT của bạn đang nằm ở ma trận rủi ro nào. Mô hình này bao gồm 3 lớp tấn công (Attack Vectors) và 4 yêu cầu bảo mật (CIA triad + Authenticity).

### 1. Ma trận Rủi ro (The Risk Matrix)
Hãy xác định thiết bị của bạn dễ bị tấn công ở hình thức nào:
*   **Capture (Thu thập):** Tấn công nghe lén, đánh cắp dữ liệu (Sniffing).
*   **Disrupt (Phá hủy):** Tấn công từ chối dịch vụ (DoS), làm tê liệt hệ thống.
*   **Manipulate (Can thiệp):** Thay đổi dữ liệu đầu vào/ra, giả mạo lệnh điều khiển.

### 2. Kim tự tháp Yêu cầu Bảo mật (CIA + A)
Mọi quyết định thiết kế đều phải trả lời được 4 câu hỏi này:
1.  **Confidentiality (Tính bí mật):** Dữ liệu có bị read bởi kẻ tấn công khi truyền đi không? (*Giải pháp: Mã hóa*)
2.  **Integrity (Tính toàn vẹn):** Dữ liệu có bị thay đổi giữa thiết bị và server không? (*Giải pháp: Chữ ký số*)
3.  **Availability (Tính sẵn sàng):** Hệ thống có chống được DoS không? (*Giải pháp: Rate limit, Keepalive*)
4.  **Authenticity (Tính xác thực):** Bên gửi có phải là thiết bị thật không? (*Giải pháp: Xác thực 2 chiều*)

---

## Decision Tables (Bảng quyết định)

Dùng bảng này để chọn phương pháp bảo mật phù hợp dựa trên ngữ cảnh hệ thống.

### Quyết định 1: Chọn Giao thức Truyền tải (Transport Protocol)

| Bối cảnh Hệ thống | Yêu cầu An ninh | Phương án Tối ưu | Cấu hình Bắt buộc |
| :--- | :--- | :--- | :--- |
| **IoNet Nông nghiệp / Nhà máy (LAN/RS485)** | Độ trễ thấp, độ tin cậy cao | **MQTT over TLS** | Sử dụng TLS 1.2+, xác thực Client Certificate (mTLS). |
| **Thiết bị Y tế / An ninh (WAN)** | Tính bí mật cao, latency trung bình | **HTTPS (REST/CoAP)** | Xác thực Token (JWT/OAuth2), mã hóa AES-256 payload. |
| **Thiết bị giá rẻ / MCU yếu** | Tiết kiệm băng thông | **MQTT-SN / CoAP** | **Quyết định:** Nếu MCU không hỗ trợ TLS, bắt buộc dùng **Gateway** để xử lý mã hóa phía ngoài. |

### Quyết định 2: Kiểu Xác thực (Authentication Strategy)

| Loại Thiết bị | Mục đích | Chiến lược Xác thực | Anti-Pattern (Cần tránh) |
| :--- | :--- | :--- | :--- |
| **Thiết bị Cá nhân** | Cá nhân hóa, App điều khiển | **User-to-Device** (Token/App) | Hardcode password trong firmware. |
| **Gateway / Hub** | Thu thập dữ liệu hàng loạt | **Device-to-Cloud (mTLS / X.509)** | Dùng chung một Secret key cho tất cả thiết bị (Single Shared Secret). |
| **Firmware Update** | Cập nhật phần mềm | **Code Signing (Chữ ký số)** | Cập nhật mà không kiểm tra tính hợp lệ của fileirmware. |

---

## Architecture Patterns (Mẫu kiến trúc)

Áp dụng các mô hình kiến trúc để giảm thiểu rủi ro bảo mật "I1-I10".

### Pattern 1: Secure Gateway Edge (Giảm thiểu I3, I10)
Sử dụng Gateway làm lớp lá chắn cho các thiết bị cuối yếu (Edge Device).
*   **Cấu hình:**
    *   **Edge Device:** Chỉ giao tiếp nội bộ qua UART/SPI với Gateway, không mở port ra Internet.
    *   **Gateway:** Nhận dữ liệu, mã hóa lại bằng TLS và gửi lên Cloud.
*   **Lợi ích:** Che giấu thiết bị cuối, xử lý gánh nặng mã hóa thay cho MCU yếu.

### Pattern 2: Zone-based Security (Phân tách Network - I3)
*   **Concept:** Phân chia mạng IoT thành các Zone: DMZ (Public), Secure Zone (Gateway), Private Zone (Sensor).
*   **Implementation:** Sử dụng VLAN hoặc Firewall để ngăn traffic từ Zone Private sang Zone Public trực tiếp.

---

## Code Patterns (Mẫu code thực hành)

Đoạn code minh họa cho các hoạt động bảo mật cốt lõi: **Kiểm tra Certificate** và **Xác thực Payload**.

### Mẫu 1: Xác thực Chữ ký Firmware (Code Signing)
Phòng tránh tấn công **I9 (Insecure Software)** bằng cách kiểm tra SHA256 của fileirmware trước khi flash.

```python
import hashlib
import os

# Giả sử file .bin đã được ký bằng private key ở server
# Ở device, ta chỉ cần verify hash signature

def verify_firmware(file_path, expected_signature):
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        # Đọc file theo block để tránh tràn bộ nhớ
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    
    calculated_signature = sha256_hash.hexdigest()
    
    if calculated_signature == expected_signature:
        print("Verified: Firmware hợp lệ.")
        return True
    else:
        print("Alert: Firmware bị giả mạo! Hủy bỏ cập nhật.")
        return False

# Usage
# verify_firmware("update_v2.bin", "a1b2c3d4...expected_hash")
```

### Mẫu 2: Mã hóa Payload đơn giản (AES-GCM)
Phòng tránh tấn công **I4 (Lack of Transport Encryption)** nếu dùng UDP/Custom Protocol.

```python
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os

def encrypt_payload(key, plaintext):
    # AES-256-GCM cung cấp cả Confidentiality và Integrity
    aesgcm = AESGCM(key)
    nonce = os.urandom(12) # Nonce phải unique cho mỗi message
    ciphertext = aesgcm.encrypt(nonce, plaintext, None)
    return nonce + ciphertext # Gửi kèm nonce

def decrypt_payload(key, data):
    nonce = data[:12]
    ciphertext = data[12:]
    aesgcm = AESGCM(key)
    try:
        return aesgcm.decrypt(nonce, ciphertext, None)
    except:
        print("Integrity Check Failed: Dữ liệu đã bị thay đổi!")
        return None

# Usage
# key = AESGCM.generate_key(bit_length=256)
# encrypted = encrypt_payload(key, b"Temp: 45C")
```

---

## Anti-patterns (Các lỗi thiết kế cần tránh)

Dựa trên các điểm yếu I1-I10, đây là 5 sai lầm chí mạng cần loại bỏ ngay lập tức.

1.  **Hardcoded Credentials (I2, I9):**
    *   *Hành vi:* Đặt username/password root/admin ngay trong file source code.
    *   *Hậu quả:* Khi code leak, cả triệu thiết bị bị chiếm quyền.
    *   *Thay thế:* Sử dụng cơ chế provisioning (cấp phát) Unique ID/Secret khi thiết bị khởi động lần đầu.

2.  **Plaintext Protocols (I3, I4):**
    *   *Hành vi:* Dùng HTTP (không TLS) hoặc Telnet để quản trị thiết bị.
    *   *Hậu quả:* Dễ bị **Sniffing** (nghe lén) và **Man-in-the-Middle**.
    *   *Thay thế:* Luôn dùng HTTPS, MQTT over TLS.

3.  **Default Settings (I8):**
    *   *Hành vi:* Port mở sẵn (80, 443, 23), Password mặc định không đổi.
    *   *Hậu quả:* Tự động bị quét và bắn script bởi Botnet (ví dụ Mirai).
    *   *Thay thế:* Buổi người dùng thay đổi password ngay khi kích hoạt, đóng tất cả port không dùng.

4.  **No Input Validation (I1, I7):**
    *   *Hành vi:* Web/Mobile Interface không lọc dữ liệu đầu vào.
    *   *Hậu quả:* Bị tấn công **SQL Injection** hoặc **Buffer Overflow**.
    *   *Thay thế:* Validate dữ liệu nghiêm ngặt (white-list) trước khi xử lý.

5.  **Exposing Debug Interfaces (I10):**
    *   *Hành vi:* Giữ JTAG/UART mở trên sản phẩm thương mại.
    *   *Hậu quả:* Kẻ tấn công dump memory, đọc flash, lấy key mã hóa.
    *   *Thay thế:* Vô hiệu hóa Debug port trong file cấu hình chip (Fuse bits).

---

## Cheat Sheet (Bảng tra cứu nhanh)

Danh sách checklist bảo mật IoT để rà soát trước khi release.

### 1. Network & Transport (I3, I4)
- [ ] **TLS Everywhere:** Đã kích TLS 1.2+ cho tất cả kết nối?
- [ ] **Certificate Pinning:** Ứng dụng Mobile có cố định Server Certificate không?
- [ ] **Firewall:** Đã đóng các port không cần thiết (SSH/Telnet)?
- [ ] **Segregation:** Thiết bị có ở mạng VLAN riêng không?

### 2. Authentication & Access (I2)
- [ ] **Unique Keys:** Mỗi thiết bị có Key/Secret riêng biệt?
- [ ] **Rate Limiting:** Có bảo vệ chống Brute Force Password không?
- [ ] **Least Privilege:** Tài khoản hệ thống có quyền hạn tối thiểu không?

### 3. Firmware & Update (I9)
- [ ] **Code Signing:** Firmware có được ký số chưa?
- [ ] **Secure Boot:** Bootloader có kiểm tra signature trước khi chạy OS không?
- [ ] **Anti-Rollback:** Có cơ chế ngăn cài firmware cũ hơn (dễ bị khai thác lỗ hổng cũ) không?

### 4. Cloud & API (I6)
- [ ] **API Validation:** Kiểm tra input/output kỹ lưỡng?
- [ ] **Logging:** Có ghi lại log truy cập bất thường không?
- [ ] **Downtime Plan:** Cloud có chống được DDoS không?

### 5. Physical Security (I10)
- [ ] **Encrypted Storage:** Dữ liệu nhạy cảm lưu trên Flash có được mã hóa (Encrypted Filesystem)?
- [ ] **Tamper Detection:** Có sensor phát hiện bấm phá thiết bị (Tamper switch)?



<!-- CHUNK 304-314 -->

# DEVELOPER DECISION GUIDE: An toàn và Bảo mật IoT (Chương 4)

Tài liệu này cung cấp các quyết định thiết kế và thực hành mã nguồn cho các lỗ hổng bảo mật IoT điển hình.

---

## 1. Core Mental Model (Mô hình nhận thức)

Để thiết kế hệ thống IoT an toàn, bạn cần hiểu rõ các vectơ tấn công cơ bản và nguyên tắc CIA.

### 1.1. Các vectơ tấn công (Threat Vectors)
*   **Capture (Thu thập):** Kẻ tấn công nghe lén dữ liệu (Sniffing).
    *   *Hậu quả:* Rò rỉ thông tin nhạy cảm.
*   **Disrupt (Phá hủy):** Kẻ tấn công làm gián đoạn dịch vụ (Denial of Service).
    *   *Hậu quả:* Thiết bị ngừng hoạt động, mất kiểm soát.
*   **Manipulate (Can thiệp):** Kẻ tấn công sửa đổi dữ liệu hoặc lệnh.
    *   *Hậu quả:* Thiết bị hành động sai (ví dụ: mở khóa cửa sai).

### 1.2. Yêu cầu bảo mật (CIA Triad + A)
1.  **Confidentiality (Tính bí mật):** Chỉ người/phần tử được phép đọc dữ liệu.
2.  **Integrity (Tính toàn vẹn):** Dữ liệu không bị thay đổi khi truyền/tiết.
3.  **Availability (Tính sẵn sàng):** Hệ thống luôn hoạt động khi cần.
4.  **Authenticity (Tính xác thực):** Xác minh danh tính của thiết bị/server.

---

## 2. Decision Tables (Bảng quyết định)

Chọn giải pháp bảo mật dựa trên ngữ cảnh sử dụng.

### 2.1. Quyết định Xác thực (Authentication)
| Kịch bản | Giải pháp không khuyến khích (Insecure) | Giải pháp khuyến khích (Secure) | Lợi ích |
| :--- | :--- | :--- | :--- |
| **Nội bộ mạng (LAN)** | Hardcoded credentials (User/Pass | Wired) | **Mutual TLS (mTLS)** | Chứng minh cả Server và Device đều đúng danh tính. |
| **Cloud/Mobile** | API Key lộ thiên, không có TTL | **OAuth 2.0 / JWT** | Kiểm soát truy cập linh hoạt, hết hạn tự động. |
| **Vật lý (Cập nhật FW)** | Cập nhật USB không kiểm tra | **Ký số Firmware (Digital Signature)** | Đảm bảo file update không bị giả mạo. |

### 2.2. Quyết định Mã hóa (Encryption)
| Dữ liệu | Trạng thái | Thuật toán | Action |
| :--- | :--- | :--- | :--- |
| **Dữ liệu nhạy cảm** | Tại nghỉ (At Rest) - On Device | **AES-256** | Mã hóa trước khi ghi vào Flash/EEPROM. |
| **Dữ liệu đang truyền** | Trong kênh (In Transit) | **TLS 1.2/1.3 (HTTPS/MQTT over SSL)** | Bắt buộc dùng chứng chỉ số. |
| **Dữ liệu quy mô lớn/hiệu năng cao** | Trong kênh | **DTLS** (cho UDP) | Giữ bảo mật nhưng giảm độ trễ so với TCP/TLS. |

---

## 3. Architecture Patterns (Mẫu kiến trúc)

Thiết kế hệ thống để tránh các lỗ hổng I1-I10.

### 3.1. Mẫu "Phân tách mạng và API Gateway" (Giải quyết I1, I3, I6)
*   **Vấn đề:** Giao diện quản trị mở ra mạng công cộng (I1), Dịch vụ mạng không an toàn (I3).
*   **Thiết kế:**
    1.  **VLAN/IoT Network:** Cô lập thiết bị IoT trên mạng nội bộ, không cho truy cập trực tiếp từ Internet.
    2.  **API Gateway:** Chỉ Gateway tiếp xúc với Internet. Nó sẽ xác thực và chuyển tiếp yêu cầu vào mạng IoT.
    3.  **Firewall:** Chỉ mở các port cần thiết (HTTPS/MQTTS).

### 3.2. Mẫu "Zero Trust & OTA Update" (Giải quyết I2, I9, I10)
*   **Vấn đề:** Xác thực yếu (I2), Phần mềm lỗi thời (I9), Thiếu bảo mật vật lý (I10).
*   **Thiết kế:**
    1.  **Xác thực mọi lúc:** Mỗi request đều phải mang Token/JWT hoặc Certificate.
    2.  **Cơ chế OTA (Over-the-Air):** Hỗ trợ cập nhật firmware từ xa để patch lỗ hổng (I9).
    3.  **Bảo vệ Bootloader:** Khóa Bootloader để chỉ chấp nhận firmware đã được ký số (I10 -防 Copy/Spoof firmware).

---

## 4. Code Patterns (Mẫu mã nguồn)

Áp dụng trực tiếp vào code để đảm bảo an toàn.

### 4.1. Giải quyết "Cơ chế xác thực không an toàn" (I2) & "Mã hóa" (I4)
Sử dụng **API Key + AES-GCM** cho truyền dữ liệu nhạy cảm.

```python
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import base64

class SecureIoTDevice:
    def __init__(self, api_key: str):
        # API Key dùng để xác thực truy cập Cloud, không hardcode
        self.api_key = api_key 
        # Khóa AES 256-bit (phải được phân phối an toàn, ví dụ bấm nút pairing)
        self.aes_key = AESGCM.generate_key(bit_length=256)

    def encrypt_payload(self, data: bytes) -> dict:
        """
        Giải quyết I4: Thiếu mã hóa tầng giao vận.
        Sử dụng AES-GCM để vừa mã hóa vừa đảm bảo tính toàn vẹn (Authenticated Encryption).
        """
        aesgcm = AESGCM(self.aes_key)
        nonce = os.urandom(12) # 96-bit nonce
        # Associated data là API Key để link encrypted data với identity
        ciphertext = aesgcm.encrypt(nonce, data, associated_data=self.api_key.encode())
        
        return {
            "payload": base64.b64encode(nonce + ciphertext).decode('utf-8'),
            "key_id": "device_01_key_v1"
        }

# Sử dụng
device = SecureIoTDevice(api_key="SECRET_API_TOKEN_888")
secret_data = device.encrypt_payload(b"User SSN: 123-456-789")
print(f"Encrypted Packet: {secret_data['payload'][:50]}...")
```

### 4.2. Giải quyết "Phần mềm không an toàn" (I9) & "Thiếu bảo mật vật lý" (I10)
Xác minh tính toàn vẹn của Firmware update trước khi chạy.

```python
import hashlib
import os

def verify_and_apply_update(file_path: str, expected_hash: str) -> bool:
    """
    Giải quyết I9 & I10: Kiểm tra Firmware trước khi Update.
    Tại device, ta chỉ cần verify hash signature (giả sử file đã được ký trên server).
    """
    if not os.path.exists(file_path):
        print("Error: File not found.")
        return False

    # Tính hash SHA-256 của file nhận được
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    
    calculated_hash = sha256_hash.hexdigest()

    # So sánh với hash mong đợi (Expected Hash từ Server qua kênh an toàn)
    if calculated_hash == expected_hash:
        print("Verification Success: Firmware is authentic and intact.")
        # perform_update(file_path)
        return True
    else:
        print("Verification Failed: Firmware tampered or corrupted!")
        return False

# Ví dụ sử dụng (Giả sử hash được gửi kèm trong JWT hoặc TLS an toàn)
# update_firmware("fw_v2.1.bin", "a1b2c3d4...expected_hash")
```

---

## 5. Anti-patterns (Các lỗi thiết kế cần tránh)

Những việc làm *không bao giờ* được làm khi phát triển IoT.

1.  **Giao diện Web không bảo mật (I1):**
    *   *Lỗi:* Dùng HTTP Basic Auth (Username/Pass truyền plaintext) hoặc để default admin/admin.
    *   *Hậu quả:* Dễ bị Sniffing và Brute-force.

2.  **Hardcoded Secrets (I2, I9):**
    *   *Lỗi:* Đặt API Key, Private Key trực tiếp trong source code biên dịch ra binary.
    *   *Hậu quả:* Khó thay đổi khi lộ, ai cũng có thể trích xuất firmware để lấy key.

3.  **DNS Rebinding (I6 - Cloud):**
    *   *Lỗi:* Ứng dụng Web của Cloud không kiểm tra domain khi gọi API nội bộ.
    *   *Hậu quả:* Hacker có thể chuyển hướng request từ domain hợp lệ về IP local để tấn công Router/LAN.

4.  **Bỏ qua SSL Pinning trên Mobile (I7):**
    *   *Lỗi:* Accept mọi chứng chỉ SSL.
    *   *Hậu quả:* Dễ bị Man-in-the-Middle (MITM) để lấy dữ liệu từ App.

---

## 6. Cheat Sheet (Bảng tra cứu nhanh)

Danh sách kiểm tra (Checklist) trước khi deploy hệ thống IoT.

*   **[ ] Port & Service Scanning:**
    *   Chạy `nmap` quét port开放 (open ports). Chỉ để lại cổng quản trị nếu cần (HTTPS).
    *   Tắt các dịch vụ không dùng đến (Telnet, FTP, HTTP).
*   **[ ] Xác thực (Auth):**
    *   Có dùng **mTLS** (Mutual TLS) cho giao tiếp Device <-> Gateway không?
    *   Có dùng **JWT** hoặc **OAuth** cho User/App không?
    *   Tắt các tài khoản mặc định (default accounts).
*   **[ ] Mã hóa (Encrypt):**
    *   Dữ liệu nhạy cảm có được mã hóa khi lưu trên Flash không?
    *   Firmware update có được ký số không? (Digital Signature).
    *   Protocol có dùng TLS/SSL không?
*   **[ ] Quyền riêng tư (Privacy I5):**
    *   Có thu thập dữ liệu không cần thiết? (Data minimization).
    *   Có cơ chế xóa dữ liệu người dùng (Data deletion)?
*   **[ ] Physical Security (I10):**
    *   Có **JTAG/UART** debug port暴露在外 không? Cần khóa (fuse) hoặc che phủ.
    *   Bootloader có yêu cầu signature không?

---
*End of Decision Guide*



<!-- SECTION 315-324 -->

## Chương 5. Thiết kế và xây dựng hệ thống IoT (pages 315-324)

**Global Section Summary**

Chương 5 tập trung vào phương pháp **Project-Based Learning** (học dựa trên dự án) để thiết kế và xây dựng hệ thống IoT. Sinh viên được hướng dẫn quy trình từ xác định bài toán, phân tích thiết kế, lựa chọn thiết bị/phần mềm, đến lập trình và trình báo cáo.

- **Mục tiêu chính:** Hướng dẫn sinh viên thực hành thiết kế trọn vẹn một hệ thống IoT qua các dự án cụ thể.
- **Khái niệm cốt lõi:**
  - Phân tích và thiết kế hệ thống (Kiến trúc tổng quan & Chi tiết).
  - Lựa chọn phần cứng (Máy tính nhúng, Sensors) và phần mềm.
  - Làm việc nhóm và kỹ năng trình bày.
- **Phụ thuộc quan trọng:** Cần hiểu các khái niệm cơ bản về IoT và linh kiện phần cứng từ các chương trước.
- **Thuật ngữ:** Project-Based Learning, System Architecture, Implementation, Smart Agriculture, Smart Home, Smart Utilities, Smart Transportation.



<!-- CHUNK 315-324 -->

# DEVELOPER DECISION GUIDE: Chương 5 - Thiết kế và Xây dựng Hệ thống IoT

Tài liệu này cung cấp các quyết định thiết kế và thực hành cốt lõi cho kỹ sư phần mềm IoT dựa trên phương pháp **Project-Based Learning** (Học dựa trên dự án).

---

## 1. Core Mental Model (Mô hình nhận thức)

Hãy tư duy hệ thống IoT như một cơ thể sống với 3 lớp tư duy tương ứng: **Tri giác (Device)**, **Truyền dẫn (Network)**, và **Trí tuệ (Cloud/Logic)**.

| Lớp | Vai trò | Câu hỏi ra quyết định |
| :--- | :--- | :--- |
| **感知 (Perception/Device)** | "Mắt và Tai" - Thu thập dữ liệu thô. | Dữ liệu có cần độ chính xác cao không? Môi trường khắc nghiệt hay tiêu chuẩn? (Chọn Sensor & MCU). |
| **Truyền dẫn (Connectivity)** | "Mạch Máu" - Vận chuyển dữ liệu. | Khoảng cách bao xa? Cần bao nhiêu dữ liệu? Pin có quan trọng? (Chọn Protocol: MQTT/LoRa/Wi-Fi). |
| **Trí tuệ (Intelligence)** | "Não bộ" - Xử lý & Ra quyết định. | Logic có phức tạp không? Có cần AI/Real-time? (Chọn Cloud, Edge Computing hay Local Logic). |

---

## 2. Decision Tables (Bảng quyết định)

### 2.1. Lựa chọn Giao thức Truyền dẫn (Connectivity Protocol)

Dựa trên dự án **Smart Agriculture** (Nông nghiệp thông minh) hoặc **Smart Utilities** (Tiện ích).

| Yêu cầu Dự án | Khoảng cách | Dữ liệu | Giao thức Đề xuất | Tại sao? |
| :--- | :--- | :--- | :--- | :--- |
| **Nhà thông minh (Smart Home)** | Ngắn (< 50m) | Trung bình | **Wi-Fi / Zigbee** | Tốc độ cao, dễ tích hợp điện thoại, không cần độ trễ quá thấp. |
| **Nông nghiệp/Đo xa (Smart Agri)** | Dài (> 500m) | Thấp (Cảm biến) | **LoRaWAN** | Tiết kiệm pin (LPWAN), truyền xa tốt qua địa hình phức tạp. |
| **Giám sát công nghiệp (Utilities)** | Trung bình | Cao/Liên tục | **MQTT over Ethernet/4G** | Ổn định, publish-subscribe模式, xử lý dữ liệu lớn tốt. |

### 2.2. Lựa chọn Nền tảng Phần cứng (Hardware Stack)

| Mục đích | Thiết bị Đề xuất | Ví dụ Code/Logic |
| :--- | :--- | :--- |
| **Điều khiển & Thu thập** | **ESP32 / ESP8266** | `if (WiFi.status() == WL_CONNECTED) { pushData(sensors.read()); }` |
| **Xử lý Trung gian (Edge)** | **Raspberry Pi** | `running python script to aggregate data from multiple nodes before sending to cloud.` |
| **Phát triển nhanh** | **Arduino IDE / PlatformIO** | **PlatformIO** tốt hơn cho dự án lớn (Dependency management). |

---

## 3. Architecture Patterns (Mẫu kiến trúc)

Áp dụng cho các chủ đề: **Smart Home, Smart Transportation, Smart Air Quality**.

### 3.1. Mẫu Arduino-to-Cloud (Direct Injection)
*Phù hợp: Dự án nhỏ, sinh viên, Proof of Concept.*
*Luồng: Cảm biến -> MCU -> WiFi/MQTT -> Cloud.*
*Ưu điểm: Đơn giản, ít chi phí.*

### 3.2. Mẫu Gateway-Edge (Edge Computing)
*Phù hợp: Smart Utilities, Smart Agriculture (Nhiều node sensor).*
*Luồng: Sensor Node -> LoRa -> Gateway (Raspberry Pi) -> Xử lý logic cục bộ -> Cloud.*
*Lưu ý: Gateway có vai trò lọc nhiễu, tổng hợp dữ liệu trước khi đẩy lên cloud.*

---

## 4. Code Patterns (Mẫu mã nguồn)

### 4.1. Vòng lặp bất đồng bộ (Asynchronous Loop)
Trong IoT, `delay()` là kẻ thù. Sử dụng Non-blocking code để giữ kết nối mạng ổn định.

```cpp
// BAD: delay(5000) làm đẹt cứng thiết bị (Blocking)
// GOOD: Kiểm tra thời gian (Non-blocking)
unsigned long previousMillis = 0;
const long interval = 5000; // Gửi dữ liệu mỗi 5s

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    // 1. Đọc cảm biến
    float temp = readSensor(); 
    
    // 2. Gửi dữ liệu (MQTT/HTTP)
    // handleData(temp);
    Serial.println("Data sent: " + String(temp));
  }
  
  // 3. Duy trì kết nối mạng (Keep-alive)
  client.loop(); 
}
```

### 4.2. Tách biệt Logic điều khiển (Separation of Concerns)
Tách biệt giữa phần "Đọc" và "Viết" (Actuate vs Sense). Tránh gây rối loạn trạng thái thiết bị.

```python
# Python Code (Edge/Gateway)

def read_data_from_sensor():
    # Logic thuần túy đọc dữ liệu
    return json.loads(mqtt_client.get_payload())

def control_actuator(value):
    # Logic điều khiển thiết bị
    if value > 30:
        mqtt_client.publish("home/livingroom/fan", "ON")
    else:
        mqtt_client.publish("home/livingroom/fan", "OFF")

# Main Loop
data = read_data_from_sensor()
control_actuator(data['temperature'])
```

---

## 5. Anti-patterns (Các lỗi thiết kế cần tránh)

| Tên Anti-pattern | Mô tả | Hậu quả | Giải pháp |
| :--- | :--- | :--- | :--- |
| **"Hardcoded Config"** | Lấy địa chỉ IP, API Key, Topic MQTT gõ cứng trong code. | Khó thay đổi, dễ rò rỉ bí mật khi share code. | Sử dụng file `config.h` hoặc biến môi trường (Environment Variables). |
| **"Trusting the Network"** | Giả định mạng luôn ổn định, không xử lý lỗi mất kết nối. | Mất dữ liệu quan trọng, hệ thống đơ. | Implement **Retry Mechanism** (Thử lại) và **Buffer** (Lưu tạm vào bộ nhớ nếu mất mạng). |
| **"Do Everything in Interrupt"** | Viết logic phức tạp (gửi data lên cloud) ngay trong hàm Interrupt Service Routine (ISR). | Gây crash, treo hệ thống, bộ nhớ nhớt. | ISR chỉ dùng để set Flag, xử lý logic trong `loop()` chính. |

---

## 6. Cheat Sheet (Bảng tra cứu nhanh)

Quy trình thực hiện dự án (Project Lifecycle):

1.  **Finding Problems**: Chọn bài toán cụ thể (VD: Tưới cây tự động).
2.  **System Design**:
    *   Vẽ sơ đồ khối (Block Diagram).
    *   Chọn giao thức (MQTT/LoRa).
3.  **Implementation**:
    *   Lập trình Device (C/C++).
    *   Cấu hình Cloud (MQTT Broker/Ngrok).
4.  **Testing**: Kiểm tra ngắt kết nối, kiểm tra dữ liệu ngoài ngưỡng.
5.  **Reporting**: Trình bày giải pháp, demo thực tế.

**Lưu ý quan trọng:** Luôn ưu tiên **Energy Efficiency** (Tiết kiệm năng lượng) cho các bài toán Smart Agriculture hoặc Monitoring.



<!-- SECTION 325-349 -->

## Sensors (pages 325-349)

**Global Section Summary**

Mục tiêu chính của phần này là trình bày các khái niệm cốt lõi và minh họa các mô hình hệ thống IoT thông qua các ví dụ dự án thực tế, từ việc giám sát chất lượng không khí đến các ứng dụng dân sinh như smart home, smart garden, và smart parking. Phần tài liệu tập trung vào việc mô tả các khối chức năng trong kiến trúc IoT.

- **Mục tiêu chính:** Minh họa cách các thành phần IoT (cảm biến, module truyền thông, server, ứng dụng) được kết hợp để hình thành các hệ thống thực tế như giám sát không khí, quản lý rác thải, nhà ở và nông nghiệp thông minh.
- **Các khái niệm cốt lõi:**
  - Khối thu thập dữ liệu: Cảm biến (NO2, CO2, PM2.5), GPS, Module (GSM/Wifi).
  - Khối xử lý & Lưu trữ: Server, Database, Webserver (NodeJS, MongoDB).
  - Khối giao diện & Ứng dụng: Web app, Mobile app (React Native, React JS).
  - Giao thức truyền thông: HTTP, TCP/IP.
- **Phụ thuộc quan trọng:** Cần hiểu các kiến thức về IoT Basics (đặc biệt là giao thức HTTP/TCP và cấu trúc Server-Client) trước khi phân tích chi tiết các dự án.
- **Từ khoá cần nhớ:** Cảm biến (Sensors), Mobile/Web App, Server, Database, API (GET/POST), HTTP/TCP/IP.



<!-- CHUNK 325-336 -->

# DEVELOPER DECISION GUIDE: IoT System Design (Sensors & Applications)

## Core Mental Model

Hệ thống IoT hiện đại tuân theo mô hình **Edge-to-Cloud**. Dữ liệu được thu thập tại nguồn (Edge), truyền tải qua mạng (Gateway), xử lý và lưu trữ trên Cloud, cuối cùng hiển thị cho người dùng qua Client App.

*   **Edge (Thu thập):** Nơi dữ liệu sinh ra. Bao gồm Cảm biến (Sensors) và Module truyền thông.
*   **Cloud (Xử lý):** Nơi xử lý logic phức tạp (Data Analyzing) và lưu trữ (Database).
*   **Client (Trải nghiệm):** Giao diện người dùng (Mobile/Web App) để giám sát và điều khiển.

**Vòng đời dữ liệu:** `Sensor -> Gateway -> Network Protocol (HTTP/TCP) -> Server/API -> Database -> Application Logic -> User Alert`.

## Decision Tables (Bảng Quyết Định)

Chọn Module truyền thông dựa trên môi trường và tốc độ dữ liệu:

| Kịch bản | Phạm vi | Bandwidth | Module đề xuất | Giao thức chính |
| :--- | :--- | :--- | :--- | :--- |
| **Giám sát cố định** (Smart Air, Smart Garden) | Nội bộ (Wifi) | Cao | ESP8266/ESP32 (Wifi) | HTTP/MQTT |
| **Quản lý rác/Đỗ xe** (Outdoor) | Di động (Cellular) | Trung bình | SIM800L/7600 (GSM/4G) | TCP/IP (Raw) |
| **Nhà kho/Bãi xe rộng** | Dài (LPWAN) | Thấp | LoRaWAN/NB-IoT | MQTT/Sigfox |

Chọn Server Stack cho bài toán IoT:

| Yêu cầu | NodeJS | Python | Lựa chọn tối ưu |
| :--- | :--- | :--- | :--- |
| **Real-time & High I/O** | Nổi tiếng với Non-blocking I/O (Event Loop) | Cần Async/Celery để xử lý tương đương | **NodeJS** (Nhanh hơn cho IoT Gateway) |
| **Xử lý AI/ML** | Khó khăn (Require C++ bindings) | Dễ dàng (Scikit-learn, TensorFlow) | **Python** (Dễ tích hợp AI) |
| **Development Speed** | Javascript (Fullstack JS) | Python (Syntax đơn giản) | **NodeJS** (Nếu team熟悉 JS) |

## Architecture Patterns

### 1. IoT Event-Driven Architecture (Biến sự kiện thành hành động)

Hệ thống Smart Air Quality Monitoring không polling liên tục mà dựa trên Event. Cảm biến đẩy dữ liệu, Server xử lý và trả về cảnh báo nếu ngưỡng an toàn bị vượt.

*   **Luồng hoạt động:**
    1.  **Collect:** Cảm biến (NO2, PM2.5) thu thập dữ liệu.
    2.  **Transport:** Module GSM/Wifi gửi `POST` request đến Server.
    3.  **Process:** Server kiểm tra dữ liệu vs Threshold (ngưỡng).
    4.  **Notify:** Nếu vượt ngưỡng -> Push通知 hoặc hiển thị trên Web/Mobile App.

```python
# Pseudo-code: Logic xử lý trên Server (NodeJS/Python)
# Biểu diễn luồng "Collect -> Analyze -> Warning"

def handle_sensor_post(data):
    # 1. Collect
    station_id = data['station_id']
    pm25 = data['pm25']
    no2 = data['no2']
    
    # 2. Analyze (AI-based Logic)
    is_hazardous = False
    if pm25 > 50 or no2 > 0.1:
        is_hazardous = True
        
    # 3. Save to DB
    db.save_reading(station_id, pm25, no2)
    
    # 4. Warning (Push to Clients)
    if is_hazardous:
        push_notification(f"Station {station_id} - Danger: High PM2.5")
        update_live_dashboard(station_id, status="red")
```

### 2. Unified Smart Home Controller (Kiểm soát tập trung)

Áp dụng cho **Smart Home**. Mục tiêu: Một Server duy nhất điều khiển nhiều thiết bị (Lights, Curtains) từ nhiều giao diện (Mobile App, Physical Switch).

*   **Cấu trúc:**
    *   **Central Hub (Server):** Giữ state của toàn bộ ngôi nhà (State Management).
    *   **Physical Layer:** Relay module nhận tín hiệu từ Hub.
    *   **Application Layer:** Mobile App gọi API để thay đổi state của Hub.

```python
# Pseudo-code: State Management cho Smart Home
# Server-side (Python/Flask hoặc NodeJS/Express)

house_state = {
    "living_room": {"lights": "off", "curtains": "closed"},
    "kitchen": {"lights": "off", "motion_sensor": "idle"}
}

@app.route('/api/control', methods=['POST'])
def control_device():
    req = request.json
    room = req['room']
    device = req['device']
    action = req['action'] # 'on' or 'off'
    
    # Validate & Update State
    if room in house_state and device in house_state[room]:
        house_state[room][device] = action
        
        # 3. Sync to Physical Hardware (Gateway)
        # Gửi tín hiệu qua MQTT hoặc HTTP đến thiết bị vật lý
        sync_to_hardware(room, device, action)
        
        return {"status": "success", "new_state": house_state[room]}
    return {"error": "Invalid device"}
```

## Code Patterns

### Pattern 1: HTTP Data Pusher (Edge Device)
Thiết bị Edge (ESP32) cần gửi dữ liệu cảm biến lên Server một cách tin cậy.

*   **Edge Code (C++/Arduino):**

```cpp
#include <WiFi.h>
#include <HTTPClient.h>

const char* serverUrl = "http://api.my-iot.com/sensor";

void loop() {
  if (millis() - lastTime > 10000) { // Gửi mỗi 10s
    float pm25 = readSensor(); // Đọc cảm biến
    
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");
    
    // Tạo JSON payload
    String payload = "{\"pm25\":" + String(pm25) + ",\"station_id\":1}";
    
    int httpResponseCode = http.POST(payload);
    
    if (httpResponseCode > 0) {
      Serial.println("Data Sent");
    } else {
      Serial.println("Error Sending");
    }
    http.end();
    lastTime = millis();
  }
}
```

### Pattern 2: Concurrent Data Ingestion (Server)
Server IoT cần xử lý đồng thời nhiều request từ hàng trăm cảm biến mà không bị block.

*   **Server Code (Python - Async):**

```python
import asyncio
import aiohttp
from aiohttp import web

# Giả lập database write
async def save_to_db(data):
    await asyncio.sleep(0.1) # Giả lập latency IO
    print(f"Saved: {data}")

async def handle_sensor(request):
    try:
        data = await request.json()
        # Non-blocking DB operation
        asyncio.create_task(save_to_db(data))
        return web.json_response({"status": "ok"})
    except Exception as e:
        return web.json_response({"error": str(e)}, status=400)

app = web.Application()
app.router.add_post('/ingest', handle_sensor)

# Khởi chạy server có thể chấp nhận hàng nghìn kết nối đồng thời
if __name__ == '__main__':
    web.run_app(app, port=8080)
```

## Anti-patterns (Các lỗi thiết kế cần tránh)

1.  **Blocking Main Thread on Device (Edge):**
    *   *Lỗi:* Dùng `delay()` (Arduino) hoặc `time.sleep()` (Python) lâu trong vòng lặp chính.
    *   *Hậu quả:* Thiết bị không thể đọc cảm biến khác hoặc xử lý nút bấm, gây trễ hệ thống.
    *   *Khắc phục:* Dùng millis() (C++) hoặc Async/Await (Python/JS) để lập trình bất đồng bộ.

2.  **Insecure API (No Auth):**
    *   *Lỗi:* Cảm biến gửi dữ liệu qua `HTTP` (không mã hóa) hoặc Server không kiểm tra Token.
    *   *Hậu quả:* Dễ bị giả mạo dữ liệu (Spam Fake Data làm sập Server hoặc sai lệch cảnh báo).
    *   *Khắc phục:* Luôn dùng **HTTPS**. Sử dụng API Key hoặc JWT Token cho mỗi request (dù là máy cảm biến).

3.  **Direct Database Write from Sensor:**
    *   *Lỗi:* Sensor gửi trực tiếp vào Database (MongoDB/SQL).
    *   *Hậu quả:* Bỏ qua Logic xử lý (Validate, Alert), khó scale.
    *   *Khắc phục:* Sensor chỉ gọi **API**. Server xử lý logic trước khi lưu DB.

## Cheat Sheet

| Concept | English Term | Vietnamese Description | Example Usage |
| :--- | :--- | :--- | :--- |
| **Cảm biến** | Sensors | Thiết bị phần cứng thu thập dữ liệu môi trường (Khí, Rác, Ánh sáng). | `readSensor()` |
| **Gateway** | Module (GSM/Wifi) | Cầu nối giữa thiết bị IoT và Internet. | `ESP32`, `SIM800L` |
| **Giao thức** | Protocol | Quy tắc giao tiếp giữa Client và Server. | `HTTP`, `TCP/IP` |
| **API Method** | GET / POST | `GET`: Lấy dữ liệu từ Server. `POST`: Gửi dữ liệu lên Server. | `POST /sensor` |
| **Xử lý dữ liệu** | Data Analyzing | Phân tích dữ liệu thô để tìm ra thông tin hữu ích. | `if (pm25 > 50) alert()` |
| **Giao diện** | Client (Web/Mobile) | Ứng dụng người dùng cuối giám sát hệ thống. | `React Native` |
| **Cơ sở dữ liệu** | Database | Nơi lưu trữ histórico dữ liệu Sensor. | `MongoDB` |



<!-- CHUNK 337-348 -->

# DEVELOPER DECISION GUIDE: IoT Smart Systems

**Tác giả:** Kỹ sư Phần mềm cao cấp & Giảng viên Kỹ thuật
**Đối tượng:** Lập trình viên Backend/Frontend, Kỹ sư IoT
**Ngôn ngữ:** Tiếng Việt (Kèm thuật ngữ kỹ thuật)

---

## Core Mental Model

Hệ thống IoT hiện đại hoạt động theo mô hình **"Edge -> Cloud -> User"**. Dựa trên tài liệu dự án Smart Garden/Home, luồng dữ liệu điển hình là:

1.  **Edge (Cảm biến/Device):** Thu thập dữ liệu thô (Nhiệt độ, Độ ẩm, GPS).
2.  **Gateway/Network:** Đẩy dữ liệu lên Cloud thông qua **HTTP API (POST)**.
3.  **Cloud (Server & DB):** Xác thực (Auth), Lưu trữ (MongoDB), Phê duyệt logic (Business Logic).
4.  **Presentation (App/Web):** Lấy dữ liệu qua **HTTP API (GET)** và Hiển thị UI.

> **Quyết địnhthen chốt:** Luôn tách biệt **Logic Xử lý** (Server) khỏi **Logic Thu thập** (Device). Device không bao giờ được phép trực tiếp ghi vào Database của người dùng cuối.

---

## Decision Tables (Bảng Quyết định)

### Table 1: Chọn Giao thức Truyền thông (Communication Protocol)

| Tiêu chí | HTTP/REST (JSON) | MQTT | TCP/IP Raw |
| :--- | :--- | :--- | :--- |
| **Bối cảnh** | Web/Mobile App, API Gateway | Mạng yếu, Ping频繁 (Tần suất cao) | Dữ liệu lớn, realtime strict (Nghiêm ngặt) |
| **Ưu điểm** | Dễ test (Postman), Web std | Tiết kiệm pin, Bandwidth | Tối ưu tốc độ |
| **Nhược điểm** | Overhead header lớn | Cần Broker server | Khó debug, Cấu hình phức tạp |
| **Phản hồi từ Tài liệu** | **ĐƯỢC DÙNG:** `POST /v1/device`, `GET /v1/data` | Chưa thấy đề cập | Chưa thấy đề cập |
| **Lời khuyên** | **Dùng cho hầu hết Smart Home/Garden** vì tích hợp dễ với Web/Mobile App (React/React Native). | Dùng cho Sensor Network quy mô lớn (Smart City). | Dùng cho Streaming video/High frequency data. |

### Table 2: Quyền truy cập API (Role-Based Access)

| Endpoint | Method | Role | Logic bảo mật |
| :--- | :--- | :--- | :--- |
| `/auth/register` | POST | Public | Kiểm tra trùng email, Hash mật khẩu. |
| `/house` | POST | Admin (User) | Creator ID = User ID (Session). |
| `/device/{houseId}` | GET | Member (User) | Kiểm tra User ID có trong danh sách member của House không (Join DB). |
| `/house/delete-member` | PUT | Admin (User) | Chỉ Admin mới được xóa thành viên. |

---

## Architecture Patterns

### 1. Layered Architecture (Kiến trúc Lớp)

Tài liệu mô tả 3 lớp rõ ràng:

*   **Presentation Layer:** React Native (Mobile), React JS (Web).
*   **Business Logic Layer:** NodeJS/ExpressJS (Xử lý API, Validation).
*   **Data Access Layer:** MongoDB (Lưu trữ documents, IoT Data).

### 2. API Gateway Pattern (Mẫu Cổng API)

Tài liệu liệt kê các API rõ ràng. Đây là cách thiết kế chuẩn để Smartphone tương tác với IoT Gateway.

*   **Cấu trúc URL:** `/v1/{resource}/{action}/{id}`
*   **Phương thức:** Sử dụng đúng semantic HTTP (GET, POST, PUT, DELETE).

**Ví dụ Logic xử lý Smart Garden (NodeJS):**

```javascript
// File: routes/garden.js
const express = require('express');
const router = express.Router();

// Middleware kiểm tra Auth đã đăng nhập chưa
const authMiddleware = require('../middleware/auth');

// API: Lấy dữ liệu cảm biến (GET)
// Flow: Client -> Server -> DB Query -> Response
router.get('/data/:houseId', authMiddleware, async (req, res) => {
    try {
        const { houseId } = req.params;
        // Logic: Chỉ trả data nếu user là thành viên của house
        const data = await SensorData.find({ houseId }).sort({ timestamp: -1 }).limit(10);
        res.json({ success: true, data: data });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

module.exports = router;
```

---

## Code Patterns

### Pattern 1: Server-side Logic (NodeJS/Express)

Khi构建 API cho Smart Home, bạn cần xử lý luồng **"Thêm/Xóa người dùng"** (Được đề cập trong tài liệu). Mẫu code này minh họa cách quản lý quan hệ phức tạp (House <-> User).

```javascript
// Logic: Thêm thành viên vào nhà (Smart Home/Smart Garden)
// PUT /v1/house/update-member/{houseId}

app.put('/v1/house/update-member/:houseId', auth, async (req, res) => {
    const { houseId } = req.params;
    const { newMemberEmail } = req.body; // Input từ Admin

    // 1. Tìm user được thêm
    const userToAdd = await User.findOne({ email: newMemberEmail });
    if (!userToAdd) return res.status(404).json({ msg: "User not found" });

    // 2. Kiểm tra quyền Admin (Logic quan trọng)
    const house = await House.findById(houseId);
    if (house.adminId.toString() !== req.user.id) {
        return res.status(403).json({ msg: "Access Denied. Only Admin." });
    }

    // 3. Thêm vào mảng members (Schema design)
    if (!house.members.includes(userToAdd._id)) {
        house.members.push(userToAdd._id);
        await house.save();
    }

    res.json({ msg: "User added successfully", house });
});
```

### Pattern 2: Data Ingestion (Device -> Server)

Máy chủ phải chịu được hàng nghìn kết nối đồng thời. Sử dụng cơ chế **Non-blocking I/O** (NodeJS).

```javascript
// Logic: Cảm biến gửi dữ liệu (POST)
// Device -> Server -> DB

app.post('/v1/sensor/upload', async (req, res) => {
    // Giả lập xử lý nhanh, không block thread
    const { deviceId, value, type } = req.body;

    // Validate payload
    if (!deviceId || value == null) {
        return res.status(400).json({ error: "Invalid Data" });
    }

    // 2. Lưu vào Database (Async)
    // Pattern: Write Buffer -> DB (Firestore/MongoDB)
    SensorData.create({
        deviceId,
        type, // VD: "air_quality"
        value,
        timestamp: new Date()
    });

    // 3. Trả về ngay lập tức để thiết bị không bị treo
    res.status(200).json({ status: "Received" });
});
```

---

## Anti-patterns (Lỗi thiết kế cần tránh)

1.  **Truy cập Database trực tiếp từ Client (No API):**
    *   *Hành động:* Mobile App connect trực tiếp MongoDB.
    *   *Hậu quả:* Lộ credential, không thể kiểm soát quyền truy cập, dễ hack.
    *   *Đúng:* Qua NodeJS API Gateway.

2.  **Synchronous Processing cho Block Request:**
    *   *Hành động:* Đợi xử lý logic nặng trước khi trả về `200 OK` cho Device.
    *   *Hậu quả:* Device mất kết nối, treo cảm biến.
    *   *Đúng:* Trả về `200 OK` ngay, đưa job vào Queue (Background Worker).

3.  **Flat Permission Model:**
    *   *Hành động:* Bất kỳ ai có token đều xem được dữ liệu nhà khác.
    *   *Hậu quả:* Vi phạm quyền riêng tư (VD: Xem dữ liệu Smart Garden hàng xóm).
    *   *Đúng:* Kiểm tra quan hệ `User ID` trong collection `House`.

---

## Cheat Sheet (Bảng tóm tắt)

| Yếu tố | Công cụ/Công nghệ (Theo Tài liệu) | Mục đích |
| :--- | :--- | :--- |
| **Sensor Data** | NO2, CO2, PM2.5, GPS | Thu thập môi trường |
| **Network** | HTTP, TCP/IP | Vận chuyển dữ liệu |
| **Backend API** | NodeJS, ExpressJS | Logic & Routing |
| **Database** | MongoDB | Lưu trữ NoSQL, linh hoạt cho IoT |
| **Frontend Web** | React JS | Dashboard Admin |
| **Frontend Mobile** | React Native | Ứng dụng người dùng |
| **API Method** | `GET /device`, `POST /house` | Đọc và Ghi dữ liệu |
| **Auth** | JWT / Session | Xác thực người dùng |



<!-- CHUNK 349-349 -->

# DEVELOPER DECISION GUIDE: Smart Garden IoT

## Core Mental Model

Hệ thống Smart Garden là một kiến trúc IoT kinh điển theo mô hình **Sense -> Transmit -> Process -> Act**.

1.  **Sense (Thu thập):** Cảm biến (độ ẩm đất, nhiệt độ, ánh sáng) đóng vai trò là "người gác cổng" thu thập dữ liệu môi trường thô.
2.  **Transmit (Truyền tải):** Module truyền thông (Wi-Fi/4G) đóng vai trò "người đưa thư", chuyển đổi tín hiệu analog thành dữ liệu số và gửithông qua giao thức HTTP.
3.  **Process (Xử lý):** Server & Database đóng vai trò "bộ não", ra quyết định dựa trên ngưỡng dữ liệu (threshold).
4.  **Act (Hành động):** Cảm biến chấp hành (rơ-le bơm nước) thực hiện hành động vật lý khi Server gửi lệnh.

**Bài học cốt lõi:** Tách biệt hoàn toàn logic thu thập dữ liệu (Edge) và logic ra quyết định (Cloud) để hệ thống có thể mở rộng và dễ bảo trì.

---

## Decision Tables (Bảng Quyết định)

Bảng này giúp chọn công nghệ phù hợp cho từng thành phần của hệ thống Smart Garden.

| Phân khu | Lựa chọn tối ưu (Best Fit) | Lựa chọn thay thế (Alternative) | Tiêu chí ra quyết định |
| :--- | :--- | :--- | :--- |
| **Giao thức truyền thông** | **HTTP (REST API)** | MQTT | **Độ phức tạp & Tần suất:** HTTP phù hợp cho Smart Garden vì dữ liệu gửi theo chu kỳ (khoảng 5-10 phút/lần), dễ debug và tương thích tốt với Web API. MQTT phù hợp hơn nếu cần độ trễ cực thấp (< 1s). |
| **Cảm biến** | **Capacitive Soil Sensor** | Resistive Sensor | **Độ bền:** Capacitive không tiếp xúc trực tiếp với đất ẩm, chống ăn mòn tốt hơn cho môi trường ngoài trời. Resistive rẻ hơn nhưng hỏng nhanh. |
| **Phía Server** | **Node.js + Express** | Python (Flask) | **I/O Model:** Node.js xử lý tốt các tác vụ I/O (như gọi API tới database) bất đồng bộ, phù hợp cho việc server liên tục nhận dữ liệu cảm biến từ nhiều vườn khác nhau. |
| **Database** | **Time-Series DB (InfluxDB)** | MongoDB / MySQL | **Bản chất dữ liệu:** Smart Garden sinh ra dữ liệu theo thời gian (ví dụ: độ ẩm 30% lúc 10h, 25% lúc 10h05). Time-Series DB tối ưu cho việc lưu và truy vấn theo khoảng thời gian. |

---

## Architecture

Kiến trúc hệ thống Smart Garden bao gồm 3 lớp chính:

1.  **Lớp Thiết bị (Device Layer):**
    *   **Controller:** ESP32/ESP8266 (kết nối Wi-Fi).
    *   **Sensor:** DHT22 (Nhiệt độ/Độ ẩm), YL-69 (Độ ẩm đất).
    *   **Actuator:** Relay 5V (Điều khiển bơm nước).
    *   **Nhiệm vụ:** Đọc giá trị -> Tạo Payload JSON -> POST lên Server.

2.  **Lớp Điện toán Đám mây (Cloud Layer):**
    *   **API Gateway (Server):** NodeJS Express lắng nghe PORT 3000.
    *   **Logic:** Kiểm tra `if (soil_moisture < 30) -> send Pump Command`.
    *   **Database:** Lưu trữ lịch sử để hiển thị biểu đồ.

3.  **Lớp Ứng dụng (Application Layer):**
    *   **Dashboard (Web/Mobile):** React Native/App. Hiển thị dữ liệu realtime và cho phép người dùng can thiệp thủ công (Bật/Tắt bơm).

```javascript
// Ví dụ Mockup Kiến trúc Server (Node.js)
// Lớp Cloud: Nhận dữ liệu và xử lý logic
const express = require('express');
const app = express();
app.use(express.json());

// Mock Database
let gardenState = { soil_moisture: 0, pump_status: 'OFF' };

// API Endpoint để Device POST data
app.post('/api/sensor-data', (req, res) => {
    const { soil_moisture } = req.body;
    gardenState.soil_moisture = soil_moisture;

    // Logic Ra quyết định (Actuation Logic)
    if (soil_moisture < 30) {
        gardenState.pump_status = 'ON'; // Gửi lệnh về Device
        console.log(`[System] Đất khô (${soil_moisture}%) - Bật bơm.`);
    } else {
        gardenState.pump_status = 'OFF';
    }
    
    res.json({ status: 'OK', action: gardenState.pump_status });
});

app.listen(3000, () => console.log('Smart Garden Server running on port 3000'));
```

---

## Code Patterns

### 1. Pattern: Chu kỳ đọc cảm biến có kiểm soát (Polling with Sleep)
Thiết bị IoT không nên chạy liên tục (while true) mà cần ngủ để tiết kiệm năng lượng và tránh treo Gerät.

```cpp
// C++ (ESP32/Arduino)
void loop() {
  // 1. Đọc dữ liệu
  int soilValue = analogRead(A0);
  
  // 2. Xử lý và Gửi (HTTP POST)
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin("http://your-server.com/api/sensor-data");
    http.addHeader("Content-Type", "application/json");
    
    String payload = "{\"soil_moisture\":" + String(soilValue) + "}";
    int httpResponseCode = http.POST(payload);
    
    http.end();
  }

  // 3. Ngủ động (Deep Sleep) để tiết kiệm pin
  // Awake mỗi 300 giây (5 phút)
  esp_sleep_enable_timer_wakeup(300 * 1000000);
  esp_deep_sleep_start();
}
```

### 2. Pattern: Khả năng phục vụ hàng nghìn kết nối (Concurrency)
Sử dụng `async/await` trong Node.js để xử lý nhiều request cảm biến đồng thời mà không block thread chính.

```javascript
// Node.js: Xử lý nhiều request đồng thời
const processGardenData = async (req, res) => {
    try {
        // Giả lập độ trễ database (I/O Bound)
        // await db.query(...) 
        
        const decision = req.body.moisture < 20 ? 'CRITICAL_PUMP' : 'NORMAL';
        res.status(200).json({ action: decision });
    } catch (error) {
        res.status(500).json({ error: "Internal Error" });
    }
};

app.post('/garden', processGardenData); 
```

---

## Anti-patterns (Lỗi thiết kế cần tránh)

1.  **Hardcoded API Keys (Mã hóa cứng khóa API):**
    *   *Hành động:* Đặt `const API_KEY = "sk_live_1234..."` ngay trong file code của thiết bị.
    *   *Hệ quả:* Rất nguy hiểm. Nếu lộ code, kẻ xấu có thể điều khiển hệ thống bơm nước hoặc spam dữ liệu giả.
    *   *Giải pháp:* Sử dụng Environment Variables (`.env`) hoặc Secret Manager.

2.  **Chặn luồng chính (Blocking Main Thread):**
    *   *Hành động:* Trong code ESP32, dùng `delay(10000)` (chờ 10s) ngay giữa các tác vụ quan trọng.
    *   *Hệ quả:* Thiết bị không thể phản hồi với các tác vụ khác (ví dụ: nhận nút bấm khẩn cấp) trong lúc chờ.
    *   *Giải pháp:* Sử dụng Interrupts hoặc Timer (như trong `loop()` của Arduino hoặc FreeRTOS tasks).

3.  **CORS (Cross-Origin Resource Sharing) bị cấm hoàn toàn:**
    *   *Hành động:* Server từ chối mọi request từ Web/Mobile App (lỗi CORS).
    *   *Hệ quả:* App không thể lấy dữ liệu để hiển thị Dashboard.
    *   *Giải pháp:* Cấu hình Server cho phép các domain cụ thể (`app.use(cors({ origin: 'http://localhost:3000' }))`).

---

## Cheat Sheet

### Dữ liệu Cảm biến (Sensor Payload)
*   **Format:** JSON
*   **Ví dụ:** `{"device_id": "garden_01", "temp": 28, "humidity": 65, "battery": 3.3}`

### API Endpoints
*   **POST** `/api/data`: Gửi dữ liệu từ Device lên Server.
*   **GET** `/api/status`: Lấy trạng thái hiện tại (bật/tắt) từ App hoặc Device.
*   **POST** `/api/command`: Gửi lệnh từ App xuống Device (override manual).

### Lưu lượng mạng (Network Flow)
1.  **Device -> Server:** POST Request (Mật độ thấp: 5-10 phút/lần).
2.  **App -> Server:** GET Request (Mật độ cao: Realtime or Pull-to-refresh).
3.  **Server -> Device:** Push通知 via WebSocket hoặc MQTT (Nếu cần realtime strict). Nếu dùng HTTP Model, Device sẽ phải poll (hỏi lại) Server sau mỗi lần POST để nhận lệnh.

